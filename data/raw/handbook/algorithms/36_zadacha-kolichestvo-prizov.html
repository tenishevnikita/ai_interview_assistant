<html lang="ru" class="__className_a39d3e __variable_a39d3e __variable_5a49b6 __variable_2ac229 HR-9-31-0"><head><script src="https://yastatic.net/s3/gdpr/v3/gdpr.js" type="text/javascript" charset="utf-8" async=""></script><style id="react-aria-pressable-style">@layer {
  [data-react-aria-pressable] {
    touch-action: pan-x pan-y pinch-zoom;
  }
}</style><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="viewport" content="initial-scale=1, width=device-width"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/logo_mobile_8bc5eb38fb.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/edu_logo_simple_9790e70002.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/social_icon_vk_97bf858cd5.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/social_icon_yt_d20daea655.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/social_icon_tg_9faafb663e.svg"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/00e25bd25bbd0437.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb46cd5c40721db6.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/85781da132a474d7.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/df0a82ffea795a48.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c800df164b7b8c22.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/033fa3e38f305e9b.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/80e3798aa7f5abc0.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/17fdf933d7378e89.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a2f4cf3f3bb12d85.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d844ab516aaccc48.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb0e02f100b08559.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/381835674ab7c3f7.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/8268a37c4890f71e.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/e2bd809ab2e171e9.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84f1d4eada6960dd.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cee7c32dde4c9323.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ef486034b69d75eb.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/4453bad77d6636b4.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dfbd22c99f7f399e.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5c966d7ef241f1d1.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b1ea991da29cd10f.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cb7ec9243c9cb1bf.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ca947b8fe9734df5.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a412a0891b49ea16.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ddb8c975b9776637.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9425ba6f0e81e31a.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/feca8288b0586eb3.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d238d176bd8ae895.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9fc77bcede8e7238.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/daf421f1dcbde59d.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/bd270492e7e016dc.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/500049d7c719a090.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/3e9ccf27ab1f71e9.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b6dc735f8f16428c.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/094d7d6ad311c845.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84de599a45688bb1.css" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c08d5e89b37d645e.css" data-precedence="next"><link rel="preload" as="script" fetchpriority="low" nonce="" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/webpack-05f11ea662126375.js" crossorigin=""><script async="" src="https://mc.yandex.ru/metrika/tag.js"></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/2a182bb7-47baf338ad7d9e66.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/9500-a8aeea1077b58079.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/main-app-3c64833220c523df.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/1281-08bad9a3d2a60887.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/5080-82f4daed94452227.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/4194-172db2b948bd13ee.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/5609-185e25579372eca4.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/8619-3a701f3773450188.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/9275-7c8f52465eb2613c.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/9515-b7b857111af67561.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/layout-e3a20ad13303521f.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/app/layout-e78d4be001a57a28.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/2665-c77f7b9517a535fe.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/app/error-da5ebf8e69abf3a6.js" async="" crossorigin="" nonce=""></script><link rel="preload" href="https://yastatic.net/s3/cloud/forms/_/embed.js" as="script" nonce=""><meta name="theme-color" content="#a48eef"><meta name="next-size-adjust" content=""><link rel="icon" href="https://yastatic.net/s3/education-portal/web/favicon.ico" sizes="any"><link rel="icon" href="https://yastatic.net/s3/education-portal/web/icon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="https://yastatic.net/s3/education-portal/web/apple-touch-icon.png"><title>Задача «Количество призов» - Основы алгоритмов</title><meta name="description" content="Задача «Количество призов» - Хендбук от Яндекс.Образования. Откройте для себя передовые подходы, практические советы и вдохновляющие идеи от наших экспертов."><link rel="manifest" href="/manifest.webmanifest"><meta name="mobile-web-app-capable" content="yes"><meta name="BookSlug" content="algorithms"><link rel="canonical" href="https://education.yandex.ru/handbook/algorithms/article/zadacha-kolichestvo-prizov"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Яндекс Образование"><link href="https://yastatic.net/s3/education-portal/pwa/logos/ios/512.png" rel="apple-touch-startup-image"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta property="og:title" content="Задача «Количество призов» - Основы алгоритмов"><meta property="og:description" content="Задача «Количество призов» - Хендбук от Яндекс.Образования. Откройте для себя передовые подходы, практические советы и вдохновляющие идеи от наших экспертов."><meta property="og:url" content="https://education.yandex.ru/handbook/algorithms/article/zadacha-kolichestvo-prizov"><meta property="og:image" content="https://yastatic.net/s3/education-portal/media/opengraph_handbook_3_605d176072_3304739c31.webp"><meta property="og:type" content="website"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Задача «Количество призов» - Основы алгоритмов"><meta name="twitter:description" content="Задача «Количество призов» - Хендбук от Яндекс.Образования. Откройте для себя передовые подходы, практические советы и вдохновляющие идеи от наших экспертов."><meta name="twitter:image" content="https://yastatic.net/s3/education-portal/media/opengraph_handbook_3_605d176072_3304739c31.webp"><script id="ab-test-data" nonce="">window.__AB_TEST_DATA = {"flags":{},"experiments":"P54lnS9LcLo,"};</script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/polyfills-42372ed130431b0a.js" crossorigin="anonymous" nomodule="" nonce=""></script><script nonce="" id="rum-error">!function(e,t){if(e.Ya=e.Ya||{},Ya.Rum)throw new Error("Rum: interface is already defined");var n=e.performance,i=n&&n.timing&&n.timing.navigationStart||Ya.startPageLoad||+new Date,s=e.requestAnimationFrame,r=function(){},a=Ya.Rum={_defTimes:[],_defRes:[],_countersToExposeAsEvents:["2325","2616.85.1928","react.inited"],enabled:!!n,version:"6.1.21",vsStart:document.visibilityState,vsChanged:!1,vsChangeTime:1/0,_deltaMarks:{},_markListeners:{},_onComplete:[],_onInit:[],_unsubscribers:[],_eventLisneters:{},_settings:{},_vars:{},init:function(e,t){a._settings=e,a._vars=t},getTime:n&&n.now?function(){return n.now()}:Date.now?function(){return Date.now()-i}:function(){return new Date-i},time:function(e){a._deltaMarks[e]=[a.getTime()]},timeEnd:function(e,t){var n=a._deltaMarks[e];n&&0!==n.length&&n.push(a.getTime(),t)},sendTimeMark:function(e,t,n,i){void 0===t&&(t=a.getTime()),a.emit({metricName:"defTimes",data:[e,t,i]}),a.mark(e,t)},sendDelta:function(e,t,n,i){var s,r=a._deltaMarks;r[e]||void 0===t||(s=i&&i.originalEndTime?i.originalEndTime:a.getTime(),r[e]=[s-t,s,n])},sendResTiming:function(e,t){a.emit({metricName:"defRes",data:[e,t]})},sendRaf:function(e){var t=a.getSetting("forcePaintTimeSending");if(s&&(t||a.isTimeAfterPageShow(a.getTime()))){var n="2616."+e;s((function(){a.getSetting("sendFirstRaf")&&a.sendTimeMark(n+".205"),s((function(){a.sendTimeMark(n+".1928")}))}))}},isVisibilityChanged:function(){return a.vsStart&&("visible"!==a.vsStart||a.vsChanged)},isTimeAfterPageShow:function(e){return"visible"===a.vsStart||a.vsChangeTime<e},mark:n&&n.mark?function(e,t){n.mark(e+(t?": "+t:""))}:function(){},getSetting:function(e){var t=a._settings[e];return null===t?null:t||""},on:function(e,t){if("function"==typeof t)return(a._markListeners[e]=a._markListeners[e]||[]).push(t),function(){if(a._markListeners[e]){var n=a._markListeners[e].indexOf(t);n>-1&&a._markListeners[e].splice(n,1)}}},noop:r,sendTrafficData:r,finalizeLayoutShiftScore:r,finalizeLargestContentfulPaint:r,getLCPAdditionalParams:r,getCLSAdditionalParams:r,getINPAdditionalParams:r,getImageGoodnessAdditionalParams:r,_eventListeners:{},_eventsBuffer:{},subscribe:function(e,t){if(!a.getSetting("noEvents"))return this._eventLisneters[e]=this._eventLisneters[e]||new Set,this._eventLisneters[e].add(t),function(){this.unsubscribe(e,t)}.bind(this)},unsubscribe:function(e,t){this._eventLisneters[e].delete(t)},emit:function(e){if(!a.getSetting("noEvents")){var t=a.getSetting("eventsLimits")&&a.getSetting("eventsLimits")[e.metricName]||20;this._eventLisneters[e.metricName]&&this._eventLisneters[e.metricName].forEach((function(t){t(e)})),this._eventsBuffer[e.metricName]=this._eventsBuffer[e.metricName]||[],this._eventsBuffer[e.metricName].push(e),this._eventsBuffer[e.metricName].length>t&&(this._eventsBuffer[e.metricName].length=Math.floor(t/2))}},getBufferedEvents:function(e){var t=this._eventsBuffer,n={};return Object.keys(t).forEach((function(i){-1!==e.indexOf(i)&&(n[i]=t[i])})),n},clearEvents:function(e){this._eventsBuffer[e]&&(this._eventsBuffer[e].length=0)}};function f(){Ya.Rum.vsChanged=!0,Ya.Rum.vsChangeTime=a.getTime(),removeEventListener("visibilitychange",f)}addEventListener("visibilitychange",f),a._onVisibilityChange=f}(window);
!function(){if(window.PerformanceLongTaskTiming){var e=function(e,n){return(e=e.concat(n)).length>300&&(e=e.slice(e.length-300)),e},n="undefined"!=typeof PerformanceLongAnimationFrameTiming,t=n?["longtask","long-animation-frame"]:["longtask"];function r(){var r=Ya.Rum._tti={events:[],loafEvents:n?[]:void 0,eventsAfterTTI:[],fired:!1,observer:new PerformanceObserver((function(t){var o=t.getEntriesByType("longtask"),s=t.getEntriesByType("long-animation-frame");r.events=e(r.events,o),n&&(r.loafEvents=e(r.loafEvents,s)),r.fired&&(r.eventsAfterTTI=e(r.eventsAfterTTI,o))}))};r.observer.observe({entryTypes:t}),Ya.Rum._unsubscribers&&Ya.Rum._unsubscribers.push((function(){r.observer.disconnect()}))}r(),Ya.Rum._onInit.push(r)}}();
Ya.Rum.observeDOMNode=window.IntersectionObserver?function(e,i,n){var t=this,o=Ya.Rum.getSetting("forcePaintTimeSending");!function r(){if(o||!t.isVisibilityChanged()){var s="string"==typeof i?document.querySelector(i):i;s?new IntersectionObserver((function(i,n){!o&&t.isVisibilityChanged()||(Ya.Rum.sendTimeMark(e),n.unobserve(s))}),n).observe(s):setTimeout(r,100)}}()}:function(){};
var rum_platform = window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop';
    var rum_segment = window.location.pathname.replace(/^\//, "").replace(/\/.*/);
    
    if (["knowledge", "journal", "profile", "handbook"].indexOf(rum_segment) === -1) {
      rum_segment = "portal";
    }

    Ya.Rum.init({ beacon: true, clck: 'https://yandex.ru/clck/click', reqid: '1768063975593584-1199238271730949658'},
    {
        rum_id: 'ru.education.' + rum_platform + '.' + rum_segment,
        '-env': 'production',
        '-project': 'education-web',
        '-page': window.location.pathname,
        '-version': 'undefined',
        '-platform': rum_platform
    });Ya.Rum.observeDOMNode('2876', 'body');!function(){var e,t,n,i=Ya.Rum,o=42,r=4e4,g=15,a=[],s="\r\n",l=i.getSetting("countersInitialDelay")||0;if(l){var c;function u(){removeEventListener("visibilitychange",h),clearTimeout(c),l=0,f()}function h(){document.hidden&&u()}c=setTimeout(u,l),addEventListener("visibilitychange",h)}function f(){if(t&&a.length){for(var n=0,i=0,l=0;i<a.length&&l<=r&&n<o;i++)(l+=(i?s.length:0)+a[i].length)<=r&&n++;var c=a.splice(0,n);d(t,c.join(s)),a.length&&(e=setTimeout(f,g))}else a.length=0}function d(e,t){if(!(navigator.sendBeacon&&n&&navigator.sendBeacon(e,t))){var o=Boolean(i.getSetting("sendCookie")),r=new XMLHttpRequest;r.open("POST",e),r.withCredentials=o,r.send(t)}}i.send=function(c,u,h,d,v,m,S,p){t=i.getSetting("clck"),n=i.getSetting("beacon"),o=i.getSetting("maxBatchCounters")||o,r=i.getSetting("maxBatchLength")||r,g=i.getSetting("countersBatchTimeout")||g,function(t,n,i,c,u,h,d,v,m,S){clearTimeout(e);var p=[t?"/reqid="+t:"",n?"/"+n.join("/"):"",i?"/path="+i:"",c?"/events="+c:"",u?"/slots="+u.join(";"):"",h?"/experiments="+h.join(";"):"",d?"/vars="+d:"","/cts="+(new Date).getTime(),"","/*"].join("");p.length>r?"undefined"!=typeof console&&console.error&&console.error("Counter length "+p.length+" is more than allowed "+r,p):(a.push(p),l||(function(){if(a.length>=o)return!0;for(var e=0,t=0;t<a.length;t++)if((e+=(t?s.length:0)+a[t].length)>=r)return!0;return!1}()?f():e=setTimeout(f,g)))}(i.getSetting("reqid"),S,u,v,i.getSetting("slots"),i.getSetting("experiments"),h)}}();
!function(){var e=Ya.Rum,n=!window.BigInt||!("PerformanceObserver"in window);function t(n){e._unsubscribers.push(n)}function i(e,i,o){if(!n){var a=o||{};if(e){a.type=e,a.hasOwnProperty("buffered")||(a.buffered=!0);var s=new PerformanceObserver((function(e,n){return i(e.getEntries(),n)}));return r((function(){try{s.observe(a)}catch(e){return void console.error(e.message)}t((function(){s.disconnect()}))}),0),s}throw new Error("PO without type field is forbidden")}}function r(e,n){var i=setTimeout(e,n);return t((function(){clearInterval(i)})),i}function o(e,n,i){addEventListener(e,n,i),t((function(){removeEventListener(e,n,i)}))}function a(e,n,t){o("visibilitychange",(function i(){if("hidden"===document.visibilityState){try{t||(removeEventListener("visibilitychange",i),e.disconnect())}catch(e){}n()}})),o("beforeunload",n)}function s(e,n){return"string"==typeof e?encodeURIComponent(e):Math.round(1e3*(e-(n||0)))/1e3}function u(e){if(!e)return"";var n=(e.tagName||"").toLowerCase(),t=e.className&&void 0!==e.className.baseVal?e.className.baseVal:e.className;return n+(t?(" "+t).replace(/\s+/g,"."):"")}function c(e){function n(){removeEventListener("DOMContentLoaded",n),removeEventListener("load",n),e()}"loading"===document.readyState?(o("DOMContentLoaded",n),o("load",n)):e()}function d(n){e._onComplete.push(n)}function f(){return e._periodicTasks}function l(){var n=e._vars;return Object.keys(n).map((function(e){return e+"="+encodeURIComponent(n[e]).replace(/\*/g,"%2A")}))}var m={connectEnd:2116,connectStart:2114,decodedBodySize:2886,domComplete:2124,domContentLoadedEventEnd:2131,domContentLoadedEventStart:2123,domInteractive:2770,domLoading:2769,domainLookupEnd:2113,domainLookupStart:2112,duration:2136,encodedBodySize:2887,entryType:2888,fetchStart:2111,initiatorType:2889,loadEventEnd:2126,loadEventStart:2125,nextHopProtocol:2890,redirectCount:1385,redirectEnd:2110,redirectStart:2109,requestStart:2117,responseEnd:2120,responseStart:2119,secureConnectionStart:2115,startTime:2322,transferSize:2323,type:76,unloadEventEnd:2128,unloadEventStart:2127,workerStart:2137},v=625;function g(n,t){Object.keys(m).forEach((function(e){if(e in t){var i=t[e];(i||0===i)&&n.push(m[e]+"="+s(i))}})),n.push("".concat(v,"=").concat(e.version))}var p,h,y,S,T,b="690.2096.2877",w="690.2096.207",E="690.2096.2044",C=3,k=e.getSetting("savedDeltasLimit")||0,L=document.createElement("link"),P=window.performance||{},M="function"==typeof P.getEntriesByType,_=0;function O(n,t,i,r,o){void 0===t&&(t=e.getTime()),void 0!==i&&!0!==i||e.mark(n,t);var a=I(n);if(a.push("207="+s(t)),x(a,r)){j(w,a,o&&o.force),p[n]=p[n]||[],p[n].push(t);var u=e._markListeners[n];u&&u.length&&u.forEach((function(e){e(t)})),e.emit({metricName:n,value:t,params:r})}}function I(n){return T.concat([e.isVisibilityChanged()?"-vsChanged=1":"","1701="+n,e.ajaxStart&&"1201.2154="+s(e.ajaxStart),e.ajaxComplete&&"1201.2052="+s(e.ajaxComplete)])}function N(){S=l(),e.getSetting("sendClientUa")&&S.push("1042="+encodeURIComponent(navigator.userAgent))}function R(){var e=window.performance&&window.performance.timing&&window.performance.timing.navigationStart;T=S.concat(["143.2129="+e])}function x(e,n){if(n){if(n.isCanceled&&n.isCanceled())return!1;var t=e.reduce((function(e,n,t){return"string"==typeof n&&(e[n.split("=")[0]]=t),e}),{});Object.keys(n).forEach((function(i){if("function"!=typeof n[i]){var r=t[i],o=i+"="+n[i];void 0===r?e.push(o):e[r]=o}}))}return!0}function j(n,t,i){var r=encodeURIComponent(window.YaStaticRegion||"unknown");t.push("-cdn="+r);var o=t.filter(Boolean).join(",");e.send(null,n,o,void 0,void 0,void 0,void 0,i)}function z(e,n,t){j(e,F().concat(n),t)}function B(n,t){var i=y[n];i&&0!==i.length&&(i.push(e.getTime(),t),A(n))}function A(n,t,i,r){var o,a,u,c=y[n];if(void 0!==t?o=(a=r&&r.originalEndTime?r.originalEndTime:e.getTime())-t:c&&(o=c[0],a=c[1],u=c[2]),void 0!==o&&void 0!==a){var d=I(n);d.push("207.2154="+s(o),"207.1428="+s(a),"2877="+s(a-o)),x(d,i)&&x(d,u)&&(j(b,d,r&&r.force),_<k&&(h[n]=h[n]||[],h[n].push(a-o),_++),e.emit({metricName:n,value:a-o,params:{start:o,end:a}}),delete y[n])}}function V(e,n){if(!M)return n(null);L.href=e;var t=0,i=100,o=L.href;r((function e(){var a=P.getEntriesByName(o);if(a.length)return n(a);t++<C?(r(e,i),i+=i):n(null)}),0)}function U(e,n,t){V(n,(function(i){i&&D(e,i[i.length-1],n,t)}))}function D(n,t,i,r){var o=I(n);e.getSetting("sendUrlInResTiming")&&o.push("13="+encodeURIComponent(i)),g(o,t),x(o,r),j(E,o)}function F(){return S}var W={bluetooth:2064,cellular:2065,ethernet:2066,none:1229,wifi:2067,wimax:2068,other:861,unknown:836,0:836,1:2066,2:2067,3:2070,4:2071,5:2768},H=navigator.connection;function Q(e){if(H){var n=W[H.type];e.push("2437="+(n||2771),void 0!==H.downlinkMax&&"2439="+H.downlinkMax,H.effectiveType&&"2870="+H.effectiveType,void 0!==H.rtt&&"rtt="+H.rtt,void 0!==H.downlink&&"dwl="+H.downlink,!n&&"rawType="+H.type)}}var Y,q,G,J,$,K,X,Z,ee="690.2096.4004",ne=!1,te=1/0,ie=1/0,re=("layout-shift",Boolean(window.PerformanceObserver&&window.PerformanceObserver.supportedEntryTypes&&-1!==window.PerformanceObserver.supportedEntryTypes.indexOf("layout-shift"))?0:null);function oe(){$>q&&(q=$,G=J,e.emit({metricName:"cls-debug",value:q,params:{clsEntries:G,target:ae(G)}}))}function ae(e){var n;if(!e)return null;var t=null;if((n=e.reduce((function(e,n){return e&&e.value>n.value?e:n})))&&n.sources&&n.sources.length){for(var i=0;i<n.sources.length;i++){var r=n.sources[i];if(r.node&&1===r.node.nodeType){t=r;break}}t=t||n.sources[0]}return t}function se(e){null==q&&(q=0);for(var n=0;n<e.length;n++){var t=e[n];t.hadRecentInput||($&&t.startTime-J[J.length-1].startTime<te&&t.startTime-J[0].startTime<ie?($+=t.value,J.push(t)):(oe(),$=t.value,J=[t]))}oe()}function ue(){q=re,Y=void 0,G=null,J=null,$=null,ne=!1}function ce(n){if(null!=q&&!ne){var t=Math.round(1e6*q)/1e6;if(Y!==t){Y=t,e.getSetting("enableContinuousCollection")||(ne=!0);var i=ae(G),r=["s="+t];r.push("target="+u(i&&i.node));var o=e.getCLSAdditionalParams(i);o&&x(r,o),z(ee,r,n),e.emit({metricName:"cls-debug",value:q,params:{clsEntries:J,target:i,isFinalized:ne}})}}}function de(n){var t=n[n.length-1];K=t.renderTime||t.loadTime,X=t,e.emit({metricName:"largest-contentful-paint-debug",value:K,params:{entry:t}}),Z||(O("largest-loading-elem-paint",K),Z=!0)}function fe(n){if(null!=K){var t=e.getLCPAdditionalParams(X);O("largest-contentful-paint",K,!1,t,n&&{force:!0}),e.emit({metricName:"largest-contentful-paint-debug",value:K,params:{additionalParams:t,entry:X,isFinalized:!0}}),K=null,X=null}}e.getLCPAdditionalParams===e.noop&&(e.getLCPAdditionalParams=function(){var n={},t=X.element;if(t){n["-className"]=e.getSelector(t),n["-tagName"]=t.tagName.toLowerCase();var i=t.getBoundingClientRect();n["-width"]=i.width,n["-height"]=i.height}return X.size&&(n["-size"]=X.size),n});var le={"first-paint":2793,"first-contentful-paint":2794},me=Object.keys(le).length,ve={},ge=window.performance||{},pe="function"==typeof ge.getEntriesByType,he=0;function ye(){if(pe&&(e.getSetting("forcePaintTimeSending")||!e.isVisibilityChanged()))for(var n=ge.getEntriesByType("paint"),t=0;t<n.length;t++){var i=n[t],r=le[i.name];r&&!ve[i.name]&&(ve[i.name]=!0,he++,O("1926."+r,i.startTime))}}var Se=3e3,Te=1;function be(){return e._tti.events||[]}function we(){return e._tti.loafEvents}function Ee(){return e._tti}function Ce(n){return n?n===e.getPageUrl()?"<page>":n.replace(/\?.*$/,""):n}function ke(n,t,i){if(Ee()){var r=e.getTime(),o="undefined"!=typeof PerformanceLongAnimationFrameTiming&&e.getSetting("sendLongAnimationFrames");Le((function(a){var u,c={2796.2797:Pe(be(),t),689.2322:s(r)};if(o){var d=function(e){var n=we();if(n)return e?n.filter((function(n){return n.startTime+n.duration>=e})):n}(t);d&&(c["loaf.2797"]=Pe(d,void 0,{useName:!1}),1===e.getSetting("longAnimationFramesMode")&&(c["-additional"]=encodeURIComponent(JSON.stringify({loaf:(u=d,u.map(Me))}))))}i&&Object.keys(i).forEach((function(e){c[e]=i[e]})),O(n||"2795",a,!0,c,{force:Boolean(o)}),e._tti.fired=!0}),t)}}function Le(n,t){var i=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).mode,o=void 0===i?Te:i;Ee()&&(t||(t=e.getTime()),function i(){var a,s=t,u=e.getTime(),c=o===Te?be():we()||[],d=c.length;0!==d&&(a=c[d-1],s=Math.max(s,Math.floor(a.startTime+a.duration))),u-s>=Se?n(s):r(i,1e3)}())}function Pe(e,n){var t=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).useName,i=void 0===t||t;return n=n||0,(e=e||[]).filter((function(e){return n-e.startTime<=50})).map((function(e){var n=Math.floor(e.startTime),t=Math.floor(n+e.duration);return i?(e.name?e.name.split("-").map((function(e){return e[0]})).join(""):"u")+"-"+n+"-"+t:n+"-"+t})).join(".")}function Me(e){var n=e.blockingDuration,t=e.duration,i=e.firstUIEventTimestamp,r=e.renderStart,o=e.scripts,a=e.startTime,s=e.styleAndLayoutStart;return[Math.round(a),Math.round(t),o.map(Oe),Math.round(n),Math.round(i),Math.round(r),Math.round(s)]}function _e(e){return{"user-callback":1,"event-listener":2,"resolve-promise":3,"reject-promise":4,"classic-script":5,"module-script":6}[e]||0}function Oe(e){var n=e.invoker,t=e.sourceURL,i=e.sourceFunctionName,r=e.sourceCharPosition,o=e.startTime,a=e.duration,s=e.windowAttribution,u=e.executionStart,c=e.forcedStyleAndLayoutDuration,d=e.pauseDuration,f=e.invokerType;return[Ce(n),Ce(t),i,r,Math.round(o),Math.round(a),s,Math.round(u),Math.round(c),Math.round(d),_e(f)]}var Ie="690.2096.361",Ne=document.createElement("a"),Re=0,xe={};function je(e){var n=e.transferSize;if(null!=n){Ne.href=e.name;var t=Ne.pathname;if(0!==t.indexOf("/clck")){var i=t.lastIndexOf("."),r="";return-1!==i&&t.lastIndexOf("/")<i&&t.length-i<=5&&(r=t.slice(i+1)),{size:n,domain:Ne.hostname,extension:r}}}}function ze(){var n=e.getSetting("maxTrafficCounters")||250;if(Re>=n)return!1;for(var t=Object.keys(xe),i="",r=0;r<t.length;r++){var o=t[r],a=xe[o];i+=encodeURIComponent(o)+"!"+a.count+"!"+a.size+";"}return i.length&&(Re++,z(Ie,["d="+i,"t="+s(e.getTime())])),xe={},Re<n}d(ze);var Be="690.1033",Ae={visible:1,hidden:2,prerender:3},Ve=window.performance||{},Ue=Ve.navigation||{},De=Ve.timing||{},Fe=De.navigationStart;function We(){var n=De.domContentLoadedEventStart,t=De.domContentLoadedEventEnd;if(0!==n||0!==t){var i=0===De.responseStart?Fe:De.responseStart,o=0===De.domainLookupStart?Fe:De.domainLookupStart,a=["2129="+Fe,"1036="+(o-Fe),"1037="+(De.domainLookupEnd-De.domainLookupStart),"1038="+(De.connectEnd-De.connectStart),De.secureConnectionStart&&"1383="+(De.connectEnd-De.secureConnectionStart),"1039="+(De.responseStart-De.connectEnd),"1040="+(De.responseEnd-i),"1040.906="+(De.responseEnd-o),"1310.2084="+(De.domLoading-i),"1310.2085="+(De.domInteractive-i),"1310.1309="+(t-n),"1310.1007="+(n-i),navigator.deviceMemory&&"3140="+navigator.deviceMemory,navigator.hardwareConcurrency&&"3141="+navigator.hardwareConcurrency];Object.keys(m).forEach((function(e){e in De&&De[e]&&a.push(m[e]+"="+s(De[e],Fe))})),e.vsStart?(a.push("1484="+(Ae[e.vsStart]||2771)),e.vsChanged&&a.push("1484.719=1")):a.push("1484="+Ae.visible),Ue&&(Ue.redirectCount&&a.push("1384.1385="+Ue.redirectCount),1!==Ue.type&&2!==Ue.type||a.push("770.76="+Ue.type)),Q(a),z(Be,a)}else r(We,50)}var He="690.2096.2892",Qe=window.performance||{},Ye="function"==typeof Qe.getEntriesByType;if(!e)throw new Error("Rum: interface is not included");if(e.enabled){function qe(){p={},h={},_=0,y=e._deltaMarks,N(),R(),e.ajaxStart=0,e.ajaxComplete=0,c(Je)}function Ge(){var n;e.sendTimeMark=O,e.sendResTiming=U,e.sendTiming=D,e.timeEnd=B;var t=(e.getBufferedEvents(["defRes"]).defRes||[]).map((function(e){return e.data}));for(n=0;n<t.length;n++)U(t[n][0],t[n][1]);e.clearEvents("defRes");var i=(e.getBufferedEvents(["defTimes"]).defTimes||[]).map((function(e){return e.data}));for(n=0;n<i.length;n++)O(i[n][0],i[n][1],!1,i[n][2]);e.clearEvents("defTimes"),Object.keys(y).forEach((function(e){A(e)}))}function Je(){var n=window.performance&&window.performance.timing&&window.performance.timing.navigationStart,t=e.getSetting("skipTiming"),a=e.getSetting("techParamsByVisible");n&&(a&&addEventListener("visibilitychange",(function n(){"visible"!==e.vsStart?"visible"===document.visibilityState&&(e.vsStart="visible",removeEventListener("visibilitychange",n),We()):removeEventListener("visibilitychange",n)})),r((function(){Ge(),(!t&&!a||a&&"visible"===e.vsStart)&&We(),e.getSetting("disableFCP")||(ye(),he<me&&i("paint",(function(e,n){ye(),n&&he>=me&&n.disconnect()}),{buffered:!0})),e.getSetting("sendAutoElementTiming")&&(!window.PerformanceObserver||!e.getSetting("forcePaintTimeSending")&&e.isVisibilityChanged()||i("element",(function(e){for(var n=0;n<e.length;n++){var t=e[n];O("element-timing."+t.identifier,t.startTime)}}))),o("pageshow",Xe),ke(),"complete"===document.readyState?$e({skipTimingApi:t}):o("load",$e.bind(void 0,{skipTimingApi:t}))}),0))}function $e(n){var r,s;e.getSetting("disableOnLoadTasks")||(removeEventListener("load",$e),n.skipTimingApi||function(){if(Ye){var e=Qe.getEntriesByType("navigation")[0];if(e){var n=[];g(n,e),Q(n);var t=Qe.getEntriesByName("yndxNavigationSource")[0];t&&n.push("2091.186="+t.value);var i=Qe.getEntriesByName("yndxNavigationToken","yndxEntry")[0];i&&n.push("2091.3649="+i.value),z(He,n)}}}(),(s=e.getSetting("periodicStatsIntervalMs"))||null===s||(s=15e3),s&&(r=setInterval(Ze,s),t((function(){clearInterval(r)})),Ke=r),o("beforeunload",Ze),function(){if(window.PerformanceObserver){xe={},Re=0;var e=function(e){!function(e){if(e&&e.length)for(var n=xe,t=0;t<e.length;t++){var i=je(e[t]);if(i){var r=i.domain+"-"+i.extension,o=n[r]=n[r]||{count:0,size:0};o.count++,o.size+=i.size}}}(e)};i("resource",e),i("navigation",e),f().push(ze)}}(),e.getSetting("disableFID")||i("first-input",(function(n,t){var i=n[0];if(i){var r=i.processingStart,o={duration:i.duration,js:i.processingEnd-r,name:i.name};i.target&&(o.target=u(i.target));var a=r-i.startTime;A("first-input",a,o),e.emit({metricName:"first-input-debug",value:a,params:{entry:i,additionalParams:o}}),t.disconnect()}}),{buffered:!0}),e.getSetting("disableCLS")||window.PerformanceObserver&&(d(ce),d(ue),q=re,G=null,J=null,$=null,te=e.getSetting("clsWindowGap")||te,ie=e.getSetting("clsWindowSize")||ie,a(i("layout-shift",se),(function(){return ce(!0)}),!0)),e.getSetting("disableLCP")||!window.PerformanceObserver||!e.getSetting("forcePaintTimeSending")&&e.isVisibilityChanged()||(d(fe),K=null,X=null,Z=!1,a(i("largest-contentful-paint",de),(function(){return fe(!0)}),!1)))}var Ke;function Xe(e){e.persisted&&O("bfcache")}function Ze(){var e=!1;f().forEach((function(n){n()&&(e=!0)})),e||clearInterval(Ke)}d(Ge),e.destroy=function(n){var t=e._unsubscribers;n.shouldComplete&&e.completeSession(!0),e._onComplete=[];for(var i=0;i<t.length;i++)t[i]();removeEventListener("visibilitychange",e._onVisibilityChange),e._unsubscribers=[],e._periodicTasks=[],e._markListeners={},e._deltaMarks={}},e.restart=function(n,t,i){e.destroy({shouldComplete:i}),e.init(n,t),addEventListener("visibilitychange",e._onVisibilityChange),qe(),function(){for(var n=0;n<e._onInit.length;n++)e._onInit[n]()}()},e.setVars=function(n){Object.keys(n).forEach((function(t){e._vars[t]=n[t]})),N(),R()},e.completeSession=function(n){for(var t=e._onComplete,i=0;i<t.length;i++)t[i](n)},qe(),e._periodicTasks=[],e.sendHeroElement=function(e){O("2876",e)},e.getPageUrl=function(){return window.location.href},e._subpages={},e.makeSubPage=function(n,t){var i=e._subpages[n];e._subpages[n]=void 0===i?i=0:++i;var r=!1;return{689.2322:s(void 0!==t?t:e.getTime()),2924:n,2925:i,isCanceled:function(){return r},cancel:function(){r=!0}}},e.getTimeMarks=function(){return p},e.getDeltas=function(){return h},e.getVarsList=l,e.getResourceTimings=V,e.pushConnectionTypeTo=Q,e.pushTimingTo=g,e.normalize=s,e.sendCounter=j,e.sendDelta=A,e.onReady=c,e.getSelector=u,e.getSetting("disableCLS")||(e.finalizeLayoutShiftScore=ce),e.getSetting("disableLCP")||(e.finalizeLargestContentfulPaint=fe),e.sendTrafficData=ze,e._getCommonVars=F,e._addListener=o,e._observe=i,e._timeout=r,e.sendTTI=ke,e._getLongtasksStringValue=Pe,e.onQuietWindow=Le,e.sendBFCacheTimeMark=Xe}else e.getSetting=function(){return""},e.getVarsList=function(){return[]},e.getResourceTimings=e.completeSession=e.pushConnectionTypeTo=e.pushTimingTo=e.normalize=e.sendCounter=e.destroy=e.restart=e.setVars=e.completeSession=e.sendDelta=e.sendTimeMark=e.sendResTiming=e.sendTiming=e.sendTTI=e.makeSubPage=e.sendHeroElement=e.onReady=e.onQuietWindow=function(){}}();
!function(n){if(!n.Ya||!Ya.Rum)throw new Error("Rum: interface is not defined");var e=Ya.Rum;e.getSetting=function(n){var t=e._settings[n];return null===t?null:t||""}}("undefined"!=typeof self?self:window);
!function(e,r){var n={client:["690.2354",1e3,100,0],uncaught:["690.2361",100,10,0],external:["690.2854",100,10,0],script:["690.2609",100,10,0]},t={};r.ERROR_LEVEL={INFO:"info",DEBUG:"debug",WARN:"warn",ERROR:"error",FATAL:"fatal"},r._errorSettings={clck:"https://yandex.ru/clck/click",beacon:!0,project:"unknown",page:"",env:"",experiments:[],additional:{},platform:"",region:"",dc:"",host:"",service:"",level:"",version:"",yandexuid:"",loggedin:!1,coordinates_gp:"",referrer:!0,preventError:!1,unhandledRejection:!1,traceUnhandledRejection:!1,uncaughtException:!0,debug:!1,limits:{},silent:{},filters:{},pageMaxAge:864e6,initTimestamp:+new Date};var o=!1;function a(e,r){for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n]);return e}function i(e){return"boolean"==typeof e&&(e=+e),"number"==typeof e?e+"":null}r.initErrors=function(n){var t=a(r._errorSettings,n);o||(t.uncaughtException&&function(){var n=r._errorSettings;if(e.addEventListener)e.addEventListener("error",s),n.resourceFails&&e.addEventListener("error",l,!0),"Promise"in e&&n.unhandledRejection&&e.addEventListener("unhandledrejection",function(e){var n,t,o=e.reason,a={};o&&(o.stack&&o.message?(n=o.message,t=o.stack):(n=String(o),t=r._parseTraceablePromiseStack(e.promise),"[object Event]"===n?n="event.type: "+o.type:"[object Object]"===n&&(a.unhandledObject=o)),o.target&&o.target.src&&(a.src=o.target.src),s({message:"Unhandled rejection: "+n,stack:t,additional:a}))});else{var t=e.onerror;e.onerror=function(e,r,n,o,a){s({error:a||new Error(e||"Empty error"),message:e,lineno:n,colno:o,filename:r}),t&&t.apply(this,arguments)}}}(),t.unhandledRejection&&t.traceUnhandledRejection&&r._traceUnhandledRejection&&r._traceUnhandledRejection(),o=!0)},r.updateErrors=function(e){a(r._errorSettings,e)},r.updateAdditional=function(e){r._errorSettings.additional=a(r._errorSettings.additional||{},e)},r._handleError=function(e,o,i){var s,l,c=r._errorSettings;if(c.preventError&&e.preventDefault&&e.preventDefault(),o)s=e,l="client";else{s=r._normalizeError(e),l=s.type;var d=c.onError;"function"==typeof d&&d(s);var u=c.transform;if("function"==typeof u&&(s=u(s)),!s)return;s.settings&&(i=s.settings)}var g=+new Date,f=c.initTimestamp,p=c.pageMaxAge;if(!(-1!==p&&f&&f+p<g)){var m=n[l][1];"number"==typeof c.limits[l]&&(m=c.limits[l]);var v=n[l][2];"number"==typeof c.silent[l]&&(v=c.silent[l]);var h=n[l][3];if(h<m||-1===m){s.path=n[l][0];var E=r._getErrorData(s,{silent:h<v||-1===v?"no":"yes",isCustom:Boolean(o)},a(a({},c),i)),_=function(e){t[s.message]=!1,r._sendError(e.path,e.vars),n[l][3]++}.bind(this,E);if(void 0===c.throttleSend)_();else{if(t[s.message])return;t[s.message]=!0,setTimeout(_,c.throttleSend)}}}},r._getReferrer=function(r){var n=r.referrer,t=typeof n;return"function"===t?n():"string"===t&&n?n:!1!==n&&e.location?e.location.href:void 0},r.getErrorSetting=function(e){return r._errorSettings[e]},r._buildExperiments=function(e){return e instanceof Array?e.join(";"):""},r._buildAdditional=function(e,r){var n="";try{var t=a(a({},e),r);0!==Object.keys(t).length&&(n=JSON.stringify(t))}catch(e){}return n},r._getErrorData=function(n,t,o){t=t||{};var a=r._buildExperiments(o.experiments),s=r._buildAdditional(o.additional,n.additional),l={"-stack":n.stack,"-url":n.file,"-line":n.line,"-col":n.col,"-block":n.block,"-method":n.method,"-msg":n.message,"-env":o.env,"-external":n.external,"-externalCustom":n.externalCustom,"-project":o.project,"-service":n.service||o.service,"-page":n.page||o.page,"-platform":o.platform,"-level":n.level,"-experiments":a,"-version":o.version,"-region":o.region,"-dc":o.dc,"-host":o.host,"-yandexuid":o.yandexuid,"-loggedin":o.loggedin,"-coordinates_gp":n.coordinates_gp||o.coordinates_gp,"-referrer":r._getReferrer(o),"-source":n.source,"-sourceMethod":n.sourceMethod,"-type":t.isCustom?n.type:"","-additional":s,"-adb":i(Ya.blocker)||i(o.blocker),"-cdn":e.YaStaticRegion,"-ua":navigator.userAgent,"-silent":t.silent,"-ts":+new Date,"-init-ts":o.initTimestamp};return o.debug&&e.console&&console[console[n.level]?n.level:"error"]("[error-counter] "+n.message,l,n.stack),{path:n.path,vars:l}},r._baseNormalizeError=function(e){var r=(e=e||{}).error,n=e.filename||e.fileName||"",t=r&&r.stack||e.stack||"",o=e.message||"",a=r&&r.additional||e.additional;return{file:n,line:e.lineno||e.lineNumber,col:e.colno||e.colNumber,stack:t,message:o,additional:a}},r._normalizeError=function(e){var n=r._baseNormalizeError(e),t="uncaught",o=r._isExternalError(n.file,n.message,n.stack),a="",i="";return o.hasExternal?(t="external",a=o.common,i=o.custom):/^Script error\.?$/.test(n.message)&&(t="script"),n.external=a,n.externalCustom=i,n.type=t,n},r._createVarsString=function(e){var r=[];for(var n in e)e.hasOwnProperty(n)&&(e[n]||0===e[n])&&r.push(n+"="+encodeURIComponent(e[n]).replace(/\*/g,"%2A"));return r.join(",")},r._sendError=function(e,n){r.send(null,e,r._createVarsString(n),null,null,null,null)};var s=function(e){r._handleError(e,!1)},l=function(e){var n=e.target;if(n){var t=n.srcset||n.src;if(t||(t=n.href),t){var o=n.tagName||"UNKNOWN";r.logError({message:o+" load error",additional:{src:t}})}}};r._parseTraceablePromiseStack=function(){}}("undefined"!=typeof self?self:window,Ya.Rum);
!function(e){var r={url:{0:/(miscellaneous|extension)_bindings/,1:/^chrome:/,2:/kaspersky-labs\.com\//,3:/^(?:moz|chrome|safari)-extension:\/\//,4:/^file:/,5:/^resource:\/\//,6:/webnetc\.top/,7:/local\.adguard\.com/},message:{0:/__adgRemoveDirect/,1:/Content Security Policy/,2:/vid_mate_check/,3:/ucapi/,4:/Access is denied/i,5:/^Uncaught SecurityError/i,6:/__ybro/,7:/__show__deepen/,8:/ntp is not defined/,9:/Cannot set property 'install' of undefined/,10:/NS_ERROR/,11:/Error loading script/,12:/^TypeError: undefined is not a function$/,13:/__firefox__\.(?:favicons|metadata|reader|searchQueryForField|searchLoginField)/},stack:{0:/(?:moz|chrome|safari)-extension:\/\//,1:/adguard.*\.user\.js/i}};function n(e,r){if(e&&r){var n=[];for(var o in r)if(r.hasOwnProperty(o)){var i=r[o];"string"==typeof i&&(i=new RegExp(i)),i instanceof RegExp&&i.test(e)&&n.push(o)}return n.join("_")}}function o(e,o){var i,a=[];for(var t in r)r.hasOwnProperty(t)&&(i=n(e[t],o[t]))&&a.push(t+"~"+i);return a.join(";")}e._isExternalError=function(n,i,a){var t=e._errorSettings.filters||{},s={url:(n||"")+"",message:(i||"")+"",stack:(a||"")+""},c=o(s,r),u=o(s,t);return{common:c,custom:u,hasExternal:!(!c&&!u)}}}(Ya.Rum);
Ya.Rum.initErrors({
        reqid: '1768063975593584-1199238271730949658',
        project: 'education-web',
        env: 'production',
        page: window.location.pathname,
        version: 'undefined',
        platform: window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop'
    });</script><style></style><style></style><script nonce="" id="yandex-metrika">
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
  m[i].l=1*new Date();
  for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
  k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
</script><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/0f6801932ea3fcf4-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/305b936a915bc48f-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/3fdc59da94114ecd-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/a853c69d3cf13b17-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/b4b0da158404816f-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/c8ae0fac15b37b16-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/cc87cb16fedd6384-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/dd32e121f6104240-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/e10f0a1f1c5bddfe-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/f2f0493f5123f937-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/f3f9c83d0bcb2176-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" as="style" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84de599a45688bb1.css"><link rel="preload" as="style" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c08d5e89b37d645e.css"></head><body class="utilityfocus HR-9-31-0 Theme Theme_color_hrLight Theme_root_hrLight Theme_controls_size_m styles_with-sticky-drawer__bAg_p" style="overflow: initial;"><style>.gdpr-popup-v3-hidden{display:none;}
.gdpr-popup-v3-button{background-color:#FFDD57;color:#2F3747;padding:8px 16px 8px 16px;border-radius:12px;border:none;cursor:pointer;display:inline-block;}.gdpr-popup-v3-button_theme_dark{background-color:rgba(176,189,214,0.2);color:white;}.gdpr-popup-v3-button_theme_transparent{background-color:transparent;color:white;border:#4C5264 solid 1px;}@media (max-width:576px){.gdpr-popup-v3-button{display:block;text-align:center;padding:1.5vh;border-radius:1.5vh;}}
.gdpr-popup-v3-checkbox{width:36px;height:20px;border-radius:18px;background-color:rgba(165,177,202,0.3);display:flex;cursor:pointer;}.gdpr-popup-v3-checkbox__check{width:16px;height:16px;border-radius:8px;background-color:white;margin:auto;transition:margin ease 1s;}.gdpr-popup-v3-checkbox_checked_yes{background-color:#FFDD57;}.gdpr-popup-v3-checkbox_disabled_yes{background-color:rgba(176,189,214,0.15);}.gdpr-popup-v3-checkbox_disabled_yes .gdpr-popup-v3-checkbox__check{background:rgba(255,255,255,0.5);}.gdpr-popup-v3-checkbox_checked_yes .gdpr-popup-v3-checkbox__check{float:right;margin-right:2px;}.gdpr-popup-v3-checkbox_checked_no .gdpr-popup-v3-checkbox__check{margin-left:2px;}@media (max-width:576px){.gdpr-popup-v3-checkbox{height:5vw;border-radius:2.5vw;width:10vw;}.gdpr-popup-v3-checkbox__check{height:calc(5vw - 4px);width:calc(5vw - 4px);border-radius:calc(2.5vw - 2px);}}
.gdpr-popup-v3-svg{margin:auto;}
.gdpr-popup-v3-spoiler{border-bottom:solid 1px #5F697F;}.gdpr-popup-v3-spoiler__header{display:flex;padding-top:12px;padding-bottom:12px;}.gdpr-popup-v3-spoiler__opener{margin:auto 8px auto 0;cursor:pointer;display:flex;min-height:14px;min-width:14px;}.gdpr-popup-v3-spoiler__opener{background-color:#FFDD57\0/;width:20px\0/;}.gdpr-popup-v3-spoiler__opener .gdpr-popup-v3-svg{margin-top:auto;margin-bottom:auto;}.gdpr-popup-v3-spoiler__label{color:white;font-weight:500;font-size:16px;line-height:24px;margin:0;}.gdpr-popup-v3-spoiler__checkbox-container{margin:auto 0 auto auto;}.gdpr-popup-v3-spoiler__content{margin-bottom:8px;padding-left:30px;}.gdpr-popup-v3-spoiler__description{margin-bottom:16px;line-height:20px;}@media (max-width:576px){.gdpr-popup-v3-spoiler{border-bottom:solid 1px #5F697F;}.gdpr-popup-v3-spoiler__header{height:9vw;padding-top:2vw;padding-bottom:2vw;}.gdpr-popup-v3-spoiler__opener{margin:auto 2vw auto 0;}.gdpr-popup-v3-spoiler__label{font-size:14px;margin-top:auto;margin-bottom:auto;}.gdpr-popup-v3-spoiler__content{margin-bottom:3vw;padding-left:7vw;}.gdpr-popup-v3-spoiler__description{margin-bottom:4vw;}}
.gdpr-popup-v3-main{background-color:#252A38;width:460px;padding:20px;color:#BEBFC3;font-family:'YS Text',Arial,Helvetica,"Arial Unicode MS",sans-serif;font-style:normal;font-size:14px;position:fixed;bottom:30px;right:20px;border-radius:14px;max-height:458px;overflow-y:scroll;z-index:10000;-webkit-text-size-adjust:100%;}.gdpr-popup-v3-main__main-description{line-height:20px;}.gdpr-popup-v3-main::-webkit-scrollbar{display:none;}.gdpr-popup-v3-main__spoilers{margin-top:8px;border-top:solid 1px #5F697F;}.gdpr-popup-v3-main__title{color:white;font-weight:500;font-size:16px;line-height:24px;margin-top:0;}.gdpr-popup-v3-main__buttons{margin-top:16px;display:flex;}.gdpr-popup-v3-main__buttons .gdpr-popup-v3-button{margin-right:8px;}.gdpr-popup-v3-main__buttons .gdpr-popup-v3-button_id_back{padding:8px 10px 8px 10px;font-size:18px;display:flex;}.gdpr-popup-v3-button_id_mobile-back{height:1em;display:none;}.gdpr-popup-v3-main__settings-description{line-height:20px;}.gdpr-popup-v3-main a{color:#FFD21F;text-decoration:none;cursor:pointer;}.gdpr-popup-v3-main a:visited{color:#FFD21F;text-decoration:none;}@media (max-width:576px){.gdpr-popup-v3-main{padding:2.3vh;width:calc(100% - 6.6vh);max-height:80vh;font-size:14px;border-radius:1.5vh;right:1vh;}.gdpr-popup-v3-main__spoilers{margin-top:2vw;border-top:solid 1px #5F697F;}.gdpr-popup-v3-main__title{font-size:16px;line-height:inherit;margin-bottom:0;}.gdpr-popup-v3-main__title span{margin:auto auto auto 16px;}.gdpr-popup-v3-main__title .gdpr-popup-v3-button{padding:8px;float:left;}.gdpr-popup-v3-main__buttons{margin-top:4vw;display:block;}.gdpr-popup-v3-main__buttons .gdpr-popup-v3-button{display:block;margin-right:0;margin-top:8px;}.gdpr-popup-v3-main__buttons .gdpr-popup-v3-button_id_back{display:none;}.gdpr-popup-v3-button_id_mobile-back{display:block;margin-right:10px;}.gdpr-popup-v3-main__settings-title{margin-bottom:8px;text-align:center;display:flex;align-items:center;}}@media (orientation:landscape) and (max-height:450px){.gdpr-popup-v3-main{max-height:70vh;}}</style><div hidden=""><!--$--><!--/$--></div><script id="hasOwnPolyfill" nonce="">('hasOwn' in Object) || (Object.hasOwn = Object.call.bind(Object.hasOwnProperty));</script><script id="UserAGentUADataPolyfill" nonce="">
  function applyUADataPolyfill(){
    function e(a){let b=/Windows NT (\d+(\.\d+)*)/.exec(a);if(!b)return null;let c={"6.1":"0.1","6.2":"0.2","6.3":"0.3","10.0":"10.0","11.0":"13.0"}[b[1]],d=c?q(c,3):"",e="",f="";return/\b(WOW64|Win64|x64)\b/.test(a)&&(e="x86",f="64"),{platform:"Windows",platformVersion:d,architecture:e,bitness:f}}
    function f(a,b){let c=/Android (\d+(\.\d+)*)/.exec(a);if(!c)return null;let d="",e="",f=/Linux (\w+)/.exec(b);if(f&&f[1]){let a=p(f[1]);d=a[0],e=a[1]}return{platform:"Android",platformVersion:q(c[1]),architecture:d,bitness:e}}
    function g(a){let b=/(iPhone|iPod touch); CPU iPhone OS (\d+(_\d+)*)/.exec(a),c=/(iPad); CPU OS (\d+(_\d+)*)/.exec(a),d=b||c;return d?{platform:"iOS",platformVersion:q(d[2].replace(/_/g,"."))}:null}
    function h(a){let b=/Macintosh; (Intel|\w+) Mac OS X (\d+([_.]\d+)*)/.exec(a);return b?{platform:"macOS",platformVersion:q(b[2].replace(/_/g,"."))}:null}
    function i(a){let b=/CrOS (\w+) (\d+(\.\d+)*)/.exec(a);if(!b)return null;let c=p(b[1]);return{platform:"Chrome OS",platformVersion:q(b[2]),architecture:c[0],bitness:c[1]}}
    function j(a,b){for(let c of[()=>e(a),()=>f(a,b),()=>g(a),()=>h(a),()=>i(a)]){let a=c();if(a)return a}return/Linux/.test(a)?{platform:"Linux",platformVersion:""}:{platform:"Unknown",platformVersion:""}}
    function k(a,b,c){let d=/Chrome\/(\d+(\.\d+)*)/.exec(a);if(!d||"Google Inc."!==c)return null;let e=[{brand:"Chromium",version:q(d[1],4)}],f=/(Edge?)\/(\d+(\.\d+)*)/.exec(a);if(f){let a={Edge:"Microsoft Edge",Edg:"Microsoft Edge"}[f[1]];e.push({brand:a,version:q(f[2],4)})}else e.push({brand:"Google Chrome",version:q(d[1],4)});return e}
    function l(a,b){let c=/AppleWebKit\/(\d+(\.\d+)*)/.exec(a);return c&&"Apple Computer, Inc."===b?[{brand:"WebKit",version:q(c[1])}]:null}
    function m(a){let b=/Firefox\/(\d+(\.\d+)*)/.exec(a);return b?[{brand:"Firefox",version:q(b[1])}]:null}
    function n(a,b,c,d,e){let f=!1,g=[];for(let h of[()=>k(a,b,c),()=>l(a,c),()=>m(a)]){let c=h();if(c){g=c,h===k&&/\bwv\b/.test(b)&&(f=!0);let i=/(CriOS|EdgiOS|FxiOS|Version)\/(\d+(\.\d+)*)/.exec(a);if(h===l&&"iOS"===d&&i){let a={CriOS:"Google Chrome",EdgiOS:"Microsoft Edge",FxiOS:"Mozilla Firefox",Version:"Apple Safari"}[i[1]];g.push({brand:a,version:q(i[2])}),e&&!e.some(a=>a.startsWith("Safari/"))&&(f=!0)}break}}return 0===g.length&&(g=[{brand:"Not;A Brand",version:"99.0.0.0"}]),{fullVersionList:g,webview:f}}
    function o(a){let{userAgent:b,platform:c,vendor:d}=a,e=b,f=!1,g=b.replace(/\(([^)]+)\)/g,(a,b)=>(f||(e=b,f=!0),"")),h=g.match(/(\S+)\/(\S+)/g),i=b.includes("Mobile"),k=j(e,c),{fullVersionList:l,webview:m}=n(g,e,d,k.platform,h),o=l.length>0?l[l.length-1].version:"",p=l.map(a=>{let b=a.version.indexOf("."),c=-1===b?a.version:a.version.slice(0,b);return{brand:a.brand,version:c}});return{mobile:i,platform:k.platform,brands:p,platformVersion:k.platformVersion,architecture:k.architecture||"",bitness:k.bitness||"",model:"",uaFullVersion:o,fullVersionList:l,webview:m}}
    function p(a){switch(a){case"x86_64":case"x64":return["x86","64"];case"x86_32":case"x86":return["x86",""];case"armv6l":case"armv7l":case"armv8l":return[a,""];case"aarch64":return["arm","64"];default:return["",""]}}
    function q(a,b=3){let c=a.split(".");if(c.length<b)for(;c.length<b;)c.push("0");return c.join(".")}
    class r{constructor(a){this._clientHints=o(a),Object.defineProperties(this,{_clientHints:{enumerable:!1}})}get mobile(){return this._clientHints.mobile}get platform(){return this._clientHints.platform}get brands(){return this._clientHints.brands}getHighEntropyValues(a){return new Promise(b=>{if(!Array.isArray(a))throw TypeError("Argument hints must be an array");let c=new Set(a),d=this._clientHints,e={mobile:d.mobile,platform:d.platform,brands:d.brands};c.has("architecture")&&(e.architecture=d.architecture),c.has("bitness")&&(e.bitness=d.bitness),c.has("model")&&(e.model=d.model),c.has("platformVersion")&&(e.platformVersion=d.platformVersion),c.has("uaFullVersion")&&(e.uaFullVersion=d.uaFullVersion),c.has("fullVersionList")&&(e.fullVersionList=d.fullVersionList),b(e)})}toJSON(){return{mobile:this._clientHints.mobile,brands:this._clientHints.brands}}}
    function(){if("https:"===location.protocol&&!navigator.userAgentData){Object.defineProperty(r.prototype,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!1,value:"NavigatorUAData"});let a=new r(navigator);return Object.defineProperty(Navigator.prototype,"userAgentData",{enumerable:!0,configurable:!0,get:function(){return a}}),Object.defineProperty(window,"NavigatorUAData",{enumerable:!1,configurable:!0,writable:!0,value:r}),!0}return!1}
    polyfill();
  }
  applyUADataPolyfill();
</script><div class="styles_container__LRzqX"><div class="Toastify" id="defaultToastContainer"></div></div><div class="styles_container__LRzqX"><div class="Toastify" id="noCloseButtonToastContainer"></div></div><header class="styles_header__cN9zm styles_noContentWidth__pFPRk"><div class="styles_header__inset__mXfjd"><div class="styles_header__backdrop__ZkyIx"></div><section class="styles_root__IBJUG styles_header__container__J_Yo5" style="--gutter-size-xs:50px;--gutter-size-sm:50px;--gutter-size-lg:50px;--gutter-size-xl:50px"><div class="styles_header__row__nqo4h"><div class="styles_header__start__OHmLc"><div class="styles_header__logo__TIaUe"><div class="styles_logo-header_primary__Ezzwg"><a aria-label="Яндекс Образование" class="styles_logo-header__link__pDHX1 styles_logo-header__image__zuDpr" href="/"><img alt="Яндекс Образование" aria-hidden="true" class="styles_desktopOnly__j_5Ge" src="https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg"><img alt="Яндекс Образование" aria-hidden="true" class="styles_mobileOnly__3cLf9" src="https://yastatic.net/s3/education-portal/media/logo_mobile_8bc5eb38fb.svg"><h1 aria-hidden="true" class="Text Text_color_primary Text_typography_bodyS styles_logo-header__title__0_MiO styles_text__iQHEy">Яндекс Образование — Личный кабинет</h1></a></div></div></div><div aria-hidden="true" class="styles_header__controls-burger__WUP18"><div class="styles_header__swipe-element__q6aOO"></div><div class="styles_buttonsContainerMobile___WcOD"><div class="styles_header-buttons__WWn3B styles_header__buttons__z2b3Y"><a tabindex="-1" href="https://passport.yandex.ru/auth/?origin=education&amp;retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Falgorithms%2Farticle%2Fzadacha-kolichestvo-prizov"><span class="Button Button_view_primary Button_size_s Button_isInteractive Theme_controls_size_s styles_header-buttons__item__DNLsb" autocomplete="off"><span class="Button-Content Theme_palette_inverse"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span class="Text Text_hideOverflow Button-Text" aria-describedby="2e717e8d-4181-480c-a1a0-2a61dff9d0fe" style="--text-max-visible-lines: 1;">Войти в ID</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></span></a></div></div><nav aria-label="Навигация по сайту" class="styles_top-menu__37_My"><div class="styles_top-menu__links__vkwzq"><a title="Школьникам" class="styles_top-menu__link__joHz8" id="19" tabindex="-1" href="/pupils">Школьникам</a><a aria-disabled="false" title="Студентам" class="styles_top-menu__link__joHz8" id="4136" tabindex="-1" href="/students">Студентам</a><a aria-disabled="false" title="Абитуриентам" class="styles_top-menu__link__joHz8" id="4137" tabindex="-1" href="/university">Абитуриентам</a><a aria-disabled="false" title="Партнёрам" class="styles_top-menu__link__joHz8" id="4138" tabindex="-1" href="https://edumakers.yandex.ru/">Партнёрам</a><a aria-disabled="false" title="События" class="styles_top-menu__link__joHz8" id="4139" tabindex="-1" href="/handbook">Хендбуки</a><a aria-disabled="false" title="Журнал" class="styles_top-menu__link__joHz8" id="4140" tabindex="-1" href="/journal">Журнал</a><a aria-disabled="false" title="AI" class="styles_top-menu__link__joHz8" id="4141" tabindex="-1" href="https://education.yandex.ru/ai">AI</a></div></nav></div><div class="styles_sideGroup__gWR7N"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_header-buttons__search__0Sfs6" aria-label="Поиск" autocomplete="off" type="button" data-testid="search-button"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_icon Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span class="Icon Icon_size_l Icon_hasGlyph_noFill Icon_oldFormat Icon_sizeManagement_self Icon_glyph_search Button-Icon styles_header-buttons__search-icon__6kEp0" aria-hidden="true" style="--hr-icon-color:var(--hr-color-text-secondary)"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11 5a6 6 0 1 0 0 12 6 6 0 0 0 0-12Zm-8 6a8 8 0 1 1 14.32 4.906l3.387 3.387a1 1 0 0 1-1.414 1.414l-3.387-3.387A8 8 0 0 1 3 11Z" fill="currentColor"></path></svg></span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_icon Button-Slot"></div><span class="Button-State"></span></span></button><div class="styles_buttonsContainerDesktop__W9OAy"><div class="styles_header-buttons__WWn3B styles_header__buttons__z2b3Y"><a tabindex="-1" href="https://passport.yandex.ru/auth/?origin=education&amp;retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Falgorithms%2Farticle%2Fzadacha-kolichestvo-prizov"><span class="Button Button_view_primary Button_size_s Button_isInteractive Theme_controls_size_s styles_header-buttons__item__DNLsb" autocomplete="off"><span class="Button-Content Theme_palette_inverse"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text">Войти в ID</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></span></a></div></div><div class="styles_header__toggle__xS3iB"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_toggle__n99_Y" aria-label="Меню" autocomplete="off" type="button" data-testid="header-menu-button"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_icon Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span class="Icon Icon_size_l Icon_hasGlyph_noFill Icon_oldFormat Icon_sizeManagement_self Icon_glyph_menu Button-Icon styles_toggleIcon__SAvbq" aria-hidden="true" style="--hr-icon-color:var(--hr-color-text-secondary)"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3 12a1 1 0 0 1 1-1h16a1 1 0 1 1 0 2H4a1 1 0 0 1-1-1ZM3 18a1 1 0 0 1 1-1h16a1 1 0 1 1 0 2H4a1 1 0 0 1-1-1ZM3 6a1 1 0 0 1 1-1h16a1 1 0 1 1 0 2H4a1 1 0 0 1-1-1Z" fill="currentColor"></path></svg></span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_icon Button-Slot"></div><span class="Button-State"></span></span></button></div></div></div></section></div></header><div class="TopDrawer_root__OZJVp TopDrawer_isOpening__po5Fn styles_drawer__QQFuJ" data-testid="TopDrawer" style="height: 812px;"><div class="TopDrawer_observer__KZrCY"><div class="TopDrawer_overlay__NhRuz"></div><div class="TopDrawer_curtain__RLie3"><div aria-label="Поиск" aria-modal="true" class="TopDrawer_content__qJybk" data-slot="content" role="dialog" tabindex="-1"><div class="styles_content__n9ucm"><button aria-label="Закрыть" class="styles_close__Tvrr3"><span class="Icon Icon_size_l Icon_hasGlyph_noFill Icon_oldFormat Icon_sizeManagement_self Icon_glyph_close" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.293 4.293a1 1 0 0 1 1.414 0L12 10.586l6.293-6.293a1 1 0 1 1 1.414 1.414L13.414 12l6.293 6.293a1 1 0 0 1-1.414 1.414L12 13.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L10.586 12 4.293 5.707a1 1 0 0 1 0-1.414Z" fill="currentColor"></path></svg></span></button><form class="styles_search__3lV53"><div class="styles_root__Yoz99" data-testid="borderlessInput-root"><span aria-hidden="true" class="Icon Icon_size_l Icon_hasGlyph_noFill Icon_oldFormat Icon_sizeManagement_self Icon_glyph_search styles_searchIcon__Fnqiw"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11 5a6 6 0 1 0 0 12 6 6 0 0 0 0-12Zm-8 6a8 8 0 1 1 14.32 4.906l3.387 3.387a1 1 0 0 1-1.414 1.414l-3.387-3.387A8 8 0 0 1 3 11Z" fill="currentColor"></path></svg></span><input autofocus="" maxlength="300" placeholder="Поиск по сайту" class="styles_search_input__xpJY1 styles_input__1iRua" value=""></div></form></div></div></div></div></div><div class="hb"><div class="styles_article-side-panel__k1oHL"><div class="styles_drawer__zco4X"><div class="styles_drawerWrapper__yQ6Ju"><div class="styles_overlay__OqjzT"></div><div class="styles_drawerHeader__G3tPl"><div class="styles_panel-tabs__8BQ4K"><div class="styles_button-wrapper__A8ySg"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button__b2Aik styles_button__slVGb" aria-label="Содержание" autocomplete="off" type="button" data-testid="panel-contents-tab"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span data-icon="book" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__1BYeh" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4.992a6.013 6.013 0 0 0-.107-.132C11.14 3.956 9.881 3 8 3H6a4 4 0 0 0-4 4v8a4 4 0 0 0 3.999 4H8c1.846 0 2.547.46 2.793.707C11.162 20.228 11.15 21 12 21c.85 0 .838-.771 1.207-1.293.246-.246.947-.707 2.793-.707h2.001A3.999 3.999 0 0 0 22 15V7a4 4 0 0 0-4-4h-2c-1.881 0-3.14.956-3.893 1.86a6.013 6.013 0 0 0-.107.132ZM6 5a2 2 0 0 0-2 2v8a2 2 0 0 0 1.999 2H8c1.28 0 2.259.19 3 .503V7.188a4.396 4.396 0 0 0-.643-1.048C9.86 5.544 9.119 5 8 5H6Zm7 12.503c.741-.313 1.72-.503 3-.503h2.001A1.999 1.999 0 0 0 20 15V7a2 2 0 0 0-2-2h-2c-1.119 0-1.86.544-2.357 1.14A4.396 4.396 0 0 0 13 7.188v10.315Z" fill="currentColor"></path></svg></span><span class="styles_text-wrapper__ap6Ri">Содержание</span></span><span class="Button-State"></span></span></button></div><div class="styles_button-wrapper__A8ySg"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button__b2Aik styles_button__slVGb" aria-label="Заметки" autocomplete="off" type="button" data-testid="panel-notes-tab"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span data-icon="bookmark" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__1BYeh" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 6a4 4 0 0 1 4-4h8a4 4 0 0 1 4 4v12.942c0 1.67-1.923 2.604-3.236 1.573L12 16.772l-4.764 3.743C5.923 21.546 4 20.611 4 18.942V6Zm4-2a2 2 0 0 0-2 2v12.942l4.764-3.743a2 2 0 0 1 2.472 0L18 18.942V6a2 2 0 0 0-2-2H8Z" fill="currentColor"></path></svg></span><span class="styles_text-wrapper__ap6Ri">Заметки</span></span><span class="Button-State"></span></span></button></div></div></div><div class="styles_drawerBody__Xqvde" aria-hidden="true" tabindex="-1" hidden=""><div class="styles_header__RdXaV"><h2 class="styles_root__EmBCZ styles_title__w1r1k" data-variant="heading" data-weight="medium" data-color="primary">Содержание</h2><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_close__InH6S styles_button__slVGb" autocomplete="off" type="button" title="закрыть"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_icon Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span data-icon="close" class="Icon Icon_size_s Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat Button-Icon" aria-hidden="true" style="--hr-icon-color:var(--hr-color-text-secondary)"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.293 4.293a1 1 0 0 1 1.414 0L12 10.586l6.293-6.293a1 1 0 1 1 1.414 1.414L13.414 12l6.293 6.293a1 1 0 0 1-1.414 1.414L12 13.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L10.586 12 4.293 5.707a1 1 0 0 1 0-1.414Z" fill="currentColor"></path></svg></span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_icon Button-Slot"></div><span class="Button-State"></span></span></button></div><div class="styles_content__rxXV3"><nav class="styles_menu__EGY9t" data-search-hidden="true" aria-label="Навигация по статье"><ul class="styles_menu-list__bqpuA"><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">1.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Введение</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->4</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">2.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Основные структуры данных</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->7</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">3.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Решение практических задач по программированию</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->4</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">4.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Разминка. Последовательные алгоритмы</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->3</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">5.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Графы</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->6</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">6.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Техники проектирования алгоритмов</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->7</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">7.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Жадные алгоритмы</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->7</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp styles_open__iwALZ" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div><ul class="styles_menu-block__items-list__ZrouL"><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">7.1</span><a class="styles_menu-item__link___ZydP" href="./zadacha-razmen"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Задача «Размен»</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">7.2</span><a class="styles_menu-item__link___ZydP" href="./zadacha-specii"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Задача «Специи»</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">7.3</span><a class="styles_menu-item__link___ZydP" href="./zadacha-reklamnaya-kampaniya"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Задача «Рекламная кампания»</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">7.4</span><a class="styles_menu-item__link___ZydP" href="./zadacha-sbor-podpisej"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Задача «Сбор подписей»</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">7.5</span><span class="styles_menu-item__link___ZydP styles_menu-item__link_active__5CBIq"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__active__a59KG styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Задача «Количество призов»</span><div class="styles_indicator__MC7hu styles_indicator__active__NjQNY" data-testid="sidepanel-indicator"></div></div><ul class="styles_sections__eCQId"><li class="styles_section__BUd09" data-top="220"><a href="#klyuchevye-voprosy-paragrafa">Ключевые вопросы параграфа</a></li><li class="styles_section__BUd09" data-top="743"><a href="#nestandartnaya-zadacha-i-zhadnyj-algoritm">Нестандартная задача и жадный алгоритм</a></li><li class="styles_section__BUd09" data-top="2879"><a href="#chto-dalshe">Что дальше</a></li></ul></span></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">7.6</span><a class="styles_menu-item__link___ZydP" href="./zadacha-maksimalnyj-oklad"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Задача «Максимальный оклад»</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">7.7</span><a class="styles_menu-item__link___ZydP" href="./chemu-vi-nauchilis-seven"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Чему вы научились</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li></ul></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">8.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Динамическое программирование</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->9</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">9.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Разделяй и властвуй</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->6</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li></ul></nav></div></div></div><div class="styles_children__KSNca"><meta property="og:type" content="article" itemprop=""><meta property="article:modified_time" content="2026-01-10T12:07:08.588Z" itemprop=""><meta property="article:author" content="Алексей Толстиков" itemprop=""><meta property="article:author" content="Александр Куликов" itemprop=""><meta property="article:section" content="Основы алгоритмов" itemprop=""><div class="styles_container__SBhDc"><div class="styles_progressContainer__1vGGr"><div class="styles_progressBar__XS_vE" style="width:11px"></div></div><div class="styles_articleCover__EKYZn"><div class="styles_root__jRQsx styles_breadcrumbs__nMPkF" data-search-hidden="true"><div class="styles_backArrow__WbYmN"><span data-icon="arrowShortRight" aria-hidden="true" class="Icon Icon_size_xs Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div><nav aria-label="Хлебные крошки" class="styles_root__vgBQ1" data-search-hidden="true"><ol class="styles_items__QJQzv" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="styles_item__uyDoI" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/" tabindex="0" data-react-aria-pressable="true" itemprop="item" class=""><span class="styles_root__EmBCZ" itemprop="name" data-weight="regular" data-color="inherit">Главная</span></a><meta itemprop="position" content="0"></li><li aria-hidden="true" class="styles_separator__tQEdo">/</li><li class="styles_item__uyDoI" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/handbook" tabindex="0" data-react-aria-pressable="true" itemprop="item" class=""><span class="styles_root__EmBCZ" itemprop="name" data-weight="regular" data-color="inherit">Хендбуки</span></a><meta itemprop="position" content="1"></li><li aria-hidden="true" class="styles_separator__tQEdo">/</li><li class="styles_item__uyDoI styles_showMobile__l2S6V" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/handbook/algorithms" tabindex="0" data-react-aria-pressable="true" itemprop="item" class=""><span class="styles_root__EmBCZ" itemprop="name" data-weight="regular" data-color="inherit">Основы алгоритмов</span></a><meta itemprop="position" content="2"></li><li aria-hidden="true" class="styles_separator__tQEdo">/</li><li class="styles_item__uyDoI" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><span class="styles_root__EmBCZ" itemprop="name" data-weight="regular" data-color="inherit">Задача «Количество призов»</span><meta itemprop="position" content="3"></li></ol></nav></div><h1 class="styles_root__EmBCZ styles_title__Ae0WW" data-search-hidden="true" data-variant="heading" data-weight="medium" data-color="primary">7.5 Задача «Количество призов»</h1><div class="styles_authors__hRs06"><span class="styles_root__EmBCZ styles_title__rlqZz" data-weight="medium" data-color="primary">Авторы</span><a class="styles_author__OycJw" href="../team#tolstikov"><div class="styles_avatar__hR8ST"><img aria-hidden="true" name="Алексей Толстиков" hash="tolstikov_60bac4f4ce_9fe4041647" ext=".webp" mime="image/webp" size="208.27" url="https://yastatic.net/s3/education-portal/media/tolstikov_60bac4f4ce_9fe4041647.webp" provider="strapi-plugin-yandexify" alt="Алексей Толстиков" loading="lazy" width="1863" height="1809" decoding="async" data-nimg="1" style="color:transparent" src="https://yastatic.net/s3/education-portal/media/tolstikov_60bac4f4ce_9fe4041647.webp"></div><div class="styles_name__Fz_z2"><span>Алексей Толстиков</span></div></a><a class="styles_author__OycJw" href="../team#kulikov"><div class="styles_avatar__hR8ST"><img aria-hidden="true" name="Александр Куликов" hash="kulikov_75205593a5_f3f4036ed9" ext=".webp" mime="image/webp" size="90.21" url="https://yastatic.net/s3/education-portal/media/kulikov_75205593a5_f3f4036ed9.webp" provider="strapi-plugin-yandexify" alt="Александр Куликов" loading="lazy" width="1135" height="1280" decoding="async" data-nimg="1" style="color:transparent" src="https://yastatic.net/s3/education-portal/media/kulikov_75205593a5_f3f4036ed9.webp"></div><div class="styles_name__Fz_z2"><span>Александр Куликов</span></div></a></div></div><main class="styles_root__R5rVX" data-testid="ArticleContent-root" data-ai-main-material="true"><div class="hljs_hljs-atelier-heath__2Efzm styles_content__jb6Og" id="article-content"><div class="styles_notes-from-selected__d23uG"><div><div class="styles_content__Lzr6L"><div id="wysiwyg-client-content"><p>В этом параграфе вы разберёте задачу, в которой нужно раздать ограниченное количество конфет максимально возможному числу призёров, соблюдая строгий порядок награждения. Это пример нестандартной задачи, которую можно решить с помощью жадного подхода и внимательного анализа. Вы научитесь строить возрастающие последовательности и использовать арифметические свойства для оптимального распределения.</p>
<h2 id="klyuchevye-voprosy-paragrafa">Ключевые вопросы параграфа</h2>
<ul>
<li>Как спланировать последовательность наград, чтобы максимизировать число получателей?</li>
<li>Почему здесь работает жадный подход и как доказать его корректность?</li>
<li>Как использовать свойства суммы арифметической прогрессии при решении алгоритмических задач?</li>
</ul>
<p></p><figure class="fig-img"><img class="img" src="https://yastatic.net/s3/education-portal/media/algosy_6_5_1_c964476899_f29fc8d130.svg" alt="algosy"></figure><p></p>
<h2 id="nestandartnaya-zadacha-i-zhadnyj-algoritm">Нестандартная задача и жадный алгоритм</h2>
<p>Вы занимаетесь организацией соревнований для детей, и у вас есть <span class="yfm-latex" data-content="n" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> конфет, которые собираетесь раздать в качестве призов. Вы хотите отдать эти конфеты тем, кто займёт первые <span class="yfm-latex" data-content="k" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> мест в соревнованиях, и распределить конфеты так, чтобы за более высокое место всегда выходило больше конфет. Чтобы порадовать как можно больше детей, вам понадобится найти самое большое значение <span class="yfm-latex" data-content="k" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span>, при котором это возможно.</p>
<ul>
<li>Входные данные: Целое число <span class="yfm-latex" data-content="n" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>.</li>
<li>Выходные данные: Первая строка содержит максимальное число <span class="yfm-latex" data-content="k" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span>, при котором <span class="yfm-latex" data-content="n" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> можно представить как сумму <span class="yfm-latex" data-content="k" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> пар неповторяющихся положительных целых чисел. Вторая строка — <span class="yfm-latex" data-content="k" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> пар неповторяющихся положительных целых чисел, сумма которых будет <span class="yfm-latex" data-content="n" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> (если есть несколько таких вариантов, то можно использовать любой из них).</li>
<li>Ограничения: <span class="yfm-latex" data-content="1%20%5Cle%20n%20%5Cle%2010%5E9" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></span>.</li>
</ul>
<h4 id="primer-1">Пример 1</h4>
<table>
<tbody>
<tr>
<td>
<p>Ввод</p>
</td>
<td>
<p>Вывод</p>
</td>
</tr>
<tr>
<td>
<p>6</p>
</td>
<td>
<p>3<br>1 2 3</p>
</td>
</tr>
</tbody>
</table>
<h4 id="primer-2">Пример 2</h4>
<table>
<tbody>
<tr>
<td>
<p>Ввод</p>
</td>
<td>
<p>Вывод</p>
</td>
</tr>
<tr>
<td>
<p>8</p>
</td>
<td>
<p>3<br>1 2 5</p>
</td>
</tr>
</tbody>
</table>
<h4 id="primer-3">Пример 3</h4>
<table>
<tbody>
<tr>
<td>
<p>Ввод</p>
</td>
<td>
<p>Вывод</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>1<br>2</p>
</td>
</tr>
</tbody>
</table>
<h3 id="uprazhnenie">Упражнение</h3>
<p>Можно ли представить 8 как сумму четырёх неповторяющихся положительных целых чисел?</p>
<p>Нетрудно понять, что ответ на этот вопрос: «Нет». Предположим, что <span class="yfm-latex" data-content="8%3Da_1%2Ba_2%2Ba_3%2Ba_4" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><mo>+</mo><msub><mi>a</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">8=a_1+a_2+a_3+a_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> и <span class="yfm-latex" data-content="a_1%20%5Clt%20a_2%20%5Clt%20a_3%20%5Clt%20a_4" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>a</mi><mn>2</mn></msub><mo>&lt;</mo><msub><mi>a</mi><mn>3</mn></msub><mo>&lt;</mo><msub><mi>a</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">a_1 \lt a_2 \lt a_3 \lt a_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> . Тогда <span class="yfm-latex" data-content="a_1%20%5Cge%201" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_1 \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>, <span class="yfm-latex" data-content="a_2%20%5Cge%202" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a_2 \ge 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></span>, <span class="yfm-latex" data-content="a_3%20%5Cge%203" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>3</mn></msub><mo>≥</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">a_3 \ge 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span> и <span class="yfm-latex" data-content="a_4%20%5Cge%204" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>4</mn></msub><mo>≥</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">a_4 \ge 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span></span>. Однако тогда <span class="yfm-latex" data-content="a_1%2Ba_2%2Ba_3%2Ba_4%20%5Cge%2010" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><mo>+</mo><msub><mi>a</mi><mn>4</mn></msub><mo>≥</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">a_1+a_2+a_3+a_4 \ge 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span></span>.</p>
<p>По этой же причине, если <span class="yfm-latex" data-content="n" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> равно сумме <span class="yfm-latex" data-content="k" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> неповторяющихся положительных целых чисел <span class="yfm-latex" data-content="a_1%2C%20%5Cdots%2C%20a_k" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_1, \dots, a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, то <span class="yfm-latex" data-content="n%3Da_1%2B%5Cdots%2Ba_k%20%5Cge%201%2B%5Cdots%2Bk%20%3D%20%5Cfrac%7Bk(k%2B1)%7D%7B2%7D" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub><mo>≥</mo><mn>1</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>k</mi><mo>=</mo><mfrac><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">n=a_1+\dots+a_k \ge 1+\dots+k = \frac{k(k+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>. Верно и обратное: если <span class="yfm-latex" data-content="n%20%5Cge%20%5Cfrac%7Bk(k%2B1)%7D%7B2%7D" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mfrac><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">n \ge \frac{k(k+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>, то можно представить <span class="yfm-latex" data-content="n" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> как сумму <span class="yfm-latex" data-content="k" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span> неповторяющихся целых чисел.</p>
<p>Действительно, пусть <span class="yfm-latex" data-content="%5Cdelta%3Dn%20-%20%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cge%200" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>=</mo><mi>n</mi><mo>−</mo><mfrac><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta=n - \frac{k(k+1)}{2} \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span>. Тогда <span class="yfm-latex" data-content="n" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> будет равно сумме следующих целых чисел: <span class="yfm-latex" data-content="1%2C%202%2C%20%5Cdots%2C%20k-1%2Ck%2B%5Cdelta" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>+</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">1, 2, \dots, k-1,k+\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span></span>. Несложно заметить, что все они отличаются друг от друга.</p>
<p>Алгоритм состоит в нахождении самого большого значения <span class="yfm-latex" data-content="k" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span>, при котором <span class="yfm-latex" data-content="%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\frac{k(k+1)}{2} \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>.</p>
<p>Время выполнения — <span class="yfm-latex" data-content="O(k)" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span> или <span class="yfm-latex" data-content="O(%5Csqrt%7Bn%7D)" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.</p>
<h2 id="chto-dalshe">Что дальше</h2>
<p>Теперь вы умеете применять жадные алгоритмы для распределения ограниченного ресурса и знаете, в каких случаях такая стратегия приводит к оптимальному решению.</p>
<p>Далее — финальная задача главы. Она покажет, что даже на собеседовании можно столкнуться с подводными камнями жадной стратегии: чтобы получить максимальный «оклад», придётся сравнивать не числа, а строки.</p>
<p>А пока вы не ушли дальше — закрепите материал на практике:</p>
<ul>
<li>Отметьте, что урок прочитан, при помощи кнопки ниже.</li>
<li>Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.</li>
<li>Перейдите к <a href="https://new.contest.yandex.ru/contest/80770" target="_blank" rel="noopener noreferrer">задачам</a> этого параграфа и потренируйтесь.</li>
<li>Перед этим — загляните в короткий <a href="https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii">гайд</a> о том, как работает система проверки.</li>
</ul>
<p>Хотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в <a href="https://t.me/handbook_algorithms" target="_blank" rel="noopener noreferrer">сообщество Хендбука</a>! Там студенты помогают друг другу разобраться.</p>
<h3 id="klyuchevye-vyvody-paragrafa">Ключевые выводы параграфа</h3>
<ul>
<li>Жадные алгоритмы хорошо работают в задачах распределения, когда нужно покрыть максимум с минимальными затратами.</li>
<li>Иногда достаточно отсортировать входные данные и обрабатывать их по порядку — это уже даёт оптимальный результат.</li>
<li>Простые стратегии требуют точной формулировки и аккуратной реализации — особенно при работе с ограничениями.</li>
</ul>
</div></div></div><div class="styles_action-wrapper__qGgRM"><span class="styles_visually-hidden__mtWeI">Чтобы добавить в заметки выделенный текст, нажмите <!-- -->Command<!-- --> + E</span><button class="Button Button_view_primary Button_size_m Button_isInteractive Theme_controls_size_m styles_button__slVGb" aria-label="Добавить в заметки" autocomplete="off" type="button" role="button"><span class="Button-Content Theme_palette_inverse"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"><div class="Slot Slot_gap_s Slot_padding_s"><span class="Slot-Item"><span data-icon="bookmark" class="Icon Icon_size_s Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat Button-Icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 6a4 4 0 0 1 4-4h8a4 4 0 0 1 4 4v12.942c0 1.67-1.923 2.604-3.236 1.573L12 16.772l-4.764 3.743C5.923 21.546 4 20.611 4 18.942V6Zm4-2a2 2 0 0 0-2 2v12.942l4.764-3.743a2 2 0 0 1 2.472 0L18 18.942V6a2 2 0 0 0-2-2H8Z" fill="currentColor"></path></svg></span></span></div></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text">Добавить в заметки</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></button></div></div></div></main><div class="styles_articleProgress__u3phH"><div class="styles_root__jW9gl" data-testid="article-progress"><div class="styles_progress__YrkcK"><label class="styles_toggleLabel__YStHs styles_cursorPointer__c_j28" style="flex-direction: row; align-items: center; gap: 8px;"><div class="styles_customToggle__qxU9H styles_sizeM__LwBcS styles_cursorPointer__c_j28"><input aria-label="Параграф не прочитан" id="article-progress-checkbox" tabindex="0" type="checkbox"><span class="styles_slider__llbkm"><span class="styles_knob__Tcd6o"></span></span></div><p id="article-progress-checkbox-text" class="Text styles_label__vdsz7 styles_labelNotRead__UoDiw">Параграф прочитан</p></label></div></div><div class="styles_errorLinkWrapper__IREsd"><a target="_blank" rel="noopener noreferrer" title="Сообщить об ошибке" aria-disabled="false" id="3761" class="styles_errorLink__LlWps" href="https://forms.yandex.ru/surveys/academy/?proekt=handbooks"><svg width="18" height="19" viewBox="0 0 18 19" fill="none" xmlns="http://www.w3.org/2000/svg" class="styles_icon__6R_y4" aria-hidden="true"><path d="M0.25 9.5C0.25 11.2306 0.763179 12.9223 1.72464 14.3612C2.6861 15.8002 4.05267 16.9217 5.65152 17.5839C7.25037 18.2462 9.00971 18.4195 10.707 18.0819C12.4044 17.7442 13.9635 16.9109 15.1872 15.6872C16.4109 14.4635 17.2442 12.9044 17.5819 11.207C17.9195 9.50971 17.7462 7.75037 17.0839 6.15152C16.4217 4.55267 15.3002 3.1861 13.8612 2.22464C12.4223 1.26318 10.7306 0.75 9 0.75C6.67936 0.75 4.45376 1.67187 2.81282 3.31282C1.17187 4.95376 0.25 7.17936 0.25 9.5ZM14.7188 14.3438L4.15625 3.78125C5.59415 2.58437 7.42745 1.96811 9.29636 2.05341C11.1653 2.13872 12.9348 2.91942 14.2577 4.24231C15.5806 5.5652 16.3613 7.33474 16.4466 9.20364C16.5319 11.0725 15.9156 12.9059 14.7188 14.3438ZM4.15 15.225C2.63645 13.9397 1.69438 12.1066 1.53035 10.1278C1.36632 8.14888 1.99373 6.18572 3.275 4.66875L13.8312 15.225C12.4776 16.3688 10.7628 16.9963 8.99062 16.9963C7.21849 16.9963 5.50361 16.3688 4.15 15.225Z" fill="#666666"></path></svg><span class="styles_root__EmBCZ" data-weight="regular" data-color="primary">Сообщить об ошибке</span></a></div></div><div class="styles_v2ContestQuiz__mOOqZ"><section class="styles_articleCTA__G_f8_" data-testid="articleCTAQuiz"><div class="styles_rootInline__JE944"><div class="styles_startQuizCard__SOyLA"><img aria-hidden="true" url="https://yastatic.net/s3/education-portal/media/Group_2131327674_d995d0f6fc.svg" ext=".svg" name="icon.svg" mime="image/svg+xml" alt="Знак вопроса" loading="lazy" width="56" height="56" decoding="async" data-nimg="1" src="https://yastatic.net/s3/education-portal/media/Group_2131327674_d995d0f6fc.svg" style="color: transparent;"><h2 class="styles_root__EmBCZ styles_title__bNN0s" data-weight="medium" data-color="primary">Пройдите квиз по параграфу</h2><div class="styles_description__Lf8CO"><span class="styles_root__EmBCZ" data-weight="regular" data-color="primary">Чтобы закрепить пройденный материал</span></div><button class="Button Button_view_primary Button_size_m Button_isInteractive Theme_controls_size_m styles_startButton__NcS1s styles_button__slVGb" autocomplete="off" type="button"><span class="Button-Content Theme_palette_inverse"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span class="Text Text_hideOverflow Button-Text" style="--text-max-visible-lines: 1;">Начать</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></button></div></div></section></div><section class="styles_callToAction__XgopL styles_bookCTA__HRQex"><div></div></section><div class="styles_errorLinkWrapper__pz4ZU"><a target="_blank" rel="noopener noreferrer" title="Сообщить об ошибке" aria-disabled="false" id="3761" class="styles_errorLink__e38cf" href="https://forms.yandex.ru/surveys/academy/?proekt=handbooks"><svg width="18" height="19" viewBox="0 0 18 19" fill="none" xmlns="http://www.w3.org/2000/svg" class="styles_icon__z8p3U" aria-hidden="true"><path d="M0.25 9.5C0.25 11.2306 0.763179 12.9223 1.72464 14.3612C2.6861 15.8002 4.05267 16.9217 5.65152 17.5839C7.25037 18.2462 9.00971 18.4195 10.707 18.0819C12.4044 17.7442 13.9635 16.9109 15.1872 15.6872C16.4109 14.4635 17.2442 12.9044 17.5819 11.207C17.9195 9.50971 17.7462 7.75037 17.0839 6.15152C16.4217 4.55267 15.3002 3.1861 13.8612 2.22464C12.4223 1.26318 10.7306 0.75 9 0.75C6.67936 0.75 4.45376 1.67187 2.81282 3.31282C1.17187 4.95376 0.25 7.17936 0.25 9.5ZM14.7188 14.3438L4.15625 3.78125C5.59415 2.58437 7.42745 1.96811 9.29636 2.05341C11.1653 2.13872 12.9348 2.91942 14.2577 4.24231C15.5806 5.5652 16.3613 7.33474 16.4466 9.20364C16.5319 11.0725 15.9156 12.9059 14.7188 14.3438ZM4.15 15.225C2.63645 13.9397 1.69438 12.1066 1.53035 10.1278C1.36632 8.14888 1.99373 6.18572 3.275 4.66875L13.8312 15.225C12.4776 16.3688 10.7628 16.9963 8.99062 16.9963C7.21849 16.9963 5.50361 16.3688 4.15 15.225Z" fill="#666666"></path></svg><span class="styles_root__EmBCZ" data-weight="regular" data-color="primary">Сообщить об ошибке</span></a></div><div class="styles_article-navigate__SKki7" data-testid="ArticleNavigate-root"><a class="styles_navigation-block__p937C" href="./zadacha-sbor-podpisej"><span class="styles_root__EmBCZ styles_label__QNj9q" data-weight="regular" data-color="primary">Предыдущий параграф</span><span class="styles_root__EmBCZ styles_title___sZy2" data-weight="medium" data-color="primary">7.4. Задача «Сбор подписей»</span><div class="styles_arrow-line__qoKkm"><span data-icon="arrowShortRight" aria-hidden="true" class="Icon Icon_size_xl Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_arrow__BhuvQ styles_back__1E0f1"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></a><a class="styles_navigation-block__p937C" href="./zadacha-maksimalnyj-oklad"><span class="styles_root__EmBCZ styles_label__QNj9q" data-weight="regular" data-color="primary">Следующий параграф</span><span class="styles_root__EmBCZ styles_title___sZy2" data-weight="medium" data-color="primary">7.6. Задача «Максимальный оклад»</span><div class="styles_arrow-line__qoKkm"><span data-icon="arrowShortRight" aria-hidden="true" class="Icon Icon_size_xl Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_arrow__BhuvQ styles_forward__d5yy6"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></a></div><section class="styles_hanbookCommunityBannerPopup__iqwEt" data-testid="HanbookCommunityBanner-root"><div><div class="styles_popupHeadderTitle__Fs756" data-test-inaccessible="true"><h3 class="styles_root__EmBCZ styles_inlineTitle__xD8ER" data-weight="medium" data-color="inverse">Вступайте в&nbsp;сообщество хендбука</h3><div class="styles_closeWrapper__WIcWK"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_popupClose__P2HBL styles_button__slVGb" aria-label="закрыть" autocomplete="off" type="button" title="закрыть"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_icon Button-Slot"></div><span class="Text Text_hideOverflow Button-Text" style="--text-max-visible-lines: 1;"><span data-icon="close" class="Icon Icon_size_s Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat Button-Icon" aria-hidden="true" style="--hr-icon-color: var(--hr-color-text-secondary);"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.293 4.293a1 1 0 0 1 1.414 0L12 10.586l6.293-6.293a1 1 0 1 1 1.414 1.414L13.414 12l6.293 6.293a1 1 0 0 1-1.414 1.414L12 13.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L10.586 12 4.293 5.707a1 1 0 0 1 0-1.414Z" fill="currentColor"></path></svg></span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_icon Button-Slot"></div><span class="Button-State"></span></span></button></div></div><div data-test-inaccessible="true"><span class="styles_root__EmBCZ styles_popupHeadderDescription__9B8Oa" data-weight="regular" data-color="inverse">Здесь можно найти единомышленников, экспертов и&nbsp;просто интересных собеседников. А&nbsp;ещё&nbsp;— получить помощь или поделиться знаниями.</span><a target="_blank" rel="noopener noreferrer" title="Вступить" aria-disabled="false" id="5541" href="https://t.me/handbook_algorithms"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_popupJoinButton__KSomV styles_button__slVGb" autocomplete="off" type="button"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span class="Text Text_hideOverflow Button-Text" style="--text-max-visible-lines: 1;">Вступить</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></button></a></div></div></section></div></div></div></div><!--$--><!--/$--></div><footer md="0" data-testid="Footer-root" class="styles_root__IBJUG styles_gutter-top__lwtYx styles_footer___2teW" style="background-color:#FFFFFF;--gutter-size-xs:0px;--gutter-size-sm:0px;--gutter-size-lg:0px;--gutter-size-xl:0px"><div class="styles_root__IBJUG styles_inner__lwcI4" style="--gutter-size-xs:50px;--gutter-size-sm:50px;--gutter-size-lg:50px;--gutter-size-xl:50px"><div class="styles_logo__oFZ4z"><a aria-label="Яндекс Образование" href="/"><img alt="Яндекс Образование" aria-hidden="true" class="styles_desktopOnly__j_5Ge" src="https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg"><img alt="Яндекс Образование" aria-hidden="true" class="styles_mobileOnly__3cLf9" src="https://yastatic.net/s3/education-portal/media/edu_logo_simple_9790e70002.svg"></a></div><div class="styles_columns__n2ryY"><div class="styles_column__XW85v"><ul><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4460" href="https://education.yandex.ru/uchebnik/main"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Яндекс Учебник</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4458" href="https://lyceum.yandex.ru/"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Яндекс Лицей</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4459" href="https://practicum.yandex.ru/?utm_source=partners&amp;utm_medium=partners&amp;utm_campaign=yandexeducation_partners_RF_Common_Unde_b2c_Landing-page_None_None"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Яндекс Практикум</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4461" href="https://shad.yandex.ru/"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Школа анализа данных</span></a></li><li><a aria-disabled="false" id="4463" href="/university"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Программы в университетах</span></a></li></ul></div><div class="styles_column__XW85v"><ul><li><a aria-disabled="false" id="4462" href="/research"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Исследования</span></a></li><li><a aria-disabled="false" id="4464" href="/handbook"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Хендбуки</span></a></li><li><a aria-disabled="false" id="5881" href="/roadmap"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Карты IT-навыков</span></a></li><li><a aria-disabled="false" id="4466" href="/knowledge"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">База знаний</span></a></li><li><a aria-disabled="false" id="4465" href="/journal"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Журнал</span></a></li><li><a aria-disabled="false" id="4467" href="/events"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">События</span></a></li></ul></div><div class="styles_column__XW85v"><ul><li><a aria-disabled="false" id="4468" href="/about"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">О нас</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4469" href="https://forms.yandex.ru/surveys/13457493.e7112b8cdd8c782bfe6e4b1ab1b73f49438edacf/"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Обратная связь</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4470" href="https://yandex.ru/legal/education_termsofuse/ru/"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Пользовательское соглашение</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4471" href="https://yandex.ru/edtech"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Сайт образовательной организации</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4472" href="https://yandex.ru/edtech/sveden"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Сведения об образовательной организации</span></a></li></ul></div></div><ul class="styles_socials__WWBdN styles_socials__Is6By"><li class="styles_social__pAnot"><a title="Рассылка" class="Button Button_view_secondary Button_size_m Button_isInteractive Theme_controls_size_m styles_button___Ftu4" aria-label="Рассылка" autocomplete="off" href="/subscribe"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span aria-hidden="true">Рассылка</span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></a></li><li class="styles_social__pAnot"><a title="Бот" class="Button Button_view_secondary Button_size_m Button_isInteractive Theme_controls_size_m styles_button___Ftu4" aria-label="Бот" autocomplete="off" href="https://t.me/yaeducation_bot?start=n_113083__c_7628"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span aria-hidden="true">Бот</span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></a></li><li class="styles_social__pAnot"><a title="ВКонтакте" class="Button Button_view_secondary Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button___Ftu4" aria-label="ВКонтакте" autocomplete="off" href="https://vk.com/yandex_education"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><img alt="ВКонтакте" aria-hidden="true" src="https://yastatic.net/s3/education-portal/media/social_icon_vk_97bf858cd5.svg" color="secondary" class="Button-Icon"></span><span class="Button-State"></span></span></a></li><li class="styles_social__pAnot"><a title="YouTube" class="Button Button_view_secondary Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button___Ftu4" aria-label="YouTube" autocomplete="off" href="https://www.youtube.com/@Education_Yandex"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><img alt="YouTube" aria-hidden="true" src="https://yastatic.net/s3/education-portal/media/social_icon_yt_d20daea655.svg" color="secondary" class="Button-Icon"></span><span class="Button-State"></span></span></a></li><li class="styles_social__pAnot"><a title="Telegram" class="Button Button_view_secondary Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button___Ftu4" aria-label="Telegram" autocomplete="off" href="https://t.me/education_yandex"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><img alt="Telegram" aria-hidden="true" src="https://yastatic.net/s3/education-portal/media/social_icon_tg_9faafb663e.svg" color="secondary" class="Button-Icon"></span><span class="Button-State"></span></span></a></li></ul><p class="Text Text_color_primary Text_typography_bodyS styles_disclaimer__ga29X styles_text__iQHEy">Образовательные услуги оказываются АНО ДПО «Образовательные технологии Яндекса»
на&nbsp;основании <a rel="noopener noreferrer" target="_self" href="https://yastatic.net/s3/academy/docs/license-ysda.pdf">Лицензии № Л035-01298-77/00185314</a> от 24 марта 2015 года.<!-- -->
<!-- -->© 2025 Яндекс, АНО ДПО «Образовательные технологии Яндекса».</p></div></footer><script nonce="">(self.__next_s=self.__next_s||[]).push([0,{"nonce":"63ec77a1-e677-4dcb-945b-702ad5710bd7","children":"!function(e,t){if(e.Ya=e.Ya||{},Ya.Rum)throw new Error(\"Rum: interface is already defined\");var n=e.performance,i=n&&n.timing&&n.timing.navigationStart||Ya.startPageLoad||+new Date,s=e.requestAnimationFrame,r=function(){},a=Ya.Rum={_defTimes:[],_defRes:[],_countersToExposeAsEvents:[\"2325\",\"2616.85.1928\",\"react.inited\"],enabled:!!n,version:\"6.1.21\",vsStart:document.visibilityState,vsChanged:!1,vsChangeTime:1/0,_deltaMarks:{},_markListeners:{},_onComplete:[],_onInit:[],_unsubscribers:[],_eventLisneters:{},_settings:{},_vars:{},init:function(e,t){a._settings=e,a._vars=t},getTime:n&&n.now?function(){return n.now()}:Date.now?function(){return Date.now()-i}:function(){return new Date-i},time:function(e){a._deltaMarks[e]=[a.getTime()]},timeEnd:function(e,t){var n=a._deltaMarks[e];n&&0!==n.length&&n.push(a.getTime(),t)},sendTimeMark:function(e,t,n,i){void 0===t&&(t=a.getTime()),a.emit({metricName:\"defTimes\",data:[e,t,i]}),a.mark(e,t)},sendDelta:function(e,t,n,i){var s,r=a._deltaMarks;r[e]||void 0===t||(s=i&&i.originalEndTime?i.originalEndTime:a.getTime(),r[e]=[s-t,s,n])},sendResTiming:function(e,t){a.emit({metricName:\"defRes\",data:[e,t]})},sendRaf:function(e){var t=a.getSetting(\"forcePaintTimeSending\");if(s&&(t||a.isTimeAfterPageShow(a.getTime()))){var n=\"2616.\"+e;s((function(){a.getSetting(\"sendFirstRaf\")&&a.sendTimeMark(n+\".205\"),s((function(){a.sendTimeMark(n+\".1928\")}))}))}},isVisibilityChanged:function(){return a.vsStart&&(\"visible\"!==a.vsStart||a.vsChanged)},isTimeAfterPageShow:function(e){return\"visible\"===a.vsStart||a.vsChangeTime<e},mark:n&&n.mark?function(e,t){n.mark(e+(t?\": \"+t:\"\"))}:function(){},getSetting:function(e){var t=a._settings[e];return null===t?null:t||\"\"},on:function(e,t){if(\"function\"==typeof t)return(a._markListeners[e]=a._markListeners[e]||[]).push(t),function(){if(a._markListeners[e]){var n=a._markListeners[e].indexOf(t);n>-1&&a._markListeners[e].splice(n,1)}}},noop:r,sendTrafficData:r,finalizeLayoutShiftScore:r,finalizeLargestContentfulPaint:r,getLCPAdditionalParams:r,getCLSAdditionalParams:r,getINPAdditionalParams:r,getImageGoodnessAdditionalParams:r,_eventListeners:{},_eventsBuffer:{},subscribe:function(e,t){if(!a.getSetting(\"noEvents\"))return this._eventLisneters[e]=this._eventLisneters[e]||new Set,this._eventLisneters[e].add(t),function(){this.unsubscribe(e,t)}.bind(this)},unsubscribe:function(e,t){this._eventLisneters[e].delete(t)},emit:function(e){if(!a.getSetting(\"noEvents\")){var t=a.getSetting(\"eventsLimits\")&&a.getSetting(\"eventsLimits\")[e.metricName]||20;this._eventLisneters[e.metricName]&&this._eventLisneters[e.metricName].forEach((function(t){t(e)})),this._eventsBuffer[e.metricName]=this._eventsBuffer[e.metricName]||[],this._eventsBuffer[e.metricName].push(e),this._eventsBuffer[e.metricName].length>t&&(this._eventsBuffer[e.metricName].length=Math.floor(t/2))}},getBufferedEvents:function(e){var t=this._eventsBuffer,n={};return Object.keys(t).forEach((function(i){-1!==e.indexOf(i)&&(n[i]=t[i])})),n},clearEvents:function(e){this._eventsBuffer[e]&&(this._eventsBuffer[e].length=0)}};function f(){Ya.Rum.vsChanged=!0,Ya.Rum.vsChangeTime=a.getTime(),removeEventListener(\"visibilitychange\",f)}addEventListener(\"visibilitychange\",f),a._onVisibilityChange=f}(window);\n!function(){if(window.PerformanceLongTaskTiming){var e=function(e,n){return(e=e.concat(n)).length>300&&(e=e.slice(e.length-300)),e},n=\"undefined\"!=typeof PerformanceLongAnimationFrameTiming,t=n?[\"longtask\",\"long-animation-frame\"]:[\"longtask\"];function r(){var r=Ya.Rum._tti={events:[],loafEvents:n?[]:void 0,eventsAfterTTI:[],fired:!1,observer:new PerformanceObserver((function(t){var o=t.getEntriesByType(\"longtask\"),s=t.getEntriesByType(\"long-animation-frame\");r.events=e(r.events,o),n&&(r.loafEvents=e(r.loafEvents,s)),r.fired&&(r.eventsAfterTTI=e(r.eventsAfterTTI,o))}))};r.observer.observe({entryTypes:t}),Ya.Rum._unsubscribers&&Ya.Rum._unsubscribers.push((function(){r.observer.disconnect()}))}r(),Ya.Rum._onInit.push(r)}}();\nYa.Rum.observeDOMNode=window.IntersectionObserver?function(e,i,n){var t=this,o=Ya.Rum.getSetting(\"forcePaintTimeSending\");!function r(){if(o||!t.isVisibilityChanged()){var s=\"string\"==typeof i?document.querySelector(i):i;s?new IntersectionObserver((function(i,n){!o&&t.isVisibilityChanged()||(Ya.Rum.sendTimeMark(e),n.unobserve(s))}),n).observe(s):setTimeout(r,100)}}()}:function(){};\nvar rum_platform = window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop';\n    var rum_segment = window.location.pathname.replace(/^\\//, \"\").replace(/\\/.*/);\n    \n    if ([\"knowledge\", \"journal\", \"profile\", \"handbook\"].indexOf(rum_segment) === -1) {\n      rum_segment = \"portal\";\n    }\n\n    Ya.Rum.init({ beacon: true, clck: 'https://yandex.ru/clck/click', reqid: '1768063975593584-1199238271730949658'},\n    {\n        rum_id: 'ru.education.' + rum_platform + '.' + rum_segment,\n        '-env': 'production',\n        '-project': 'education-web',\n        '-page': window.location.pathname,\n        '-version': 'undefined',\n        '-platform': rum_platform\n    });Ya.Rum.observeDOMNode('2876', 'body');!function(){var e,t,n,i=Ya.Rum,o=42,r=4e4,g=15,a=[],s=\"\\r\\n\",l=i.getSetting(\"countersInitialDelay\")||0;if(l){var c;function u(){removeEventListener(\"visibilitychange\",h),clearTimeout(c),l=0,f()}function h(){document.hidden&&u()}c=setTimeout(u,l),addEventListener(\"visibilitychange\",h)}function f(){if(t&&a.length){for(var n=0,i=0,l=0;i<a.length&&l<=r&&n<o;i++)(l+=(i?s.length:0)+a[i].length)<=r&&n++;var c=a.splice(0,n);d(t,c.join(s)),a.length&&(e=setTimeout(f,g))}else a.length=0}function d(e,t){if(!(navigator.sendBeacon&&n&&navigator.sendBeacon(e,t))){var o=Boolean(i.getSetting(\"sendCookie\")),r=new XMLHttpRequest;r.open(\"POST\",e),r.withCredentials=o,r.send(t)}}i.send=function(c,u,h,d,v,m,S,p){t=i.getSetting(\"clck\"),n=i.getSetting(\"beacon\"),o=i.getSetting(\"maxBatchCounters\")||o,r=i.getSetting(\"maxBatchLength\")||r,g=i.getSetting(\"countersBatchTimeout\")||g,function(t,n,i,c,u,h,d,v,m,S){clearTimeout(e);var p=[t?\"/reqid=\"+t:\"\",n?\"/\"+n.join(\"/\"):\"\",i?\"/path=\"+i:\"\",c?\"/events=\"+c:\"\",u?\"/slots=\"+u.join(\";\"):\"\",h?\"/experiments=\"+h.join(\";\"):\"\",d?\"/vars=\"+d:\"\",\"/cts=\"+(new Date).getTime(),\"\",\"/*\"].join(\"\");p.length>r?\"undefined\"!=typeof console&&console.error&&console.error(\"Counter length \"+p.length+\" is more than allowed \"+r,p):(a.push(p),l||(function(){if(a.length>=o)return!0;for(var e=0,t=0;t<a.length;t++)if((e+=(t?s.length:0)+a[t].length)>=r)return!0;return!1}()?f():e=setTimeout(f,g)))}(i.getSetting(\"reqid\"),S,u,v,i.getSetting(\"slots\"),i.getSetting(\"experiments\"),h)}}();\n!function(){var e=Ya.Rum,n=!window.BigInt||!(\"PerformanceObserver\"in window);function t(n){e._unsubscribers.push(n)}function i(e,i,o){if(!n){var a=o||{};if(e){a.type=e,a.hasOwnProperty(\"buffered\")||(a.buffered=!0);var s=new PerformanceObserver((function(e,n){return i(e.getEntries(),n)}));return r((function(){try{s.observe(a)}catch(e){return void console.error(e.message)}t((function(){s.disconnect()}))}),0),s}throw new Error(\"PO without type field is forbidden\")}}function r(e,n){var i=setTimeout(e,n);return t((function(){clearInterval(i)})),i}function o(e,n,i){addEventListener(e,n,i),t((function(){removeEventListener(e,n,i)}))}function a(e,n,t){o(\"visibilitychange\",(function i(){if(\"hidden\"===document.visibilityState){try{t||(removeEventListener(\"visibilitychange\",i),e.disconnect())}catch(e){}n()}})),o(\"beforeunload\",n)}function s(e,n){return\"string\"==typeof e?encodeURIComponent(e):Math.round(1e3*(e-(n||0)))/1e3}function u(e){if(!e)return\"\";var n=(e.tagName||\"\").toLowerCase(),t=e.className&&void 0!==e.className.baseVal?e.className.baseVal:e.className;return n+(t?(\" \"+t).replace(/\\s+/g,\".\"):\"\")}function c(e){function n(){removeEventListener(\"DOMContentLoaded\",n),removeEventListener(\"load\",n),e()}\"loading\"===document.readyState?(o(\"DOMContentLoaded\",n),o(\"load\",n)):e()}function d(n){e._onComplete.push(n)}function f(){return e._periodicTasks}function l(){var n=e._vars;return Object.keys(n).map((function(e){return e+\"=\"+encodeURIComponent(n[e]).replace(/\\*/g,\"%2A\")}))}var m={connectEnd:2116,connectStart:2114,decodedBodySize:2886,domComplete:2124,domContentLoadedEventEnd:2131,domContentLoadedEventStart:2123,domInteractive:2770,domLoading:2769,domainLookupEnd:2113,domainLookupStart:2112,duration:2136,encodedBodySize:2887,entryType:2888,fetchStart:2111,initiatorType:2889,loadEventEnd:2126,loadEventStart:2125,nextHopProtocol:2890,redirectCount:1385,redirectEnd:2110,redirectStart:2109,requestStart:2117,responseEnd:2120,responseStart:2119,secureConnectionStart:2115,startTime:2322,transferSize:2323,type:76,unloadEventEnd:2128,unloadEventStart:2127,workerStart:2137},v=625;function g(n,t){Object.keys(m).forEach((function(e){if(e in t){var i=t[e];(i||0===i)&&n.push(m[e]+\"=\"+s(i))}})),n.push(\"\".concat(v,\"=\").concat(e.version))}var p,h,y,S,T,b=\"690.2096.2877\",w=\"690.2096.207\",E=\"690.2096.2044\",C=3,k=e.getSetting(\"savedDeltasLimit\")||0,L=document.createElement(\"link\"),P=window.performance||{},M=\"function\"==typeof P.getEntriesByType,_=0;function O(n,t,i,r,o){void 0===t&&(t=e.getTime()),void 0!==i&&!0!==i||e.mark(n,t);var a=I(n);if(a.push(\"207=\"+s(t)),x(a,r)){j(w,a,o&&o.force),p[n]=p[n]||[],p[n].push(t);var u=e._markListeners[n];u&&u.length&&u.forEach((function(e){e(t)})),e.emit({metricName:n,value:t,params:r})}}function I(n){return T.concat([e.isVisibilityChanged()?\"-vsChanged=1\":\"\",\"1701=\"+n,e.ajaxStart&&\"1201.2154=\"+s(e.ajaxStart),e.ajaxComplete&&\"1201.2052=\"+s(e.ajaxComplete)])}function N(){S=l(),e.getSetting(\"sendClientUa\")&&S.push(\"1042=\"+encodeURIComponent(navigator.userAgent))}function R(){var e=window.performance&&window.performance.timing&&window.performance.timing.navigationStart;T=S.concat([\"143.2129=\"+e])}function x(e,n){if(n){if(n.isCanceled&&n.isCanceled())return!1;var t=e.reduce((function(e,n,t){return\"string\"==typeof n&&(e[n.split(\"=\")[0]]=t),e}),{});Object.keys(n).forEach((function(i){if(\"function\"!=typeof n[i]){var r=t[i],o=i+\"=\"+n[i];void 0===r?e.push(o):e[r]=o}}))}return!0}function j(n,t,i){var r=encodeURIComponent(window.YaStaticRegion||\"unknown\");t.push(\"-cdn=\"+r);var o=t.filter(Boolean).join(\",\");e.send(null,n,o,void 0,void 0,void 0,void 0,i)}function z(e,n,t){j(e,F().concat(n),t)}function B(n,t){var i=y[n];i&&0!==i.length&&(i.push(e.getTime(),t),A(n))}function A(n,t,i,r){var o,a,u,c=y[n];if(void 0!==t?o=(a=r&&r.originalEndTime?r.originalEndTime:e.getTime())-t:c&&(o=c[0],a=c[1],u=c[2]),void 0!==o&&void 0!==a){var d=I(n);d.push(\"207.2154=\"+s(o),\"207.1428=\"+s(a),\"2877=\"+s(a-o)),x(d,i)&&x(d,u)&&(j(b,d,r&&r.force),_<k&&(h[n]=h[n]||[],h[n].push(a-o),_++),e.emit({metricName:n,value:a-o,params:{start:o,end:a}}),delete y[n])}}function V(e,n){if(!M)return n(null);L.href=e;var t=0,i=100,o=L.href;r((function e(){var a=P.getEntriesByName(o);if(a.length)return n(a);t++<C?(r(e,i),i+=i):n(null)}),0)}function U(e,n,t){V(n,(function(i){i&&D(e,i[i.length-1],n,t)}))}function D(n,t,i,r){var o=I(n);e.getSetting(\"sendUrlInResTiming\")&&o.push(\"13=\"+encodeURIComponent(i)),g(o,t),x(o,r),j(E,o)}function F(){return S}var W={bluetooth:2064,cellular:2065,ethernet:2066,none:1229,wifi:2067,wimax:2068,other:861,unknown:836,0:836,1:2066,2:2067,3:2070,4:2071,5:2768},H=navigator.connection;function Q(e){if(H){var n=W[H.type];e.push(\"2437=\"+(n||2771),void 0!==H.downlinkMax&&\"2439=\"+H.downlinkMax,H.effectiveType&&\"2870=\"+H.effectiveType,void 0!==H.rtt&&\"rtt=\"+H.rtt,void 0!==H.downlink&&\"dwl=\"+H.downlink,!n&&\"rawType=\"+H.type)}}var Y,q,G,J,$,K,X,Z,ee=\"690.2096.4004\",ne=!1,te=1/0,ie=1/0,re=(\"layout-shift\",Boolean(window.PerformanceObserver&&window.PerformanceObserver.supportedEntryTypes&&-1!==window.PerformanceObserver.supportedEntryTypes.indexOf(\"layout-shift\"))?0:null);function oe(){$>q&&(q=$,G=J,e.emit({metricName:\"cls-debug\",value:q,params:{clsEntries:G,target:ae(G)}}))}function ae(e){var n;if(!e)return null;var t=null;if((n=e.reduce((function(e,n){return e&&e.value>n.value?e:n})))&&n.sources&&n.sources.length){for(var i=0;i<n.sources.length;i++){var r=n.sources[i];if(r.node&&1===r.node.nodeType){t=r;break}}t=t||n.sources[0]}return t}function se(e){null==q&&(q=0);for(var n=0;n<e.length;n++){var t=e[n];t.hadRecentInput||($&&t.startTime-J[J.length-1].startTime<te&&t.startTime-J[0].startTime<ie?($+=t.value,J.push(t)):(oe(),$=t.value,J=[t]))}oe()}function ue(){q=re,Y=void 0,G=null,J=null,$=null,ne=!1}function ce(n){if(null!=q&&!ne){var t=Math.round(1e6*q)/1e6;if(Y!==t){Y=t,e.getSetting(\"enableContinuousCollection\")||(ne=!0);var i=ae(G),r=[\"s=\"+t];r.push(\"target=\"+u(i&&i.node));var o=e.getCLSAdditionalParams(i);o&&x(r,o),z(ee,r,n),e.emit({metricName:\"cls-debug\",value:q,params:{clsEntries:J,target:i,isFinalized:ne}})}}}function de(n){var t=n[n.length-1];K=t.renderTime||t.loadTime,X=t,e.emit({metricName:\"largest-contentful-paint-debug\",value:K,params:{entry:t}}),Z||(O(\"largest-loading-elem-paint\",K),Z=!0)}function fe(n){if(null!=K){var t=e.getLCPAdditionalParams(X);O(\"largest-contentful-paint\",K,!1,t,n&&{force:!0}),e.emit({metricName:\"largest-contentful-paint-debug\",value:K,params:{additionalParams:t,entry:X,isFinalized:!0}}),K=null,X=null}}e.getLCPAdditionalParams===e.noop&&(e.getLCPAdditionalParams=function(){var n={},t=X.element;if(t){n[\"-className\"]=e.getSelector(t),n[\"-tagName\"]=t.tagName.toLowerCase();var i=t.getBoundingClientRect();n[\"-width\"]=i.width,n[\"-height\"]=i.height}return X.size&&(n[\"-size\"]=X.size),n});var le={\"first-paint\":2793,\"first-contentful-paint\":2794},me=Object.keys(le).length,ve={},ge=window.performance||{},pe=\"function\"==typeof ge.getEntriesByType,he=0;function ye(){if(pe&&(e.getSetting(\"forcePaintTimeSending\")||!e.isVisibilityChanged()))for(var n=ge.getEntriesByType(\"paint\"),t=0;t<n.length;t++){var i=n[t],r=le[i.name];r&&!ve[i.name]&&(ve[i.name]=!0,he++,O(\"1926.\"+r,i.startTime))}}var Se=3e3,Te=1;function be(){return e._tti.events||[]}function we(){return e._tti.loafEvents}function Ee(){return e._tti}function Ce(n){return n?n===e.getPageUrl()?\"<page>\":n.replace(/\\?.*$/,\"\"):n}function ke(n,t,i){if(Ee()){var r=e.getTime(),o=\"undefined\"!=typeof PerformanceLongAnimationFrameTiming&&e.getSetting(\"sendLongAnimationFrames\");Le((function(a){var u,c={2796.2797:Pe(be(),t),689.2322:s(r)};if(o){var d=function(e){var n=we();if(n)return e?n.filter((function(n){return n.startTime+n.duration>=e})):n}(t);d&&(c[\"loaf.2797\"]=Pe(d,void 0,{useName:!1}),1===e.getSetting(\"longAnimationFramesMode\")&&(c[\"-additional\"]=encodeURIComponent(JSON.stringify({loaf:(u=d,u.map(Me))}))))}i&&Object.keys(i).forEach((function(e){c[e]=i[e]})),O(n||\"2795\",a,!0,c,{force:Boolean(o)}),e._tti.fired=!0}),t)}}function Le(n,t){var i=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).mode,o=void 0===i?Te:i;Ee()&&(t||(t=e.getTime()),function i(){var a,s=t,u=e.getTime(),c=o===Te?be():we()||[],d=c.length;0!==d&&(a=c[d-1],s=Math.max(s,Math.floor(a.startTime+a.duration))),u-s>=Se?n(s):r(i,1e3)}())}function Pe(e,n){var t=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).useName,i=void 0===t||t;return n=n||0,(e=e||[]).filter((function(e){return n-e.startTime<=50})).map((function(e){var n=Math.floor(e.startTime),t=Math.floor(n+e.duration);return i?(e.name?e.name.split(\"-\").map((function(e){return e[0]})).join(\"\"):\"u\")+\"-\"+n+\"-\"+t:n+\"-\"+t})).join(\".\")}function Me(e){var n=e.blockingDuration,t=e.duration,i=e.firstUIEventTimestamp,r=e.renderStart,o=e.scripts,a=e.startTime,s=e.styleAndLayoutStart;return[Math.round(a),Math.round(t),o.map(Oe),Math.round(n),Math.round(i),Math.round(r),Math.round(s)]}function _e(e){return{\"user-callback\":1,\"event-listener\":2,\"resolve-promise\":3,\"reject-promise\":4,\"classic-script\":5,\"module-script\":6}[e]||0}function Oe(e){var n=e.invoker,t=e.sourceURL,i=e.sourceFunctionName,r=e.sourceCharPosition,o=e.startTime,a=e.duration,s=e.windowAttribution,u=e.executionStart,c=e.forcedStyleAndLayoutDuration,d=e.pauseDuration,f=e.invokerType;return[Ce(n),Ce(t),i,r,Math.round(o),Math.round(a),s,Math.round(u),Math.round(c),Math.round(d),_e(f)]}var Ie=\"690.2096.361\",Ne=document.createElement(\"a\"),Re=0,xe={};function je(e){var n=e.transferSize;if(null!=n){Ne.href=e.name;var t=Ne.pathname;if(0!==t.indexOf(\"/clck\")){var i=t.lastIndexOf(\".\"),r=\"\";return-1!==i&&t.lastIndexOf(\"/\")<i&&t.length-i<=5&&(r=t.slice(i+1)),{size:n,domain:Ne.hostname,extension:r}}}}function ze(){var n=e.getSetting(\"maxTrafficCounters\")||250;if(Re>=n)return!1;for(var t=Object.keys(xe),i=\"\",r=0;r<t.length;r++){var o=t[r],a=xe[o];i+=encodeURIComponent(o)+\"!\"+a.count+\"!\"+a.size+\";\"}return i.length&&(Re++,z(Ie,[\"d=\"+i,\"t=\"+s(e.getTime())])),xe={},Re<n}d(ze);var Be=\"690.1033\",Ae={visible:1,hidden:2,prerender:3},Ve=window.performance||{},Ue=Ve.navigation||{},De=Ve.timing||{},Fe=De.navigationStart;function We(){var n=De.domContentLoadedEventStart,t=De.domContentLoadedEventEnd;if(0!==n||0!==t){var i=0===De.responseStart?Fe:De.responseStart,o=0===De.domainLookupStart?Fe:De.domainLookupStart,a=[\"2129=\"+Fe,\"1036=\"+(o-Fe),\"1037=\"+(De.domainLookupEnd-De.domainLookupStart),\"1038=\"+(De.connectEnd-De.connectStart),De.secureConnectionStart&&\"1383=\"+(De.connectEnd-De.secureConnectionStart),\"1039=\"+(De.responseStart-De.connectEnd),\"1040=\"+(De.responseEnd-i),\"1040.906=\"+(De.responseEnd-o),\"1310.2084=\"+(De.domLoading-i),\"1310.2085=\"+(De.domInteractive-i),\"1310.1309=\"+(t-n),\"1310.1007=\"+(n-i),navigator.deviceMemory&&\"3140=\"+navigator.deviceMemory,navigator.hardwareConcurrency&&\"3141=\"+navigator.hardwareConcurrency];Object.keys(m).forEach((function(e){e in De&&De[e]&&a.push(m[e]+\"=\"+s(De[e],Fe))})),e.vsStart?(a.push(\"1484=\"+(Ae[e.vsStart]||2771)),e.vsChanged&&a.push(\"1484.719=1\")):a.push(\"1484=\"+Ae.visible),Ue&&(Ue.redirectCount&&a.push(\"1384.1385=\"+Ue.redirectCount),1!==Ue.type&&2!==Ue.type||a.push(\"770.76=\"+Ue.type)),Q(a),z(Be,a)}else r(We,50)}var He=\"690.2096.2892\",Qe=window.performance||{},Ye=\"function\"==typeof Qe.getEntriesByType;if(!e)throw new Error(\"Rum: interface is not included\");if(e.enabled){function qe(){p={},h={},_=0,y=e._deltaMarks,N(),R(),e.ajaxStart=0,e.ajaxComplete=0,c(Je)}function Ge(){var n;e.sendTimeMark=O,e.sendResTiming=U,e.sendTiming=D,e.timeEnd=B;var t=(e.getBufferedEvents([\"defRes\"]).defRes||[]).map((function(e){return e.data}));for(n=0;n<t.length;n++)U(t[n][0],t[n][1]);e.clearEvents(\"defRes\");var i=(e.getBufferedEvents([\"defTimes\"]).defTimes||[]).map((function(e){return e.data}));for(n=0;n<i.length;n++)O(i[n][0],i[n][1],!1,i[n][2]);e.clearEvents(\"defTimes\"),Object.keys(y).forEach((function(e){A(e)}))}function Je(){var n=window.performance&&window.performance.timing&&window.performance.timing.navigationStart,t=e.getSetting(\"skipTiming\"),a=e.getSetting(\"techParamsByVisible\");n&&(a&&addEventListener(\"visibilitychange\",(function n(){\"visible\"!==e.vsStart?\"visible\"===document.visibilityState&&(e.vsStart=\"visible\",removeEventListener(\"visibilitychange\",n),We()):removeEventListener(\"visibilitychange\",n)})),r((function(){Ge(),(!t&&!a||a&&\"visible\"===e.vsStart)&&We(),e.getSetting(\"disableFCP\")||(ye(),he<me&&i(\"paint\",(function(e,n){ye(),n&&he>=me&&n.disconnect()}),{buffered:!0})),e.getSetting(\"sendAutoElementTiming\")&&(!window.PerformanceObserver||!e.getSetting(\"forcePaintTimeSending\")&&e.isVisibilityChanged()||i(\"element\",(function(e){for(var n=0;n<e.length;n++){var t=e[n];O(\"element-timing.\"+t.identifier,t.startTime)}}))),o(\"pageshow\",Xe),ke(),\"complete\"===document.readyState?$e({skipTimingApi:t}):o(\"load\",$e.bind(void 0,{skipTimingApi:t}))}),0))}function $e(n){var r,s;e.getSetting(\"disableOnLoadTasks\")||(removeEventListener(\"load\",$e),n.skipTimingApi||function(){if(Ye){var e=Qe.getEntriesByType(\"navigation\")[0];if(e){var n=[];g(n,e),Q(n);var t=Qe.getEntriesByName(\"yndxNavigationSource\")[0];t&&n.push(\"2091.186=\"+t.value);var i=Qe.getEntriesByName(\"yndxNavigationToken\",\"yndxEntry\")[0];i&&n.push(\"2091.3649=\"+i.value),z(He,n)}}}(),(s=e.getSetting(\"periodicStatsIntervalMs\"))||null===s||(s=15e3),s&&(r=setInterval(Ze,s),t((function(){clearInterval(r)})),Ke=r),o(\"beforeunload\",Ze),function(){if(window.PerformanceObserver){xe={},Re=0;var e=function(e){!function(e){if(e&&e.length)for(var n=xe,t=0;t<e.length;t++){var i=je(e[t]);if(i){var r=i.domain+\"-\"+i.extension,o=n[r]=n[r]||{count:0,size:0};o.count++,o.size+=i.size}}}(e)};i(\"resource\",e),i(\"navigation\",e),f().push(ze)}}(),e.getSetting(\"disableFID\")||i(\"first-input\",(function(n,t){var i=n[0];if(i){var r=i.processingStart,o={duration:i.duration,js:i.processingEnd-r,name:i.name};i.target&&(o.target=u(i.target));var a=r-i.startTime;A(\"first-input\",a,o),e.emit({metricName:\"first-input-debug\",value:a,params:{entry:i,additionalParams:o}}),t.disconnect()}}),{buffered:!0}),e.getSetting(\"disableCLS\")||window.PerformanceObserver&&(d(ce),d(ue),q=re,G=null,J=null,$=null,te=e.getSetting(\"clsWindowGap\")||te,ie=e.getSetting(\"clsWindowSize\")||ie,a(i(\"layout-shift\",se),(function(){return ce(!0)}),!0)),e.getSetting(\"disableLCP\")||!window.PerformanceObserver||!e.getSetting(\"forcePaintTimeSending\")&&e.isVisibilityChanged()||(d(fe),K=null,X=null,Z=!1,a(i(\"largest-contentful-paint\",de),(function(){return fe(!0)}),!1)))}var Ke;function Xe(e){e.persisted&&O(\"bfcache\")}function Ze(){var e=!1;f().forEach((function(n){n()&&(e=!0)})),e||clearInterval(Ke)}d(Ge),e.destroy=function(n){var t=e._unsubscribers;n.shouldComplete&&e.completeSession(!0),e._onComplete=[];for(var i=0;i<t.length;i++)t[i]();removeEventListener(\"visibilitychange\",e._onVisibilityChange),e._unsubscribers=[],e._periodicTasks=[],e._markListeners={},e._deltaMarks={}},e.restart=function(n,t,i){e.destroy({shouldComplete:i}),e.init(n,t),addEventListener(\"visibilitychange\",e._onVisibilityChange),qe(),function(){for(var n=0;n<e._onInit.length;n++)e._onInit[n]()}()},e.setVars=function(n){Object.keys(n).forEach((function(t){e._vars[t]=n[t]})),N(),R()},e.completeSession=function(n){for(var t=e._onComplete,i=0;i<t.length;i++)t[i](n)},qe(),e._periodicTasks=[],e.sendHeroElement=function(e){O(\"2876\",e)},e.getPageUrl=function(){return window.location.href},e._subpages={},e.makeSubPage=function(n,t){var i=e._subpages[n];e._subpages[n]=void 0===i?i=0:++i;var r=!1;return{689.2322:s(void 0!==t?t:e.getTime()),2924:n,2925:i,isCanceled:function(){return r},cancel:function(){r=!0}}},e.getTimeMarks=function(){return p},e.getDeltas=function(){return h},e.getVarsList=l,e.getResourceTimings=V,e.pushConnectionTypeTo=Q,e.pushTimingTo=g,e.normalize=s,e.sendCounter=j,e.sendDelta=A,e.onReady=c,e.getSelector=u,e.getSetting(\"disableCLS\")||(e.finalizeLayoutShiftScore=ce),e.getSetting(\"disableLCP\")||(e.finalizeLargestContentfulPaint=fe),e.sendTrafficData=ze,e._getCommonVars=F,e._addListener=o,e._observe=i,e._timeout=r,e.sendTTI=ke,e._getLongtasksStringValue=Pe,e.onQuietWindow=Le,e.sendBFCacheTimeMark=Xe}else e.getSetting=function(){return\"\"},e.getVarsList=function(){return[]},e.getResourceTimings=e.completeSession=e.pushConnectionTypeTo=e.pushTimingTo=e.normalize=e.sendCounter=e.destroy=e.restart=e.setVars=e.completeSession=e.sendDelta=e.sendTimeMark=e.sendResTiming=e.sendTiming=e.sendTTI=e.makeSubPage=e.sendHeroElement=e.onReady=e.onQuietWindow=function(){}}();\n!function(n){if(!n.Ya||!Ya.Rum)throw new Error(\"Rum: interface is not defined\");var e=Ya.Rum;e.getSetting=function(n){var t=e._settings[n];return null===t?null:t||\"\"}}(\"undefined\"!=typeof self?self:window);\n!function(e,r){var n={client:[\"690.2354\",1e3,100,0],uncaught:[\"690.2361\",100,10,0],external:[\"690.2854\",100,10,0],script:[\"690.2609\",100,10,0]},t={};r.ERROR_LEVEL={INFO:\"info\",DEBUG:\"debug\",WARN:\"warn\",ERROR:\"error\",FATAL:\"fatal\"},r._errorSettings={clck:\"https://yandex.ru/clck/click\",beacon:!0,project:\"unknown\",page:\"\",env:\"\",experiments:[],additional:{},platform:\"\",region:\"\",dc:\"\",host:\"\",service:\"\",level:\"\",version:\"\",yandexuid:\"\",loggedin:!1,coordinates_gp:\"\",referrer:!0,preventError:!1,unhandledRejection:!1,traceUnhandledRejection:!1,uncaughtException:!0,debug:!1,limits:{},silent:{},filters:{},pageMaxAge:864e6,initTimestamp:+new Date};var o=!1;function a(e,r){for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n]);return e}function i(e){return\"boolean\"==typeof e&&(e=+e),\"number\"==typeof e?e+\"\":null}r.initErrors=function(n){var t=a(r._errorSettings,n);o||(t.uncaughtException&&function(){var n=r._errorSettings;if(e.addEventListener)e.addEventListener(\"error\",s),n.resourceFails&&e.addEventListener(\"error\",l,!0),\"Promise\"in e&&n.unhandledRejection&&e.addEventListener(\"unhandledrejection\",function(e){var n,t,o=e.reason,a={};o&&(o.stack&&o.message?(n=o.message,t=o.stack):(n=String(o),t=r._parseTraceablePromiseStack(e.promise),\"[object Event]\"===n?n=\"event.type: \"+o.type:\"[object Object]\"===n&&(a.unhandledObject=o)),o.target&&o.target.src&&(a.src=o.target.src),s({message:\"Unhandled rejection: \"+n,stack:t,additional:a}))});else{var t=e.onerror;e.onerror=function(e,r,n,o,a){s({error:a||new Error(e||\"Empty error\"),message:e,lineno:n,colno:o,filename:r}),t&&t.apply(this,arguments)}}}(),t.unhandledRejection&&t.traceUnhandledRejection&&r._traceUnhandledRejection&&r._traceUnhandledRejection(),o=!0)},r.updateErrors=function(e){a(r._errorSettings,e)},r.updateAdditional=function(e){r._errorSettings.additional=a(r._errorSettings.additional||{},e)},r._handleError=function(e,o,i){var s,l,c=r._errorSettings;if(c.preventError&&e.preventDefault&&e.preventDefault(),o)s=e,l=\"client\";else{s=r._normalizeError(e),l=s.type;var d=c.onError;\"function\"==typeof d&&d(s);var u=c.transform;if(\"function\"==typeof u&&(s=u(s)),!s)return;s.settings&&(i=s.settings)}var g=+new Date,f=c.initTimestamp,p=c.pageMaxAge;if(!(-1!==p&&f&&f+p<g)){var m=n[l][1];\"number\"==typeof c.limits[l]&&(m=c.limits[l]);var v=n[l][2];\"number\"==typeof c.silent[l]&&(v=c.silent[l]);var h=n[l][3];if(h<m||-1===m){s.path=n[l][0];var E=r._getErrorData(s,{silent:h<v||-1===v?\"no\":\"yes\",isCustom:Boolean(o)},a(a({},c),i)),_=function(e){t[s.message]=!1,r._sendError(e.path,e.vars),n[l][3]++}.bind(this,E);if(void 0===c.throttleSend)_();else{if(t[s.message])return;t[s.message]=!0,setTimeout(_,c.throttleSend)}}}},r._getReferrer=function(r){var n=r.referrer,t=typeof n;return\"function\"===t?n():\"string\"===t&&n?n:!1!==n&&e.location?e.location.href:void 0},r.getErrorSetting=function(e){return r._errorSettings[e]},r._buildExperiments=function(e){return e instanceof Array?e.join(\";\"):\"\"},r._buildAdditional=function(e,r){var n=\"\";try{var t=a(a({},e),r);0!==Object.keys(t).length&&(n=JSON.stringify(t))}catch(e){}return n},r._getErrorData=function(n,t,o){t=t||{};var a=r._buildExperiments(o.experiments),s=r._buildAdditional(o.additional,n.additional),l={\"-stack\":n.stack,\"-url\":n.file,\"-line\":n.line,\"-col\":n.col,\"-block\":n.block,\"-method\":n.method,\"-msg\":n.message,\"-env\":o.env,\"-external\":n.external,\"-externalCustom\":n.externalCustom,\"-project\":o.project,\"-service\":n.service||o.service,\"-page\":n.page||o.page,\"-platform\":o.platform,\"-level\":n.level,\"-experiments\":a,\"-version\":o.version,\"-region\":o.region,\"-dc\":o.dc,\"-host\":o.host,\"-yandexuid\":o.yandexuid,\"-loggedin\":o.loggedin,\"-coordinates_gp\":n.coordinates_gp||o.coordinates_gp,\"-referrer\":r._getReferrer(o),\"-source\":n.source,\"-sourceMethod\":n.sourceMethod,\"-type\":t.isCustom?n.type:\"\",\"-additional\":s,\"-adb\":i(Ya.blocker)||i(o.blocker),\"-cdn\":e.YaStaticRegion,\"-ua\":navigator.userAgent,\"-silent\":t.silent,\"-ts\":+new Date,\"-init-ts\":o.initTimestamp};return o.debug&&e.console&&console[console[n.level]?n.level:\"error\"](\"[error-counter] \"+n.message,l,n.stack),{path:n.path,vars:l}},r._baseNormalizeError=function(e){var r=(e=e||{}).error,n=e.filename||e.fileName||\"\",t=r&&r.stack||e.stack||\"\",o=e.message||\"\",a=r&&r.additional||e.additional;return{file:n,line:e.lineno||e.lineNumber,col:e.colno||e.colNumber,stack:t,message:o,additional:a}},r._normalizeError=function(e){var n=r._baseNormalizeError(e),t=\"uncaught\",o=r._isExternalError(n.file,n.message,n.stack),a=\"\",i=\"\";return o.hasExternal?(t=\"external\",a=o.common,i=o.custom):/^Script error\\.?$/.test(n.message)&&(t=\"script\"),n.external=a,n.externalCustom=i,n.type=t,n},r._createVarsString=function(e){var r=[];for(var n in e)e.hasOwnProperty(n)&&(e[n]||0===e[n])&&r.push(n+\"=\"+encodeURIComponent(e[n]).replace(/\\*/g,\"%2A\"));return r.join(\",\")},r._sendError=function(e,n){r.send(null,e,r._createVarsString(n),null,null,null,null)};var s=function(e){r._handleError(e,!1)},l=function(e){var n=e.target;if(n){var t=n.srcset||n.src;if(t||(t=n.href),t){var o=n.tagName||\"UNKNOWN\";r.logError({message:o+\" load error\",additional:{src:t}})}}};r._parseTraceablePromiseStack=function(){}}(\"undefined\"!=typeof self?self:window,Ya.Rum);\n!function(e){var r={url:{0:/(miscellaneous|extension)_bindings/,1:/^chrome:/,2:/kaspersky-labs\\.com\\//,3:/^(?:moz|chrome|safari)-extension:\\/\\//,4:/^file:/,5:/^resource:\\/\\//,6:/webnetc\\.top/,7:/local\\.adguard\\.com/},message:{0:/__adgRemoveDirect/,1:/Content Security Policy/,2:/vid_mate_check/,3:/ucapi/,4:/Access is denied/i,5:/^Uncaught SecurityError/i,6:/__ybro/,7:/__show__deepen/,8:/ntp is not defined/,9:/Cannot set property 'install' of undefined/,10:/NS_ERROR/,11:/Error loading script/,12:/^TypeError: undefined is not a function$/,13:/__firefox__\\.(?:favicons|metadata|reader|searchQueryForField|searchLoginField)/},stack:{0:/(?:moz|chrome|safari)-extension:\\/\\//,1:/adguard.*\\.user\\.js/i}};function n(e,r){if(e&&r){var n=[];for(var o in r)if(r.hasOwnProperty(o)){var i=r[o];\"string\"==typeof i&&(i=new RegExp(i)),i instanceof RegExp&&i.test(e)&&n.push(o)}return n.join(\"_\")}}function o(e,o){var i,a=[];for(var t in r)r.hasOwnProperty(t)&&(i=n(e[t],o[t]))&&a.push(t+\"~\"+i);return a.join(\";\")}e._isExternalError=function(n,i,a){var t=e._errorSettings.filters||{},s={url:(n||\"\")+\"\",message:(i||\"\")+\"\",stack:(a||\"\")+\"\"},c=o(s,r),u=o(s,t);return{common:c,custom:u,hasExternal:!(!c&&!u)}}}(Ya.Rum);\nYa.Rum.initErrors({\n        reqid: '1768063975593584-1199238271730949658',\n        project: 'education-web',\n        env: 'production',\n        page: window.location.pathname,\n        version: 'undefined',\n        platform: window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop'\n    });","id":"rum-error"}])</script><script nonce="">(self.__next_s=self.__next_s||[]).push([0,{"nonce":"63ec77a1-e677-4dcb-945b-702ad5710bd7","children":"\n  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};\n  m[i].l=1*new Date();\n  for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}\n  k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})\n  (window, document, \"script\", \"https://mc.yandex.ru/metrika/tag.js\", \"ym\");\n","id":"yandex-metrika"}])</script><noscript><div><img loading="lazy" src="https://mc.yandex.ru/watch/26760489" style="position:absolute;left:-9999px" alt=""/></div></noscript><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/webpack-05f11ea662126375.js" nonce="" crossorigin="" id="_R_" async=""></script><script nonce="">(self.__next_f=self.__next_f||[]).push([0])</script><script nonce="">self.__next_f.push([1,"1:\"$Sreact.fragment\"\n3:I[78919,[],\"\"]\n4:I[74619,[],\"\"]\n1a:I[34733,[],\"\"]\n1d:I[7918,[],\"OutletBoundary\"]\n1f:I[33443,[],\"AsyncMetadataOutlet\"]\n21:I[7918,[],\"ViewportBoundary\"]\n23:I[7918,[],\"MetadataBoundary\"]\n24:\"$Sreact.suspense\"\n26:I[71311,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"\"]\n28:I[45866,[\"1666\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/layout-e3a20ad13303521f.js\"],\"UseLatexRuntime\"]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/0f6801932ea3fcf4-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/305b936a915bc48f-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/3fdc59da94114ecd-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/a853c69d3cf13b17-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/b4b0da158404816f-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-"])</script><script nonce="">self.__next_f.push([1,"portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/c8ae0fac15b37b16-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/cc87cb16fedd6384-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/dd32e121f6104240-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/e10f0a1f1c5bddfe-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/f2f0493f5123f937-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/f3f9c83d0bcb2176-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/00e25bd25bbd0437.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb46cd5c40721db6.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/85781da132a474d7.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]"])</script><script nonce="">self.__next_f.push([1,"\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/df0a82ffea795a48.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c800df164b7b8c22.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/033fa3e38f305e9b.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/80e3798aa7f5abc0.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/17fd"])</script><script nonce="">self.__next_f.push([1,"f933d7378e89.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a2f4cf3f3bb12d85.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d844ab516aaccc48.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb0e02f100b08559.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/381835674ab7c3f7.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/8268a37c4890f71e.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/e2bd809ab2e171e9.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84f1d4eada6960dd.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cee7c32dde4c9323.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ef486034b69d75eb.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/"])</script><script nonce="">self.__next_f.push([1,"education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/4453bad77d6636b4.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dfbd22c99f7f399e.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5c966d7ef241f1d1.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b1ea991da29cd10f.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cb7ec9243c9cb1bf.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ca947b8fe9734df5.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a412a0891b49ea16.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ddb8c975b9776637.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9425ba6f0e81e31a.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/feca8288b0586eb3.css\",\"style\",{\"cr"])</script><script nonce="">self.__next_f.push([1,"ossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d238d176bd8ae895.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9fc77bcede8e7238.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/daf421f1dcbde59d.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/bd270492e7e016dc.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/500049d7c719a090.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/3e9ccf27ab1f71e9.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b6dc735f8f16428c.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/094d7d6ad311c845.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n"])</script><script nonce="">self.__next_f.push([1,"0:{\"P\":null,\"b\":\"xZcdS5roGxWU4G4BMA8rx\",\"p\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e\",\"c\":[\"\",\"handbook\",\"algorithms\",\"article\",\"zadacha-kolichestvo-prizov\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"handbook\",{\"children\":[[\"book\",\"algorithms\",\"d\"],{\"children\":[\"article\",{\"children\":[[\"article\",\"zadacha-kolichestvo-prizov\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/00e25bd25bbd0437.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb46cd5c40721db6.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/85781da132a474d7.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/df0a82ffea795a48.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c800df164b7b8c22.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"5\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/033fa3e38f305e9b.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"6\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/80e3798aa7f5abc0.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]],\"$L2\"]}],{\"children\":[\"handbook\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"book\",\"algorithms\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],\"$L5\",\"$L6\",\"$L7\",\"$L8\",\"$L9\",\"$La\",\"$Lb\",\"$Lc\",\"$Ld\",\"$Le\",\"$Lf\",\"$L10\",\"$L11\",\"$L12\",\"$L13\",\"$L14\"],\"$L15\"]}],{\"children\":[\"article\",\"$L16\",{\"children\":[[\"article\",\"zadacha-kolichestvo-prizov\",\"d\"],\"$L17\",{\"children\":[\"__PAGE__\",\"$L18\",{},null,false]},null,false]},null,false]},null,false]},null,false]},null,false],\"$L19\",false]],\"m\":\"$undefined\",\"G\":[\"$1a\",[]],\"s\":false,\"S\":false}\n"])</script><script nonce="">self.__next_f.push([1,"5:[\"$\",\"link\",\"5\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/17fdf933d7378e89.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n6:[\"$\",\"link\",\"6\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a2f4cf3f3bb12d85.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n7:[\"$\",\"link\",\"7\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d844ab516aaccc48.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n8:[\"$\",\"link\",\"8\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb0e02f100b08559.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n9:[\"$\",\"link\",\"9\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/381835674ab7c3f7.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\na:[\"$\",\"link\",\"10\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/8268a37c4890f71e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\nb:[\"$\",\"link\",\"11\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/e2bd809ab2e171e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\nc:[\"$\",\"link\",\"12\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00"])</script><script nonce="">self.__next_f.push([1,"b204e9800998ecf8427e/_next/static/css/84f1d4eada6960dd.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\nd:[\"$\",\"link\",\"13\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cee7c32dde4c9323.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\ne:[\"$\",\"link\",\"14\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ef486034b69d75eb.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\nf:[\"$\",\"link\",\"15\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/4453bad77d6636b4.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n10:[\"$\",\"link\",\"16\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dfbd22c99f7f399e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n11:[\"$\",\"link\",\"17\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5c966d7ef241f1d1.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n12:[\"$\",\"link\",\"18\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b1ea991da29cd10f.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n13:[\"$\",\"link\",\"19\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cb7ec9243c9cb1bf.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce"])</script><script nonce="">self.__next_f.push([1,"\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n14:[\"$\",\"link\",\"20\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ca947b8fe9734df5.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n16:[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}]\n17:[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L1b\"]}]\n"])</script><script nonce="">self.__next_f.push([1,"18:[\"$\",\"$1\",\"c\",{\"children\":[\"$L1c\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a412a0891b49ea16.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ddb8c975b9776637.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9425ba6f0e81e31a.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/feca8288b0586eb3.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d238d176bd8ae895.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"5\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9fc77bcede8e7238.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"6\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/daf421f1dcbde59d.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"7\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/bd270492e7e016dc.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"8\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/500049d7c719a090.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"9\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/3e9ccf27ab1f71e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"10\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b6dc735f8f16428c.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"11\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/094d7d6ad311c845.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]],[\"$\",\"$L1d\",null,{\"children\":[\"$L1e\",[\"$\",\"$L1f\",null,{\"promise\":\"$@20\"}]]}]]}]\n"])</script><script nonce="">self.__next_f.push([1,"19:[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$L21\",null,{\"children\":\"$L22\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]],[\"$\",\"$L23\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$24\",null,{\"fallback\":null,\"children\":\"$L25\"}]}]}]]}]\n1b:[[\"$\",\"$L26\",null,{\"src\":\"https://yastatic.net/s3/cloud/forms/_/embed.js\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],\"$@27\",[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"$L28\",null,{}]]\n27:null\n22:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"2\",{\"name\":\"theme-color\",\"content\":\"#a48eef\"}]]\n1e:null\n"])</script><script nonce="">self.__next_f.push([1,"15:[\"$L29\",[\"$\",\"div\",null,{\"className\":\"hb\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],\"$L2a\"]\n"])</script><script nonce="">self.__next_f.push([1,"2c:I[75076,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"FooterPlain\"]\n29:[[\"$\",\"$1\",\"web-page.block-0\",{\"children\":[\"$L2b\"]}]]\n"])</script><script nonce="">self.__next_f.push([1,"2a:[[\"$\",\"$1\",\"web-page.block-0\",{\"children\":[[\"$\",\"$L2c\",\"web-page.footer-plain\",{\"id\":2,\"Anchor\":null,\"Theme\":\"#FFFFFF\",\"Disclaimer\":\"Образовательные услуги оказываются АНО ДПО «Образовательные технологии Яндекса»\\nна\u0026nbsp;основании [Лицензии № Л035-01298-77/00185314](https://yastatic.net/s3/academy/docs/license-ysda.pdf) от 24 марта 2015 года.\\n\\n© 2025 Яндекс, АНО ДПО «Образовательные технологии Яндекса».\",\"Columns\":[{\"id\":8,\"Name\":null,\"Links\":[{\"id\":4460,\"Text\":\"Яндекс Учебник\",\"URL\":\"https://education.yandex.ru/uchebnik/main\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4458,\"Text\":\"Яндекс Лицей\",\"URL\":\"https://lyceum.yandex.ru/\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4459,\"Text\":\"Яндекс Практикум\",\"URL\":\"https://practicum.yandex.ru/?utm_source=partners\u0026utm_medium=partners\u0026utm_campaign=yandexeducation_partners_RF_Common_Unde_b2c_Landing-page_None_None\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4461,\"Text\":\"Школа анализа данных\",\"URL\":\"https://shad.yandex.ru/\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4463,\"Text\":\"Программы в университетах\",\"URL\":\"/university\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null}]},{\"id\":9,\"Name\":null,\"Links\":[{\"id\":4462,\"Text\":\"Исследования\",\"URL\":\"/research\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4464,\"Text\":\"Хендбуки\",\"URL\":\"/handbook\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":5881,\"Text\":\"Карты IT-навыков\",\"URL\":\"/roadmap\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4466,\"Text\":\"База знаний\",\"URL\":\"/knowledge\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4465,\"Text\":\"Журнал\",\"URL\":\"/journal\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4467,\"Text\":\"События\",\"URL\":\"/events\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null}]},{\"id\":10,\"Name\":null,\"Links\":[{\"id\":4468,\"Text\":\"О нас\",\"URL\":\"/about\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4469,\"Text\":\"Обратная связь\",\"URL\":\"https://forms.yandex.ru/surveys/13457493.e7112b8cdd8c782bfe6e4b1ab1b73f49438edacf/\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4470,\"Text\":\"Пользовательское соглашение\",\"URL\":\"https://yandex.ru/legal/education_termsofuse/ru/\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4471,\"Text\":\"Сайт образовательной организации\",\"URL\":\"https://yandex.ru/edtech\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4472,\"Text\":\"Сведения об образовательной организации\",\"URL\":\"https://yandex.ru/edtech/sveden\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null}]}],\"Socials\":[{\"id\":4454,\"Text\":\"Рассылка\",\"URL\":\"/subscribe\",\"Title\":\"Рассылка\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":null}},{\"id\":4473,\"Text\":\"Бот\",\"URL\":\"https://t.me/yaeducation_bot?start=n_113083__c_7628\",\"Title\":\"Бот\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":null}},{\"id\":4455,\"Text\":\"ВКонтакте\",\"URL\":\"https://vk.com/yandex_education\",\"Title\":\"ВКонтакте\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":{\"id\":5,\"attributes\":{\"name\":\"social_icon_vk.svg\",\"alternativeText\":\"\",\"caption\":\"\",\"width\":40,\"height\":40,\"formats\":null,\"hash\":\"social_icon_vk_97bf858cd5\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":0.49,\"url\":\"https://yastatic.net/s3/education-portal/media/social_icon_vk_97bf858cd5.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-01T08:03:45.007Z\",\"updatedAt\":\"2024-02-09T11:21:16.497Z\"}}}},{\"id\":4456,\"Text\":\"YouTube\",\"URL\":\"https://www.youtube.com/@Education_Yandex\",\"Title\":\"YouTube\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":{\"id\":6,\"attributes\":{\"name\":\"social_icon_yt.svg\",\"alternativeText\":\"\",\"caption\":\"\",\"width\":40,\"height\":40,\"formats\":null,\"hash\":\"social_icon_yt_d20daea655\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":0.77,\"url\":\"https://yastatic.net/s3/education-portal/media/social_icon_yt_d20daea655.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-01T08:03:45.307Z\",\"updatedAt\":\"2024-02-01T08:03:45.307Z\"}}}},{\"id\":4457,\"Text\":\"Telegram\",\"URL\":\"https://t.me/education_yandex\",\"Title\":\"Telegram\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":{\"id\":7,\"attributes\":{\"name\":\"social_icon_tg.svg\",\"alternativeText\":\"\",\"caption\":\"\",\"width\":40,\"height\":40,\"formats\":null,\"hash\":\"social_icon_tg_9faafb663e\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":1.04,\"url\":\"https://yastatic.net/s3/education-portal/media/social_icon_tg_9faafb663e.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-01T08:03:45.537Z\",\"updatedAt\":\"2024-02-01T08:03:45.537Z\"}}}}],\"Gutter\":{\"id\":569,\"xs\":0,\"sm\":0,\"md\":0,\"lg\":0,\"xl\":0},\"Logo\":{\"id\":77,\"URL\":\"/\",\"Title\":\"Яндекс Образование\",\"Image\":{\"data\":{\"id\":8,\"attributes\":{\"name\":\"edu_logo.svg\",\"alternativeText\":null,\"caption\":null,\"width\":233,\"height\":24,\"formats\":null,\"hash\":\"edu_logo_9eee76ff17\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":13.44,\"url\":\"https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-09T11:00:59.235Z\",\"updatedAt\":\"2024-12-04T04:36:42.717Z\"}}},\"ImageMobile\":{\"data\":{\"id\":3190,\"attributes\":{\"name\":\"edu-logo-simple.svg\",\"alternativeText\":\"edu-logo-simple.svg\",\"caption\":\"edu-logo-simple.svg\",\"width\":204,\"height\":21,\"formats\":null,\"hash\":\"edu_logo_simple_9790e70002\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":7.25,\"url\":\"https://yastatic.net/s3/education-portal/media/edu_logo_simple_9790e70002.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-20T11:27:57.767Z\",\"updatedAt\":\"2024-12-04T12:30:44.339Z\"}}}}}]]}]]\n"])</script><script nonce="">self.__next_f.push([1,"2d:I[93982,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"default\"]\n"])</script><script nonce="">self.__next_f.push([1,"2b:[\"$\",\"$L2d\",\"web-page.header-block\",{\"id\":2,\"Authorization\":true,\"Search\":true,\"ProfileUrl\":\"/profile\",\"Wide\":null,\"Notifications\":true,\"Gutter\":null,\"Buttons\":[],\"Menu\":[{\"id\":19,\"Text\":\"Школьникам\",\"URL\":\"/pupils\",\"Title\":\"Школьникам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_school\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":null,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4136,\"Text\":\"Студентам\",\"URL\":\"/students\",\"Title\":\"Студентам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_students\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4137,\"Text\":\"Абитуриентам\",\"URL\":\"/university\",\"Title\":\"Абитуриентам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_abit\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4138,\"Text\":\"Партнёрам\",\"URL\":\"https://edumakers.yandex.ru/\",\"Title\":\"Партнёрам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_partner\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4139,\"Text\":\"Хендбуки\",\"URL\":\"/handbook\",\"Title\":\"События\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4140,\"Text\":\"Журнал\",\"URL\":\"/journal\",\"Title\":\"Журнал\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_journal\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4141,\"Text\":\"AI\",\"URL\":\"https://education.yandex.ru/ai\",\"Title\":\"AI\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null}],\"Logo\":{\"id\":3,\"URL\":\"/\",\"Title\":\"Яндекс Образование\",\"Image\":{\"data\":{\"id\":8,\"attributes\":{\"name\":\"edu_logo.svg\",\"alternativeText\":null,\"caption\":null,\"width\":233,\"height\":24,\"formats\":null,\"hash\":\"edu_logo_9eee76ff17\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":13.44,\"url\":\"https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-09T11:00:59.235Z\",\"updatedAt\":\"2024-12-04T04:36:42.717Z\"}}},\"ImageMobile\":{\"data\":{\"id\":10764,\"attributes\":{\"name\":\"logo_mobile.svg\",\"alternativeText\":null,\"caption\":null,\"width\":179,\"height\":25,\"formats\":null,\"hash\":\"logo_mobile_8bc5eb38fb\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":18.25,\"url\":\"https://yastatic.net/s3/education-portal/media/logo_mobile_8bc5eb38fb.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-07-17T12:53:33.633Z\",\"updatedAt\":\"2024-12-04T04:35:29.061Z\"}}}},\"isLoggedIn\":false,\"passportUrl\":\"https://passport.yandex.ru/auth/?origin=education\u0026retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Falgorithms%2Farticle%2Fzadacha-kolichestvo-prizov\",\"passportEnv\":\"prod\",\"passportUserData\":{\"avatarId\":\"$undefined\",\"plus\":false,\"name\":\"$undefined\"}}]\n"])</script><script nonce="">self.__next_f.push([1,"2e:T1248,"])</script><script nonce="">self.__next_f.push([1,"\n  function applyUADataPolyfill(){\n    function e(a){let b=/Windows NT (\\d+(\\.\\d+)*)/.exec(a);if(!b)return null;let c={\"6.1\":\"0.1\",\"6.2\":\"0.2\",\"6.3\":\"0.3\",\"10.0\":\"10.0\",\"11.0\":\"13.0\"}[b[1]],d=c?q(c,3):\"\",e=\"\",f=\"\";return/\\b(WOW64|Win64|x64)\\b/.test(a)\u0026\u0026(e=\"x86\",f=\"64\"),{platform:\"Windows\",platformVersion:d,architecture:e,bitness:f}}\n    function f(a,b){let c=/Android (\\d+(\\.\\d+)*)/.exec(a);if(!c)return null;let d=\"\",e=\"\",f=/Linux (\\w+)/.exec(b);if(f\u0026\u0026f[1]){let a=p(f[1]);d=a[0],e=a[1]}return{platform:\"Android\",platformVersion:q(c[1]),architecture:d,bitness:e}}\n    function g(a){let b=/(iPhone|iPod touch); CPU iPhone OS (\\d+(_\\d+)*)/.exec(a),c=/(iPad); CPU OS (\\d+(_\\d+)*)/.exec(a),d=b||c;return d?{platform:\"iOS\",platformVersion:q(d[2].replace(/_/g,\".\"))}:null}\n    function h(a){let b=/Macintosh; (Intel|\\w+) Mac OS X (\\d+([_.]\\d+)*)/.exec(a);return b?{platform:\"macOS\",platformVersion:q(b[2].replace(/_/g,\".\"))}:null}\n    function i(a){let b=/CrOS (\\w+) (\\d+(\\.\\d+)*)/.exec(a);if(!b)return null;let c=p(b[1]);return{platform:\"Chrome OS\",platformVersion:q(b[2]),architecture:c[0],bitness:c[1]}}\n    function j(a,b){for(let c of[()=\u003ee(a),()=\u003ef(a,b),()=\u003eg(a),()=\u003eh(a),()=\u003ei(a)]){let a=c();if(a)return a}return/Linux/.test(a)?{platform:\"Linux\",platformVersion:\"\"}:{platform:\"Unknown\",platformVersion:\"\"}}\n    function k(a,b,c){let d=/Chrome\\/(\\d+(\\.\\d+)*)/.exec(a);if(!d||\"Google Inc.\"!==c)return null;let e=[{brand:\"Chromium\",version:q(d[1],4)}],f=/(Edge?)\\/(\\d+(\\.\\d+)*)/.exec(a);if(f){let a={Edge:\"Microsoft Edge\",Edg:\"Microsoft Edge\"}[f[1]];e.push({brand:a,version:q(f[2],4)})}else e.push({brand:\"Google Chrome\",version:q(d[1],4)});return e}\n    function l(a,b){let c=/AppleWebKit\\/(\\d+(\\.\\d+)*)/.exec(a);return c\u0026\u0026\"Apple Computer, Inc.\"===b?[{brand:\"WebKit\",version:q(c[1])}]:null}\n    function m(a){let b=/Firefox\\/(\\d+(\\.\\d+)*)/.exec(a);return b?[{brand:\"Firefox\",version:q(b[1])}]:null}\n    function n(a,b,c,d,e){let f=!1,g=[];for(let h of[()=\u003ek(a,b,c),()=\u003el(a,c),()=\u003em(a)]){let c=h();if(c){g=c,h===k\u0026\u0026/\\bwv\\b/.test(b)\u0026\u0026(f=!0);let i=/(CriOS|EdgiOS|FxiOS|Version)\\/(\\d+(\\.\\d+)*)/.exec(a);if(h===l\u0026\u0026\"iOS\"===d\u0026\u0026i){let a={CriOS:\"Google Chrome\",EdgiOS:\"Microsoft Edge\",FxiOS:\"Mozilla Firefox\",Version:\"Apple Safari\"}[i[1]];g.push({brand:a,version:q(i[2])}),e\u0026\u0026!e.some(a=\u003ea.startsWith(\"Safari/\"))\u0026\u0026(f=!0)}break}}return 0===g.length\u0026\u0026(g=[{brand:\"Not;A Brand\",version:\"99.0.0.0\"}]),{fullVersionList:g,webview:f}}\n    function o(a){let{userAgent:b,platform:c,vendor:d}=a,e=b,f=!1,g=b.replace(/\\(([^)]+)\\)/g,(a,b)=\u003e(f||(e=b,f=!0),\"\")),h=g.match(/(\\S+)\\/(\\S+)/g),i=b.includes(\"Mobile\"),k=j(e,c),{fullVersionList:l,webview:m}=n(g,e,d,k.platform,h),o=l.length\u003e0?l[l.length-1].version:\"\",p=l.map(a=\u003e{let b=a.version.indexOf(\".\"),c=-1===b?a.version:a.version.slice(0,b);return{brand:a.brand,version:c}});return{mobile:i,platform:k.platform,brands:p,platformVersion:k.platformVersion,architecture:k.architecture||\"\",bitness:k.bitness||\"\",model:\"\",uaFullVersion:o,fullVersionList:l,webview:m}}\n    function p(a){switch(a){case\"x86_64\":case\"x64\":return[\"x86\",\"64\"];case\"x86_32\":case\"x86\":return[\"x86\",\"\"];case\"armv6l\":case\"armv7l\":case\"armv8l\":return[a,\"\"];case\"aarch64\":return[\"arm\",\"64\"];default:return[\"\",\"\"]}}\n    function q(a,b=3){let c=a.split(\".\");if(c.length\u003cb)for(;c.length\u003cb;)c.push(\"0\");return c.join(\".\")}\n    class r{constructor(a){this._clientHints=o(a),Object.defineProperties(this,{_clientHints:{enumerable:!1}})}get mobile(){return this._clientHints.mobile}get platform(){return this._clientHints.platform}get brands(){return this._clientHints.brands}getHighEntropyValues(a){return new Promise(b=\u003e{if(!Array.isArray(a))throw TypeError(\"Argument hints must be an array\");let c=new Set(a),d=this._clientHints,e={mobile:d.mobile,platform:d.platform,brands:d.brands};c.has(\"architecture\")\u0026\u0026(e.architecture=d.architecture),c.has(\"bitness\")\u0026\u0026(e.bitness=d.bitness),c.has(\"model\")\u0026\u0026(e.model=d.model),c.has(\"platformVersion\")\u0026\u0026(e.platformVersion=d.platformVersion),c.has(\"uaFullVersion\")\u0026\u0026(e.uaFullVersion=d.uaFullVersion),c.has(\"fullVersionList\")\u0026\u0026(e.fullVersionList=d.fullVersionList),b(e)})}toJSON(){return{mobile:this._clientHints.mobile,brands:this._clientHints.brands}}}\n    function(){if(\"https:\"===location.protocol\u0026\u0026!navigator.userAgentData){Object.defineProperty(r.prototype,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!1,value:\"NavigatorUAData\"});let a=new r(navigator);return Object.defineProperty(Navigator.prototype,\"userAgentData\",{enumerable:!0,configurable:!0,get:function(){return a}}),Object.defineProperty(window,\"NavigatorUAData\",{enumerable:!1,configurable:!0,writable:!0,value:r}),!0}return!1}\n    polyfill();\n  }\n  applyUADataPolyfill();\n"])</script><script nonce="">self.__next_f.push([1,"2:[\"$\",\"html\",null,{\"lang\":\"ru\",\"className\":\"__className_a39d3e __variable_a39d3e __variable_5a49b6 __variable_2ac229 HR-9-31-0\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"https://yastatic.net/s3/education-portal/web/favicon.ico\",\"sizes\":\"any\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"https://yastatic.net/s3/education-portal/web/icon.svg\",\"type\":\"image/svg+xml\"}],[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"href\":\"https://yastatic.net/s3/education-portal/web/apple-touch-icon.png\"}],[\"$\",\"script\",null,{\"id\":\"ab-test-data\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"dangerouslySetInnerHTML\":{\"__html\":\"window.__AB_TEST_DATA = {\\\"flags\\\":{},\\\"experiments\\\":\\\"P54lnS9LcLo,\\\"};\"},\"suppressHydrationWarning\":true}]]}],[\"$\",\"body\",null,{\"className\":\"Theme Theme_color_hrLight Theme_root_hrLight utilityfocus\",\"children\":[[[\"$\",\"script\",null,{\"id\":\"hasOwnPolyfill\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"suppressHydrationWarning\":true,\"children\":\"('hasOwn' in Object) || (Object.hasOwn = Object.call.bind(Object.hasOwnProperty));\"}],[\"$\",\"script\",null,{\"id\":\"UserAGentUADataPolyfill\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"suppressHydrationWarning\":true,\"children\":\"$2e\"}]],\"$L2f\",\"$L30\",\"$L31\",\"$L32\",\"$L33\"]}]]}]\n"])</script><script nonce="">self.__next_f.push([1,"34:I[87609,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"ErrorBoundary\"]\n35:I[46262,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"ToastContainer\"]\n36:I[85137,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"Theme\"]\n37:I[12665,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"2665\",\"static/chunks/2665-c77f7b9517a535fe.js\",\"8039\",\"static/chunks/app/error-da5ebf8e69abf3a6.js\"],\"default\"]\n46:I[79949,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"PortalMetrika\"]\n47:I[46678,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"YandexMetrikaCounter\"]\n4a:I[15552,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"ScrollToTopOnPathnameChange\"]\n4b:I[78705,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"SW\"]\n2f:[\"$\",\"$L34\",null,{\"fallback\":null,\"children\":[[\"$\",\"$L35\",null,{\"containerId\":\"defaultToastContainer\",\"enableMultiContainer\":true}],[\"$\",\"$L35\",null,{\"containerId\":\"noCloseButtonToastContainer\",\"closeButton\":false,\"enableMultiContain"])</script><script nonce="">self.__next_f.push([1,"er\":true}]]}]\n30:[\"$\",\"$L36\",null,{}]\n"])</script><script nonce="">self.__next_f.push([1,"31:[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$37\",\"errorStyles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]],\"errorScripts\":[],\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$L38\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"5\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/17fdf933d7378e89.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"6\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a2f4cf3f3bb12d85.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"7\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d844ab516aaccc48.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],[\"$\",\"link\",\"8\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb0e02f100b08559.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}],\"$L39\",\"$L3a\",\"$L3b\",\"$L3c\",\"$L3d\",\"$L3e\",\"$L3f\",\"$L40\",\"$L41\",\"$L42\",\"$L43\"]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]\n"])</script><script nonce="">self.__next_f.push([1,"32:[\"$\",\"$L34\",null,{\"fallback\":null,\"children\":[\"$L44\",[\"$L45\",[\"$\",\"$L46\",null,{}],[\"$\",\"$L47\",null,{\"id\":26760489,\"settings\":\"defer=1,webvisor=1,hitOnInit=1,fullUrl=1\",\"firstPartyParams\":{},\"experiments\":\"P54lnS9LcLo,\"}],\"$undefined\",\"$L48\",\"$L49\"]]}]\n33:[[\"$\",\"$L34\",null,{\"fallback\":null,\"children\":[\"$\",\"$L4a\",null,{}]}],[\"$\",\"$L34\",null,{\"fallback\":null,\"children\":[\"$\",\"$L4b\",null,{}]}]]\n"])</script><script nonce="">self.__next_f.push([1,"39:[\"$\",\"link\",\"9\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/381835674ab7c3f7.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n3a:[\"$\",\"link\",\"10\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/8268a37c4890f71e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n3b:[\"$\",\"link\",\"11\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/e2bd809ab2e171e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n3c:[\"$\",\"link\",\"12\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84f1d4eada6960dd.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n3d:[\"$\",\"link\",\"13\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cee7c32dde4c9323.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n3e:[\"$\",\"link\",\"14\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ef486034b69d75eb.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n3f:[\"$\",\"link\",\"15\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/4453bad77d6636b4.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n40:[\"$\",\"link\",\"16\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-"])</script><script nonce="">self.__next_f.push([1,"d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dfbd22c99f7f399e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n41:[\"$\",\"link\",\"17\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b1ea991da29cd10f.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n42:[\"$\",\"link\",\"18\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cb7ec9243c9cb1bf.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n43:[\"$\",\"link\",\"19\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5c966d7ef241f1d1.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\"}]\n45:[\"$\",\"$L26\",null,{\"id\":\"yandex-metrika\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"strategy\":\"beforeInteractive\",\"dangerouslySetInnerHTML\":{\"__html\":\"\\n  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};\\n  m[i].l=1*new Date();\\n  for (var j = 0; j \u003c document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}\\n  k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})\\n  (window, document, \\\"script\\\", \\\"https://mc.yandex.ru/metrika/tag.js\\\", \\\"ym\\\");\\n\"}}]\n48:null\n49:null\n4c:T74e8,"])</script><script nonce="">self.__next_f.push([1,"!function(e,t){if(e.Ya=e.Ya||{},Ya.Rum)throw new Error(\"Rum: interface is already defined\");var n=e.performance,i=n\u0026\u0026n.timing\u0026\u0026n.timing.navigationStart||Ya.startPageLoad||+new Date,s=e.requestAnimationFrame,r=function(){},a=Ya.Rum={_defTimes:[],_defRes:[],_countersToExposeAsEvents:[\"2325\",\"2616.85.1928\",\"react.inited\"],enabled:!!n,version:\"6.1.21\",vsStart:document.visibilityState,vsChanged:!1,vsChangeTime:1/0,_deltaMarks:{},_markListeners:{},_onComplete:[],_onInit:[],_unsubscribers:[],_eventLisneters:{},_settings:{},_vars:{},init:function(e,t){a._settings=e,a._vars=t},getTime:n\u0026\u0026n.now?function(){return n.now()}:Date.now?function(){return Date.now()-i}:function(){return new Date-i},time:function(e){a._deltaMarks[e]=[a.getTime()]},timeEnd:function(e,t){var n=a._deltaMarks[e];n\u0026\u00260!==n.length\u0026\u0026n.push(a.getTime(),t)},sendTimeMark:function(e,t,n,i){void 0===t\u0026\u0026(t=a.getTime()),a.emit({metricName:\"defTimes\",data:[e,t,i]}),a.mark(e,t)},sendDelta:function(e,t,n,i){var s,r=a._deltaMarks;r[e]||void 0===t||(s=i\u0026\u0026i.originalEndTime?i.originalEndTime:a.getTime(),r[e]=[s-t,s,n])},sendResTiming:function(e,t){a.emit({metricName:\"defRes\",data:[e,t]})},sendRaf:function(e){var t=a.getSetting(\"forcePaintTimeSending\");if(s\u0026\u0026(t||a.isTimeAfterPageShow(a.getTime()))){var n=\"2616.\"+e;s((function(){a.getSetting(\"sendFirstRaf\")\u0026\u0026a.sendTimeMark(n+\".205\"),s((function(){a.sendTimeMark(n+\".1928\")}))}))}},isVisibilityChanged:function(){return a.vsStart\u0026\u0026(\"visible\"!==a.vsStart||a.vsChanged)},isTimeAfterPageShow:function(e){return\"visible\"===a.vsStart||a.vsChangeTime\u003ce},mark:n\u0026\u0026n.mark?function(e,t){n.mark(e+(t?\": \"+t:\"\"))}:function(){},getSetting:function(e){var t=a._settings[e];return null===t?null:t||\"\"},on:function(e,t){if(\"function\"==typeof t)return(a._markListeners[e]=a._markListeners[e]||[]).push(t),function(){if(a._markListeners[e]){var n=a._markListeners[e].indexOf(t);n\u003e-1\u0026\u0026a._markListeners[e].splice(n,1)}}},noop:r,sendTrafficData:r,finalizeLayoutShiftScore:r,finalizeLargestContentfulPaint:r,getLCPAdditionalParams:r,getCLSAdditionalParams:r,getINPAdditionalParams:r,getImageGoodnessAdditionalParams:r,_eventListeners:{},_eventsBuffer:{},subscribe:function(e,t){if(!a.getSetting(\"noEvents\"))return this._eventLisneters[e]=this._eventLisneters[e]||new Set,this._eventLisneters[e].add(t),function(){this.unsubscribe(e,t)}.bind(this)},unsubscribe:function(e,t){this._eventLisneters[e].delete(t)},emit:function(e){if(!a.getSetting(\"noEvents\")){var t=a.getSetting(\"eventsLimits\")\u0026\u0026a.getSetting(\"eventsLimits\")[e.metricName]||20;this._eventLisneters[e.metricName]\u0026\u0026this._eventLisneters[e.metricName].forEach((function(t){t(e)})),this._eventsBuffer[e.metricName]=this._eventsBuffer[e.metricName]||[],this._eventsBuffer[e.metricName].push(e),this._eventsBuffer[e.metricName].length\u003et\u0026\u0026(this._eventsBuffer[e.metricName].length=Math.floor(t/2))}},getBufferedEvents:function(e){var t=this._eventsBuffer,n={};return Object.keys(t).forEach((function(i){-1!==e.indexOf(i)\u0026\u0026(n[i]=t[i])})),n},clearEvents:function(e){this._eventsBuffer[e]\u0026\u0026(this._eventsBuffer[e].length=0)}};function f(){Ya.Rum.vsChanged=!0,Ya.Rum.vsChangeTime=a.getTime(),removeEventListener(\"visibilitychange\",f)}addEventListener(\"visibilitychange\",f),a._onVisibilityChange=f}(window);\n!function(){if(window.PerformanceLongTaskTiming){var e=function(e,n){return(e=e.concat(n)).length\u003e300\u0026\u0026(e=e.slice(e.length-300)),e},n=\"undefined\"!=typeof PerformanceLongAnimationFrameTiming,t=n?[\"longtask\",\"long-animation-frame\"]:[\"longtask\"];function r(){var r=Ya.Rum._tti={events:[],loafEvents:n?[]:void 0,eventsAfterTTI:[],fired:!1,observer:new PerformanceObserver((function(t){var o=t.getEntriesByType(\"longtask\"),s=t.getEntriesByType(\"long-animation-frame\");r.events=e(r.events,o),n\u0026\u0026(r.loafEvents=e(r.loafEvents,s)),r.fired\u0026\u0026(r.eventsAfterTTI=e(r.eventsAfterTTI,o))}))};r.observer.observe({entryTypes:t}),Ya.Rum._unsubscribers\u0026\u0026Ya.Rum._unsubscribers.push((function(){r.observer.disconnect()}))}r(),Ya.Rum._onInit.push(r)}}();\nYa.Rum.observeDOMNode=window.IntersectionObserver?function(e,i,n){var t=this,o=Ya.Rum.getSetting(\"forcePaintTimeSending\");!function r(){if(o||!t.isVisibilityChanged()){var s=\"string\"==typeof i?document.querySelector(i):i;s?new IntersectionObserver((function(i,n){!o\u0026\u0026t.isVisibilityChanged()||(Ya.Rum.sendTimeMark(e),n.unobserve(s))}),n).observe(s):setTimeout(r,100)}}()}:function(){};\nvar rum_platform = window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop';\n    var rum_segment = window.location.pathname.replace(/^\\//, \"\").replace(/\\/.*/);\n    \n    if ([\"knowledge\", \"journal\", \"profile\", \"handbook\"].indexOf(rum_segment) === -1) {\n      rum_segment = \"portal\";\n    }\n\n    Ya.Rum.init({ beacon: true, clck: 'https://yandex.ru/clck/click', reqid: '1768063975593584-1199238271730949658'},\n    {\n        rum_id: 'ru.education.' + rum_platform + '.' + rum_segment,\n        '-env': 'production',\n        '-project': 'education-web',\n        '-page': window.location.pathname,\n        '-version': 'undefined',\n        '-platform': rum_platform\n    });Ya.Rum.observeDOMNode('2876', 'body');!function(){var e,t,n,i=Ya.Rum,o=42,r=4e4,g=15,a=[],s=\"\\r\\n\",l=i.getSetting(\"countersInitialDelay\")||0;if(l){var c;function u(){removeEventListener(\"visibilitychange\",h),clearTimeout(c),l=0,f()}function h(){document.hidden\u0026\u0026u()}c=setTimeout(u,l),addEventListener(\"visibilitychange\",h)}function f(){if(t\u0026\u0026a.length){for(var n=0,i=0,l=0;i\u003ca.length\u0026\u0026l\u003c=r\u0026\u0026n\u003co;i++)(l+=(i?s.length:0)+a[i].length)\u003c=r\u0026\u0026n++;var c=a.splice(0,n);d(t,c.join(s)),a.length\u0026\u0026(e=setTimeout(f,g))}else a.length=0}function d(e,t){if(!(navigator.sendBeacon\u0026\u0026n\u0026\u0026navigator.sendBeacon(e,t))){var o=Boolean(i.getSetting(\"sendCookie\")),r=new XMLHttpRequest;r.open(\"POST\",e),r.withCredentials=o,r.send(t)}}i.send=function(c,u,h,d,v,m,S,p){t=i.getSetting(\"clck\"),n=i.getSetting(\"beacon\"),o=i.getSetting(\"maxBatchCounters\")||o,r=i.getSetting(\"maxBatchLength\")||r,g=i.getSetting(\"countersBatchTimeout\")||g,function(t,n,i,c,u,h,d,v,m,S){clearTimeout(e);var p=[t?\"/reqid=\"+t:\"\",n?\"/\"+n.join(\"/\"):\"\",i?\"/path=\"+i:\"\",c?\"/events=\"+c:\"\",u?\"/slots=\"+u.join(\";\"):\"\",h?\"/experiments=\"+h.join(\";\"):\"\",d?\"/vars=\"+d:\"\",\"/cts=\"+(new Date).getTime(),\"\",\"/*\"].join(\"\");p.length\u003er?\"undefined\"!=typeof console\u0026\u0026console.error\u0026\u0026console.error(\"Counter length \"+p.length+\" is more than allowed \"+r,p):(a.push(p),l||(function(){if(a.length\u003e=o)return!0;for(var e=0,t=0;t\u003ca.length;t++)if((e+=(t?s.length:0)+a[t].length)\u003e=r)return!0;return!1}()?f():e=setTimeout(f,g)))}(i.getSetting(\"reqid\"),S,u,v,i.getSetting(\"slots\"),i.getSetting(\"experiments\"),h)}}();\n!function(){var e=Ya.Rum,n=!window.BigInt||!(\"PerformanceObserver\"in window);function t(n){e._unsubscribers.push(n)}function i(e,i,o){if(!n){var a=o||{};if(e){a.type=e,a.hasOwnProperty(\"buffered\")||(a.buffered=!0);var s=new PerformanceObserver((function(e,n){return i(e.getEntries(),n)}));return r((function(){try{s.observe(a)}catch(e){return void console.error(e.message)}t((function(){s.disconnect()}))}),0),s}throw new Error(\"PO without type field is forbidden\")}}function r(e,n){var i=setTimeout(e,n);return t((function(){clearInterval(i)})),i}function o(e,n,i){addEventListener(e,n,i),t((function(){removeEventListener(e,n,i)}))}function a(e,n,t){o(\"visibilitychange\",(function i(){if(\"hidden\"===document.visibilityState){try{t||(removeEventListener(\"visibilitychange\",i),e.disconnect())}catch(e){}n()}})),o(\"beforeunload\",n)}function s(e,n){return\"string\"==typeof e?encodeURIComponent(e):Math.round(1e3*(e-(n||0)))/1e3}function u(e){if(!e)return\"\";var n=(e.tagName||\"\").toLowerCase(),t=e.className\u0026\u0026void 0!==e.className.baseVal?e.className.baseVal:e.className;return n+(t?(\" \"+t).replace(/\\s+/g,\".\"):\"\")}function c(e){function n(){removeEventListener(\"DOMContentLoaded\",n),removeEventListener(\"load\",n),e()}\"loading\"===document.readyState?(o(\"DOMContentLoaded\",n),o(\"load\",n)):e()}function d(n){e._onComplete.push(n)}function f(){return e._periodicTasks}function l(){var n=e._vars;return Object.keys(n).map((function(e){return e+\"=\"+encodeURIComponent(n[e]).replace(/\\*/g,\"%2A\")}))}var m={connectEnd:2116,connectStart:2114,decodedBodySize:2886,domComplete:2124,domContentLoadedEventEnd:2131,domContentLoadedEventStart:2123,domInteractive:2770,domLoading:2769,domainLookupEnd:2113,domainLookupStart:2112,duration:2136,encodedBodySize:2887,entryType:2888,fetchStart:2111,initiatorType:2889,loadEventEnd:2126,loadEventStart:2125,nextHopProtocol:2890,redirectCount:1385,redirectEnd:2110,redirectStart:2109,requestStart:2117,responseEnd:2120,responseStart:2119,secureConnectionStart:2115,startTime:2322,transferSize:2323,type:76,unloadEventEnd:2128,unloadEventStart:2127,workerStart:2137},v=625;function g(n,t){Object.keys(m).forEach((function(e){if(e in t){var i=t[e];(i||0===i)\u0026\u0026n.push(m[e]+\"=\"+s(i))}})),n.push(\"\".concat(v,\"=\").concat(e.version))}var p,h,y,S,T,b=\"690.2096.2877\",w=\"690.2096.207\",E=\"690.2096.2044\",C=3,k=e.getSetting(\"savedDeltasLimit\")||0,L=document.createElement(\"link\"),P=window.performance||{},M=\"function\"==typeof P.getEntriesByType,_=0;function O(n,t,i,r,o){void 0===t\u0026\u0026(t=e.getTime()),void 0!==i\u0026\u0026!0!==i||e.mark(n,t);var a=I(n);if(a.push(\"207=\"+s(t)),x(a,r)){j(w,a,o\u0026\u0026o.force),p[n]=p[n]||[],p[n].push(t);var u=e._markListeners[n];u\u0026\u0026u.length\u0026\u0026u.forEach((function(e){e(t)})),e.emit({metricName:n,value:t,params:r})}}function I(n){return T.concat([e.isVisibilityChanged()?\"-vsChanged=1\":\"\",\"1701=\"+n,e.ajaxStart\u0026\u0026\"1201.2154=\"+s(e.ajaxStart),e.ajaxComplete\u0026\u0026\"1201.2052=\"+s(e.ajaxComplete)])}function N(){S=l(),e.getSetting(\"sendClientUa\")\u0026\u0026S.push(\"1042=\"+encodeURIComponent(navigator.userAgent))}function R(){var e=window.performance\u0026\u0026window.performance.timing\u0026\u0026window.performance.timing.navigationStart;T=S.concat([\"143.2129=\"+e])}function x(e,n){if(n){if(n.isCanceled\u0026\u0026n.isCanceled())return!1;var t=e.reduce((function(e,n,t){return\"string\"==typeof n\u0026\u0026(e[n.split(\"=\")[0]]=t),e}),{});Object.keys(n).forEach((function(i){if(\"function\"!=typeof n[i]){var r=t[i],o=i+\"=\"+n[i];void 0===r?e.push(o):e[r]=o}}))}return!0}function j(n,t,i){var r=encodeURIComponent(window.YaStaticRegion||\"unknown\");t.push(\"-cdn=\"+r);var o=t.filter(Boolean).join(\",\");e.send(null,n,o,void 0,void 0,void 0,void 0,i)}function z(e,n,t){j(e,F().concat(n),t)}function B(n,t){var i=y[n];i\u0026\u00260!==i.length\u0026\u0026(i.push(e.getTime(),t),A(n))}function A(n,t,i,r){var o,a,u,c=y[n];if(void 0!==t?o=(a=r\u0026\u0026r.originalEndTime?r.originalEndTime:e.getTime())-t:c\u0026\u0026(o=c[0],a=c[1],u=c[2]),void 0!==o\u0026\u0026void 0!==a){var d=I(n);d.push(\"207.2154=\"+s(o),\"207.1428=\"+s(a),\"2877=\"+s(a-o)),x(d,i)\u0026\u0026x(d,u)\u0026\u0026(j(b,d,r\u0026\u0026r.force),_\u003ck\u0026\u0026(h[n]=h[n]||[],h[n].push(a-o),_++),e.emit({metricName:n,value:a-o,params:{start:o,end:a}}),delete y[n])}}function V(e,n){if(!M)return n(null);L.href=e;var t=0,i=100,o=L.href;r((function e(){var a=P.getEntriesByName(o);if(a.length)return n(a);t++\u003cC?(r(e,i),i+=i):n(null)}),0)}function U(e,n,t){V(n,(function(i){i\u0026\u0026D(e,i[i.length-1],n,t)}))}function D(n,t,i,r){var o=I(n);e.getSetting(\"sendUrlInResTiming\")\u0026\u0026o.push(\"13=\"+encodeURIComponent(i)),g(o,t),x(o,r),j(E,o)}function F(){return S}var W={bluetooth:2064,cellular:2065,ethernet:2066,none:1229,wifi:2067,wimax:2068,other:861,unknown:836,0:836,1:2066,2:2067,3:2070,4:2071,5:2768},H=navigator.connection;function Q(e){if(H){var n=W[H.type];e.push(\"2437=\"+(n||2771),void 0!==H.downlinkMax\u0026\u0026\"2439=\"+H.downlinkMax,H.effectiveType\u0026\u0026\"2870=\"+H.effectiveType,void 0!==H.rtt\u0026\u0026\"rtt=\"+H.rtt,void 0!==H.downlink\u0026\u0026\"dwl=\"+H.downlink,!n\u0026\u0026\"rawType=\"+H.type)}}var Y,q,G,J,$,K,X,Z,ee=\"690.2096.4004\",ne=!1,te=1/0,ie=1/0,re=(\"layout-shift\",Boolean(window.PerformanceObserver\u0026\u0026window.PerformanceObserver.supportedEntryTypes\u0026\u0026-1!==window.PerformanceObserver.supportedEntryTypes.indexOf(\"layout-shift\"))?0:null);function oe(){$\u003eq\u0026\u0026(q=$,G=J,e.emit({metricName:\"cls-debug\",value:q,params:{clsEntries:G,target:ae(G)}}))}function ae(e){var n;if(!e)return null;var t=null;if((n=e.reduce((function(e,n){return e\u0026\u0026e.value\u003en.value?e:n})))\u0026\u0026n.sources\u0026\u0026n.sources.length){for(var i=0;i\u003cn.sources.length;i++){var r=n.sources[i];if(r.node\u0026\u00261===r.node.nodeType){t=r;break}}t=t||n.sources[0]}return t}function se(e){null==q\u0026\u0026(q=0);for(var n=0;n\u003ce.length;n++){var t=e[n];t.hadRecentInput||($\u0026\u0026t.startTime-J[J.length-1].startTime\u003cte\u0026\u0026t.startTime-J[0].startTime\u003cie?($+=t.value,J.push(t)):(oe(),$=t.value,J=[t]))}oe()}function ue(){q=re,Y=void 0,G=null,J=null,$=null,ne=!1}function ce(n){if(null!=q\u0026\u0026!ne){var t=Math.round(1e6*q)/1e6;if(Y!==t){Y=t,e.getSetting(\"enableContinuousCollection\")||(ne=!0);var i=ae(G),r=[\"s=\"+t];r.push(\"target=\"+u(i\u0026\u0026i.node));var o=e.getCLSAdditionalParams(i);o\u0026\u0026x(r,o),z(ee,r,n),e.emit({metricName:\"cls-debug\",value:q,params:{clsEntries:J,target:i,isFinalized:ne}})}}}function de(n){var t=n[n.length-1];K=t.renderTime||t.loadTime,X=t,e.emit({metricName:\"largest-contentful-paint-debug\",value:K,params:{entry:t}}),Z||(O(\"largest-loading-elem-paint\",K),Z=!0)}function fe(n){if(null!=K){var t=e.getLCPAdditionalParams(X);O(\"largest-contentful-paint\",K,!1,t,n\u0026\u0026{force:!0}),e.emit({metricName:\"largest-contentful-paint-debug\",value:K,params:{additionalParams:t,entry:X,isFinalized:!0}}),K=null,X=null}}e.getLCPAdditionalParams===e.noop\u0026\u0026(e.getLCPAdditionalParams=function(){var n={},t=X.element;if(t){n[\"-className\"]=e.getSelector(t),n[\"-tagName\"]=t.tagName.toLowerCase();var i=t.getBoundingClientRect();n[\"-width\"]=i.width,n[\"-height\"]=i.height}return X.size\u0026\u0026(n[\"-size\"]=X.size),n});var le={\"first-paint\":2793,\"first-contentful-paint\":2794},me=Object.keys(le).length,ve={},ge=window.performance||{},pe=\"function\"==typeof ge.getEntriesByType,he=0;function ye(){if(pe\u0026\u0026(e.getSetting(\"forcePaintTimeSending\")||!e.isVisibilityChanged()))for(var n=ge.getEntriesByType(\"paint\"),t=0;t\u003cn.length;t++){var i=n[t],r=le[i.name];r\u0026\u0026!ve[i.name]\u0026\u0026(ve[i.name]=!0,he++,O(\"1926.\"+r,i.startTime))}}var Se=3e3,Te=1;function be(){return e._tti.events||[]}function we(){return e._tti.loafEvents}function Ee(){return e._tti}function Ce(n){return n?n===e.getPageUrl()?\"\u003cpage\u003e\":n.replace(/\\?.*$/,\"\"):n}function ke(n,t,i){if(Ee()){var r=e.getTime(),o=\"undefined\"!=typeof PerformanceLongAnimationFrameTiming\u0026\u0026e.getSetting(\"sendLongAnimationFrames\");Le((function(a){var u,c={2796.2797:Pe(be(),t),689.2322:s(r)};if(o){var d=function(e){var n=we();if(n)return e?n.filter((function(n){return n.startTime+n.duration\u003e=e})):n}(t);d\u0026\u0026(c[\"loaf.2797\"]=Pe(d,void 0,{useName:!1}),1===e.getSetting(\"longAnimationFramesMode\")\u0026\u0026(c[\"-additional\"]=encodeURIComponent(JSON.stringify({loaf:(u=d,u.map(Me))}))))}i\u0026\u0026Object.keys(i).forEach((function(e){c[e]=i[e]})),O(n||\"2795\",a,!0,c,{force:Boolean(o)}),e._tti.fired=!0}),t)}}function Le(n,t){var i=(arguments.length\u003e2\u0026\u0026void 0!==arguments[2]?arguments[2]:{}).mode,o=void 0===i?Te:i;Ee()\u0026\u0026(t||(t=e.getTime()),function i(){var a,s=t,u=e.getTime(),c=o===Te?be():we()||[],d=c.length;0!==d\u0026\u0026(a=c[d-1],s=Math.max(s,Math.floor(a.startTime+a.duration))),u-s\u003e=Se?n(s):r(i,1e3)}())}function Pe(e,n){var t=(arguments.length\u003e2\u0026\u0026void 0!==arguments[2]?arguments[2]:{}).useName,i=void 0===t||t;return n=n||0,(e=e||[]).filter((function(e){return n-e.startTime\u003c=50})).map((function(e){var n=Math.floor(e.startTime),t=Math.floor(n+e.duration);return i?(e.name?e.name.split(\"-\").map((function(e){return e[0]})).join(\"\"):\"u\")+\"-\"+n+\"-\"+t:n+\"-\"+t})).join(\".\")}function Me(e){var n=e.blockingDuration,t=e.duration,i=e.firstUIEventTimestamp,r=e.renderStart,o=e.scripts,a=e.startTime,s=e.styleAndLayoutStart;return[Math.round(a),Math.round(t),o.map(Oe),Math.round(n),Math.round(i),Math.round(r),Math.round(s)]}function _e(e){return{\"user-callback\":1,\"event-listener\":2,\"resolve-promise\":3,\"reject-promise\":4,\"classic-script\":5,\"module-script\":6}[e]||0}function Oe(e){var n=e.invoker,t=e.sourceURL,i=e.sourceFunctionName,r=e.sourceCharPosition,o=e.startTime,a=e.duration,s=e.windowAttribution,u=e.executionStart,c=e.forcedStyleAndLayoutDuration,d=e.pauseDuration,f=e.invokerType;return[Ce(n),Ce(t),i,r,Math.round(o),Math.round(a),s,Math.round(u),Math.round(c),Math.round(d),_e(f)]}var Ie=\"690.2096.361\",Ne=document.createElement(\"a\"),Re=0,xe={};function je(e){var n=e.transferSize;if(null!=n){Ne.href=e.name;var t=Ne.pathname;if(0!==t.indexOf(\"/clck\")){var i=t.lastIndexOf(\".\"),r=\"\";return-1!==i\u0026\u0026t.lastIndexOf(\"/\")\u003ci\u0026\u0026t.length-i\u003c=5\u0026\u0026(r=t.slice(i+1)),{size:n,domain:Ne.hostname,extension:r}}}}function ze(){var n=e.getSetting(\"maxTrafficCounters\")||250;if(Re\u003e=n)return!1;for(var t=Object.keys(xe),i=\"\",r=0;r\u003ct.length;r++){var o=t[r],a=xe[o];i+=encodeURIComponent(o)+\"!\"+a.count+\"!\"+a.size+\";\"}return i.length\u0026\u0026(Re++,z(Ie,[\"d=\"+i,\"t=\"+s(e.getTime())])),xe={},Re\u003cn}d(ze);var Be=\"690.1033\",Ae={visible:1,hidden:2,prerender:3},Ve=window.performance||{},Ue=Ve.navigation||{},De=Ve.timing||{},Fe=De.navigationStart;function We(){var n=De.domContentLoadedEventStart,t=De.domContentLoadedEventEnd;if(0!==n||0!==t){var i=0===De.responseStart?Fe:De.responseStart,o=0===De.domainLookupStart?Fe:De.domainLookupStart,a=[\"2129=\"+Fe,\"1036=\"+(o-Fe),\"1037=\"+(De.domainLookupEnd-De.domainLookupStart),\"1038=\"+(De.connectEnd-De.connectStart),De.secureConnectionStart\u0026\u0026\"1383=\"+(De.connectEnd-De.secureConnectionStart),\"1039=\"+(De.responseStart-De.connectEnd),\"1040=\"+(De.responseEnd-i),\"1040.906=\"+(De.responseEnd-o),\"1310.2084=\"+(De.domLoading-i),\"1310.2085=\"+(De.domInteractive-i),\"1310.1309=\"+(t-n),\"1310.1007=\"+(n-i),navigator.deviceMemory\u0026\u0026\"3140=\"+navigator.deviceMemory,navigator.hardwareConcurrency\u0026\u0026\"3141=\"+navigator.hardwareConcurrency];Object.keys(m).forEach((function(e){e in De\u0026\u0026De[e]\u0026\u0026a.push(m[e]+\"=\"+s(De[e],Fe))})),e.vsStart?(a.push(\"1484=\"+(Ae[e.vsStart]||2771)),e.vsChanged\u0026\u0026a.push(\"1484.719=1\")):a.push(\"1484=\"+Ae.visible),Ue\u0026\u0026(Ue.redirectCount\u0026\u0026a.push(\"1384.1385=\"+Ue.redirectCount),1!==Ue.type\u0026\u00262!==Ue.type||a.push(\"770.76=\"+Ue.type)),Q(a),z(Be,a)}else r(We,50)}var He=\"690.2096.2892\",Qe=window.performance||{},Ye=\"function\"==typeof Qe.getEntriesByType;if(!e)throw new Error(\"Rum: interface is not included\");if(e.enabled){function qe(){p={},h={},_=0,y=e._deltaMarks,N(),R(),e.ajaxStart=0,e.ajaxComplete=0,c(Je)}function Ge(){var n;e.sendTimeMark=O,e.sendResTiming=U,e.sendTiming=D,e.timeEnd=B;var t=(e.getBufferedEvents([\"defRes\"]).defRes||[]).map((function(e){return e.data}));for(n=0;n\u003ct.length;n++)U(t[n][0],t[n][1]);e.clearEvents(\"defRes\");var i=(e.getBufferedEvents([\"defTimes\"]).defTimes||[]).map((function(e){return e.data}));for(n=0;n\u003ci.length;n++)O(i[n][0],i[n][1],!1,i[n][2]);e.clearEvents(\"defTimes\"),Object.keys(y).forEach((function(e){A(e)}))}function Je(){var n=window.performance\u0026\u0026window.performance.timing\u0026\u0026window.performance.timing.navigationStart,t=e.getSetting(\"skipTiming\"),a=e.getSetting(\"techParamsByVisible\");n\u0026\u0026(a\u0026\u0026addEventListener(\"visibilitychange\",(function n(){\"visible\"!==e.vsStart?\"visible\"===document.visibilityState\u0026\u0026(e.vsStart=\"visible\",removeEventListener(\"visibilitychange\",n),We()):removeEventListener(\"visibilitychange\",n)})),r((function(){Ge(),(!t\u0026\u0026!a||a\u0026\u0026\"visible\"===e.vsStart)\u0026\u0026We(),e.getSetting(\"disableFCP\")||(ye(),he\u003cme\u0026\u0026i(\"paint\",(function(e,n){ye(),n\u0026\u0026he\u003e=me\u0026\u0026n.disconnect()}),{buffered:!0})),e.getSetting(\"sendAutoElementTiming\")\u0026\u0026(!window.PerformanceObserver||!e.getSetting(\"forcePaintTimeSending\")\u0026\u0026e.isVisibilityChanged()||i(\"element\",(function(e){for(var n=0;n\u003ce.length;n++){var t=e[n];O(\"element-timing.\"+t.identifier,t.startTime)}}))),o(\"pageshow\",Xe),ke(),\"complete\"===document.readyState?$e({skipTimingApi:t}):o(\"load\",$e.bind(void 0,{skipTimingApi:t}))}),0))}function $e(n){var r,s;e.getSetting(\"disableOnLoadTasks\")||(removeEventListener(\"load\",$e),n.skipTimingApi||function(){if(Ye){var e=Qe.getEntriesByType(\"navigation\")[0];if(e){var n=[];g(n,e),Q(n);var t=Qe.getEntriesByName(\"yndxNavigationSource\")[0];t\u0026\u0026n.push(\"2091.186=\"+t.value);var i=Qe.getEntriesByName(\"yndxNavigationToken\",\"yndxEntry\")[0];i\u0026\u0026n.push(\"2091.3649=\"+i.value),z(He,n)}}}(),(s=e.getSetting(\"periodicStatsIntervalMs\"))||null===s||(s=15e3),s\u0026\u0026(r=setInterval(Ze,s),t((function(){clearInterval(r)})),Ke=r),o(\"beforeunload\",Ze),function(){if(window.PerformanceObserver){xe={},Re=0;var e=function(e){!function(e){if(e\u0026\u0026e.length)for(var n=xe,t=0;t\u003ce.length;t++){var i=je(e[t]);if(i){var r=i.domain+\"-\"+i.extension,o=n[r]=n[r]||{count:0,size:0};o.count++,o.size+=i.size}}}(e)};i(\"resource\",e),i(\"navigation\",e),f().push(ze)}}(),e.getSetting(\"disableFID\")||i(\"first-input\",(function(n,t){var i=n[0];if(i){var r=i.processingStart,o={duration:i.duration,js:i.processingEnd-r,name:i.name};i.target\u0026\u0026(o.target=u(i.target));var a=r-i.startTime;A(\"first-input\",a,o),e.emit({metricName:\"first-input-debug\",value:a,params:{entry:i,additionalParams:o}}),t.disconnect()}}),{buffered:!0}),e.getSetting(\"disableCLS\")||window.PerformanceObserver\u0026\u0026(d(ce),d(ue),q=re,G=null,J=null,$=null,te=e.getSetting(\"clsWindowGap\")||te,ie=e.getSetting(\"clsWindowSize\")||ie,a(i(\"layout-shift\",se),(function(){return ce(!0)}),!0)),e.getSetting(\"disableLCP\")||!window.PerformanceObserver||!e.getSetting(\"forcePaintTimeSending\")\u0026\u0026e.isVisibilityChanged()||(d(fe),K=null,X=null,Z=!1,a(i(\"largest-contentful-paint\",de),(function(){return fe(!0)}),!1)))}var Ke;function Xe(e){e.persisted\u0026\u0026O(\"bfcache\")}function Ze(){var e=!1;f().forEach((function(n){n()\u0026\u0026(e=!0)})),e||clearInterval(Ke)}d(Ge),e.destroy=function(n){var t=e._unsubscribers;n.shouldComplete\u0026\u0026e.completeSession(!0),e._onComplete=[];for(var i=0;i\u003ct.length;i++)t[i]();removeEventListener(\"visibilitychange\",e._onVisibilityChange),e._unsubscribers=[],e._periodicTasks=[],e._markListeners={},e._deltaMarks={}},e.restart=function(n,t,i){e.destroy({shouldComplete:i}),e.init(n,t),addEventListener(\"visibilitychange\",e._onVisibilityChange),qe(),function(){for(var n=0;n\u003ce._onInit.length;n++)e._onInit[n]()}()},e.setVars=function(n){Object.keys(n).forEach((function(t){e._vars[t]=n[t]})),N(),R()},e.completeSession=function(n){for(var t=e._onComplete,i=0;i\u003ct.length;i++)t[i](n)},qe(),e._periodicTasks=[],e.sendHeroElement=function(e){O(\"2876\",e)},e.getPageUrl=function(){return window.location.href},e._subpages={},e.makeSubPage=function(n,t){var i=e._subpages[n];e._subpages[n]=void 0===i?i=0:++i;var r=!1;return{689.2322:s(void 0!==t?t:e.getTime()),2924:n,2925:i,isCanceled:function(){return r},cancel:function(){r=!0}}},e.getTimeMarks=function(){return p},e.getDeltas=function(){return h},e.getVarsList=l,e.getResourceTimings=V,e.pushConnectionTypeTo=Q,e.pushTimingTo=g,e.normalize=s,e.sendCounter=j,e.sendDelta=A,e.onReady=c,e.getSelector=u,e.getSetting(\"disableCLS\")||(e.finalizeLayoutShiftScore=ce),e.getSetting(\"disableLCP\")||(e.finalizeLargestContentfulPaint=fe),e.sendTrafficData=ze,e._getCommonVars=F,e._addListener=o,e._observe=i,e._timeout=r,e.sendTTI=ke,e._getLongtasksStringValue=Pe,e.onQuietWindow=Le,e.sendBFCacheTimeMark=Xe}else e.getSetting=function(){return\"\"},e.getVarsList=function(){return[]},e.getResourceTimings=e.completeSession=e.pushConnectionTypeTo=e.pushTimingTo=e.normalize=e.sendCounter=e.destroy=e.restart=e.setVars=e.completeSession=e.sendDelta=e.sendTimeMark=e.sendResTiming=e.sendTiming=e.sendTTI=e.makeSubPage=e.sendHeroElement=e.onReady=e.onQuietWindow=function(){}}();\n!function(n){if(!n.Ya||!Ya.Rum)throw new Error(\"Rum: interface is not defined\");var e=Ya.Rum;e.getSetting=function(n){var t=e._settings[n];return null===t?null:t||\"\"}}(\"undefined\"!=typeof self?self:window);\n!function(e,r){var n={client:[\"690.2354\",1e3,100,0],uncaught:[\"690.2361\",100,10,0],external:[\"690.2854\",100,10,0],script:[\"690.2609\",100,10,0]},t={};r.ERROR_LEVEL={INFO:\"info\",DEBUG:\"debug\",WARN:\"warn\",ERROR:\"error\",FATAL:\"fatal\"},r._errorSettings={clck:\"https://yandex.ru/clck/click\",beacon:!0,project:\"unknown\",page:\"\",env:\"\",experiments:[],additional:{},platform:\"\",region:\"\",dc:\"\",host:\"\",service:\"\",level:\"\",version:\"\",yandexuid:\"\",loggedin:!1,coordinates_gp:\"\",referrer:!0,preventError:!1,unhandledRejection:!1,traceUnhandledRejection:!1,uncaughtException:!0,debug:!1,limits:{},silent:{},filters:{},pageMaxAge:864e6,initTimestamp:+new Date};var o=!1;function a(e,r){for(var n in r)r.hasOwnProperty(n)\u0026\u0026(e[n]=r[n]);return e}function i(e){return\"boolean\"==typeof e\u0026\u0026(e=+e),\"number\"==typeof e?e+\"\":null}r.initErrors=function(n){var t=a(r._errorSettings,n);o||(t.uncaughtException\u0026\u0026function(){var n=r._errorSettings;if(e.addEventListener)e.addEventListener(\"error\",s),n.resourceFails\u0026\u0026e.addEventListener(\"error\",l,!0),\"Promise\"in e\u0026\u0026n.unhandledRejection\u0026\u0026e.addEventListener(\"unhandledrejection\",function(e){var n,t,o=e.reason,a={};o\u0026\u0026(o.stack\u0026\u0026o.message?(n=o.message,t=o.stack):(n=String(o),t=r._parseTraceablePromiseStack(e.promise),\"[object Event]\"===n?n=\"event.type: \"+o.type:\"[object Object]\"===n\u0026\u0026(a.unhandledObject=o)),o.target\u0026\u0026o.target.src\u0026\u0026(a.src=o.target.src),s({message:\"Unhandled rejection: \"+n,stack:t,additional:a}))});else{var t=e.onerror;e.onerror=function(e,r,n,o,a){s({error:a||new Error(e||\"Empty error\"),message:e,lineno:n,colno:o,filename:r}),t\u0026\u0026t.apply(this,arguments)}}}(),t.unhandledRejection\u0026\u0026t.traceUnhandledRejection\u0026\u0026r._traceUnhandledRejection\u0026\u0026r._traceUnhandledRejection(),o=!0)},r.updateErrors=function(e){a(r._errorSettings,e)},r.updateAdditional=function(e){r._errorSettings.additional=a(r._errorSettings.additional||{},e)},r._handleError=function(e,o,i){var s,l,c=r._errorSettings;if(c.preventError\u0026\u0026e.preventDefault\u0026\u0026e.preventDefault(),o)s=e,l=\"client\";else{s=r._normalizeError(e),l=s.type;var d=c.onError;\"function\"==typeof d\u0026\u0026d(s);var u=c.transform;if(\"function\"==typeof u\u0026\u0026(s=u(s)),!s)return;s.settings\u0026\u0026(i=s.settings)}var g=+new Date,f=c.initTimestamp,p=c.pageMaxAge;if(!(-1!==p\u0026\u0026f\u0026\u0026f+p\u003cg)){var m=n[l][1];\"number\"==typeof c.limits[l]\u0026\u0026(m=c.limits[l]);var v=n[l][2];\"number\"==typeof c.silent[l]\u0026\u0026(v=c.silent[l]);var h=n[l][3];if(h\u003cm||-1===m){s.path=n[l][0];var E=r._getErrorData(s,{silent:h\u003cv||-1===v?\"no\":\"yes\",isCustom:Boolean(o)},a(a({},c),i)),_=function(e){t[s.message]=!1,r._sendError(e.path,e.vars),n[l][3]++}.bind(this,E);if(void 0===c.throttleSend)_();else{if(t[s.message])return;t[s.message]=!0,setTimeout(_,c.throttleSend)}}}},r._getReferrer=function(r){var n=r.referrer,t=typeof n;return\"function\"===t?n():\"string\"===t\u0026\u0026n?n:!1!==n\u0026\u0026e.location?e.location.href:void 0},r.getErrorSetting=function(e){return r._errorSettings[e]},r._buildExperiments=function(e){return e instanceof Array?e.join(\";\"):\"\"},r._buildAdditional=function(e,r){var n=\"\";try{var t=a(a({},e),r);0!==Object.keys(t).length\u0026\u0026(n=JSON.stringify(t))}catch(e){}return n},r._getErrorData=function(n,t,o){t=t||{};var a=r._buildExperiments(o.experiments),s=r._buildAdditional(o.additional,n.additional),l={\"-stack\":n.stack,\"-url\":n.file,\"-line\":n.line,\"-col\":n.col,\"-block\":n.block,\"-method\":n.method,\"-msg\":n.message,\"-env\":o.env,\"-external\":n.external,\"-externalCustom\":n.externalCustom,\"-project\":o.project,\"-service\":n.service||o.service,\"-page\":n.page||o.page,\"-platform\":o.platform,\"-level\":n.level,\"-experiments\":a,\"-version\":o.version,\"-region\":o.region,\"-dc\":o.dc,\"-host\":o.host,\"-yandexuid\":o.yandexuid,\"-loggedin\":o.loggedin,\"-coordinates_gp\":n.coordinates_gp||o.coordinates_gp,\"-referrer\":r._getReferrer(o),\"-source\":n.source,\"-sourceMethod\":n.sourceMethod,\"-type\":t.isCustom?n.type:\"\",\"-additional\":s,\"-adb\":i(Ya.blocker)||i(o.blocker),\"-cdn\":e.YaStaticRegion,\"-ua\":navigator.userAgent,\"-silent\":t.silent,\"-ts\":+new Date,\"-init-ts\":o.initTimestamp};return o.debug\u0026\u0026e.console\u0026\u0026console[console[n.level]?n.level:\"error\"](\"[error-counter] \"+n.message,l,n.stack),{path:n.path,vars:l}},r._baseNormalizeError=function(e){var r=(e=e||{}).error,n=e.filename||e.fileName||\"\",t=r\u0026\u0026r.stack||e.stack||\"\",o=e.message||\"\",a=r\u0026\u0026r.additional||e.additional;return{file:n,line:e.lineno||e.lineNumber,col:e.colno||e.colNumber,stack:t,message:o,additional:a}},r._normalizeError=function(e){var n=r._baseNormalizeError(e),t=\"uncaught\",o=r._isExternalError(n.file,n.message,n.stack),a=\"\",i=\"\";return o.hasExternal?(t=\"external\",a=o.common,i=o.custom):/^Script error\\.?$/.test(n.message)\u0026\u0026(t=\"script\"),n.external=a,n.externalCustom=i,n.type=t,n},r._createVarsString=function(e){var r=[];for(var n in e)e.hasOwnProperty(n)\u0026\u0026(e[n]||0===e[n])\u0026\u0026r.push(n+\"=\"+encodeURIComponent(e[n]).replace(/\\*/g,\"%2A\"));return r.join(\",\")},r._sendError=function(e,n){r.send(null,e,r._createVarsString(n),null,null,null,null)};var s=function(e){r._handleError(e,!1)},l=function(e){var n=e.target;if(n){var t=n.srcset||n.src;if(t||(t=n.href),t){var o=n.tagName||\"UNKNOWN\";r.logError({message:o+\" load error\",additional:{src:t}})}}};r._parseTraceablePromiseStack=function(){}}(\"undefined\"!=typeof self?self:window,Ya.Rum);\n!function(e){var r={url:{0:/(miscellaneous|extension)_bindings/,1:/^chrome:/,2:/kaspersky-labs\\.com\\//,3:/^(?:moz|chrome|safari)-extension:\\/\\//,4:/^file:/,5:/^resource:\\/\\//,6:/webnetc\\.top/,7:/local\\.adguard\\.com/},message:{0:/__adgRemoveDirect/,1:/Content Security Policy/,2:/vid_mate_check/,3:/ucapi/,4:/Access is denied/i,5:/^Uncaught SecurityError/i,6:/__ybro/,7:/__show__deepen/,8:/ntp is not defined/,9:/Cannot set property 'install' of undefined/,10:/NS_ERROR/,11:/Error loading script/,12:/^TypeError: undefined is not a function$/,13:/__firefox__\\.(?:favicons|metadata|reader|searchQueryForField|searchLoginField)/},stack:{0:/(?:moz|chrome|safari)-extension:\\/\\//,1:/adguard.*\\.user\\.js/i}};function n(e,r){if(e\u0026\u0026r){var n=[];for(var o in r)if(r.hasOwnProperty(o)){var i=r[o];\"string\"==typeof i\u0026\u0026(i=new RegExp(i)),i instanceof RegExp\u0026\u0026i.test(e)\u0026\u0026n.push(o)}return n.join(\"_\")}}function o(e,o){var i,a=[];for(var t in r)r.hasOwnProperty(t)\u0026\u0026(i=n(e[t],o[t]))\u0026\u0026a.push(t+\"~\"+i);return a.join(\";\")}e._isExternalError=function(n,i,a){var t=e._errorSettings.filters||{},s={url:(n||\"\")+\"\",message:(i||\"\")+\"\",stack:(a||\"\")+\"\"},c=o(s,r),u=o(s,t);return{common:c,custom:u,hasExternal:!(!c\u0026\u0026!u)}}}(Ya.Rum);\nYa.Rum.initErrors({\n        reqid: '1768063975593584-1199238271730949658',\n        project: 'education-web',\n        env: 'production',\n        page: window.location.pathname,\n        version: 'undefined',\n        platform: window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop'\n    });"])</script><script nonce="">self.__next_f.push([1,"44:[\"$\",\"$L26\",null,{\"id\":\"rum-error\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"strategy\":\"beforeInteractive\",\"dangerouslySetInnerHTML\":{\"__html\":\"$4c\"}}]\n"])</script><script nonce="">self.__next_f.push([1,"20:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Задача «Количество призов» - Основы алгоритмов\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Задача «Количество призов» - Хендбук от Яндекс.Образования. Откройте для себя передовые подходы, практические советы и вдохновляющие идеи от наших экспертов.\"}],[\"$\",\"link\",\"2\",{\"rel\":\"manifest\",\"href\":\"/manifest.webmanifest\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"initial-scale=1, width=device-width\"}],[\"$\",\"meta\",\"4\",{\"name\":\"mobile-web-app-capable\",\"content\":\"yes\"}],[\"$\",\"meta\",\"5\",{\"name\":\"BookSlug\",\"content\":\"algorithms\"}],[\"$\",\"link\",\"6\",{\"rel\":\"canonical\",\"href\":\"https://education.yandex.ru/handbook/algorithms/article/zadacha-kolichestvo-prizov\"}],[\"$\",\"meta\",\"7\",{\"name\":\"mobile-web-app-capable\",\"content\":\"yes\"}],[\"$\",\"meta\",\"8\",{\"name\":\"apple-mobile-web-app-title\",\"content\":\"Яндекс Образование\"}],[\"$\",\"link\",\"9\",{\"href\":\"https://yastatic.net/s3/education-portal/pwa/logos/ios/512.png\",\"media\":\"$undefined\",\"rel\":\"apple-touch-startup-image\"}],[\"$\",\"meta\",\"10\",{\"name\":\"apple-mobile-web-app-status-bar-style\",\"content\":\"black-translucent\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:title\",\"content\":\"Задача «Количество призов» - Основы алгоритмов\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:description\",\"content\":\"Задача «Количество призов» - Хендбук от Яндекс.Образования. Откройте для себя передовые подходы, практические советы и вдохновляющие идеи от наших экспертов.\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:url\",\"content\":\"https://education.yandex.ru/handbook/algorithms/article/zadacha-kolichestvo-prizov\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:image\",\"content\":\"https://yastatic.net/s3/education-portal/media/opengraph_handbook_3_605d176072_3304739c31.webp\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:title\",\"content\":\"Задача «Количество призов» - Основы алгоритмов\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:description\",\"content\":\"Задача «Количество призов» - Хендбук от Яндекс.Образования. Откройте для себя передовые подходы, практические советы и вдохновляющие идеи от наших экспертов.\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:image\",\"content\":\"https://yastatic.net/s3/education-portal/media/opengraph_handbook_3_605d176072_3304739c31.webp\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script nonce="">self.__next_f.push([1,"25:\"$20:metadata\"\n4d:T1248,"])</script><script nonce="">self.__next_f.push([1,"\n  function applyUADataPolyfill(){\n    function e(a){let b=/Windows NT (\\d+(\\.\\d+)*)/.exec(a);if(!b)return null;let c={\"6.1\":\"0.1\",\"6.2\":\"0.2\",\"6.3\":\"0.3\",\"10.0\":\"10.0\",\"11.0\":\"13.0\"}[b[1]],d=c?q(c,3):\"\",e=\"\",f=\"\";return/\\b(WOW64|Win64|x64)\\b/.test(a)\u0026\u0026(e=\"x86\",f=\"64\"),{platform:\"Windows\",platformVersion:d,architecture:e,bitness:f}}\n    function f(a,b){let c=/Android (\\d+(\\.\\d+)*)/.exec(a);if(!c)return null;let d=\"\",e=\"\",f=/Linux (\\w+)/.exec(b);if(f\u0026\u0026f[1]){let a=p(f[1]);d=a[0],e=a[1]}return{platform:\"Android\",platformVersion:q(c[1]),architecture:d,bitness:e}}\n    function g(a){let b=/(iPhone|iPod touch); CPU iPhone OS (\\d+(_\\d+)*)/.exec(a),c=/(iPad); CPU OS (\\d+(_\\d+)*)/.exec(a),d=b||c;return d?{platform:\"iOS\",platformVersion:q(d[2].replace(/_/g,\".\"))}:null}\n    function h(a){let b=/Macintosh; (Intel|\\w+) Mac OS X (\\d+([_.]\\d+)*)/.exec(a);return b?{platform:\"macOS\",platformVersion:q(b[2].replace(/_/g,\".\"))}:null}\n    function i(a){let b=/CrOS (\\w+) (\\d+(\\.\\d+)*)/.exec(a);if(!b)return null;let c=p(b[1]);return{platform:\"Chrome OS\",platformVersion:q(b[2]),architecture:c[0],bitness:c[1]}}\n    function j(a,b){for(let c of[()=\u003ee(a),()=\u003ef(a,b),()=\u003eg(a),()=\u003eh(a),()=\u003ei(a)]){let a=c();if(a)return a}return/Linux/.test(a)?{platform:\"Linux\",platformVersion:\"\"}:{platform:\"Unknown\",platformVersion:\"\"}}\n    function k(a,b,c){let d=/Chrome\\/(\\d+(\\.\\d+)*)/.exec(a);if(!d||\"Google Inc.\"!==c)return null;let e=[{brand:\"Chromium\",version:q(d[1],4)}],f=/(Edge?)\\/(\\d+(\\.\\d+)*)/.exec(a);if(f){let a={Edge:\"Microsoft Edge\",Edg:\"Microsoft Edge\"}[f[1]];e.push({brand:a,version:q(f[2],4)})}else e.push({brand:\"Google Chrome\",version:q(d[1],4)});return e}\n    function l(a,b){let c=/AppleWebKit\\/(\\d+(\\.\\d+)*)/.exec(a);return c\u0026\u0026\"Apple Computer, Inc.\"===b?[{brand:\"WebKit\",version:q(c[1])}]:null}\n    function m(a){let b=/Firefox\\/(\\d+(\\.\\d+)*)/.exec(a);return b?[{brand:\"Firefox\",version:q(b[1])}]:null}\n    function n(a,b,c,d,e){let f=!1,g=[];for(let h of[()=\u003ek(a,b,c),()=\u003el(a,c),()=\u003em(a)]){let c=h();if(c){g=c,h===k\u0026\u0026/\\bwv\\b/.test(b)\u0026\u0026(f=!0);let i=/(CriOS|EdgiOS|FxiOS|Version)\\/(\\d+(\\.\\d+)*)/.exec(a);if(h===l\u0026\u0026\"iOS\"===d\u0026\u0026i){let a={CriOS:\"Google Chrome\",EdgiOS:\"Microsoft Edge\",FxiOS:\"Mozilla Firefox\",Version:\"Apple Safari\"}[i[1]];g.push({brand:a,version:q(i[2])}),e\u0026\u0026!e.some(a=\u003ea.startsWith(\"Safari/\"))\u0026\u0026(f=!0)}break}}return 0===g.length\u0026\u0026(g=[{brand:\"Not;A Brand\",version:\"99.0.0.0\"}]),{fullVersionList:g,webview:f}}\n    function o(a){let{userAgent:b,platform:c,vendor:d}=a,e=b,f=!1,g=b.replace(/\\(([^)]+)\\)/g,(a,b)=\u003e(f||(e=b,f=!0),\"\")),h=g.match(/(\\S+)\\/(\\S+)/g),i=b.includes(\"Mobile\"),k=j(e,c),{fullVersionList:l,webview:m}=n(g,e,d,k.platform,h),o=l.length\u003e0?l[l.length-1].version:\"\",p=l.map(a=\u003e{let b=a.version.indexOf(\".\"),c=-1===b?a.version:a.version.slice(0,b);return{brand:a.brand,version:c}});return{mobile:i,platform:k.platform,brands:p,platformVersion:k.platformVersion,architecture:k.architecture||\"\",bitness:k.bitness||\"\",model:\"\",uaFullVersion:o,fullVersionList:l,webview:m}}\n    function p(a){switch(a){case\"x86_64\":case\"x64\":return[\"x86\",\"64\"];case\"x86_32\":case\"x86\":return[\"x86\",\"\"];case\"armv6l\":case\"armv7l\":case\"armv8l\":return[a,\"\"];case\"aarch64\":return[\"arm\",\"64\"];default:return[\"\",\"\"]}}\n    function q(a,b=3){let c=a.split(\".\");if(c.length\u003cb)for(;c.length\u003cb;)c.push(\"0\");return c.join(\".\")}\n    class r{constructor(a){this._clientHints=o(a),Object.defineProperties(this,{_clientHints:{enumerable:!1}})}get mobile(){return this._clientHints.mobile}get platform(){return this._clientHints.platform}get brands(){return this._clientHints.brands}getHighEntropyValues(a){return new Promise(b=\u003e{if(!Array.isArray(a))throw TypeError(\"Argument hints must be an array\");let c=new Set(a),d=this._clientHints,e={mobile:d.mobile,platform:d.platform,brands:d.brands};c.has(\"architecture\")\u0026\u0026(e.architecture=d.architecture),c.has(\"bitness\")\u0026\u0026(e.bitness=d.bitness),c.has(\"model\")\u0026\u0026(e.model=d.model),c.has(\"platformVersion\")\u0026\u0026(e.platformVersion=d.platformVersion),c.has(\"uaFullVersion\")\u0026\u0026(e.uaFullVersion=d.uaFullVersion),c.has(\"fullVersionList\")\u0026\u0026(e.fullVersionList=d.fullVersionList),b(e)})}toJSON(){return{mobile:this._clientHints.mobile,brands:this._clientHints.brands}}}\n    function(){if(\"https:\"===location.protocol\u0026\u0026!navigator.userAgentData){Object.defineProperty(r.prototype,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!1,value:\"NavigatorUAData\"});let a=new r(navigator);return Object.defineProperty(Navigator.prototype,\"userAgentData\",{enumerable:!0,configurable:!0,get:function(){return a}}),Object.defineProperty(window,\"NavigatorUAData\",{enumerable:!1,configurable:!0,writable:!0,value:r}),!0}return!1}\n    polyfill();\n  }\n  applyUADataPolyfill();\n"])</script><script nonce="">self.__next_f.push([1,"38:[[[\"$\",\"script\",null,{\"id\":\"hasOwnPolyfill\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"suppressHydrationWarning\":true,\"children\":\"('hasOwn' in Object) || (Object.hasOwn = Object.call.bind(Object.hasOwnProperty));\"}],[\"$\",\"script\",null,{\"id\":\"UserAGentUADataPolyfill\",\"nonce\":\"63ec77a1-e677-4dcb-945b-702ad5710bd7\",\"suppressHydrationWarning\":true,\"children\":\"$4d\"}]],\"$L4e\",\"$L4f\",\"$L50\",\"$L51\",\"$L52\"]\n"])</script><script nonce="">self.__next_f.push([1,"53:I[40678,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"Link\"]\n54:I[18694,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"Button\"]\n"])</script><script nonce="">self.__next_f.push([1,"4f:[\"$\",\"section\",null,{\"id\":\"error\",\"className\":\"styles_root__IBJUG styles_gutter-bottom__5KdTv styles_root__nqTMc\",\"style\":{\"--gutter-size-xs\":\"140px\",\"--gutter-size-sm\":\"140px\",\"--gutter-size-lg\":\"400px\",\"--gutter-size-xl\":\"400px\"},\"children\":[[\"$\",\"div\",null,{\"className\":\"styles_background-image__Etqcy\",\"style\":{\"backgroundImage\":\"url(https://yastatic.net/s3/education-portal/media/404_63c36c7c45.webp)\"}}],[\"$\",\"section\",null,{\"className\":\"styles_root__IBJUG styles_container__q8aSe\",\"style\":{\"--gutter-size-xs\":\"50px\",\"--gutter-size-sm\":\"50px\",\"--gutter-size-lg\":\"50px\",\"--gutter-size-xl\":\"50px\"},\"children\":[null,[\"$\",\"span\",null,{\"ref\":\"$undefined\",\"className\":\"styles_root__EmBCZ styles_description__ZE0yq\",\"style\":{},\"children\":\"Такой страницы нет,\\nвернитесь на главную\",\"data-variant\":\"$undefined\",\"data-weight\":\"regular\",\"data-color\":\"primary\"}],[\"$\",\"$L53\",null,{\"Text\":\"Вернуться на главную\",\"URL\":\"/\",\"Variant\":\"primary\",\"children\":[\"$\",\"$L54\",null,{\"as\":\"span\",\"view\":\"primary\",\"children\":\"Вернуться на главную\"}]}]]}]]}]\n"])</script><script nonce="">self.__next_f.push([1,"52:[\"$\",\"title\",null,{\"children\":\"Страница не найдена - 404 Not Found\"}]\n"])</script><script nonce="">self.__next_f.push([1,"4e:[[\"$\",\"$1\",\"web-page.block-0\",{\"children\":[\"$L55\"]}]]\n50:null\n51:null\n"])</script><script nonce="">self.__next_f.push([1,"55:[\"$\",\"$L2d\",\"web-page.header-block\",{\"id\":2,\"Authorization\":true,\"Search\":true,\"ProfileUrl\":\"/profile\",\"Wide\":null,\"Notifications\":true,\"Gutter\":null,\"Buttons\":[],\"Menu\":[{\"id\":19,\"Text\":\"Школьникам\",\"URL\":\"/pupils\",\"Title\":\"Школьникам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_school\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":null,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4136,\"Text\":\"Студентам\",\"URL\":\"/students\",\"Title\":\"Студентам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_students\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4137,\"Text\":\"Абитуриентам\",\"URL\":\"/university\",\"Title\":\"Абитуриентам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_abit\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4138,\"Text\":\"Партнёрам\",\"URL\":\"https://edumakers.yandex.ru/\",\"Title\":\"Партнёрам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_partner\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4139,\"Text\":\"Хендбуки\",\"URL\":\"/handbook\",\"Title\":\"События\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4140,\"Text\":\"Журнал\",\"URL\":\"/journal\",\"Title\":\"Журнал\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_journal\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4141,\"Text\":\"AI\",\"URL\":\"https://education.yandex.ru/ai\",\"Title\":\"AI\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null}],\"Logo\":{\"id\":3,\"URL\":\"/\",\"Title\":\"Яндекс Образование\",\"Image\":{\"data\":{\"id\":8,\"attributes\":{\"name\":\"edu_logo.svg\",\"alternativeText\":null,\"caption\":null,\"width\":233,\"height\":24,\"formats\":null,\"hash\":\"edu_logo_9eee76ff17\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":13.44,\"url\":\"https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-09T11:00:59.235Z\",\"updatedAt\":\"2024-12-04T04:36:42.717Z\"}}},\"ImageMobile\":{\"data\":{\"id\":10764,\"attributes\":{\"name\":\"logo_mobile.svg\",\"alternativeText\":null,\"caption\":null,\"width\":179,\"height\":25,\"formats\":null,\"hash\":\"logo_mobile_8bc5eb38fb\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":18.25,\"url\":\"https://yastatic.net/s3/education-portal/media/logo_mobile_8bc5eb38fb.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-07-17T12:53:33.633Z\",\"updatedAt\":\"2024-12-04T04:35:29.061Z\"}}}},\"isLoggedIn\":false,\"passportUrl\":\"https://passport.yandex.ru/auth/?origin=education\u0026retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Falgorithms%2Farticle%2Fzadacha-kolichestvo-prizov\",\"passportEnv\":\"prod\",\"passportUserData\":{\"avatarId\":\"$undefined\",\"plus\":false,\"name\":\"$undefined\"}}]\n"])</script><script nonce="">self.__next_f.push([1,"56:I[97469,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"HandbookBookProgressProvider\"]\n57:I[63314,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"SelectedNoteProvider\"]\n58:I[71379,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"ArticleSidePanel\"]\n59:T1ca8,"])</script><script nonce="">self.__next_f.push([1,"Привет!\n\nПеред вами бесплатный хендбук по алгоритмам. Здесь вас ждёт не только понятная теория, но и много практики, которая поможет закрепить знания и научиться применять алгоритмическое мышление на деле.\n\n### Какие темы вам предстоит освоить\n\nЭтот хендбук поможет вам разобраться в алгоритмах — от базовых понятий до сложных задач, с которыми сталкиваются программисты в работе. Мы будем идти поэтапно: от принципов и техник к решению реальных задач.\n\nХендбук состоит из 9 глав.\n\n* Глава №1 — вводная (мы сейчас в ней). Она — обо всём, что нужно знать, прежде чем начинать работу с хендбуком. Разберёмся, что такое алгоритмы, зачем они нужны и как оценивать их эффективность\n\n* Глава №2 — структуры данных. Познакомитесь со списками, множествами, словарями, стеками, очередями и деком.\n\n* В главе №3 — практические задачи. Попробуете применить полученные знания на практике: решите классические задачи с автоматической проверкой.\n\n* Глава №4 — разминка на простых алгоритмах. Здесь вас ждут задачи на последовательные вычисления, НОД, НОК и числа Фибоначчи.\n\n* Глава №5 — графы. Изучите представление графов, алгоритмы обхода, поиск кратчайших путей и компоненты связности.\n\n* В главе №6— техники проектирования алгоритмов. Вы узнаете, как работают перебор, жадные алгоритмы, динамическое программирование, рекурсия, подход «разделяй и властвуй» и рандомизация.\n\n* Глава №7 — жадные алгоритмы. Отработаете жадные подходы на задачах про деньги, рекламу, зарплаты и призы.\n\n* Глава №8 — динамическое программирование. Большая глава с разнообразными задачами: от размена и редактирования строк до рюкзака и скобочной последовательности.\n\n* Глава №9 — алгоритмы «разделяй и властвуй». Погрузитесь в двоичный поиск, быструю сортировку и задачи на деление массива.\n\n### Как это пригодится в реальной жизни\n\nЗнания об алгоритмах — это не просто формулы и схемы. Это возможность изменить способ мышления, чтобы эффективнее решать задачи в работе и жизни, — даже если вы не программист.\n\nА если ваша работа связана с кодом, то алгоритмы помогут создать базу для любой сложной программы: от поисковиков до игр, от рекомендательных систем до мобильных приложений.\n\nПонимание алгоритмов пригодится, если вы хотите:\n\n* писать код, который работает быстро даже на больших данных;\n* уверенно решать задачи на собеседованиях в IT-компании;\n* участвовать в хакатонах, олимпиадах и конкурсах по программированию;\n* проектировать архитектуру приложений и выбирать правильные структуры данных;\n* углубиться в машинное обучение и понимать, как «под капотом» устроены модели;\n* перейти от простого кодинга к инженерному подходу.\n\nЭтот хендбук — хорошая отправная точка не только для того, чтобы научиться решать алгоритмические задачи, но и для дальнейшего изучения смежных тем. После него будет проще продолжить обучение в хендбуках [по машинному обучению](https://education.yandex.ru/handbook/ml), [математике для анализа данных](https://education.yandex.ru/handbook/math) и [языкам программирования](https://education.yandex.ru/handbook/python).\n\n### Как устроен этот хендбук\n\nОтмечайте параграфы как прочитанные — это поможет отслеживать прогресс. Для этого внизу страницы есть специальная кнопка «Параграф не прочитан».\n\n![algorithms1.1](https://yastatic.net/s3/education-portal/media/algorithms1_1_79268c8944.webp)\n\nИзменение статуса главы отразится на странице содержания и в прогресс-баре хендбука:\n\n![algorithms1.2](https://yastatic.net/s3/education-portal/media/algorithms1_2_f12e084199.webp)\n\nДля перемещения по хендбуку вы можете воспользоваться навигацией внутри страниц:\n\n![algorithms1.3](https://yastatic.net/s3/education-portal/media/algorithms1_3_8c0cf94a23.webp)\n\nПосле некоторых разделов есть мини-квизы, они помогут понять, что вы уже хорошо усвоили. Если вы готовы, нажмите «Начать» в конце параграфа и проверьте себя.\n\n![algorithms1.4](https://yastatic.net/s3/education-portal/media/algorithms1_4_0ed0da7bb5.webp)\n\nОткрывайте тренажёр с задачами после каждого параграфа, чтобы закрепить навык. Для этого нажмите на кнопку «Выполнять задачи» после параграфа.\n\nКак работать с заданиями — [читайте здесь](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii).\n\nА если что-то непонятно — можно в любой момент обратиться в [сообщество](https://t.me/handbook_algorithms) студентов."])</script><script nonce="">self.__next_f.push([1,"5a:T1779,"])</script><script nonce="">self.__next_f.push([1,"В конце некоторых параграфов вы встретите практические задачи. Они помогут лучше разобраться в теме и закрепить материал. Чтобы уверенно с ними работать, разберёмся, как устроена система проверки. Спойлер: всё просто, но есть нюансы.\n\n## Интерфейс\n\nМы рекомендуем решать задачи с компьютера: так удобнее, и интерфейс отображается корректно.\n\nКогда вы открываете задачу, экран делится на две части:\n\n* слева — описание задания,\n* справа — редактор, где вы пишете код.\n\n![algorithms1.2.1](https://yastatic.net/s3/education-portal/media/algorithms1_2_1_e2e1cdbfa0.webp)\n\n## Структура описания задачи\n\nОписание включает:\n\n* условие задачи;\n* формат ввода и вывода — какие данные программа получает и должна вернуть;\n* пример — демонстрирует ожидаемый результат;\n* ограничения — по времени и памяти.\n\n![algorithms1.2.2](https://yastatic.net/s3/education-portal/media/algorithms1_2_2_b4eb315a73.webp)\n\nВы можете ввести код прямо в редакторе или загрузить файл с решением.\n\n## Отправка решения\n\nПосле этого начнётся проверка — код будет протестирован на разных входных данных. Этот процесс занимает некоторое время.\n\n\u003e Для решения задач вы можете выбрать любой удобный язык программирования из списка, представленного в системе. Однако имейте в виду, что ограничения по времени и памяти подбирались с расчётом на использование C++23 (Clang 18.1.6).\n\n![algorithms1.2.3](https://yastatic.net/s3/education-portal/media/algorithms1_2_3_123e795d77.webp)\n\n## Проверка и тесты\n\nЭти данные не всегда совпадают с примерами из условия задачи — они подобраны так, чтобы проверить решение на корректность, граничные случаи и эффективность.\n\nПроверка занимает несколько секунд. Прогресс и историю можно отследить на вкладке «Отправленные решения».\n\n![algorithms1.2.4](https://yastatic.net/s3/education-portal/media/algorithms1_2_4_0a0558dd3e.webp)\n\n### Статусы проверки\n\nРезультаты отображаются в виде вердиктов. Вот основные из них:\n\n* OK (Accepted) — решение прошло все тесты успешно.\n\n* WA (Wrong Answer) — программа выдала неверный результат хотя бы на одном из тестов.\n\n* CE (Compilation Error) — ошибка компиляции.\n\n* RE (Runtime Error) — ошибка выполнения.\n\n* TM (Time Limit) —\u0026nbsp;при выполнении превышено допустимое время.\n\n* ML (Memory Limit) — при выполнении превышена допустимая память.\n\n#### Wrong Answer\n\nВ случае WA для тестов из примеров отображаются:\n\n* входные данные;\n* вывод вашей программы;\n* ожидаемый правильный ответ;\n* вывод системы.\n\n![algorithms1.2.5](https://yastatic.net/s3/education-portal/media/algorithms1_2_5_8112f3801a.webp)\n\nЭто поможет вам отладить решение. Остальные тесты остаются скрытыми — попробуйте сами смоделировать граничные случаи.\n\n### Compilation Error\n\nОзначает, что в коде допущена синтаксическая или другая ошибка, из-за которой программа не запускается.\n\n![algorithms1.2.6](https://yastatic.net/s3/education-portal/media/algorithms1_2_6_d89d577d54.webp)\n\nПерейдите в «Лог компиляции», чтобы увидеть подробности:\n\n* тип ошибки;\n* строка, где она возникла;\n* комментарий от компилятора.\n\n#### Runtime Error\n\nЭто ошибка, которая возникает во время выполнения программы.\n\nВозможные причины:\n\n* деление на ноль;\n* выход за границы массива;\n* необработанное исключение и т. п.\n\n#### Time Limit и Memory Limit\n\nЭти ошибки возникают в ответ на плохо оптимизированный код.\n\nНапример, если встречается «матрёшка» из циклов. Решение тут только одно — вдумчиво изучить код и попробовать его оптимизировать, сделав менее ресурсоёмким.\n\n### Совет\n\nЕсли не удаётся разобраться с ошибкой — не спешите расстраиваться. Попробуйте:\n\n* упростить тест и воссоздать ситуацию локально;\n* добавить отладочный вывод;\n* обсудить решение с участниками [сообщества](https://t.me/handbook_python) хендбука."])</script><script nonce="">self.__next_f.push([1,"5b:T1d68,"])</script><script nonce="">self.__next_f.push([1,"В этом хендбуке мы сделаем акцент на фундаменте построения алгоритмов и преобразовании их в программы. Это важно — практически на любую задачу можно посмотреть с различных сторон, и это может привести к необычайным результатам: где-то подход станет намного проще и понятнее, а где-то значительно вырастет эффективность и итоговая программа будет находить результат в тысячи и даже в миллионы раз быстрее.\n\n## Зачем изучать алгоритмы?\n\nЭтот вопрос интересует большинство начинающих разработчиков. На него нет однозначно верного ответа, но мы считаем изучение алгоритмов важным и полезным.\n\nАлгоритмизация превращает мысли и рассуждения в последовательность действий. Но к одному и тому же результату могут приводить разные действия — поэтому составление алгоритма это ещё и поиск наиболее эффективного (в данный момент) набора действий.\n\nЗная фундаментальные алгоритмы, вы сможете:\n\n- виртуозно использовать стандартные библиотеки языков программирования,\n- уверенно оценивать ожидаемое время работы программы,\n- читать и понимать код, написанный другими программистами.\n\n## Пример из жизни\n\nАлгоритмизация важна и «для общего развития»: она помогает планировать свои действия в реальной жизни. Почти всё, что нас окружает, можно описать алгоритмически.\n\nВзять, например, очередь.\n\nЗдесь алгоритмы помогают по-разному организовать работу с клиентами — в зависимости от разных факторов: количества посетителей, количества сотрудников и так далее.\n\nОрганизация очереди в аэропорту и в супермаркете различается:\n\n- в супермаркете клиенты оплачивают покупки по одному;\n- в аэропорту подходят к стойке в общей очереди, но «обработчики» забирают клиентов по одному, как только заканчивают работу с предыдущим.\n\nИ там и тут — очередь, организованная по принципу «первый пришёл — первый вышел» (First In First Out, FIFO), но за счёт различий в реализации в каждом случае удаётся получить оптимальное время на обслуживание клиентов.\n\nОчередь — важный примитив из простых абстрактных структур данных, более детально о ней поговорим в одном из параграфов.\n\n## Немного о самом хендбуке\n\nВ основе нашего хендбука — перевод интерактивного учебника [Ace Your Next Coding Interview by Learning Algorithms through Programming and Puzzle Solving](https://acecodinginterview.org/) (Alexander S. Kulikov, Pavel Pevzner), дополненный новыми практическими задачами и несколькими тематическими разделами.\n\nМы уверены, что по-настоящему разобраться в новом материале помогает глубокая практическая проработка — для закрепления новых знаний необходимо попробовать решить задачу и посмотреть на неё под разными углами, задать себе вопросы о возможном применении того или иного подхода, или способах его обобщить.\n\nОбязательно решайте практические задачи, закрепляйте свои знания.\n\nПроверка решений практических заданий проводится автоматически в системе Яндекс Контест. Мы подготовили наборы тестовых примеров, которые покрывают различные возможные ошибки в программной реализации алгоритмов. Если для какой-то из задач вы обнаружите, что решение проходит системные тесты, но при этом не является корректным, присылайте ваши дополнительные тесты, обязательно добавим их в задачу, чтобы улучшить ее качество.\n\nИ последнее, на чём хочется заострить внимание: в этом хендбуке мы будем больше фокусироваться на проектировании подходов и создании эффективных алгоритмов — где-то не будем совсем строго доказывать корректность алгоритмов, а где-то только выпишем итоговую трудоемкость, но опять же не будем её строго обосновывать. Корректность и анализ трудоемкости (в худшем случае и в среднем) — очень важные части составления алгоритмов, но всему свое время, давайте погружаться постепенно.\n\nЖелаем вам удовольствия от познания нового, а ещё — успешного применения алгоритмических подходов в жизни, при трудоустройстве и в решении практических задач. Надеемся, что вы будете так же радоваться придуманным подходам, как радуемся мы.\n\nИ ещё кое-что: для этого хендбука у нас есть коммьюнити студентов. В нём можно найти единомышленников, обсудить материалы и задания. Вступить в него можно по [ссылке](https://t.me/handbook_algorithms). А чтобы быть в курсе обновлений хендбука — советуем [подписаться](https://forms.yandex.ru/surveys/algorythm) на рассылку."])</script><script nonce="">self.__next_f.push([1,"5c:T54df,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы узнаете, что такое алгоритм, как формулируется задача и чем она отличается от её конкретного экземпляра. Мы обсудим, как проверить корректность алгоритма, зачем нужен псевдокод и как оценивать эффективность решений.\n\nТакже вы познакомитесь с понятием временной сложности и увидите разницу между «медленными» и «быстрыми» алгоритмами.\n\n## Ключевые вопросы параграфа\n\n- Чем задача отличается от её конкретного экземпляра и почему это различие важно?\n- Какие ошибки может допустить алгоритм и как проверить его корректность?\n- В чём преимущества описания алгоритма на псевдокоде?\n- Как измерять «быстроту» алгоритма и почему не всегда важно абсолютное время работы?\n- Почему полиномиальные алгоритмы считаются приемлемыми, а экспоненциальные — проблемными?\n\n## Что такое алгоритм?\n\nАлгоритм — это последовательность указаний, которые нужно исполнить, чтобы решить чётко сформулированную задачу. Мы описываем задачи, исходя из ввода и вывода, и алгоритм становится способом превращения ввода в вывод. При этом формулировка задачи должна быть точной и недвусмысленной — это помогает избежать неверной интерпретации.\n\nКогда вы закончили проектировать алгоритм, необходимо ответить на два важных вопроса: «Правильно ли он работает?» и «Сколько времени занимает выполнение?».\n\nРазумеется, вас не устроит алгоритм, который выдаёт правильный результат лишь в половине случаев или требует $1 000$ лет для поиска ответа.\n\n## Псевдокод\n\nЧтобы понять, как работает алгоритм, нам необходимо перечислить шаги, которые он выполняет. Для этого мы будем использовать псевдокод — язык, которым пользуются разработчики для описания алгоритмов. Он игнорирует многие детали, необходимые в языках программирования, но он более точен, чем рецепт из кулинарной книги.\n\n## Задача и экземпляр задачи\n\nЗадача описывает класс возможных входных данных.\n\nЭкземпляр задачи — это один конкретный ввод такого класса. Чтобы продемонстрировать понятия задачи и экземпляра задачи, рассмотрим следующий пример.\n\n### Пример\n\nВы оказались в книжном магазине и собираетесь купить книгу за  $4,23＄$, расплатившись купюрой в $5＄$. Вам должны вернуть $77$ центов в качестве сдачи. Теперь кассир принимает решение, как именно это сделать. Согласитесь, неприятно получить горсть из $77$ пенни или $15$ никелей и $2$ пенни. Возникает вопрос: как выдать сдачу, не расстроив клиента? Большинство кассиров стараются уместить сумму сдачи в наименьшее количество монет.\n\n{% cut \"**Остановитесь и подумайте**:\" %}\n\nКаково минимальное количество монет номиналом $(25, 10, 5, 1)$, необходимо для сдачи в $77$ центов?\n\n{% endcut %}\n\nПример с $77$ центами представляет собой экземпляр задачи `Размен`. Предполагается, что есть $d$ номиналов, которые представлены массивом $c = (c_1, c_2, \\dotsc, c_d)$. Для упрощения будем считать, что номиналы даны в порядке убывания. Например, $c = (25, 10, 5, 1)$ для монет, используемых в США.\n\n### `Задача «Размен»`\n\n*Переведите определенное количество денег в данные номиналы, используя как можно меньше монет.*\n\n- Входные данные: Целое число $money$ и массив из $d$ номиналов\n  $c = (c_1, c_2, \\dotsc, c_d)$ в порядке убывания ( $c_1 \u003e c_2 \u003e \\dotsb \u003e c_d$ ).\n- Выходные данные: Список из $d$ целых чисел $i_1, i_2, \\dotsc , i_d$, в котором $c_1\\cdot i_1+c_2 \\cdot i_2+\\dotsm+ c_d \\cdot i_d = money$ и $i_1 + i_2 +\\dotsm +i_d$ как можно меньше.\n\nКассиры по всему миру решают эту проблему с помощью простого алгоритма:\n\n```cpp\nChange(money, c, d):\n    while money \u003e 0:\n        coin = ... // монета с самым большим номиналом, который не превышает money\n        // дать монету с номиналом coin клиенту\n        money = money - coin\n```\n\nВот быстрая версия Change:\n\n```cpp\nChange(money, c, d):\n    for k in range(1, d + 1) \n        i_k = floor(money / c[k]) // наибольшее количество монет номинала c[k]\n        // дать i_k монет с номиналом c[k] клиенту\n        money = money - c[k] * i_k\n```\n\n## Корректные и некорректные алгоритмы\n\nМы называем алгоритм корректным, если на каждый получаемый ввод он делает правильный вывод. Алгоритм считается некорректным, если хотя бы один ввод приводит к неправильному выводу.\n\n{% cut \"**Остановитесь и подумайте**:\" %}\n\nКаково минимальное количество монет номиналами $(25, 20, 10, 5, 1)$, необходимое для сдачи в $40$ центов?\n\n{% endcut %}\n\n`Change` — это некорректный алгоритм! Представьте сдачу в 40 центов, выданную в номиналах $c_1 = 25$, $c_2 = 20$, $c_3 = 10$, $c_4 = 5$ и $c_5 = 1$.\n\n`Change` привел бы к неправильному результату: он выдал бы 1 четвертак (25 центов), 1 дайм (10 центов) и 1 никель (5 центов) вместо 2 монет по двадцать центов. Хоть это и может выглядеть надуманно, в 1875 году в США существовала монета в двадцать центов.\n\nНасколько мы можем быть уверены, что `Change` выдаст минимальное количество монет в современных номиналах Соединенных Штатов или любой другой страны?\n\n### Как исправить алгоритм `Change`\n\nЧтобы исправить алгоритм `Change`, нам нужно рассмотреть все возможные комбинации монет с номиналами $c_1, c_2, \\dotsc , c_d$, которые дают в сумме $money$, и выдать комбинацию с минимальным количеством монет.\n\nМы рассматриваем только комбинации, в которых $i_1 \\le  money/c_1$ и $i_2 \\le money/c_2$ (в целом, величина $i_k$ не должна превышать $money/c_k$), в ином случае мы вернем большее количество денег, чем $money$.\n\nВ псевдокоде, приведенном ниже, используется символ $\\sum$. Он обозначает суммирование: $\\sum^m_{i=1} a_i = a_1 + a_2 + \\dotsm + a_m$. Псевдокод также использует концепт «бесконечность» (обозначается $\\infty$) в качестве начального значения для $smallestNumberOfCoins$.\n\nРеализация описанного подхода на реальных языках программирования может различаться, но сейчас подробности для нас не важны.\n\n```cpp\nBruteForceChange(money, c, d):\n    smallestNumberOfCoins = ∞\n    for each combinations of coins (i_1,...,i_d)\n    // от (0,...,0) до (money/c[1],...,money/c[d])\n        valueOfCoins = ∑ i_k*c_k // сумма по всем k от 1 до d\n        if valueOfCoins = money:\n            numberOfCoins = ∑ i_k // суммарное количество монет\n            if numberOfCoins \u003c smallestNumberOfCoins:\n                smallestNumberOfCoins = numberOfCoins\n                change = (i_1, i_2, ... ,i_d)\n    return change\n```\n\nЦикл повторяется с каждой возможной комбинацией $(i_1, \\dotsc, i_d)$ из $d$ индексов и останавливается, когда достигает\n\n$$\\left(\\frac{money}{c_1}, \\dotsc, \\frac{money}{c_d}\\right)\n$$\n\n### Проверка `BruteForceChange`\n\nКак мы можем узнать, что `BruteForceChange` не содержит ту же проблему, что и `Change`, — неверный результат при каком-то вводе? Раз `BruteForceChange` рассматривает все возможные комбинации номиналов, рано или поздно алгоритм придёт к оптимальному решению и запишет его в массив $change$. В любой комбинации монет, которая даёт в сумме $M$, должно быть как минимум столько же монет, сколько и в оптимальной. Таким образом, `BruteForceChange` никогда не завершит работу с неоптимальным набором $change$.\n\nНа данный момент мы ответили только на один из двух важных вопросов об алгоритмах: \"Работает ли он?\". Однако мы не ответили на вопрос: \"Сколько времени занимает выполнение?\".\n\n{% cut \"**Остановитесь и подумайте**:\" %}\n\n*Сколько примерно итераций цикла `for` выполняет `BruteForceChange`?*\n\n- $money$\n- $money^d$\n- $d$\n\n{% endcut %}\n\n## Быстрые и медленные алгоритмы\n\nНастоящие компьютеры требуют определенное количество времени на выполнение таких операций, как сложение, вычитание или проверка условий цикла while. Суперкомпьютер может выполнить сложение за $10^{-10}$ секунды, а калькулятор — за $10^{-5}$.\n\nПредставьте, что у вас есть компьютер, которому требуется $10^{-10}$ секунды на выполнение простой операции (например, сложения), и вы знаете, сколько операций выполняет какой-то конкретный алгоритм. Вы могли бы рассчитать время выполнения алгоритма, просто взяв произведение количества операций и времени, которое занимает одна операция.\n\nОднако компьютеры постоянно улучшаются, благодаря чему им требуется меньше времени на операцию. Так, ваше представление о времени выполнения быстро стало бы устаревшим.\n\nВместо того, чтобы рассчитывать время выполнения на каждом компьютере, мы описываем время выполнения через общее количество операций, необходимых алгоритму, — это характеристика самого алгоритма, а не компьютера, который вы используете.\n\n### Как определить количество операций алгоритма\n\nК сожалению, нам не всегда легко определить, сколько операций выполнит алгоритм. Однако если мы можем рассчитать количество базовых операций, выполняемых алгоритмом, то это позволит сравнить его с другим алгоритмом, решающим ту же задачу. Чтобы мучительно не подсчитывать каждое умножение и сложение, можно сравнивать только те участки кода, которые при увеличении размера ввода потребуют больше операций.\n\nПредставьте, что алгоритм $A$ выполняет $n^2$ операций при вводе размера $n$, и алгоритм $B$ решает ту же задачу за $3n+2$ операций. Какой алгоритм быстрее: $A$ или $B$? Хотя $A$ и может быть быстрее, чем $B$, при более малом значении $n$ (например, при $n$ между 1 и 3), $B$ будет быстрее при больших значениях $n$ (например, $n \u003e4$). (См. рис.). Так как $f(n)=n^2$ — это, в каком-то смысле, более «быстрорастущая» функция относительно $n$, чем $g(n)=n$.\n\nПри этом константы 3 и 2 в $3n+2$ не влияют на конкуренцию между двумя алгоритмами при больших значениях $n$. Мы называем $A$ квадратичным алгоритмом и $B$ — линейным. $A$ менее эффективен, чем $B$, потому что он выполняет больше операций для решения задачи, когда значение $n$ большое. Так, иногда мы будем допускать неточности при подсчете операций алгоритма: поведение алгоритма при маленьком вводе неважно.\n\n![Group](https://yastatic.net/s3/education-portal/media/Group_1_e4f2b45a91_04c613f05b.svg)\n\n### Пример расчёта количества операций для BruteForceChange\n\nРассчитаем примерное количество операций, которое потребуется для `BruteForceChange` при вводе из $M$ центов и номиналов $(c_1, c_2, \\dotsc, c_d)$. Чтобы рассчитать общее количество операций в цикле for, нам необходимо взять примерное число операций, выполняемое при каждой итерации, и умножить его на общее количество итераций. В нашем случае количество операций можно оценить сверху величиной\n\n$$\\frac{money}{c_1} \\times \\frac{money}{c_2} \\times \\dotsm \\times \\frac{money}{c_d}\n$$\n\nТакой тип алгоритмов называется экспоненциальным в противоположность квадратичным, кубическим или другим полиномиальным алгоритмам.\n\nВыражение времени выполнения экспоненциального алгоритма использует $n^d$, где $n$ и $d$ — это параметры задачи (например, $n$ и $d$ можно произвольно сделать большими, изменив ввод для алгоритма).\n\nВремя выполнения полиномиального алгоритма ограничено $n^k$, где $k$ — это константа, не связанная с тестовыми данными.\n\nНапример, алгоритм с временем выполнения $n^1$ (линейный), $n^2$ (квадратичный), $n^3$ (кубический) или даже $n^{2018}$ будет полиномиальным. Конечно, алгоритм с временем выполнения $n^{2018}$ не очень практичен. Возможно, даже менее практичен, чем некоторые экспоненциальные алгоритмы.\n\nВпрочем, разработчики тратят много усилий, чтобы проектировать всё более и более быстрые полиномиальные алгоритмы. Раз значение $d$ может быть большим при вызове алгоритма с большим количеством номиналов (например, $c = (1, 2, 3, 4, 5, \\dotsc , 100)$), мы видим, что выполнение `BruteForceChange` может потребовать много времени.\n\n## Что дальше\n\nТеперь вы знаете, что такое алгоритм, чем задача отличается от её экземпляра и как алгоритмы помогают решать поставленные задачи. Вы познакомились с псевдокодом, понятием корректности алгоритма и идеей оценки его эффективности. А ещё узнали, почему время выполнения важно и как отличать «быстрые» алгоритмы от «медленных» с точки зрения роста числа операций.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n- Отметьте, что урок прочитан, при помощи кнопки ниже.\n\n- Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n- Алгоритм — это способ преобразования входных данных в выходные. Он решает задачу, формулируемую через множество возможных входов и условий.\n\n- Псевдокод помогает описывать шаги алгоритма понятно и точно, а корректность означает, что алгоритм всегда выдаёт правильный результат.\n\n- Эффективность алгоритма оценивается по количеству операций, которые он выполняет, — это позволяет сравнивать алгоритмы независимо от устройства.\n\n- Полиномиальные алгоритмы масштабируются лучше и считаются эффективными, тогда как экспоненциальные быстро становятся непрактичными при росте входных данных.\n\nВ следующей главе вы познакомитесь со структурами данных: стеком, очередью, словарём, множеством и списками. Вы узнаете, как они устроены, где используются и чем отличаются друг от друга, — а заодно научитесь применять их в задачах."])</script><script nonce="">self.__next_f.push([1,"5d:T212b,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с односвязным списком — одной из базовых структур данных. Эта структура лежит в основе многих других: стека, очереди и даже более сложных реализаций. Мы разберём её устройство и научимся работать с элементами списка, чтобы увидеть, почему иногда списки оказываются удобнее массивов.\n\n## Ключевые вопросы параграфа\n\n* Как устроен односвязный список и чем он отличается от массива?\n* Какие операции можно выполнять со списком и какова их сложность?\n* Когда стоит использовать односвязный список вместо других структур?\n  {% if handbookVideosEnable == '1' %}\n\n\u003cp align=center\u003e\u003cscript src=\"https://vk.com/js/api/videoplayer.js\"\u003e\u003c/script\u003e\u003ciframe src=\"https://vk.com/video_ext.php?oid=-84793390\u0026id=456239967\u0026autoplay=1\" width=\"853\" height=\"480\" allow=\"autoplay; encrypted-media; fullscreen; picture-in-picture;\" frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n{% endif %}\n\n## Элементы односвязного списка\n\nОдносвязный список (иногда «связный список») — базовая структура данных, представляющая собой соединённые узлы с однотипными данными. Каждый узел состоит из элемента и ссылки на следующий элемент (см. рисунок).\n\nСамый первый элемент списка называют головой (head) односвязного списка, а последний — хвостом (tail). Последний элемент односвязного списка в качестве ссылки содержит null-значение.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_9_1_682a724c58_02386a3b42.svg)\n\n\u003e **Остановитесь и подумайте:**\n\u003e Какие достоинства и недостатки по сравнению с обычным массивом у односвязного списка?\n\nВ отличие от классического массива, где данные в памяти расположены строго последовательно, в односвязном списке, наоборот, данные расположены хаотично и связывание узлов списка происходит посредством ссылок. За счёт этой особенности в односвязный список можно добавлять произвольное число элементов, однако доступ будет осуществляться только последовательно. Произвольного доступа к элементам в односвязном списке нет.\n\nСо списком можно производить ряд операций:\n\n* Добавить элемент (add).\n\n* Удалить элемент (remove).\n\n* Найти элемент (find).\n\n* Посчитать количество элементов по условию (count).\n\nОперация добавления элемента (add) может быть представлена в нескольких вариантах.\n\n* В случае добавления в начало списка ссылка нового узла будет указывать на голову списка, а голова списка должна быть перемещена на новый узел. Сложность этого варианта — $O(1)$.\n\n* Если добавление идёт в конце списка, то ссылка хвоста списка должна указывать на новый узел, а после должна быть перемещена на новый узел. Сложность этого варианта — $O(1)$.\n\n* Вставка промежуточного элемента предполагает, что будет найдена позиция после которой будет вставлено новое значение. Сложность этого варианта — $O(n)$, где n число элементов в списке.\n\nУдаление элемента (remove) предполагает, что будет найден заданный элемент и следом он будет удалён. Нахождение узла требует прохода по односвязному списку, после чего необходимо ссылку с элемента перед удаляемым перенаправить на элемент после удаляемого. Сложность операции — $O(n)$, где $n$ — число элементов в списке.\n\nНахождение элемента (find) предполагает простой однократный проход по списку с нахождением ссылки на заданный элемент. Сложность операции — $O(n)$, где $n$ — число элементов в списке.\n\nПодсчёт числа элементов по условию (count) предполагает проход по списку и сравнение всех элементов с заданным с подсчётом количества удовлетворяющих условию элементов. Сложность операции — $O(n)$, где $n$ — число элементов в списке.\n\n## Что дальше\n\nТеперь вы знаете, как устроен односвязный список и как с ним работать: добавлять, удалять, искать и считать элементы. Вы поняли, чем он отличается от массива и в каких случаях может быть полезен.\n\nДалее — ещё одна важная структура данных: множество. Вы увидите, как оно позволяет хранить уникальные элементы и выполнять быстрые проверки на принадлежность.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80784) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий гайд о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Односвязный список состоит из узлов, где каждый узел хранит значение и ссылку на следующий элемент.\n* В отличие от массива, доступ к элементам возможен только через последовательный обход списка.\n* Основные операции (добавление, удаление) могут выполняться эффективно при работе с началом списка, но поиск элемента занимает больше времени.\n* Односвязный список удобен, когда важнее динамическое изменение структуры, чем быстрый доступ по индексу."])</script><script nonce="">self.__next_f.push([1,"5e:T2b8c,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с множествами — структурами данных, в которых каждый элемент встречается не более одного раза. Вы узнаете, как устроены множества в Python и C\\+\\+, какие бывают разновидности множеств и как различается поведение упорядоченных и неупорядоченных коллекций. Научитесь выполнять базовые операции — добавление, удаление, проверку наличия, объединение и пересечение.\n\n## Ключевые вопросы параграфа\n\n* Чем множество отличается от списка и в каких случаях его удобнее использовать?\n* Как реализованы множества в разных языках — упорядоченные и неупорядоченные?\n* Какие операции над множествами поддерживаются и в чём их сложность?\n  {% if handbookVideosEnable == '1' %}\n\n\u003cp align=center\u003e\u003cscript src=\"https://vk.com/js/api/videoplayer.js\"\u003e\u003c/script\u003e\u003ciframe src=\"https://vk.com/video_ext.php?oid=-84793390\u0026id=456239968\u0026autoplay=1\" width=\"853\" height=\"480\" allow=\"autoplay; encrypted-media; fullscreen; picture-in-picture;\" frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n{% endif %}\n\n## Определение множества (set)\n\nСледующей структурой данных, которую мы рассмотрим, будет множество (set). Множество представляет собой контейнер, содержащий неповторяющиеся элементы в произвольном порядке.\n\n{% cut \"Обратите внимание\" %}\n\nв стандартной библиотеке С\\+\\+ реализовано упорядоченное множество, что накладывает свои особенности на вычислительную сложность некоторых операций.\n\n{% endcut %}\n\nДалее в данном параграфе мы будем разграничивать упорядоченные и неупорядоченные множества.\n\nКроме того, существует такое понятие, как мультимножество (multiset), которое может включать в себя несколько одинаковых элементов.\n\nВы можете посмотреть на различия между множеством и мультимножеством на рисунке ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_9_2_59961e6818_49f28c2278.svg)\n\nВнутренняя реализация множества осуществляется различными способами, включая использование хэш-таблицы, бинарного дерева поиска и других алгоритмов. В данном параграфе мы сосредоточимся на функциях, которые можно производить со множеством, а не на внутренней его реализации.\n\nОсновные операции со множеством:\n\n* Добавление элемента в множество.\n* Удаление элемента из множества.\n* Проверка наличия элемента в множестве.\n* Объединение двух множеств.\n* Пересечение двух множеств.\n* Разность двух множеств.\n\nРассмотрим основные операции со множеством на примере двух языков С\\+\\+ и Python. В STL языка С\\+\\+ реализовано упорядоченное множество, в то время как в Python — неупорядоченное множество.\n\n## Добавление элемента\n\nДобавление элемента в множество можно произвести следующим образом.\n\n```cpp\n    my_set = {1, 2, 3}\n    my_set.add(2)\n    print(my_set)\n    my_set.add(4)\n    print(my_set)\n```\n\nВ результате исполнения фрагмента кода выше на экран будет выведено две строки: 1 2 3 и 1 2 3 4. Сложность операции добавления элемента во множество в Python — $O(1)$, так как множество не упорядочено и не нужно искать позиции для его вставки.\n\nВ языке С\\+\\+ добавление элемента может быть осуществлено следующим образом (не забудьте добавить #include\\\u003cset\\\u003e в начало вашего кода).\n\n```cpp\n    set\u003cint\u003e val = {6, 10, 5, 1};\n    val.insert(6);\n    val.insert(10);\n    val.insert(2);\n    cout \u003c\u003c val.size();\n```\n\nВ итоге на экран будет выведено 5. В случае реализации на С\\+\\+ мы имеем дело с упорядоченным множеством, что накладывает дополнительные временные издержки. Асимптотическая сложность добавления элемента — $O(logn)$.\n\n## Удаление элемента\n\nНе менее важной операцией является операция удаления элемента из множества.\n\n```cpp\n    set\u003cint\u003e val = {6, 10, 5, 1};\n    val.erase(6)\n    cout \u003c\u003c val.size();\n```\n\nБлагодаря фрагменту кода выше произошло удаление элемента, поэтому на экране появится число 3. Сложность операции удаления в упорядоченном множестве — $O(logn)$.\n\nРассмотрим удаление элемента из множества в Python:\n\n```cpp\n    my_set = {1, 2, 3}\n    my_set.remove(1);\n    print(len(my_set))\n```\n\nРазмер множества после удаления элемента становится равным двум. Сложность операции удаления в неупорядоченном множестве — $O(1)$.\n\n## Другие операции\n\n* Проверка наличия элемента в множестве предполагает просмотр элементов в нём. В случае неупорядоченного множества, реализованного на хэш-таблицах, сложность — О(1). Однако, при использовании упорядоченного множества сложность становится O(logn).\n* Объединение множеств предполагает их слияние в единое множество. Например, пусть было два множества. Первое содержало элементы 1, 2 и 3, а второе 2, 3 и 4. В результате объединения получится множество, содержащее четыре элемента 1, 2, 3 и 4.\n* Пересечение множеств представляет из себя поиск в двух множествах одинаковых элементов. Пусть первое множество содержит элементы 1, 2 и 3, а второе — 2, 3 и 4. Тогда пересечением множеств будут являться элементы 2 и 3.\n* Разность двух множеств предполагает нахождение всех элементов из первого множества, за исключением тех, которые находятся во втором множестве. Пусть первое множество содержит элементы 1, 2 и 3, а второе — 2, 3 и 4. Тогда разностью множеств будет элемент 1.\n\n## Упражнение\n\nПоработайте с двумя множествами А = {1, 3, 4, 5, 6}, B = {1, 2, 4, 6, 8, 9}. Для данных множеств найдите объединение, пересечение и разность.\n\n## Что дальше\n\nТеперь вы умеете работать с множествами: добавлять и удалять элементы, проверять их наличие, объединять и находить пересечение. Вы узнали, что множества полезны, когда важна уникальность, а не порядок, и что разные реализации дают разную эффективность.\n\nДалее — структура, где каждому ключу сопоставлено значение. Вы познакомитесь со словарями, научитесь использовать ассоциативные массивы и узнаете, в чём их сила.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80785) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Множество — это структура, содержащая только уникальные элементы.\n* В Python используется неупорядоченное множество, а в C\\+\\+ — упорядоченное.\n* Основные операции: добавление, удаление, проверка наличия, объединение и пересечение.\n* Эффективность зависит от реализации: хеш-таблицы обеспечивают быстрые операции, но не сохраняют порядок."])</script><script nonce="">self.__next_f.push([1,"5f:T1785,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с одной из самых удобных структур данных — словарём (или ассоциативным массивом). Словари лежат в основе многих приложений: от хранения конфигураций и частотных словарей в тексте до быстрых поисковых индексов. Мы разберём, как словарь устроен, почему он так быстро работает и какие варианты его реализации существуют.\n\n**Ключевые вопросы параграфа**\n\n* Что такое словарь и зачем он нужен?\n\n* Какие операции поддерживает словарь и какова их сложность?\n\n* Как реализуются словари в языках программирования и почему хеш-таблицы — хороший выбор?\n  {% if handbookVideosEnable == '1' %}\n\n\u003cp align=center\u003e\u003cscript src=\"https://vk.com/js/api/videoplayer.js\"\u003e\u003c/script\u003e\u003ciframe src=\"https://vk.com/video_ext.php?oid=-84793390\u0026id=456239969\u0026autoplay=1\" width=\"853\" height=\"480\" allow=\"autoplay; encrypted-media; fullscreen; picture-in-picture;\" frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n{% endif %}\n\n## Определения словаря\n\nСледующей структурой данных, которую мы рассмотрим, будет словарь (map, dictionary), или так называемый ассоциативный массив, позволяющий хранить пары вида «ключ — значение». Ключ — уникальный идентификатор, а значение может быть любой объектной переменной, включая другие структуры данных. Например, списки или другие словари. Ключи и значения могут выводиться в различном порядке, потому что словари не упорядочены.\n\nАналогично множеству, у словаря существует мультисловарь (multimap), который позволяет хранить несколько элементов с одинаковым ключом. Посмотрите на примеры ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_9_3_4a162ebdc9_5dcc04ac1f.svg)\n\nДовольно часто словари реализуют с использованием хеш-таблиц. Говоря об асимптотической сложности операций со словарём, будем иметь ввиду реализацию на хеш-таблицах.\n\nОсновные операции со словарем и их асимптотическая сложность:\n\n1. Добавление нового элемента с уникальным ключом — $O(1)$.\n2. Удаление элемента по ключу — $O(1)$.\n3. Изменение значения по ключу — $O(1)$.\n4. Получение значения по ключу — $O(1)$.\n\n## Что дальше\n\nТеперь вы знаете, как устроен словарь, и умеете использовать его для хранения данных, связанных с уникальными ключами, и быстрого поиска по этим ключам. Вы познакомились с операциями вставки, удаления, изменения и извлечения значений.\n\nСледующий шаг — дек (двусторонняя очередь). В отличие от обычной очереди, здесь можно добавлять и удалять элементы как с начала, так и с конца. Вы увидите, как дек сочетает свойства очереди и стека и где именно такая гибкость оказывается особенно полезной.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80786) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Словарь хранит пары «ключ — значение» и обеспечивает быстрый доступ по ключу.\n* Большинство операций (добавление, удаление, поиск) выполняются за константное время при реализации через хеш-таблицу.\n* Словари часто используют для подсчёта, группировки и хранения вложенных структур.\n* Мультимапы позволяют хранить несколько значений для одного ключа."])</script><script nonce="">self.__next_f.push([1,"60:T1194,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с деком — универсальной структурой данных, которая позволяет добавлять и удалять элементы как с начала, так и с конца. Вы узнаете, как реализуется дек, чем он удобен и в каких задачах помогает упростить логику программы.\n\n## Ключевые вопросы параграфа\n\n* Что такое дек и как он отличается от обычной очереди или стека?\n* Какие операции поддерживает дек и с какой сложностью?\n* Как реализовать дек на практике и где он пригодится?\n\n## Определение дека\n\nДек (deque, double-ended queue) — универсальная структура данных; представляет собой последовательность элементов, у которой есть два конца. Причём добавление и удаление элементов может происходить как в начало, так и в конец структуры.\n\nСтруктура дека обладает следующими особенностями:\n\n* Доступ к первому и последнему элементу производится за константное время $O(1)$.\n* Доступ к элементам в середине дека осуществляется за линейное время $O(n)$, так как элементы хранятся последовательно.\n\nВ целом дек представляет собой смесь стека и очереди.\n\nСтруктура дек может реализовываться различными способами, например с использованием двух стеков или двусвязного списка.\n\n![algosy_9_6_3f25b95c24.svg](https://yastatic.net/s3/education-portal/media/algosy_9_6_3f25b95c24_81bf28239d.svg)\n\n## Что дальше\n\nТеперь вы умеете использовать дек — структуру, которая совмещает свойства очереди и стека. Вы увидели, как с помощью дека можно реализовать гибкие алгоритмы обработки данных с доступом к обоим концам последовательности.\n\nДалее — базовые структуры стека и очереди, с помощью которых можно удобно организовывать данные в процессе выполнения алгоритмов.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80789) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Дек — структура данных, которая позволяет добавлять и удалять элементы с обеих сторон за O(1).\n* Он совмещает поведение очереди и стека, сохраняя гибкость и эффективность.\n* Часто используется в задачах, где нужен доступ к краям списка или симметричная обработка элементов.\n"])</script><script nonce="">self.__next_f.push([1,"61:T1780,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь со стеком — простой, но мощной структурой данных. Вы узнаете, как реализовать стек и для чего он применяется: от разворота строк до парсинга скобочных выражений.\n\n## Ключевые вопросы параграфа\n\n* Что такое стек и как он устроен?\n* Какие операции поддерживает стек и какова их сложность?\n* Где и как стек применяется в алгоритмах и повседневных задачах?\n\n## Определение стека\n\nСтек (stack) — структура данных, которая работает по принципу «последним пришёл, первым ушёл» (LIFO — last in, first out). Стек можно представить как некий контейнер, в котором элементы (например, числа, символы и так далее) могут быть добавлены в вершину, а затем извлечены только из вершины. В бытовом плане стек напоминает стопку тарелок. Тарелка, которую положили первой, в самый низ, будет использована последней.\n\n![algorithms](https://yastatic.net/s3/education-portal/media/Algosy_9_4_b8f5e64d21.svg)\n\nСуществуют различные реализации стека. Например, стек может быть реализован на массиве, на односвязном списке, на двусвязном списке и так далее. В параграфе будем говорить о реализации стека на односвязном списке.\n\nОсновные операции, которые можно производить со стеком, включают:\n\n* Добавление элемента в вершину стека (push) — $O(1)$.\n* Удаление элемента из вершины стека (pop) — $O(1)$.\n* Возврат верхнего элемента без его удаления (peek) — $O(1)$.\n* Проверка стека на пустоту (isEmpty) — $O(1)$.\n\nСтоит отметить, что стек представляет собой список с элементами и указателя на вершину стека, указывающего на последний элемент, добавленный в стек.\n\nКаждый раз, когда в стек добавляется новый элемент, указатель на вершину смещается на следующий элемент. Когда элемент удаляется из вершины стека, указатель смещается на предыдущий элемент. Если указатель находится в конце стека, то стек пуст.\n\n## Что дальше\n\nТеперь вы знаете, как устроен стек и как использовать его для решения задач с вложенностью, отменой действий или разворотом данных. Вы освоили основные операции и поняли, почему стек важен в алгоритмах.\n\nДалее — структура, которая позволяет не просто сохранять элементы, а учитывать их приоритет. Вы узнаете, как работает очередь с приоритетом и где она применяется в реальных алгоритмах.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80787) этого параграфа и потренируйтесь.\n\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Стек — структура данных, работающая по принципу LIFO («последним пришёл — первым вышел»).\n* Основные операции: добавление (`push`), удаление (`pop`) и просмотр верхнего элемента (`peek`) — выполняются за `O(1)`.\n* Стек удобен для задач со вложенной структурой: проверка корректности скобок в выражениях (каждая открывающая должна иметь соответствующую закрывающую); поддержка рекурсии (системный стек вызовов); откат действий в редакторах и программах.\n* Прост в реализации и широко используется в парсерах, алгоритмах обхода графов и обработке выражений."])</script><script nonce="">self.__next_f.push([1,"62:T160e,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с очередью с приоритетом — структурой данных, где порядок обработки элементов определяется не временем добавления, а их «важностью» (приоритетом). Мы разберём, как устроена такая очередь, какие существуют варианты её реализации и почему она играет ключевую роль в алгоритмах на графах и системах планирования.\n\n## Ключевые вопросы параграфа\n\n* Как работает очередь с приоритетом и чем она отличается от обычной очереди?\n* Какими способами можно реализовать очередь с приоритетом (массив, куча, дерево)?\n* В каких алгоритмах и прикладных задачах применяется очередь с приоритетом?\n\n## Определение очереди с приоритетом\n\nОчередь с приоритетом — коллекция элементов, где каждый элемент имеет связанный с ним приоритет. Элемент с высшим приоритетом будет обрабатываться раньше, чем элементы с более низким приоритетом.\n\nОчередь с приоритетом можно реализовать различными способами, но обычно главные операции над ними:\n\n1. Вставка элемента с приоритетом — добавление элемента в очередь с учётом его приоритета. В зависимости от реализации, элемент может быть добавлен в начало, в середину очереди или конец.\n2. Извлечение элемента с наивысшим приоритетом — удаление элемента из очереди с наивысшим приоритетом. В зависимости от реализации, удаление может происходить из начала, середины очереди или конца.\n3. Просмотр элемента с наивысшим приоритетом — просмотр элемента с наивысшим приоритетом без его удаления.\n4. Поиск элемента с определённым приоритетом — поиск элемента в очереди с опредёленным приоритетом.\n\nОсновные способы реализации очереди с приоритетом включают в себя использование массивов, связанных списков, бинарных куч и древовидных структур. В зависимости от реализации, каждый из этих способов имеет свои преимущества и недостатки в терминах времени выполнения операций.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_9_5_68368001dc_e61e72b895.svg)\n\n## Что дальше\n\nТеперь вы знаете, как работает очередь с приоритетом и как выбирать её реализацию под конкретную задачу. Вы освоили базовые операции, поняли роль этой структуры в алгоритмах на графах (например, в алгоритме Дейкстры) и в задачах планирования.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80788) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Очередь с приоритетом позволяет обрабатывать элементы в порядке их важности, а не добавления.\n* Для реализации чаще всего используется структура «куча», обеспечивающая логарифмическое время на добавление и удаление.\n* Такая очередь используется во многих алгоритмах, например в поиске кратчайшего пути или планировании задач."])</script><script nonce="">self.__next_f.push([1,"63:T798,"])</script><script nonce="">self.__next_f.push([1,"В этой главе вы познакомились с ключевыми структурами данных, которые лежат в основе большинства алгоритмов. Вы поняли, как они устроены, чем отличаются друг от друга и какие задачи помогают решать.\n\nТеперь вы умеете:\n\n* Работать с односвязным списком — простой, но гибкой структурой для хранения и обхода элементов.\n\n* Использовать множества и словари для быстрого поиска, проверки принадлежности и хранения пар «ключ —\u0026nbsp;значение».\n\n* Применять стек и очередь с приоритетом в задачах, где важен порядок обработки или приоритет выполнения.\n\n* Использовать дэк (двустороннюю очередь) — структуру, объединяющую свойства очереди и стека, для симметричной работы с данными.\n\n* Выбирать подходящую структуру данных под задачу и оценивать эффективность операций: вставки, удаления, поиска.\n\nВы увидели, как структура данных влияет на производительность и читаемость алгоритма, и научились применять эти знания на практике.\n\nВ следующих параграфах вы научитесь применять это на практике — решать задачи, анализировать сложность и сравнивать подходы в реальных условиях."])</script><script nonce="">self.__next_f.push([1,"64:T40b1,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с процессом решения задач по программированию: от понимания условия и проектирования алгоритма до реализации, тестирования и анализа результатов.\n\n## Ключевые вопросы параграфа\n\n* Какие шаги проходит программист при решении алгоритмической задачи?\n* Как проверить корректность и эффективность своего решения до его сдачи?\n\n## Пять простых шагов для решения задачи по программированию\n\nЧтобы рассказать, как работает наша система автоматической оценки, мы по шагам разберём две простые задачи. А заодно покажем несколько распространённых проблем и способы их преодоления.\n\nИтак, решение задач по программированию состоит из пяти шагов:\n\n* **Разбор условия задачи.** Формулировка задачи указывает формат ввода и вывода, ограничения для данных ввода и использования памяти. От вас требуется написать быструю программу, которая уложится в ограничения по времени и использованию памяти.\n\n* **Проектирование алгоритма.** Когда вы поняли, в чём состоит задача, начинайте проектировать алгоритм. Не забудьте доказать, что он работает правильно.\n\n* **Реализация алгоритма.** Когда алгоритм спроектирован, его можно реализовать в вашем языке программирования.\n\n* **Тестирование и отладка.** Тестирование — это искусство поиска багов. Отладка — это искусство устранения багов. Когда программа готова, приступайте к тестированию! А если обнаружите баг — исправьте его и протестируйте программу снова.\n\n* **Отправка программы на оценку.** Когда программа протестирована, сдайте её системе оценки. Если вы увидите сообщение `OK`, значит всё в порядке. Если нет — возвращайтесь к предыдущим шагам.\n\n### Разбор условий задачи\n\nДля начала прочтите формулировку задачи. В неё входят описание вычислительной части, ограничения по времени и использованию памяти и несколько демонстрационных тестов. Убедитесь, что вы понимаете, как вывод соотносится с вводом в каждом из демонстрационных примеров.\n\nЕсли ограничения по времени и памяти не указаны прямо в формулировке задачи, используются следующие значения по умолчанию.\n\n* **Ограничение по времени (с):** 1\n* **Ограничение памяти:** 512 Mb\n\n### Проектирование алгоритма\n\nКогда вы разработали алгоритм, докажите, что он работает верно, и попробуйте оценить время выполнения с помощью самых сложных вводных данных, указанных в секции об ограничениях.\n\nЕсли ваш ноутбук выполняет около $10^8$–$10^9$ операций в секунду, и максимальный размер набора данных в описании задачи $n = 10^5$, тогда алгоритм с квадратичным временем выполнения вряд ли уложится в ограничение по времени (так как $n^2 = 10^{10}$), в то время как решение с временем выполнения $O(n\\log n)$ сможет это сделать. Тем не менее решение с $O(n^2)$ подойдёт, если $n=1\\,000$ и если $n=100$.\n\nСработать могут даже решения с $O(n^3)$. Хотя для некоторых трудных задач в книге полиномиальные алгоритмы и остаются неизвестными, решение с временем выполнения $O(2^nn^2)$ может уложиться в ограничение по времени при $n$ ниже $20$.\n\n### Реализация алгоритма\n\nНачните реализацию алгоритма на одном из языков программирования, которые поддерживаются нашей системой автоматической оценки. Напоминаем, это: `C++`, `Java`, `Python3`.\n\nДля `C++`, `Java`, и `Python3` есть примеры (авторские решения) с правильным решением задачи, учитывающие ее ограничения. Они тратят максимум 1/3 заданного лимита по времени и максимум 1/2 по памяти.\n\n\u003c!--Вы также можете использовать другие языки. Для них мы рассчитали множители ограничений по времени.\nОднако мы не гарантируем, что на других языках существует правильное решение конкретной задачи, которое укладывается в эти ограничения.--\u003e\n\n\u003c!-- В приложении перечислены версии компиляторов и флаги, используемые системой оценки.}\\stepikcourseonly{\\href{https://stepik.org/lesson/63139/step/13?unit=40268}{Здесь} перечисляются версии компиляторов и флаги, используемые системой оценки.} Мы советуем использовать те же флаги компилятора при локальном тестировании. Это увеличит вероятность того, что ваша программа поведёт себя одинаково и на вашем компьютере, и на компьютере для тестирования (заметьте, что программа с багами может работать по-разному при компиляции на разных устройствах — или даже при одном и том же компиляторе с разными флагами --\u003e\n\n### Тестирование и отладка\n\nСдавать вашу реализацию на оценку, не проверив её, — это плохая идея!\n\n* Начните с маленьких наборов данных и убедитесь, что ваша программа выдаёт верный результат со всеми предложенными наборами данных.\n* Затем проверьте, сколько времени занимает обработка большого набора данных.\n\n#### Оценка времени\n\nДля оценки времени выполнения имеет смысл реализовать ваш алгоритм как функцию — например, `solve(dataset)` — и потом реализовать дополнительную процедуру `generate()`, которая выдаст большой набор данных.\n\nНапример, если ввод задачи — это последовательность целых чисел длиной $1 \\le n \\le 10^5$, тогда сгенерируйте последовательность длиной $10^5$, передайте её функции `solve()` и убедитесь, что программа выдаёт правильный результат.\n\n#### Проверка ограничивающих значений и экстремальных случаев\n\nПроверьте ограничивающие значения, чтобы можно было гарантировать, что программа правильно обрабатывает и короткие (например, из 2 элементов), и длинные последовательности (например, из 105105 элементов).\n\nЕсли последовательность целых чисел от 00 до 106106 даётся в качестве ввода — проверьте, как ваша программа ведёт себя с последовательностью 0,0,…,00,0,…,0 или с 106,106,…,106106,106,…,106. После этого проверьте программу на случайном наборе данных.\n\nДополнительно советуем проверить экстремальные случаи: пустой набор данных, три точки на одной строке, дерево из одного узла и так далее.\n\n#### Стресс-тестирование\n\nУбедившись, что ваша программа выполняет все эти тесты, переходите к стресс-тестированию.\n\n1. Реализуйте медленный, но простой и верный алгоритм.\n2. Проверьте, выдают ли две программы одинаковый результат, — однако обратите внимание, что это не применимо к задачам, в которых вывод не уникален.\n3. Сгенерируйте случайные тестовые сценарии, а также тесты с изменением параметров — например, с использованием только маленького диапазона больших чисел, строки с одной буквой `a` или только двумя разными буквами (вместо строк, использующих все буквы латинского алфавита) и так далее.\n4. Подумайте, какие ещё тесты могут быть в каком-то смысле необычными.\n\nНапример, если вы генерируете графы, попробуйте генерировать древовидные, несвязные, полные, двудольные и так далее.\n\n* Если вы генерируете древовидные графы, попробуйте генерировать пути, двоичные деревья, звезды и так далее.\n* Если вы генерируете целые числа, попробуйте генерировать и простые, и составные числа.\n\n### Использование системы проверки\n\nКогда вы закончили тестирование, сдавайте вашу программу на проверку.\n\n1. Перейдите на страницу, где сдаются задания, и создайте новое выполненное задание.\n2. Загрузите файл с вашей программой (обязательно загрузите исходный файл, а не готовое приложение).\n3. После этого система оценки скомпилирует вашу программу и использует набор тщательно продуманных тестов, чтобы убедиться, что программа выдаёт правильный результат для всех тестов и что она укладывается в ограничения по времени и памяти.\n4. В большинстве случаев оценка занимает около минуты, но в редких случаях, когда серверы загружены, может потребоваться больше времени. Пожалуйста, наберитесь терпения. После загрузки решения можно спокойно уходить со страницы.\n5. В качестве результата вы получите обратную связь от системы оценки. Вам нужно получить вердикт `OK` — он обозначает, что ваша программа прошла все тесты.\n\nСообщения `Wrong answer`, `Time limit exceeded`, `Memory limit exceeded` означают, что программа не прошла тест по одной из этих причин.\n\n* Если ваша программа даёт сбой, проходя один из первых двух тестовых сценариев, система оценки скажет вам об этом и покажет тестовый сценарий и вывод вашей программы. Это должно помочь вам использовать правильный формат ввода/вывода.\n* В остальных случаях система оценки не будет показывать вам тестовый сценарий, который ваша программа не смогла выполнить.\n\n## Что дальше\n\nТеперь вы понимаете, как проходит полный цикл работы над задачей: от разбора условия до уверенного тестирования решения. Вы научились не только писать алгоритмы, но и проверять их корректность и производительность.\n\nДалее — простейшая задача, с которой удобно начать практику. Вы увидите, как её можно решить на C\\+\\+, Java и Python 3, и попробуете реализовать свой первый рабочий код.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Решение задачи по программированию проходит через пять ключевых этапов: разбор условия, проектирование алгоритма, реализация, тестирование и анализ результатов.\n* Оценка корректности и эффективности алгоритма помогает убедиться, что решение работает правильно и укладывается в заданные ограничения.\n* Хорошее тестирование — это не просто проверка на примерах, а систематический подход: граничные случаи, случайные данные, стресс-тесты."])</script><script nonce="">self.__next_f.push([1,"65:T1a58,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте простейшую задачу «Сумма двух чисел» и познакомитесь с тем, как она реализуется на C\\+\\+, Java и Python. Это хороший первый шаг: вы увидите, как выглядит рабочее решение и как оформлять код, пригодный для тестирования и анализа.\n\n## Ключевые вопросы параграфа\n\n* Как выглядит корректное решение самой простой задачи на разных языках программирования?\n* Что важно учитывать при оформлении и тестировании даже самых базовых программ?\n\n## Разбор примера\n\nРассмотрим совсем простую задачу.\n\n* Входные данные: Целые числа $a$ и $b$ на одной строке (разделённые пробелом).\n* Выходные данные: Сумма $a$ и $b$.\n* Ограничения: $0 \\le a, b \\le 9$.\n* Пример\n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n9 7\n\n|\n\n16\n\n||\n|#\n\n* Ограничение по времени (с): 1 секунда\n* Ограничение по памяти: 512 Mb.\n\nПоскольку задача решается в одно действие, шаг ``Спроектировать алгоритм`` мы пропустим и перейдём сразу к псевдокоду.\n\n```cpp\nSumOfTwoDigits(a, b):\n    return a + b\n```\n\nТак как псевдокод не уточняет ввод $a$ и $b$, ниже мы приводим решения для языков ``C++``, ``Java`` и ``Python3``, а также рекомендации по компиляции и реализации.\n\nВы можете скопировать и вставить код в файл, скомпилировать, запустить и протестировать с разными данными, а затем сдать исходный файл в систему проверки.\n\nРазумеется, мы рассчитываем, что вы знакомы с основами одного из языков программирования, который используется в нашей системе тестирования: ``C++``, ``Python3``, ``Java``.\n\n### ``C++``\n\u003c!-- %-[C++]\\hfill\n\\afivebookonly{\\mycppfilesmall{starters/sum_of_two_digits_book.cpp}}\n\\afourbookonly{\\mycppfile{starters/sum_of_two_digits_book.cpp}}\n%\\end{minipage} --\u003e\n```cpp\n#include \u003ciostream\u003e\n\nint sum_of_digits(int first, int second) {\n    return first + second;\n}\n\nint main() {\n    int a = 0;\n    int b = 0;\n    std::cin \u003e\u003e a;\n    std::cin \u003e\u003e b;\n    std::cout \u003c\u003c sum_of_digits(a, b);\n    return 0;\n}\n```\n\n### ``Java``\n\u003c!-- %-[Java]\\hfill\n\\afivebookonly{\\myjavafilesmall{starters/SumOfDigits.java}}\n\\afourbookonly{\\myjavafile{starters/SumOfDigits.java}}\n%\\end{minipage} --\u003e\n```java\nimport java.util.Scanner;\n\nclass SumOfTwoDigits {\n    static int sumOfTwoDigits(int first_digit, int second_digit) {\n        return first_digit + second_digit;\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int a = s.nextInt();\n        int b = s.nextInt();\n        System.out.println(sumOfTwoDigits(a, b));\n    }\n}\n```\n\n### ``Python3``\n\u003c!-- %-[Python3]\\hfill\n\\afivebookonly{\\mypythonfilesmall{starters/sum_of_two_digits_book.py}}\n\\afourbookonly{\\mypythonfile{starters/sum_of_two_digits_book.py}}\n%\\end{minipage} --\u003e\n```python\ndef sum_of_digits(first_digit, second_digit):\n    return first_digit + second_digit\n\nif __name__ == '__main__':\n    a, b = map(int, input().split())\n    print(sum_of_digits(a, b))\n```\n\nВаша цель — реализовать алгоритм, который даёт верный результат с ограничениями по времени и памяти и при любом вводе. Нет необходимости проверять, что входные данные соответствуют ограничениям, — например, в задаче `Сумма двух чисел` вам не нужно следить за тем, чтобы целые числа $a$ и $b$ действительно были однозначными (это гарантировано).\n\n## Что дальше\n\nТеперь вы разобрались, как выглядит самая простая задача и как оформить корректное решение на разных языках программирования. Это важный шаг: вы научились уверенно работать с вводом, выводом и базовой логикой программы.\n\nДалее — задача посложнее. Она потребует не только корректной реализации, но и оценки эффективности. Вы увидите, почему наивный алгоритм не всегда подходит, и научитесь искать более быстрые решения.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80761) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Даже у простой задачи есть структура: ввод, обработка, вывод.\n* Важно уметь оформить решение понятно и корректно, чтобы можно было уверенно работать с ним, проверять и развивать его дальше.\n"])</script><script nonce="">self.__next_f.push([1,"66:T832d,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте задачу, в которой требуется найти максимальное попарное произведение элементов массива. На её примере вы научитесь оценивать эффективность алгоритма, избегать переполнений и проводить стресс-тестирование, чтобы находить скрытые ошибки.\n\n## Ключевые вопросы параграфа\n\n- Почему наивное решение не всегда укладывается в ограничение по времени?\n- Как реализовать быстрый и надёжный алгоритм для вычисления максимального попарного произведения?\n- Зачем нужно стресс-тестирование и как оно помогает найти ошибки, незаметные при обычной проверке?\n\n## Разбор задачи\n\nРазберём чуть более сложную задачу. Итак, вам дана последовательность неотрицательных целых чисел $a_1, \\dots, a_{n}$. Вычислите\n\n$$\\max\\limits_{1 \\le i \\neq j \\le n}a_i \\cdot a_j \\, .\n$$\n\nОбратите внимание, что $i$ и $j$ должны быть разными, хотя в каких-то случаях можно наблюдать, что $a_i=a_j$.\n\n- Формат ввода: Первая строка содержит целое число $n$. Следующая строка содержит $n$ неотрицательных целых чисел $a_1, \\dotsc, a_{n}$ (разделены пробелами).\n- Формат вывода: Максимальное попарное произведение.\n- Ограничения: $2 \\le n \\le 2\\cdot10^5$; $0 \\le a_1, \\dots, a_{n} \\le 2\\cdot 10^5$.\n- Примеры\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr/\u003e1 2 3\n\n|\n\n6\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n10\u003cbr/\u003e7 5 14 2 8 8 10 1 2 3\n\n|\n\n140\n\n||\n|#\n\n## Наивный подход\n\nНаивный способ решить задачу `Максимальное произведение` — перебрать все возможные пары вводных элементов $A[1\\dotsc n]=[a_1,\\dotsc, a_n]$ и найти пару, которая даёт наибольшее произведение.\n\n```cpp\nMaxPairwiseProductNaive(A[1..n]):\n    product = 0\n    for i from 1 to n\n        for j from 1 to n\n            if i != j\n                if product \u003c A[i] * A[j]\n                    product = A[i] * A[j]\n    return product\n```\n\nЭтот код можно оптимизировать и сократить следующим образом.\n\n```cpp\nMaxPairwiseProductNaive(A[1..n]):\n    product = 0\n    for i from 1 to n\n        for j from i+1 to n\n            product = max(product, A[i] * A[j])\n    return product\n```\n\nРеализуйте этот алгоритм, используя ваш любимый язык программирования. Если вы используете `C++`, `Java` или `Python3`, вам могут пригодиться начальные заготовки (для всех задач из хендбука мы предлагаем стартовые заготовки с использованием этих трёх языков в интерфейсе тестирующей системы). С другими языками вам понадобится сделать работу с нуля.\n\nСтартовые заготовки решений для `C++`, `Java` и `Python3` представлены ниже.\n\n### `C++`\n\n\u003c!-- \\afourbookonly{\\mycppfile{starters/max_pairwise_product.cpp}}\n\\afivebookonly{\\mycppfileverysmall{starters/max_pairwise_product.cpp}} --\u003e\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n#include \u003calgorithm\u003e\n\nint MaxPairwiseProduct(const std::vector\u003cint\u003e\u0026 numbers) {\n    int max_product = 0;\n    int n = numbers.size();\n\n    for (int first = 0; first \u003c n; ++first) {\n        for (int second = first + 1; second \u003c n; ++second) {\n            max_product = std::max(max_product,\n                numbers[first] * numbers[second]);\n        }\n    }\n\n    return max_product;\n}\n\nint main() {\n    int n;\n    std::cin \u003e\u003e n;\n    std::vector\u003cint\u003e numbers(n);\n    for (int i = 0; i \u003c n; ++i) {\n        std::cin \u003e\u003e numbers[i];\n    }\n\n    std::cout \u003c\u003c MaxPairwiseProduct(numbers) \u003c\u003c \"\\n\";\n    return 0;\n}\n```\n\n### `Java`\n\n\u003c!-- \\afourbookonly{\\myjavafile{starters/MaxPairwiseProduct.java}}\n\\afivebookonly{\\myjavafileverysmall{starters/MaxPairwiseProduct.java}} --\u003e\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class MaxPairwiseProduct {\n    static int getMaxPairwiseProduct(int[] numbers) {\n        int max_product = 0;\n        int n = numbers.length;\n\n        for (int first = 0; first \u003c n; ++first) {\n            for (int second = first + 1; second \u003c n; ++second) {\n                max_product = Math.max(max_product,\n                    numbers[first] * numbers[second]);\n            }\n        }\n\n        return max_product;\n    }\n\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner(System.in);\n        int n = scanner.nextInt();\n        int[] numbers = new int[n];\n        for (int i = 0; i \u003c n; i++) {\n            numbers[i] = scanner.nextInt();\n        }\n        System.out.println(getMaxPairwiseProduct(numbers));\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(InputStream stream) {\n            try {\n                br = new BufferedReader(new\n                    InputStreamReader(stream));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n\n}\n```\n\n### `Python`\n\n\u003c!--\\afourbookonly{\\mypythonfile{starters/max_pairwise_product.py}}\n\\afivebookonly{\\mypythonfileverysmall{starters/max_pairwise_product.py}} --\u003e\n\n```python\ndef max_pairwise_product(numbers):\n    n = len(numbers)\n    max_product = 0\n    for first in range(n):\n        for second in range(first + 1, n):\n            max_product = max(max_product,\n                numbers[first] * numbers[second])\n\n    return max_product\n\n\nif __name__ == '__main__':\n    _ = int(input())\n    input_numbers = list(map(int, input().split()))\n    print(max_pairwise_product(input_numbers))\n```\n\nПосле проверки вы можете увидеть такое сообщение:\n\n\u003cpre\u003e\nFailed case #4/17: time limit exceeded\n\u003c/pre\u003e\n\nДело в том, что мы проверяем ваше решение на тестовых примерах — это помогает убедиться, что программа работает быстро и без ошибок. В результате мы, как правило, знаем, какие ошибки вы допустили. Сообщение выше говорит о том, что предложенная программа превышает ограничение по времени в 4-м тестовом примере из 17.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Почему решение не укладывается в ограничение по времени?\n\n`MaxPairwiseProductNaive` выполняет порядка $n^2$ шагов при последовательности длиной $n$. При максимальном возможном значении $n=2\\cdot 10^5$ количество шагов будет порядка $4\\cdot 10^{10}$. Так как большинство современных компьютеров выполняют около $10^8$–$10^9$ базовых операций в секунду (разумеется, это зависит от компьютера), выполнение `MaxPairwiseProductNaive` может занять десятки секунд. Это превысит временное ограничение задачи.\n\nНам нужен более быстрый алгоритм!\n\n## Быстрый алгоритм\n\nА что если внимательнее рассмотреть более мелкие примеры— скажем, $[5,6,2,7,4]$?\n\nЭврика! Достаточно помножить два самых больших элемента массива — $7$ и $6$.\n\nТо есть нам достаточно просканировать последовательность лишь дважды. При первом сканировании мы найдем самый большой элемент, затем — второй по величине.\n\n```cpp\nMaxPairwiseProductFast(A[1..n]):\n    index_1 = 1\n    for i from 2 to n\n        if A[i] \u003e A[index_1]\n            index_1 = i\n    index_2 = 1\n    for i from 2 to n\n        if A[i] != A[index_1] and A[i] \u003e A[index_2]\n            index_2 = i\n    return A[index_1] * A[index_2]\n```\n\n## Тестирование и отладка\n\n1. Реализуйте этот алгоритм и протестируйте его на вводе $A=[1,2]$.\n2. Как и ожидалось, алгоритм выводит $2$.\n3. Затем проверьте на вводе $A=[2,1]$. На удивление, алгоритм выводит $4$.\n4. Изучив код, вы обнаружите, что после первого цикла $index_1=1$.\n5. Далее алгоритм инициализирует $index_2$ значением $1$, и цикл for не обновляет $index_2$.\n6. В результате перед возвратом $index_1=index_2$.\n7. Чтобы этого избежать, необходимо изменить псевдокод следующим образом:\n\n```cpp\nMaxPairwiseProductFast(A[1..n]):\n    index_1 = 1\n    for i from 2 to n\n        if A[i] \u003e A[index_1]:\n            index_1 = i\n    if index_1 = 1\n        index_2 = 2\n    else:\n        index_2 = 1\n    for i from 1 to n\n        if A[i] != A[index_1] and A[i] \u003e A[index_2]\n            index_2 = i\n    return A[index_1] * A[index_2]\n```\n\nОпробуйте этот код на маленьких наборах данных $[7,4,5,6]$, чтобы убедиться, что он выдает правильные результаты. Затем попробуйте ввод.\n\n\u003cpre\u003e\n2  \n100000 90000  \n\u003c/pre\u003e\n\n### Вывод\n\nМожет оказаться, что программа выдает что-то вроде $410\\,065\\,408$ или даже отрицательное число вместо правильного результата — $9\\,000\\,000\\,000$. Вероятнее всего, это вызвано целочисленным переполнением. Например, на языке `C++` такое большое число, как $9\\,000\\,000\\,000$, не умещается в стандартный тип `int`, который занимает 4 байта на большинстве компьютеров и варьируется от $-2^{31}$ до $2^{31}-1$ при\n\n$$2^{31}=2\\,147\\,483\\,648 \\,.\n$$\n\n### Тип `int64_t`\n\nСоответственно, вместо использования типа `int` в `C++` при вычислении произведения и сохранении результата вам нужно использовать тип `int64_t`. Это предотвратит целочисленное переполнение, так как тип `int64_t` занимает 8 байтов и хранимые значения варьируются от $-2^{63}$ до $2^{63}-1$ при\n\n$$2^{63}=9\\,223\\,372\\,036\\,854\\,775\\,808 \\, .\n$$\n\n### Тест\n\nПротестируйте вашу программу с большими наборами данных, например с массивом $A[1 \\dotsc 2 \\cdot 10^5]$, где $A[i]=i$ для всех $1 \\le i \\le 2 \\cdot 10^5$. Это можно сделать двумя способами:\n\n- Создать массив в программе и передать его `MaxPairwiseProductFast` (чтобы не считывать его из стандартного ввода).\n- Создать отдельную программу, которая запишет такой массив в файл `dataset.txt`. Затем передать этот набор данных вашей программе из консоли:\n\n\u003cpre\u003e\nyourprogram \u003c dataset.txt\n\u003c/pre\u003e\n\nУбедитесь, что при обработке данных ваша программа укладывается в ограничение по времени и выдаёт верный результат: $39\\,999\\,800\\,000$. Теперь вы можете быть уверенным, что ваша программа работает!\n\nОднако система оценки снова ругается:\n\n\u003cpre\u003e\nFailed case #5/17: wrong answer\n\u003c/pre\u003e\n\nНо как создать такой тестовый сценарий, который приведет к сбою программы и поможет понять, что с ней не так?\n\n### А в чём ошибка?\n\nВероятно, вас интересует, почему мы не предоставили 5-й набор данных из 17 — тот, который привел к сбою программы? Причина проста: в реальности вам не будут показывать тестовые примеры.\n\nДаже опытные программисты при решении задач с алгоритмами часто совершают ошибки, которые трудно обнаружить. Поэтому важно научиться находить баги как можно раньше. Когда авторы этой книги только начинали программировать, они ошибочно полагали, что почти все их программы правильные. Сейчас же мы знаем, что при первом запуске наши программы почти никогда не верны.\n\nКогда разработчик уверен в работе своей программы, он зачастую использует всего лишь несколько примеров для тестирования.\n\n- Если результаты выглядят приемлемо, он считает свою работу законченной — но это путь к катастрофе.\n- Если вы хотите убедиться, что ваша программа работает всегда, то советуем тщательно подобрать примеры для тестирования.\n\nРеализация алгоритмов, а также их тестирование и отладка будут бесценным навыком для вашей будущей карьеры программиста.\n\n### Стресс-тестирование\n\nПредставляем вам стресс-тестирование — технику, которая позволяет генерировать тысячи тестовых сценариев. С её помощью можно найти тот, из-за которого провалилось ваше решение.\n\nСтресс-тестирование состоит из четырёх частей:\n\n- Реализация алгоритма.\n- Альтернативная, банальная и медленная, но правильная реализация алгоритма для той же самой задачи.\n- Генератор случайных тестов.\n- Бесконечный цикл, генерирующий тесты и передающий их обоим вариантам реализации для сравнения результатов. Если результаты разнятся, выводятся оба результата и пример для тестирования, а программа останавливается. В ином случае цикл повторяется.\n\nСтресс-тестирование основано на идее, что две правильных реализации с каждым тестом должны приводить к одному ответу (при условии, что ответ на задачу уникален). Однако если одна из реализаций неправильна, должен существовать такой тест, который приводит к разным ответам.\n\nЕдинственный случай, при котором это не так, — когда в обеих реализациях есть одна и та же ошибка. Но это маловероятно — если ошибка не где-то в программе ввода/вывода, общей для обоих решений.\n\n- Действительно, если одно решение правильно, а другое — нет, то существует сценарий тестирования, при котором они различаются.\n- Если оба решения неверны, но баги отличаются — скорее всего, есть тест, при котором два решения дают разные результаты.\n\nПродемонстрируем стресс-тестирование `MaxPairwiseProductFast`, используя\n\n`MaxPairwiseProductNaive` в качестве тривиальной реализации:\n\n```cpp\nStressTest(N, M):\n    while true:\n        n = ... // случайное целое число между 2 и N\n        // создать массив A[1..n]\n        for i from 1 to n\n            A[i] = ... // случайное целое число между 0 и M\n        print(A[1..n])\n        result_1 = MaxPairwiseProductNaive(A)\n        result_2 = MaxPairwiseProductFast(A)\n        if result_1 = result_2:\n            print(\"OK\")\n        else:\n            print(\"Wrong answer:\", result_1, result_2)\n            return\n```\n\n### Разбор цикла `while`\n\nПредставленный выше цикл `while` сначала генерирует длину вводной последовательности $n$, случайное число между $2$ и $N$. Оно должно быть не менее $2$: формулировка задачи гласит, что $n \\ge 2$.\n\n1. Параметр $N$ должен быть достаточно маленьким, чтобы позволить нам рассмотреть множество тестов, несмотря на то, что наши решения медленные.\n2. Сгенерировав $n$, мы генерируем массив $A$ с $n$ целыми числами от $0$ до $M$ и выводим его, чтобы по ходу бесконечного цикла мы всегда знали, какой тест проходит сейчас. Это упростит нахождение ошибок в коде для генерации теста.\n3. Затем мы вызываем два алгоритма для $A$ и сравниваем результаты.\n4. Если результаты отличаются, мы их печатаем и останавливаемся. В ином случае мы продолжаем цикл while.\n\nДавайте запустим `StressTest(10, 100'000)` и скрестим пальцы в надежде, что он выдаст `Wrong answer`.\n\nДля нас это выглядит как-то так (результат может отличаться на вашем компьютере из-за другого генератора случайных чисел).\n\n\u003cpre\u003e\n...  \nOK  \n67232 68874 69499  \nOK  \n6132 56210 45236 95361 68380 16906 80495 95298  \nOK  \n62180 1856 89047 14251 8362 34171 93584 87362 83341 8784  \nOK  \n21468 16859 82178 70496 82939 44491  \nOK\n68165 87637 74297 2904 32873 86010 87637 66131 82858 82935  \nWrong answer: 7680243769 7537658370  \n\u003c/pre\u003e\n\nУра! Мы нашли пример, в котором `MaxPairwiseProductNaive` и `MaxPairwiseProductFast` приводят к разным результатам, и теперь можем проверить, что именно пошло не так. Затем мы отлаживаем это решение через этот пример, находим баг, исправляем его и повторяем стресс-тестирование.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Видите что-то подозрительное в найденном наборе данных?\n\nОбратите внимание, что генерировать тесты автоматически и проводить стресс-тестирование легко, но находить и исправлять баги — сложно. Прежде чем углубиться в отладку багов, давайте попробуем сгенерировать тестовый пример поменьше — это упростит нам работу. Для этого мы поменяем $N$ с 10 на 5 и $M$ с $100\\,000$ на $9$.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Почему мы сначала запустили `StressTest` с большими параметрами $N$ и $M$, а теперь хотим запустить с маленькими?\n\nЗатем мы заново начинаем стресс-тестирование и получаем следующее:\n\n\u003cpre\u003e\n...  \n7 3 6  \nOK  \n2 9 3 1 9\nWrong answer: 81 27  \n\u003c/pre\u003e\n\nМедленный алгоритм `MaxPairwiseProductNaive` даёт верный ответ $81$ ( $9 \\cdot 9 = 81$ ), но быстрый `MaxPairwiseProductFast` — неверный ($27$).\n\n\u003e **Остановитесь и подумайте:**\n\u003e Как может выйти, что `MaxPairwiseProductFast` выдаёт $27$?\n\nЧтобы избавиться от багов в первом решении, давайте проверим, какие два числа он считает наибольшими. Для этого мы добавим следующую строку перед `return` в функции `MaxPairwiseProductFast`:\n\n```Python\nprint(index_1, index_2)\n```\n\nКогда мы снова начинаем стресс-тестирование, мы получаем следующее:\n\n\u003cpre\u003e\n...  \n7 3 6  \nOK  \n2 9 3 1 9  \n2 3  \nWrong answer: 81 27  \n\u003c/pre\u003e\n\n{% cut \"Обратите внимание\" %}\n\nчто наши решения работали и давали сбой на одних и тех же примерах тестирования, так как мы ничего не меняли в генераторе тестов. Он использует псевдослучайные числа при создании тестов вместо действительно случайных.\n\n{% endcut %}\n\nЭто значит, что последовательность выглядит случайной, но она одинакова каждый раз, когда работает программа. Такое свойство удобно и важно.\n\nСоветуем вам использовать эту практику, потому что в детерминированных программах (тех, что всегда выдают одинаковый результат при одинаковых вводных данных) легче находить баги, чем в недетерминированных.\n\n### Индекс  $index_1=2$ и $index_2=3$\n\nДавайте теперь рассмотрим $index_1=2$ и $index_2=3$.\n\nЕсли мы обратим внимание на код для определения второго максимального числа, то заметим неочевидный баг. Когда мы использовали условие для $i$ (число не должно быть таким же, как предыдущее самое большое), вместо сравнения $i$ и $index_1$ мы сравнили $A[i]$ и $A[index_1]$.\n\nЭто означает, что второе максимальное число отличается от первого по значению, а не по индексу элемента, который мы выбрали для решения задачи. Так, наше решение не работает при любом тесте, в котором второе самое большое число равно первому.\n\nТеперь изменим условие: вместо\n\n```cpp\nA[i] != A[index_1]\n```\n\nмы используем\n\n```cpp\ni != index_1\n```\n\nПроведя стресс-тестирование еще раз, мы видим на экране шквал сообщений `OK`. Ждём минуту, пока нам не надоест, и заключаем, что `MaxPairwiseProductFast` наконец-то работает правильно!\n\nОднако не стоит останавливаться на этом, так как вы сгенерировали только очень маленькие тесты с $N=5$ и $M=10$. Теперь нужно проверить, работает ли наша программа при большем $n$ и бо́льших элементах массива. Таким образом, мы меняем $N$ на $1\\,000$ (при большем $N$ примитивное решение будет довольно медленным из-за квадратичного времени выполнения).\n\n1. Мы также меняем $M$ на $200\\,000$ и запускаем программу.\n2. Ещё раз наблюдаем, как экран заполняется сообщениями `OK`. Затем ждём минуту, а потом решаем, что `MaxPairwiseProductFast` действительно работает верно.\n3. После этого мы сдаём получившееся решение системе оценки и успешно проходим тест!\n\nКак вы можете заметить, даже при решении такой простой задачи как `Максимальное попарное произведение` сложно избежать труднораспознаваемых ошибок на этапе проектирования и реализации алгоритма.\n\nПриведённый ниже псевдокод — это пример более `надежного` способа реализации алгоритма.\n\n```cpp\nMaxPairwiseProductFast(A[1..n]):\n    index = 1\n    for i from 2 to n\n        if A[i] \u003e A[index]:\n            index = i\n    swap(A[index], A[n]) // поставим наибольшее значение в конец массива\n    index = 1:\n    for i from 2 to n - 1\n        if A[i] \u003e A[index]:\n            index = i\n    swap(A[index], A[n - 1]) // поставим второй по величине элемент предпоследним\n    return A[n - 1] * A[n]\n```\n\nВ этом хендбуке вы узнаете, как проектировать и реализовывать алгоритмы так, чтобы минимизировать вероятность ошибок. А заодно научитесь тестировать вашу реализацию.\n\n## Ещё более быстрый алгоритм\n\nАлгоритм `MaxPairwiseProductFast` находит два самых больших числа примерно за $2n$ сравнений.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Найдите два самых больших элемента в массиве за $1.5n$ сравнений.\n\nКогда вы решите эту задачу, вас ждет ещё более сложное упражнение. Попробуйте с ним справиться!\n\n\u003e Остановитесь и подумайте:\n\u003e Найдите два самых наибольших элемента в массиве за $n + \\lceil \\log_2 n \\rceil - 2$ сравнений.\n\nЕсли это упражнение показалось вам слишком простым, посмотрите задачи ниже. Они вполне могут оказаться на следующем собеседовании!\n\n### Упражнение 1\n\nДокажите, что не существует алгоритма, которому потребуется менее $n + \\lceil \\log_2 n \\rceil - 2$ сравнений, чтобы найти два самых больших элемента массива.\n\n### Упражнение 2\n\nКакой алгоритм найдёт три самых больших элемента быстрее всего?\n\n## Более компактный алгоритм\n\nЗадачу `Максимальное попарное произведение` можно решить с помощью следующего компактного алгоритма, который использует сортировку (в неубывающем порядке).\n\n```cpp\nMaxPairwiseProductBySorting(A[1..n]):\n    Sort(A)\n    return A[n-1]*A[n]\n```\n\nЭтот алгоритм делает даже больше, чем нам нужно: вместо того, чтобы найти два самых больших элемента, он сортирует весь массив. Поэтому его время выполнения $O(n\\log n)$, а не $O(n)$. Однако для таких ограничений ($2 \\le n \\le 2 \\cdot 10^5$) он достаточно быстрый, чтобы выполнить задачу за секунду и успешно пройти тесты в нашей системе оценки.\n\n## Что дальше\n\nТеперь вы увидели, как задача на попарное произведение помогает отработать сразу несколько важных умений: оценку сложности алгоритма, поиск оптимального решения, работу с переполнением и стресс-тестирование. Вы научились сравнивать наивные и быстрые реализации, находить баги и проверять программу на надёжность с помощью генератора случайных тестов.\n\nДалее — небольшой параграф с итогами: вспомним, что вы узнали в этой главе, и наметим, куда двигаться дальше.\n\nА пока закрепите материал на практике:\n\n- Отметьте, что урок прочитан, при помощи кнопки ниже.\n- Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n- Перейдите к [задачам](https://new.contest.yandex.ru/contest/80762) этого параграфа и потренируйтесь.\n- Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n- Даже в простой на первый взгляд задаче важно учитывать эффективность: наивный перебор может не уложиться в ограничение по времени.\n- Быстрый алгоритм позволяет решить задачу линейно, но требует аккуратности в работе с индексами и типами данных.\n- Стресс-тестирование помогает находить ошибки, которые не видны на демонстрационных примерах, и делает решение по-настоящему надёжным."])</script><script nonce="">self.__next_f.push([1,"67:T765,"])</script><script nonce="">self.__next_f.push([1,"В третьей главе вы начали практиковаться в решении задач, с которых обычно и начинается знакомство с алгоритмами. Эти задачи — простые по формулировке, но важные для понимания того, как устроен алгоритмический подход: от чтения условия до обоснованного и устойчивого решения.\n\nТеперь вы умеете:\n\n* Применять базовую структуру решения задач — от анализа входных данных до отправки итоговой программы.\n* Работать с вводом и выводом на разных языках программирования: C\\+\\+, Java и Python.\n* Понимать границы применимости наивных алгоритмов и видеть, когда требуется оптимизация.\n* Оценивать сложность решений и адаптировать их под ограничения по времени и памяти.\n* Использовать стресс-тестирование, чтобы находить ошибки и делать решения более надёжными.\n* Учитывать особенности языков и типов данных (например, защиту от переполнения в C\\+\\+).\n\nДалее вас ждёт глава 4. В ней вы познакомитесь с первыми последовательными алгоритмами и увидите на примерах вычисления чисел Фибоначчи, НОД и НОК, как освоенные здесь идеи начинают работать на практике."])</script><script nonce="">self.__next_f.push([1,"68:T7923,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы научитесь решать задачи, связанные с числами Фибоначчи — одной из самых известных числовых последовательностей в алгоритмах. Вы разберёте разные способы вычисления FnF_nFn​: от рекурсивного и итерационного до мемоизации и работы по модулю. А заодно поймёте, как оценивать эффективность решений и избегать переполнения целых чисел при работе с большими значениями Fₙ.\n\n## Ключевые вопросы параграфа\n\n* Как устроены числа Фибоначчи и какие есть способы их вычисления?\n* Почему важно учитывать время выполнения, типы данных и переполнение даже в простых задачах?\n* Что такое период Пизано и как он помогает находить остатки от огромных чисел Фибоначчи?\n\n## Числа Фибоначчи\n\nПрежде чем начать, коротко напомним, что числа Фибоначчи — числовой ряд, при котором каждое последующее число равно сумме двух предыдущих.\n\nТакие числа определяются рекурсивно:\n\n$$F_n=\\begin{cases} n \u0026 \\text{при $n$ равном 0 или 1}\\\\\nF_{n-2}+F_{n-1} \u0026 \\text{при $n \\ge 2$}\\end{cases}\n$$\n\nЭто приводит к следующему рекурсивному алгоритму:\n\n```cpp\nFibonacci(n):\n     if n \u003c= 1:\n        return n\n     else:\n        return Fibonacci(n−2)+Fibonacci(n−1)\n```\n\nРассмотрим совсем простую задачу.\n\n* Входные данные: Целое число $n$.\n* Выходные данные: $F_n$.\n* Ограничения: $0 \\le n \\le 45$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\n\n|\n\n2\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n10\n\n|\n\n55\n\n||\n|#\n\n### Решение 1: Рекурсивный алгоритм\n\nНиже мы описываем простую реализацию рекурсивного псевдокода для **Python**. В неё входит инструкция по обнаружению багов, которая выводит то, что вычисляется в данный момент. Мы пробуем вычислить $F_7$ с помощью этого кода.\n\n```python\ndef fibonacci(n):\n    if n \u003c= 1:\n        return n\n    else:\n        print(f'Computing F{n} recursively...')\n        return fibonacci(n - 2) + fibonacci(n - 1)\n\n\nprint(fibonacci(7))\n```\n\n```\nComputing F7 recursively...\nComputing F5 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\nComputing F4 recursively...\nComputing F2 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\nComputing F6 recursively...\nComputing F4 recursively...\nComputing F2 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\nComputing F5 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\nComputing F4 recursively...\nComputing F2 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\n13\n```\n\nКак видите, код даёт нам верный результат ($13$), но многие вычисления повторяются. Если вы решите вычислить $F_{150}$ с помощью этого кода, то Солнце потухнет раньше, чем компьютер выдаст вам результат.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Как вычислить $F_7$ вручную?\n\n### Решение 2: Итерационный алгоритм\n\nСкорее всего вы бы взяли лист бумаги и написали что-то вроде:\n\n$$\\begin{align*}\nF_0\u0026=0\\\\\nF_1\u0026=1\\\\\nF_2\u0026=0+1=1\\\\\nF_3\u0026=1+1=2\\\\\nF_4\u0026=1+2=3\\\\\nF_5\u0026=2+3=5\\\\\nF_6\u0026=3+5=8\\\\\nF_7\u0026=5+8=13\n\\end{align*}\n$$\n\nВполне разумно попросить компьютер вычислить $F_n$ таким же *итерационным* способом:\n\n```cpp\nFibonacci(n):\n    if n \u003c= 1:\n        return n\n    allocate an array F[0..n]\n    F[0] = 0\n    F[1] = 1\n    for i from 2 to n:\n        F[i] = F[i − 2] + F[i − 1]\n    return F[n]\n```\n\nПриблизительное количество операций, необходимых алгоритму, — $n$. Этот алгоритм хорошо работает на практике.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Можно ли обойтись без хранения всего массива?\n\nКак вы могли заметить, нет необходимости хранить все числа последовательности Фибоначчи: чтобы вычислить текущее число, достаточно знать два предыдущих.\n\n```cpp\nFibonacci(n):\n    if n \u003c= 1:\n        return n\n    previous = 0\n    current = 1\n    for iter in range(n-1):\n        oldPrevious = previous\n        previous = current\n        current = oldPevious + previous\n    return current\n```\n\n### Решение 3: Запоминание\n\nРекурсивный алгоритм требует так много времени, потому что он повторяет множество одинаковых вычислений: например `Fibonacci(7)` вызывает `Fibonacci(3)` пять раз. Не проще ли сохранить $F_3$, как только это значение вычислено, и при необходимости использовать сохранённое значение вместо того, чтобы вычислять его с нуля?\n\nТакой простой подход называется «мемоизация» — при вычислении чего-либо сохраните это в структуре данных, чтобы избежать повторных вычислений в будущем.\n\nДавайте добавим мемоизацию в рекурсивный алгоритм, чтобы сделать его практичнее.\n\n```cpp\ntable — некоторый ассоциативный контейнер (в table[i]  будем сохранять F[i])\n\nFibonacci(n):\n    if table[n] ещё не вычисляли:\n        if n \u003c= 1:\n            table[n] = n\n        else:\n            table[n] = Fibonacci(n−2)+Fibonacci(n−1)\n    return table[n]\n```\n\nПо сравнению с изначальным рекурсивным алгоритмом этот сделает максимум $n+1$ «серьёзных» рекурсивных вызовов: для каждого $0 \\le i \\le n$ первый вызов `Fibonacci(i)` вычисляет $F_i$, сохраняя в $table[i]$; затем все дальнейшие вызовы `Fibonacci(i)` становятся просто поиском по таблице.\n\n## Последняя цифра числа Фибоначчи\n\n* Формат ввода: Целое число $n$.\n* Формат вывода: Последняя цифра $F_n$.\n* Ограничения: $0 \\le n \\le 10^6$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\n\n|\n\n2\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n139\n\n|\n\n1\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n91239\n\n|\n\n6\n\n||\n|#\n\n\u003e Предупреждение: будьте аккуратны с целочисленным переполнением. Значение $F_{139}=50\\,095\\,301\\,248\\,058\\,391\\,139\\,327\\,916\\,261$ превосходит диапазон стандартных целочисленных типов, а количество цифр в $F_{91239}$ более $19\\,000$, но последняя точно 6.\n\n### Решение: Взять каждое промежуточное звено по модулю 10\n\nДля решения этой задачи мы вычислим $F_n$ и просто выведем последнюю цифру последовательности:\n\n```cpp\nFibonacciLastDigit(n):\n    if n \u003c= 1:\n        return n\n    F[0..n] — массив для промежуточных значений\n    F[0] = 0\n    F[1] = 1\n    for i from 2 to n:\n        F[i] = F[i − 1] + F[i − 2]\n    return F[n] mod 10\n```\n\n\u003e Обратите внимание, что числа Фибоначчи растут очень быстро. Например,\n\n$$F_{100}=354\\,224\\,848\\,179\\,261\\,915\\,075.\n$$\n\nТаким образом, если вы используете типы C\\+\\+ **int32** или **int64** для хранения $F$, вы быстро придёте к целочисленному переполнению. Если вы используете числа произвольной точности, например, **BigInteger** в Java или встроенные целые числа в Python, то вы заметите, что цикл проходит намного медленнее при повышающемся числе итераций.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Последняя цифра в $F_{102}$ — $6$ и последняя цифра в $F_{103}$ — $7$. Какова последняя цифра в $F_{104}$?\n\nНесложно увидеть, что последняя цифра в $F_{104}$ равна $3$, и она полностью определена последними цифрами в $F_{102}$ и $F_{103}$. Это подсказывает нам, как сделать алгоритм практичнее: вместо вычисления $F_n$ и использования последней цифры можно взять каждое промежуточное звено по модулю 10.\n\nГлавный посыл этой задачи: когда вам нужно вычислить результат последовательности арифметических операций по модулю $m$, берите результат каждой операции по модулю $m$.\n\nТак можно гарантировать, что числа, с которыми вы работаете,  будут маленькими (они уместятся в стандартный тип языка программирования, который вы предпочитаете) и что арифметические операции с ними будут выполняться быстро.\n\n```cpp\nFibonacciLastDigit(n):\n    if n \u003c= 1:\n        return n\n    F[0..n] — массив для промежуточных значений\n    F[0] = 0\n    F[1] = 1\n    for i from 2 to n:\n        F[i] = (F[i − 1] + F[i − 2]) mod 10\n    return F[n]\n```\n\n## Огромное число Фибоначчи\n\n![Algoritmy](https://yastatic.net/s3/education-portal/media/Algoritmy_3_0dff0b5b41_c365b250aa.svg)\n\n* **Формат ввода:** Целые числа $n$ и $m$.\n* **Формат вывода:** $F_n \\bmod{m}$.\n* **Ограничения:** $1 \\le n \\le 10^{14}$, $2 \\le m \\le 10^3$.\n* **Примеры**\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1 239\n\n|\n\n1\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n115 1000\n\n|\n\n885\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2816213588 239\n\n|\n\n151\n\n||\n|#\n\n*Предупреждение:*\n\n* $F_1 \\bmod{239}=1\\bmod{239}=1$.\n* $F_{115} \\bmod{1000}=483\\,162\\,952\\,612\\,010\\,163\\,284\\,885 \\bmod{1000} =885$.\n* $F_{2\\,816\\,213\\,588}$ содержит миллионы цифр, но $F_{2\\,816\\,213\\,588} \\bmod{239}=151$.\n\n### Решение 1: Период Пизано\n\nВ этой задаче $n$ может быть настолько большим, что алгоритму потребуется слишком много времени, чтобы пройти через все числа Фибоначчи $F_i$ для $i$ от $0$ до $n$. Чтобы понять, как решить эту задачу, не проходя через все числа $F_0, F_1, \\dotsc, F_n$, взгляните на таблицу ниже:\n\n![1](https://yastatic.net/s3/education-portal/media/1_a3ea272f09_69e1f2cfb4.webp)\n\n\u003e **Остановитесь и подумайте:**\n\u003e Вы могли заметить в таблице необычные свойства в последних двух рядах.\n\nОбе эти последовательности — периодические! Период для $m=2$ — $0 1 1$. Его длина — $3$. Для $m=3$ период будет $0 1 1 2 0 2 2 1$, и его длина — $8$.\n\n![2](https://yastatic.net/s3/education-portal/media/2_5a84e87768_658ad306de.webp)\n\nВ итоге, чтобы вычислить, например, $F_{2015} \\bmod{3}$, нам понадобится найти остальную часть $2015$ при делении на $8$. Так как $2015=251 \\cdot 8 + 7$, мы можем заключить, что $F_{2015} \\bmod{3} = F_{7} \\bmod{3}=1$.\n\nОказывается, что для любого целого числа $m \\ge 2$ последовательность $F_n \\bmod{m}$ будет периодической. Период всегда начинается с $0 1$. Он называется «период Пизано» (Фибоначчи также называют «Пизано»).\n\n### Упражнение 1\n\nКаким будет период $F_i \\bmod{5}$?\n\n### Упражнение 2\n\nДокажите, что для каждого числа $m$ последовательность $F_i \\bmod{m}$ будет периодической.\n\n### Упражнение 3\n\nДокажите, что период последовательности $F_i \\bmod{m}$ не превышает\u003cbr\u003e$m^2$.\n\nТаблица ниже демонстрирует, что последовательность $F_n \\bmod 10$ — периодическая. Последние цифры повторяются по периоду Пизано длиной $60$. Другими словами:\n\n$$F_n \\bmod 10 = F_{n \\bmod 60} \\bmod 10 \\, .\n$$\n\nНапример:\n\n![3](https://yastatic.net/s3/education-portal/media/3_e8f4183dec_fef380f042.webp)\n\nЧтобы доказать, что последние цифры чисел Фибоначчи периодические, обратите внимание на пары остатков по модулю $m$, следующих друг за другом чисел Фибоначчи:\n\n![4](https://yastatic.net/s3/education-portal/media/4_d1d78c7b28_703f29ef6c.webp)\n\nКаждую из колонок таблицы можно вычислить на основе предыдущей колонки\n\n$\\begin{bmatrix}\n  a\\\\\n  b\\\\\n\\end{bmatrix}$\n\nкак\n\n$\\begin{bmatrix}\n  b\\\\\n  (a+b) \\bmod m\\\\\n\\end{bmatrix}$.\n\nПо такой же логике колонка перед колонкой\n\n$\\begin{bmatrix}\n  a\\\\\n  b\\\\\n\\end{bmatrix}$\nбудет\n\n$\\begin{bmatrix}\n  (b-a) \\bmod m\\\\\n  a\\\\\n\\end{bmatrix}$.\n\nСледовательно, для любой колонки в таблице выше можно однозначно определить соседей слева и справа. А значит, из любой позиции можно заполнить всю таблицу.\n\nПоскольку остатков по модулю $m$ только $m$, есть только $m^{2}$ возможных пар остатков, то есть максимум $m^{2}$ возможных колонок. Таким образом, некоторые колонки в таблице повторяются и будут это делать до бесконечности.\n\n![5](https://yastatic.net/s3/education-portal/media/5_26c0c230fe_d13fbbffb7.webp)\n\n### Упражнение 4\n\nДокажите, что первая повторяющаяся колонка таблицы для $F_n \\bmod m$ будет\n\n$\n\\begin{bmatrix}\n  0\\\\\n  1\\\\\n\\end{bmatrix}\n$\n\u003cbr\u003e\n\n\u003e **Остановитесь и подумайте:**\n\u003e Почему период Пизано для $m=10$ будет $60$, а не $10^2=100$ — число всевозможных пар остатков по модулю $10$?\n\nЭто наводит нас на следующий простой псевдокод, который рассчитывает период Пизано $m$ для произвольного остатка по модулю $m$.\n\n```cpp\nPisanoPeriod(m):\n    current = 0\n    next = 1\n    period = 0\n    while True:\n        oldNext = next\n        next = (current + next) mod m\n        current = oldNext\n        period = period + 1\n        if current = 0 and next = 1:\n            return period\n```\n\nОбъединяя изложенные идеи, получаем приемлемое по скорости работы решение.\n\n### Решение 2: Быстрое возведение матрицы в степень\n\nЕщё один способ вычислить $F_n \\bmod m$ — обратить внимание на то, что уравнения\n\n$$\\begin{align*}\n F_n \u0026 = 0 \\cdot F_{n-1} + 1 \\cdot F_n\\\\\n F_{n+1} \u0026 = 1 \\cdot F_{n-1} + 1 \\cdot F_n\n\\end{align*}\n$$\n\nмогут быть представлены как умножение матрицы $2\\times2$ —\n$\\begin{bmatrix}\n 0 \u0026 1\\\\\n 1 \u0026 1\\\\\n\\end{bmatrix}$\n— и вектора\n$\\begin{bmatrix}\n F_{n-1}\\\\\n F_n\\\\\n\\end{bmatrix}$:\n\n$$\\begin{bmatrix}\nF_n\\\\\nF_{n+1}\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \u0026 1\\\\\n1 \u0026 1\\\\\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\nF_{n-1}\\\\\nF_n\\\\\n\\end{bmatrix}\n$$\n\nСледовательно:\n\n$$\\begin{bmatrix}\nF_n\\\\\nF_{n+1}\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \u0026 1\\\\\n1 \u0026 1\\\\\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\nF_{n-1}\\\\\nF_n\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \u0026 1\\\\\n1 \u0026 1\\\\\n\\end{bmatrix}^2\n\\cdot\n\\begin{bmatrix}\nF_{n-2}\\\\\nF_{n-1}\\\\\n\\end{bmatrix}\n=\n\\dots\n=\n\\begin{bmatrix}\n0 \u0026 1\\\\\n1 \u0026 1\\\\\n\\end{bmatrix}^n\n\\cdot\n\\begin{bmatrix}\nF_0\\\\\nF_1\\\\\n\\end{bmatrix}\n$$\n\nПоэтому $F_n$ — просто элемент справа вверху $n$-й степени матрицы\n$\nM=\n\\begin{bmatrix}\n0 \u0026 1\\\\\n1 \u0026 1\\\\\n\\end{bmatrix}\n$.\n\u003cbr\u003e\n\n\u003e **Остановитесь и подумайте:**\n\u003e Примитивный способ вычислить $M^n$ потребует $(n-1)$ умножений матриц. Получится ли у вас сделать это, ограничившись $O(\\log n)$ умножениями матрицы?\n\nМы продемонстрируем быстрое возведение в степень с помощью целых чисел вместо матриц.\n\nИмея целое число $x$, можно было бы примитивно вычислить $x^9$, используя умножение 8 раз. Однако есть и более быстрый способ вычислить $x^9$, используя умножение лишь 4 раза:\n\n$$\\begin{align*}\n y_1 \u0026= x \\cdot x,\\\\\n y_2\u0026=y_1 \\cdot y_1,\\\\\n y_3\u0026=y_2 \\cdot y_2,\\\\\n y_4 \u0026= y_3 \\cdot x.\n\\end{align*}\n$$\n\nВ целом, при чётном $n$ вычисление $x^n$ потребует выполнить умножение лишь еще один раз по сравнению с $y=x^{n/2}$, так как $x^n =x^ {n/2}  \\cdot x^{n/2}=y \\cdot y$. Если $n$ — нечетное, то вычисление $x^n$ потребует выполнить умножение лишь ещё два раза — по сравнению с $y=x^{(n-1)/2}$, так как $x^n=(x^ {(n-1)/2}  \\cdot x^{(n-1)/2}) \\cdot x=y \\cdot y \\cdot x$.\n\n```cpp\nFastIntegerExponentiation(x, n):\n    if n = 0:\n        return 1\n    if n % 2 == 0: # чётное значение\n        y = FastIntegerExponentiation(x, n/2)\n        return y * y \n    else: # нечётное значение\n        y = FastIntegerExponentiation(x, (n−1)/2)\n        return y * y * x \n```\n\nПоскольку каждый рекурсивный вызов `FastIntegerExponentiation` приводит к двум операциям умножения целых чисел и разделяет $n$ пополам, он выполнит максимум $2\\log n$ операций умножения.\n\n\u003e Говоря о числах Фибоначчи, напомним, что последовательность $F_n$ равна элементу в правом верхнем углу $M^n$.  Поскольку нас интересует $F_n$ по модулю $m$, мы просто берём каждый промежуточный результат по модулю $m$:\n\n```cpp\nFastMatrixExponentiation(D, n, m):\n    if n = 0:\n        return [[1, 0], [0, 1]] # единичная 2×2 матрица\n     if n % 2 == 0: # чётное значение\n        Y = FastMatrixExponentiation(D, n/2, m)\n        return Multiply2x2Matrices(Y, Y, m)\n     else:\n        Y = FastMatrixExponentiation(D, (n−1)/2, m)\n        Y2 = Multiply2x2Matrices(Y, Y, m)\n        return Multiply2x2Matrices(Y2, D, m)\n```\n\n```cpp\nMultiply2x2Matrices(A, B, m):\n   C[1][1] = (A[1][1]*B[1][1] + A[1][2]*B[2][1]) mod m\n   C[1][2] = (A[1][1]*B[1][2] + A[1][2]*B[2][2]) mod m\n   C[2][1] = (A[2][1]*B[1][1] + A[2][2]*B[2][1]) mod m\n   C[2][2] = (A[2][1]*B[1][2] + A[2][2]*B[2][2]) mod m\n   return C\n```\n\nНаконец, вычисление нужного значения выглядит следующим образом:\n\n```cpp\nFibonacciModuloM(n, m):\n M = [[0, 1], [1, 1]]\n P = FastMatrixExponentiation(M, n, m)\n return P[0][1]\n```\n\n## Последняя цифра суммы чисел Фибоначчи\n\n* Формат ввода: Целое число $n$.\n* Формат вывода: $(F_0+F_1+\\dotsb+F_n) \\bmod{10}$.\n* Ограничения: $0 \\le n \\le 10^{14}$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\n\n|\n\n4\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n100\n\n|\n\n5\n\n||\n|#\n\n**Подсказка.** Раз исчерпывающий поиск будет слишком медленным для этой задачи, попробуйте придумать формулу для $F_0+F_1+F_2+\\dotsb+F_n$. Для лучшего понимания поиграйте с маленькими значениями $n$. Затем используйте решение для предыдущей задачи.\n\n### Решение\n\nВ таблице ниже указаны первые одиннадцать чисел Фибоначчи и первые одиннадцать чисел $S_n=F_0+F_1+\\dotsm+F_n$.\n\n![6](https://yastatic.net/s3/education-portal/media/6_816551dd43_f37ba1673f.webp)\n\n\u003e **Остановитесь и подумайте:**\n\u003e Можете заметить сходства между последовательностями $F_0, \\dotsc, F_{10}$ и $S_0, \\dotsc, S_{10}$?\n\nПохоже, что $S_n=F_{n+2}-1$. Давайте докажем это по индукции. Это условие определённо выполняется для первого шага ($n = 0$), так как $S_0 = F_2 -1$.\n\n1. Для шага с индукцией предположим, что утверждение верно для $0,1,\\dotsc,n$, и докажем его для $n+1$:\n\n$$S_{n+1}=F_0+F_1+\\dotsm+F_n+F_{n+1}=S_n+F_{n+1}=F_{n+2}-1+F_{n+1}=F_{n+3}-1 \\, .\n$$\n\n2. Ещё один способ прийти к формуле $S_n=F_{n+2}-1$ — сложить равенства.\n\n$$\\begin{aligned}\n\u0026F_n       \u0026=\\quad\u0026F_{n+2}\u0026-\\quad\u0026{F_{n+1}}\\\\\n\u0026F_{n-1} \u0026=\\quad\u0026{F_{n+1}}\u0026-\\quad\u0026{F_{n}}\\\\\n\u0026F_{n-2} \u0026=\\quad\u0026{F_{n}}\u0026-\\quad\u0026{F_{n-1}}\\\\\n\u0026\\phantom{F_{n-2}} \u0026 \\vdots \u0026\u0026\\\\\n\u0026F_2      \u0026=\\quad\u0026{F_4}\u0026-\\quad\u0026{F_3}\\\\\n\u0026F_1      \u0026=\\quad\u0026{F_3}\u0026-\\quad\u0026{F_2}\\\\\n\u0026F_0      \u0026=\\quad\u0026{F_2}\u0026-\\quad\u0026F_1\\\\\n\\end{aligned}\n$$\n\nТак как элементы в правых частях взаимоуничтожаются, то сумма всех элементов справа — $F_{n+2}-F_1=F_{n+2}-1$, а сумма всех элементов слева будет $S_n$,\n\nТак задача сводится к тому, чтобы найти последнюю цифру в $F_{n+2}-1$. Благодаря предыдущей задаче мы знаем, как можно быстро это сделать: исходя из того, что период Пизано по модулю $10$ равен $60$, мы имеем\n\n$$F_{n+2} \\bmod 10 = F_{(n+2) \\bmod 60} \\bmod 10 \\, .\n$$\n\n## Последняя цифра частичной суммы чисел Фибоначчи\n\n* Формат ввода: Целые числа $m$ и $n$.\n* Формат вывода: $(F_m+F_{m+1}+\\dotsb+F_n) \\bmod{10}$.\n* Ограничения: $0 \\le m \\le n \\le 10^{14}$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3 7\n\n|\n\n1\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n10 10\n\n|\n\n5\n\n||\n|#\n\n### Решение\n\nСумма частичной суммы чисел Фибоначчи равна разнице между двумя частичными суммами:\n\n$$  F_0+F_1+F_2+F_3+F_4+F_5+F_6+F_7\n$$\n\n$$  -F_0                                   -F_1-F_2\n$$\n\n$$  =F_3+F_4+F_5+F_6+F_7\n$$\n\nБолее обобщённо,\n\n$$\\sum_{i=m}^{n}F_i = \\left(\\sum_{i=0}^{n}F_i\\right) - \\left(\\sum_{i=0}^{m-1}F_i\\right) \\, .\n$$\n\nБлагодаря предыдущей задаче мы знаем, как быстро вычислять префиксные, то есть первые элементы последовательности, суммы.\n\n## Последняя цифра суммы квадратов чисел Фибоначчи\n\n![Algoritmy](https://yastatic.net/s3/education-portal/media/Algoritmy_4_60e837783f_83764e3f70.svg)\n\n* Формат ввода: Целое число $n$.\n* Формат вывода: $F_0^2+F_1^2+\\dotsb+F_n^2 \\bmod{10}$.\n* Ограничения: $0 \\le n \\le 10^{14}$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7\n\n|\n\n3\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n73\n\n|\n\n1\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1234567890\n\n|\n\n0\n\n||\n|#\n\n* $F_0^2+\\dotsb+F_{7}^2=273$.\n* $F_0^2+\\dotsb+F_{73}^2=1\\,052\\,478\\,208\\,141\\,359\\,608\\,061\\,842\\,155\\,201$.\n\n**Подсказка.** Раз алгоритм исчерпывающего поиска будет слишком медленным для этой задачи ($n$ может доходить до $10^{14}$), нам нужно найти простую формулу для $F_0^2+F_1^2+\\dotsb+F_n^2$. Рисунок выше представляет сумму $F_1^2+F_2^2+F_3^2+F_4^2+F_5^2$ как площадь прямоугольника с вертикальным ребром $F_5=5$ и горизонтальным ребром $F_5+F_4=3+5=F_6$.\n\n### Решение\n\nРисунок выше подсказывает, что для каждого неотрицательного целого числа $n$\n\n$$F_0^2+F_1^2+\\dotsb+F_n^2=F_n \\cdot F_{n+1} \\, .\n$$\n\nМы докажем это по индукции. Для двух первых случаев $n=0$ и $n=1$ получается:\n\n$$F_0^2=0=F_0F_1 \\text{ and } F_0^2+F_1^2=1=F_1F_2 \\, .\n$$\n\nДля шага с индукцией предположим, что $n \\ge 2$. Так,\n\n$$ F_0^2+F_1^2+\\dotsb+F_n^2+F_{n+1}^2\n$$\n\n$$ =(F_0^2+F_1^2+\\dotsb+F_{n}^2)+F_{n+1}^2 \\tag{шаг индукции}\n$$\n\n$$ =F_nF_{n+1}+F_{n+1}^2\n =F_{n+1}(F_n+F_{n+1})\n =F_{n+1}F_{n+2} \\, .\n$$\n\nВ итоге остаётся вычислить последние цифры $F_n$ и $F_{n+1}$.\n\n## Что дальше\n\nТеперь вы умеете вычислять числа Фибоначчи разными способами: от наивной рекурсии до оптимизированных алгоритмов с мемоизацией, итерацией и быстрым модулем. Вы познакомились с понятием периода Пизано и научились искать остатки от огромных чисел — быстро и точно.\n\nДалее — задачи на наибольший общий делитель и наименьшее общее кратное. Вы познакомитесь с алгоритмом Евклида, поймёте, почему он работает, и научитесь использовать его для ускорения решения задач с делением.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80763) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Числа Фибоначчи можно вычислять по-разному — от наивной рекурсии до оптимизированных итерационных алгоритмов.\n* Важно уметь оценивать эффективность решений: простые на вид алгоритмы могут работать слишком долго.\n* Мемоизация и вычисление по модулю позволяют ускорить программу и избежать переполнения.\n* Даже в знакомых задачах важно думать об ограничениях, типах данных и тестах на больших входах."])</script><script nonce="">self.__next_f.push([1,"69:T3054,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с одной из самых фундаментальных задач в алгоритмах — вычислением наибольшего общего делителя (НОД) и наименьшего общего кратного (НОК). Вы узнаете, как устроен алгоритм Евклида, почему он работает так эффективно и как использовать его в более сложных задачах.\n\n## Ключевые вопросы параграфа\n\n* Как работает алгоритм Евклида и чем он лучше наивных подходов?\n* Как связаны НОД и НОК, и как их вычислить быстро даже для больших чисел?\n* Почему важно контролировать сложность алгоритма даже в задачах с простой формулировкой?\n\n## Наибольший общий делитель\n\n![Algoritmy_1_896ef556d4.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_1_896ef556d4_6b68c3f619.svg)\n\nНаибольший общий делитель $\\operatorname{GCD}(a,b)$ двух положительных целых чисел $a$ и $b$ — это самое большое целое число $d$, на которое можно поделить $a$ и $b$ без остатка.\n\nДвадцать три века назад греческий математик Евклид впервые описал, как найти самый большой общий делитель.Однако нам до сих пор неизвестно имя математика, разработавшего этот алгоритм за век до Евклида. Спустя много веков алгоритм Евклида ещё раз обнаружили индийские и китайские астрономы. Теперь эффективный алгоритм, вычисляющий наибольший общий делитель, — важный ингредиент для современных криптографических алгоритмов.\n\nВаша задача — использовать алгоритм Евклида для вычисления $\\operatorname{GCD}$.\n\n* Формат ввода: Целые числа $a$ и $b$ (разделённые пробелом).\n* Формат вывода: $\\operatorname{GCD}(a,b)$.\n* Ограничения: $1 \\le a, b \\le 2\\cdot 10^9$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n18 35\n\n|\n\n1\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n28851538 1183019\n\n|\n\n17657\n\n||\n|#\n\n- Числа 18 и 35 не обладают общими нетривиальными делителями.\n- $28851538=17657 \\cdot 1634$, $1183019=17657 \\cdot 67$.\n\n### Примитивный алгоритм для вычисления наибольшего общего делителя\n\nПростой, но ужасно медленный способ вычислить наибольший общий делитель:\n\n```cpp\nGCD(a, b):\n    for d от min(a,b) вниз до 1:\n        if a % d == 0 and b % d ==0: // d делит a и d делит b\n            return d\n```\n\n\u003e **Остановитесь и подумайте:**\n\u003e Если вы вычислили $\\operatorname{GCD}(a,b)$, можете ли вы сразу найти $\\operatorname{GCD}(a-b,b)$?\n\nРисунок к задаче даёт нам простую, но чрезвычайно важную подсказку: если и $a$, и $b$ можно разделить на $d$, значит и $a-b$ можно разделить на $d$. Оказывается, что верно и обратное.\n\n#### Упражнение 1\n\nДокажите, что $\\operatorname{GCD}(a,b)=\\operatorname{GCD}(a-b,b)$ при $a \\ge b \u003e 0$.\n\nЭто наблюдение позволяет нам вычислить наибольший общий делитель,отнимая меньшее число от большего снова и снова.В конце концов одно из чисел дойдет до нуля. В таком случае мы просто возвращаем другое число (если $c\u003e0$, то $\\operatorname{GCD}(c, 0)=c$).\n\n```cpp\nGCD(a, b):\n    while a \u003e 0 and b \u003e 0:\n        if a \u003e= b:\n            a = a−b\n        else:\n            b = b−a\n    return max(a,b)\n```\n  \n#### Упражнение 2\n\nНасколько этот алгоритм быстрый?\n\nЭтот алгоритм всё ещё слишком медленный. Например, при $a=10^9$ и $b=7$ он продолжает отнимать $b$ от $a$ — более миллиона раз (в то время как изначальный алгоритм находит наибольший общий делитель при $a=10^9$ и $b=7$ моментально), так как ему нужно только пройти через $d=7,\\dotsc,1$. Но не беспокойтесь. Сейчас мы сделаем наш алгоритм эффективнее.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Что мы получим в итоге, если мы продолжим отнимать $b=7$ \u003cbr\u003eот $a=10^9$?\n\nПравильно! Мы получим 6 — остаток $10^9$ при делении на 7.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Если вы вычислили $\\operatorname{GCD}(a,b)$, можете ли вы сразу же найти $\\operatorname{GCD}(a, a \\bmod b)$? Например, $10^9 \\bmod 7$ будет $1$. Каково отношение между $\\operatorname{GCD}(10^9,7)$ и $\\operatorname{GCD}(10^9,1)$?\n\n### Алгоритм Евклида\n\nСказанное выше приводит нас к алгоритму Евклида.\n\n```cpp\nGCD(a, b):\n    while a \u003e 0 and b \u003e 0:\n        if a \u003e= b:\n            a = a % b\n        else:\n            b = b % a\n    return max(a,b)\n```\n\nЭто быстрый алгоритм: при любых $a,b \\le 2 \\cdot 10^9$, он вычисляет их наибольший общий делитель мгновенно. Для значений $a, b$ в этом диапазоне количество итераций цикла ``while`` не превышает сотни. Обоснование этого утверждения можно построить на факте, что после каждой итерации одно из чисел становится как минимум в два раза меньше.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Докажите, что при $a \\ge b$ верно $a \\bmod{b} \u003c a/2$. Рассмотрите два случая: $b \\le a/2$ и $b \u003e a/2$.\n\nСледовательно, после максимум $\\log_2a + \\log_2b + 2$ итераций или $a$, или $b$ дойдёт до нуля. Так как $a, b \\le 2^{31}$, $\\log_2a + \\log_2b + 2 \u003c 64$.\n\nВ качестве последнего комментария мы подметим, что такой же алгоритм можно использовать рекурсивно, занимая всего три строки кода.\n\n```cpp\nGCD(a, b):\n    if a = 0 or b = 0:\n        return max(a,b)\n    return GCD(b,a mod b)\n```\n\n## Наименьшее общее кратное\n\n![Algoritmy_2_8dc420a17b.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_2_8dc420a17b_ed5011a44e.svg)\n\nНаименьшее общее кратное $\\operatorname{LCM}(a,b)$ для двух положительных целых чисел $a$ и $b$ — это самое маленькое целое число $m$, которое можно разделить и на $a$, и на $b$.\n\nРисунок выше демонстрирует $\\operatorname{LCM}$ для каждой пары чисел $6$, $10$ и $15$, а также наименьшее общее кратное для всех трёх. Рисунок ниже показывает наибольший общий делитель для этих же чисел.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Какова связь между $\\operatorname{LCM}(a,b)$ и $\\operatorname{GCD}(a,b)$?\n\n* Формат ввода: Целые числа $a$ и $b$ (разделённые пробелом).\n* Формат вывода: $\\operatorname{LCM}(a,b)$\n* Ограничения: $1 \\le a, b \\le 10^9$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n6 8\n\n|\n\n24\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n761457 614573\n\n|\n\n467970912861\n\n||\n|#\n\n— Среди всех положительных целых чисел, которые можно разделить и на 6, и на 8 (например, 48, 480 и 24), 24 — наименьшее число.\n— Совет: для деления целых чисел в **Python3** используйте **//** (вместо **/**)\n\n### Решение\n\nДля обоснования соотношения $\\operatorname{LCM}(a,b) = \\dfrac{a \\cdot b}{\\operatorname{GCD}(a,b)}$ рассмотрим разложение $a$ и $b$ на простые множители.\n\nЕсли простое $p$ входит в разложение $a$ в степени $\\alpha$ и в разложение $b$ — в степени $\\beta$, то $\\operatorname{GCD}(a,b)$ делится на $\\min(\\alpha, \\beta)$, а $\\operatorname{LCM}(a,b)$ должно делиться на $\\max(\\alpha, \\beta)$. Для завершения обоснования формулы стоит использовать соотношение $\\alpha + \\beta = \\min(\\alpha, \\beta) + \\max(\\alpha, \\beta)$.\n\n## Что дальше\n\nТеперь вы знаете, как эффективно вычислять наибольший общий делитель при помощи алгоритма Евклида — и почему он работает в разы быстрее наивных подходов. Вы также научились находить наименьшее общее кратное и увидели, как связаны эти два понятия. Всё это — основа для задач, в которых важно понимать делимость и оптимально работать с числами.\n\nДалее — короткое заключение, в котором мы подведём итоги главы и соберём всё, чему вы научились в задачах на Фибоначчи, НОД и НОК.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80764) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Алгоритм Евклида позволяет быстро находить наибольший общий делитель и работает значительно эффективнее наивных решений.\n* НОК удобно вычислять через НОД, используя формулу  LCM(a,b)= a⋅b​ / GCD(a,b).\n"])</script><script nonce="">self.__next_f.push([1,"6a:T3211,"])</script><script nonce="">self.__next_f.push([1,"В данном параграфе мы разберём основные понятия и определения теории графов — раздела математики, который изучает графы, их природу, структуры и алгоритмы. Также посмотрим, где можно встретить графы в реальной жизни. Вы узнаете, что такое вершины и рёбра, какие бывают виды графов (ориентированные, взвешенные, двудольные и другие) и где в реальной жизни встречаются графовые структуры. Мы обсудим базовые определения и научимся распознавать свойства графов — такие как связность, степень вершины, циклы и деревья.\n\n## Ключевые вопросы параграфа\n\n* Что такое граф и где он применяется в жизни и программировании?\n* Какие виды графов существуют и чем они отличаются?\n* Какие свойства графа важно учитывать при решении задач?\n\n## Определение графа\n\nГраф состоит из множества вершин, соединённых ребрами. По сути, рёбра и вершины — базовые понятия. Обычно граф обозначают $G(V, E)$, где $V$ — множество вершин, $E$ — множество рёбер/дуг. Проведём аналогию с картой метро, которую можно рассматривать как граф, где станции — вершины, а перегоны — рёбра. Другим примером может служить обычная карта, где населенные пункты — вершины графа, а рёбра — соединяющие их дороги. Генеалогические деревья, блок-схемы, схемы авиалиний и железных дорог — всё это примеры графов.\n\nРёбра и вершины графа могут иметь свои имена. Посмотрим на пример графа на рисунке ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_1_929d242645_397ff32e01.svg)\n\nГраф может быть ориентированным или неориентированным. В неориентированном графе рёбра не имеют направления, то есть движение по ним возможно в двух направлениях. В ориентированном графе рёбра обычно называют дугами. Пройти по дуге можно только в заданном направлении. Пример ориентированного графа приведён на рисунке ниже. В дальнейшем под понятием «граф» мы будем понимать именно неориентированный граф.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_2_56c529e672_4601754748.svg)\n\nВ графе могут быть рёбра и дуги особого типа, которые входят и выходят из одной вершины. Такие рёбра и дуги называются петлями.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_3_83ebd64d58_e810adbeea.svg)\n\nМежду рёбрами и вершинами в графах существуют отношения смежности и инцидентности. Термин смежность применяется к объектам одного вида — смежными между собой могут быть вершины и рёбра. Одна вершина смежна другой, если они соединены дугой или ребром. Одно ребро смежно другому ребру, если у них есть общая вершина, из которой они выходят.\n\nПонятие инцидентности применяется к рёбрам и вершинам. Ребро инцидентно вершине, если это ребро выходит из вершины.\n\nПомимо обычных графов, существуют ещё графы особого вида. Например, мультиграф — граф, у которого может быть несколько кратных рёбер или дуг. Пример ориентированного и неориентированного мультиграфа приведён на рисунке ниже.\n\n![algorithms_10.1_1](https://yastatic.net/s3/education-portal/media/Algosy_10_1_1_3c07d40d45.svg)\n\n![algorithms_10.1_2](https://yastatic.net/s3/education-portal/media/Algosy_10_1_2_1cb0d473d4.svg)\n\nРёбрам графа, при необходимости, можно задать веса. В таком случае граф становится взвешенным или нагруженным. В качестве веса может выступать, например, расстояние между городами. На рисунке ниже показан пример взвешенного графа.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_6_eef5b3c93b_b1706499af.svg)\n\nВ рамках данного параграфа нам также понадобится знать определение двудольного графа. Как следует из названия, граф состоит из двух долей, в каждой из которых никакие две вершины не смежны. На рисунке ниже можно увидеть, что вершины 1, 2 и 3 принадлежат одной доле, а вершины 4 и 5 другой.\n\n![algorithms_10.1_3](https://yastatic.net/s3/education-portal/media/Algosy_10_1_3_706b7fd1d0.svg)\n\nКак вы думаете, а может ли граф вообще не содержать ребер? Да, такое бывает. В этом случае говорят о нуль-графе.\n\nА может быть и обратная ситуация, когда граф содержит все возможные ребра или дуги. Такие графы называются полными. Посмотрите на пример полного графа ниже.\n\n![algorithms_10.1_4](https://yastatic.net/s3/education-portal/media/Algosy_10_1_4_4f826a7512.svg)\n\n\u003e **Остановитесь и подумайте:**\n\u003e Сколько рёбер может быть в полном неориентированном графе? А в ориентированном?\n\nДвудольный граф также может быть полным. Полный двудольный граф — граф, содержащий все возможные рёбра или дуги. Пример полного двудольного графа изображён ниже.\n\n![algorithms_10.1_5](https://yastatic.net/s3/education-portal/media/Algosy_10_1_5_882ab61e61.svg)\n\nВ графе можно построить путь — последовательность связанных рёбер, которые соединяют вершины графа. Цикл — путь, который начинается и заканчивается в одной и той же вершине.\n\nА может ли в графе отсутствовать цикл? Да, может, и в этом случае речь о таком графе как дерево. Дерево — граф без циклов.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_10_ea6aa4dd51_9c5c630afb.svg)\n\nГрафы могут быть связными и не связными. Связный граф тот, в котором от всех вершин до каждой существует путь. Пример несвязного графа приведён на рисунке ниже.\n\n![algorithms_10.1_6](https://yastatic.net/s3/education-portal/media/Algosy_10_1_6_4cfd17ccd1.svg)\n\nПри этом в ориентированном графе говорят о сильной и слабой связности. Ориентированный граф называется:\n\n* слабо связным - если его неориентированный аналог является связным;\n* сильно связным - если всякая вершина v достижима из любой вершины u.\n\nОчевидно, что любой сильно связный граф, также является и слабо связным.\n\nВажно отметить, что графы имеют свои характеристики. Например, для вершин графа существует понятие степени. Степень вершины — число инцидентных этой вершине рёбер. Обычно степень вершины обозначают функцией $d(v)$. На рисунке ниже, $d(1)=1$, $d(2)=3$, $d(3)=2$, $d(4)=2$.\n\n![algosy_10_1_7](https://yastatic.net/s3/education-portal/media/algosy_10_1_7_550cd04177_3c88a0fd8c_2_9953b925b1.svg)\n\nВ ориентированном графе говорят про полустепени исхода и захода. Под полустепенью исхода понимается количество дуг, выходящих из вершины. Под полустепенью захода понимают число дуг, заходящих в вершину. Обычно, полустепень исхода обозначают $d-(v)$, а полустепень захода — $d+(v)$.\n\nЕсли речь про петли, то в случае неориентированного графа она учитывается как два ребра, а в случае ориентированного для вершины эта дуга учитывается и в полустепени исхода, и в полустепени захода.\n\n### Упражнение\n\nДля ориентированного графа, изображенного на рисунке 2 посчитайте полустепени исхода и захода.\n\n## Что дальше\n\nТеперь вы понимаете, как устроены графы и почему они важны для алгоритмов. Вы узнали, что графы могут описывать карты, деревья, схемы и связи между объектами, а также познакомились с их разновидностями и свойствами.\n\nДалее — узнаем, как хранить граф в памяти компьютера. Разберёмся с матрицами и списками, сравним их по эффективности и применимости к разным задачам.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Граф состоит из вершин и рёбер, которые задают структуру связей между объектами.\n* Графы бывают ориентированные, неориентированные, взвешенные, полные, деревья и другие.\n* Важные свойства графов: связность, степень вершин, наличие циклов, двудольность.\n* Графы широко применяются — от транспортных схем до анализа социальных сетей."])</script><script nonce="">self.__next_f.push([1,"6b:T1e11,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы узнаете, почему у графов нет единого «правильного» способа хранения и как выбор представления влияет на эффективность алгоритмов. Мы рассмотрим матрицу смежности, матрицу инцидентности, список смежности и список рёбер, сравним их сильные и слабые стороны и разберём, в каких случаях удобно использовать каждый из вариантов.\n\n## Ключевые вопросы параграфа\n\n* Какие основные способы хранения графа применяются на практике?\n* Как различия в представлениях отражаются на скорости работы алгоритмов и потреблении памяти?\n* По каким критериям выбирать подходящее представление графа для конкретной задачи?\n\n## Способ хранения графа\n\nВ прошлом параграфе мы обсудили основные определения теории графов. Однако, чтобы работать с графами, необходимо их как-то хранить в памяти компьютера. К сожалению, не существует универсального способа хранения графов, потому что каждый имеет свои достоинства и недостатки.\n\nРассмотрим такой способ хранения графа, как матрица смежности. Матрица смежности представляет собой матрицу, где по строкам и столбцам располагаются номера вершин. Если рёбра между вершинами отсутствует, то на пересечении $i$-ой строки и $j$-ого столбца ставится 0. Если ребро есть, то ставят 1. Пример графа и его матрицы смежности приведён на рисунке ниже.\n\n![algorithms](https://yastatic.net/s3/education-portal/media/Algosy_10_2_1_7617dcf042.svg)\n\n\u003e **Остановитесь и подумайте:**\n\u003e Всегда ли матрица смежности для неориентированного графа симметрична?\n\nРассмотрим пример матрицы смежности для ориентированного графа. В целом, отличий не так много, кроме того, что матрица смежности перестала быть симметричной. Подумайте, почему.\n\n![algorithms](https://yastatic.net/s3/education-portal/media/Algosy_10_2_2_3922a34dee.svg)\n\nТакже при работе с графами применяется и матрица инцидентности. По столбцам располагаются рёбра, а по строкам номера вершин. На пересечении $i$-ой вершины и $j$-ого ребра ставится 1, если одним из концов ребра $j$ была вершина $i$. Пример приведён ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/Algosy_10_2_3_081fdd851d.svg)\n\nВ случае ориентированного графа матрица инцидентности не сильно меняется, за исключением того, что на пересечении $i$-ой вершины и $j$-ого ребра ставится 1, когда дуга $j$ входит в вершину $i$ и -1, когда выходит.\n\n![algorithms](https://yastatic.net/s3/education-portal/media/Algosy_10_2_4_b927706993.svg)\n\nДля экономии памяти может использоваться список смежности, который представляет из себя набор списков по числу вершин в графе. Каждый список представляет из себя перечисление всех смежных данной вершине.\n\n![algorithms](https://yastatic.net/s3/education-portal/media/Algosy_10_2_5_10ca9b1f4e.svg)\n\nВ случае ориентированного графа список смежности выглядит аналогичным образом.\n\n![algosy](https://yastatic.net/s3/education-portal/media/Algosy_10_2_6_13df1441ed.svg)\n\nВ некоторых случаях удобнее использовать список рёбер. Он представляет собой перечисление всех рёбер графа. Пример приведен ниже.\n\n![algorithms](https://yastatic.net/s3/education-portal/media/Algosy_10_2_7_718fc6e381.svg)\n\n### Упражнение 1\n\nПодумайте, а какой вариант хранения графа в памяти компьютера самый оптимальный. Почему?\n\n## Что дальше\n\nТеперь вы умеете представлять граф в памяти с помощью разных структур: матриц и списков. Вы знаете, в каких задачах использовать матрицу смежности, а где лучше подойдёт список смежности или рёбер.\n\nДалее — перейдём к алгоритмам работы с графами. Начнём с базового действия — обхода графа, то есть последовательного просмотра всех его вершин и рёбер.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80790) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Граф можно хранить с помощью матрицы смежности, инцидентности, списка смежности или списка рёбер.\n* Выбор способа зависит от размера графа, плотности связей и требований к скорости доступа.\n* Нет универсального способа — у каждого формата есть свои плюсы и минусы.\n* Эффективное представление графа — залог быстрого и надёжного алгоритма."])</script><script nonce="">self.__next_f.push([1,"6c:T2efc,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с двумя базовыми способами обхода графа — обходом в глубину (Depth-First Search, DFS) и обходом в ширину (Breadth-First Search, BFS). Эти алгоритмы позволяют находить пути, проверять достижимость вершин и анализировать структуру графа. Кроме того, они часто становятся строительными блоками для более сложных методов работы с графами. Вы научитесь реализовывать оба способа, понимать, когда применять каждый из них, и избегать типичных ошибок при обходе.\n\n## Ключевые вопросы параграфа\n\n* Как работает обход графа в глубину и в ширину и в чём между ними разница?\n* Что важно учитывать при реализации DFS и BFS?\n* Как не попасть в бесконечный цикл и правильно отслеживать посещённые вершины?\n\n## Алгоритмы на графах\n\nПришла пора рассмотреть первые алгоритмы на графах. К классическим алгоритмам относятся обходы графов. Под обходом графа обычно понимают процесс систематического просмотра всех вершин или рёбер графа, чтобы найти некоторые вершины, удовлетворяющие определённым условиям. Мы рассмотрим обход в ширину и обход в глубину.\n\nОбход в глубину заключается в систематическом просмотре вершин графа и прохождении его ветвями. Иными словами, идея поиска в глубину — когда возможные пути по рёбрам, выходящим из вершин, разветвляются, нужно сначала полностью исследовать одну ветку и только потом переходить к другим веткам (если они останутся нерассмотренными).\n\nОпишем алгоритм поиска в глубину:\n\n* Шаг 1. Все вершины графа отмечаем, как не посещенные. Выбирается первая вершина и помечается как посещённая.\n* Шаг 2. Для последней помеченной как посещённой вершины выбирается смежная вершина, которая первая помеченная как не посещенная, и ей присваивается значение посещённой. Если таких вершин нет, то берётся предыдущая помеченная вершина.\n* Шаг 3. Повторяем шаг 2 до тех пор, пока все вершины не будут помечены как посещённые.\n\nПример реализации приведён ниже.\n\n```cpp\nDFS(graph, v, used):\n    used[v] = 1\n    for (var u : graph[v])\n        if (!used[u])\n           DFS(graph, u, used)\n```\n\n### Упражнение\n\nПопробуйте выполнить алгоритм поиска в глубину пошагово для графа.\n\nОбратите внимание, сейчас мы посмотрели на рекурсивную реализацию. Конечно, преимущество использования рекурсивного подхода заключается в простоте его написания, однако, рекурсивный подход имеет свои ограничения.\n\nМожно переписать алгоритм поиска в глубину с использованием особых структур данных. Например, стека.\n\nОпишем алгоритм поиска в глубину в нерекурсивной форме:\n\n* Шаг 1. Все вершины графа отмечаем, как не посещённые. Выбирается первая вершина и помечается как посещённая. Эту вершину кладем в контейнер — стек.\n* Шаг 2. Пока стек не пустой:\n  * Извлекаем последнюю добавленную вершину.\n  * Просматриваем все смежные с ней не посещённые вершины и помещаем их в стек.\nПорядок выхода вершин из стека и будет порядком обхода вершин графа.\n\nПример работы не рекурсивного алгоритма можно посмотреть на анимации.\n\n![algosy_10_3_1](https://yastatic.net/s3/education-portal/media/algosy_10_3_1_obhod_v_glubinu_1ccda4e3e8_5a7296ac85.gif)\n\nПример реализации приведён ниже.\n\n```cpp\nDFS(graph, v, used):\n    stack q\n    q.push(v)\n    used[v] = 1\n    while(!q.empty())\n      v = q.front()\n      q.pop()\n      for (var to : graph[v]):\n        if (!used[to]):\n          used[to] = true\n          q.push(to)\n```\n\nЕщё один способ обхода графа — обход в ширину. Основное его отличие в том, что сначала исследуются смежные вершины, а уже потом вершины на следующем уровне. Иначе говоря, сначала исследуются все вершины, смежные с начальной вершиной (вершина с которой начинается обход). Эти вершины находятся на расстоянии 1 от начальной. Затем исследуются все вершины на расстоянии 2 от начальной, затем все на расстоянии 3 и так далее. Обратим внимание, что при этом для каждой вершины сразу находятся длина кратчайшего маршрута от начальной вершины.\n\nОпишем алгоритм поиска в ширину:\n\n* Шаг 1. Всем вершинам графа присваивается значение не посещённой. Выбирается первая вершина и помечается как посещённая и заносится в очередь.\n* Шаг 2. Посещается первая вершина из очереди (если она не помечена как посещённая). Все её соседние вершины заносятся в очередь. После этого она удаляется из очереди.\n* Шаг 3. Повторяется шаг 2 до тех пор, пока очередь не станет пустой.\n\nПример реализации алгоритма можно посмотреть на анимации\n\n![algosy_10_3_2_](https://yastatic.net/s3/education-portal/media/algosy_10_3_2_obhod_v_shirinu_2b1ad1c070_ca75fd6fb5.gif)\n\nПример реализации приведён ниже.\n\n```cpp\nBFS(graph, v, used):\n    queue q\n    q.push(v)\n    used[v] = 1\n    while(!q.empty())\n      v = q.front()\n      q.pop()\n      for (var to : graph[v]):\n        if (!used[to]):\n          used[to] = true\n          q.push(to)\n```\n\n### Упражнение\n\nПодумайте, какое отличие алгоритма поиска в ширину от алгоритма поиска в глубину?\n\nАсимптотическая сложность алгоритма поиска в глубину и ширину — $O(V+E)$, где $V$ — число вершин, а $E$ — число рёбер и дуг. Обходы графов могут применяться для решения задач, связанных с теорией графов:\n\n* Волновой алгоритм поиска пути в лабиринте.\n* Волновая трассировка печатных плат.\n* Поиск компонент связности в графе.\n* Поиск кратчайшего пути между двумя узлами невзвешенного графа.\n* Поиск в пространстве состояний: нахождение решения задачи с наименьшим числом ходов, если каждое состояние системы можно представить вершиной графа, а переходы из одного состояния в другое — рёбрами графа.\n* Нахождение кратчайшего цикла в ориентированном невзвешенном графе.\n* Нахождение всех вершин и рёбер, лежащих на каком-либо кратчайшем пути между двумя вершинами.\n* Поиск увеличивающего пути в алгоритме Форда-Фалкерсона (алгоритм Эдмондса-Карпа).\n\n## Что дальше\n\nТеперь вы умеете реализовывать обходы графа — DFS и BFS — и использовать их для решения базовых задач, таких как проверка достижимости и построение пути. Вы научились работать с очередью и стеком, отмечать посещённые вершины и корректно обходить даже сложные структуры.\n\nДалее — задача на использование обходов. Вы узнаете, как при помощи DFS или BFS найти компоненты связности и почему важно запускать обход из каждой новой вершины.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80791) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* DFS и BFS — базовые алгоритмы, применимые ко многим задачам на графах.\n* DFS использует стек (в том числе неявный при рекурсии), а BFS — очередь.\n* Для корректного обхода важно отслеживать посещённые вершины.\n* Выбор между DFS и BFS зависит от задачи: от поиска пути до анализа структуры графа.\n"])</script><script nonce="">self.__next_f.push([1,"6d:T14cc,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы научитесь находить компоненты связности в неориентированном графе — группы вершин, внутри которых существует путь между любыми двумя. Эта задача возникает, например, при анализе социальных сетей, компьютерных сетей или при кластеризации данных. Мы разберём, как с помощью обхода в глубину (DFS) и в ширину (BFS) выделять такие компоненты и как эффективно реализовать алгоритм даже для больших графов.\n\n## Ключевые вопросы параграфа\n\n* Что именно называют компонентой связности в неориентированном графе?\n* Как применить DFS и BFS, чтобы выделить все компоненты?\n* Зачем обход нужно запускать от каждой непосещённой вершины?\n\n## Применение алгоритмов поиска в глубину и ширину\n\nАлгоритмы поиска в глубину и ширину находят широкое применение и могут использоваться в других алгоритмах. Рассмотрим один из таких алгоритмов для поиска компонент связности в графе. Под компонентой связности в графе понимают множество вершин графа достижимых попарно и рёбра их связывающие. Для поиска компонент связности необходимо из каждой не посещённой вершины запускать алгоритм обхода, накапливая результаты каждого в отдельный контейнер. Пример ниже поможет понять алгоритм.\n\n![algorithms_5.4_1.gif](https://yastatic.net/s3/education-portal/media/algorithms_5_4_1_51781b8912.gif)\n\nАсимптотическая сложность нахождения компонент связности в графе — O(V+E), где V — число вершин, а E — число рёбер и дуг.\n\n### Упражнение\n\nПопробуйте реализовать данный алгоритм.\n\n## Что дальше\n\nТеперь вы умеете находить компоненты связности в графе и применять для этого DFS или BFS. Вы поняли, почему одного обхода недостаточно и как обойти весь граф по частям.\n\nДалее — более сложные задачи, в которых нужно находить кратчайшие пути между вершинами. Вы узнаете, как работает алгоритм Дейкстры и в каких ситуациях его можно применять.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80792) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Компоненты связности — это группы вершин неориентированного графа, внутри которых существует путь между любыми двумя вершинами.\n* Чтобы найти все компоненты, используют обход графа: в глубину (Depth-First Search, DFS) или в ширину (Breadth-First Search, BFS), начиная каждый раз с новой не посещённой вершины.\n* Важно правильно отмечать посещённые вершины и учитывать номер компоненты, к которой они принадлежат.\n* Выделение компонент связности помогает понять структуру графа и служит основой для последующего анализа и алгоритмов кластеризации.\n"])</script><script nonce="">self.__next_f.push([1,"6e:T1d6b,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с алгоритмом Дейкстры — одним из самых известных алгоритмов на графах. Он позволяет находить кратчайшие пути от одной вершины до всех остальных в графе без отрицательных весов. Вы узнаете, как работает идея постепенного уточнения расстояний, научитесь реализовывать алгоритм шаг за шагом и поймёте, как восстанавливается путь.\n\n## Ключевые вопросы параграфа\n\n* Как устроен алгоритм Дейкстры и зачем нужны веса рёбер?\n* Почему алгоритм не работает с отрицательными весами?\n* Как восстановить кратчайший путь после завершения алгоритма?\n\n## Принцип работы алгоритма Дейкстры\n\nЗачастую в графах требуется находить между вершинами кратчайшие пути. Один из алгоритмов нахождения кратчайших путей от заданной вершины до любой другой — алгоритм Дейкстры. Алгоритм работает только для графов без рёбер отрицательного веса.\n\nАсимптотическая сложность нахождения компонент связности в графе — O(V\\+E), где V — число вершин, а E — число рёбер и дуг.\n\nОпишем принцип работы алгоритма Дейкстры:\n\n* Шаг 1. Всем вершинам, за исключением первой, присваивается вес равный бесконечности, а первой вершине — 0.\n* Шаг 2. Все вершины не посещены.\n* Шаг 3. Первая вершина объявляется текущей.\n* Шаг 4. Вес всех невыделенных вершин пересчитывается по формуле: вес невыделенной вершины есть минимальное число из старого веса данной вершины, суммы веса текущей вершины и веса ребра, соединяющего текущую вершину с невыделенной.\n* Шаг 5. Среди невыделенных вершин ищется вершина с минимальным весом. Если такова не найдена, то есть вес всех вершин равен бесконечности, то маршрута не существует. Следовательно, выход. Иначе, текущей становится найденная вершина. Она же выделяется.\n* Шаг 6. Если текущей вершиной оказывается конечная, то путь найден, и его вес есть вес конечной вершины.\n* Шаг 7. Переход на шаг 4.\n\nПример работы алгоритма показан на картинке ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_5_30980ce781_bfed21e61d.gif)\n\nПосмотрим на реализацию.\n\n```cpp\nDijkstra(graph, start, finish, used):\n    vector d(n, inf), p(n, -1)\n    n = len(graph)\n    graph[v] = 1\n    for (int i = 0; i \u003c n; ++i)\n      int v = -1\n      for (int j = 0; j \u003c n; ++j)\n        if (!used[j] and (v == -1 or d[j] \u003c d[v]))\n          v = j\n      used[v] = true\n      for (int j = 0; j \u003c len(graph[v]); ++j)\n        to = graph[v][i].vertex\n        len = graph[v][i].edge\n        if (d[v] + len \u003c d[to])\n          d[to] = d[v] + len\n          p[to] = v\n```\n\nАсимптотическая сложность алгоритма Дейкстры — $O(V^2+E)$, где $V$ — число вершин, а $E$ — число рёбер и дуг.\n\n### Упражнение 1\n\nПодумайте, как восстановить путь, используя введённый массив p?\n\n### Упражнение 2\n\nКак изменится кратчайший путь, если все веса рёбер увеличить на какое-то число?\n\n### Упражнение 3\n\nКак изменится кратчайший путь, если все веса рёбер увеличить в какое-то число раз?\n\n### Упражнение 4\n\nПодумайте, почему алгоритм работает только для графов без рёбер отрицательного веса?\n\n## Что дальше\n\nТеперь вы умеете находить кратчайшие пути в графах с помощью алгоритма Дейкстры. Вы научились пошагово уточнять расстояния до вершин, работать с массивом предков и восстанавливать путь. Вы также поняли, в каких случаях алгоритм применим, а в каких — нет.\n\nДалее — завершение главы. Мы кратко подведём итоги, сравним изученные подходы и обобщим стратегии, которые помогут вам уверенно решать задачи на графы.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80793) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Алгоритм Дейкстры находит кратчайшие пути от одной вершины до всех остальных в графе без отрицательных рёбер.\n* Идея алгоритма — постепенно уточнять расстояния, переходя от ближайших вершин к более дальним.\n* Для восстановления пути используется массив предков.\n* Алгоритм не работает корректно при наличии отрицательных весов — для таких случаев нужны другие подходы (например, Беллмана — Форда)."])</script><script nonce="">self.__next_f.push([1,"6f:T7d7,"])</script><script nonce="">self.__next_f.push([1,"В этой главе мы разобрали основы работы с графами — одной из ключевых структур в алгоритмах. Рассмотрели способы представления графа в памяти, их разновидности и области применения, а также освоили базовые алгоритмы: обходы в глубину и ширину, поиск компонент связности и вычисление кратчайших путей.\n\nТеперь вы умеете:\n\n* различать виды графов (направленные, ненаправленные, взвешенные, невзвешенные) и выбирать подходящее представление (список смежности, матрица);\n* выполнять обход в глубину и в ширину и понимать, в каких задачах они применимы;\n* находить компоненты связности с помощью обходов и отслеживать посещённые вершины;\n* использовать алгоритм Дейкстры для поиска кратчайших путей от одной вершины;\n* восстанавливать путь на основе массива предков и избегать ошибок в графах с отрицательными рёбрами.\n\nДалее — новая глава, в которой вы узнаете, как придумываются алгоритмы на практике. Мы разберём базовые техники проектирования: от полного перебора всех вариантов до жадных стратегий и пошаговых приближений к решению. Эти приёмы помогут вам научиться строить собственные алгоритмы."])</script><script nonce="">self.__next_f.push([1,"70:T1b25,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с одним из самых простых, но фундаментальных методов проектирования алгоритмов — полным перебором.\n\n## Ключевые вопросы параграфа\n\n* Что такое алгоритм полного перебора и когда его стоит применять?\n* Почему переборные алгоритмы считаются неэффективными?\n* Как метод ветвей и границ помогает ускорить перебор?\n\n## Основные методы проектирования алгоритмов\n\nЗа полвека программисты обнаружили, что многие алгоритмы основаны на схожих концептах, хотя и используются для решения разных проблем. Получается, основных методов проектирования алгоритмов относительно немного. Некоторые из них мы охватим в задачах, а пока расскажем о наиболее распространённых. Последующие примеры можно будет категоризировать по методологии проектирования.\n\nДля демонстрации мы рассмотрим очень простую ситуацию, с которой может столкнуться едва ли не каждый обладатель беспроводного домашнего телефона.\n\n### Метод полного перебора\n\nАлгоритм, использующий полный перебор (также этот метод называют «исчерпывающий поиск» или «метод грубой силы»), рассматривает все возможные варианты и находит определенное решение.\n\nЕсли бы вы искали телефон по такому алгоритму, то игнорировали бы звонок и проверяли бы каждый квадратный сантиметр вашего дома. Вряд ли вы бы успели взять трубку, — иначе вашей удаче можно позавидовать, — но исчерпывающий поиск гарантирует, что рано или поздно вы найдете телефон, где бы он ни был.\n\n``BruteForceChange`` — это алгоритм «грубой силы». Наши задачи включают несколько дополнительных примеров таких алгоритмов. Они самые легкие с точки зрения проектирования, но слишком медленные для решения более серьёзных задач, нежели самых маленьких. Мы советуем или избегать алгоритмов «грубой силы» или находить решения, которые ускоряют их работу.\n\n### Метод ветвей и границ\n\nЕсли рассмотреть варианты, предложенные алгоритмом «грубой силы», мы увидим, что многие из них можно опустить. Эта техника называется методом ветвей и границ.\n\nПредставьте, что вы прочёсываете первый этаж и слышите, как над вами звонит телефон. Значит, на первом этаже и в подвале можно больше не искать — и вы сэкономили себе время.\n\nХотя алгоритмы полного перебора и не подходят для построения эффективных алгоритмов, мы рекомендуем использовать их для стресс-тестирования — техники поиска ошибок в алгоритмах, подробнее о которой мы поговорим в [параграфе 4.3](https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie).\n\n## Что дальше\n\nТеперь вы знаете, как работает полный перебор и почему он не всегда подходит для сложных задач. Вы также познакомились с методом ветвей и границ — первым шагом к ускорению перебора.\n\nДалее — жадные алгоритмы. Вы узнаете, когда можно принимать решения на каждом шаге, не заглядывая вперёд, и почему это иногда приводит к оптимальному результату, а иногда — нет.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/79921) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Полный перебор перебирает все возможные варианты и гарантирует нахождение решения, если оно существует. Такой подход прост, но становится неэффективным при росте объёма входных данных.\n* Метод ветвей и границ помогает отсекать заведомо бесполезные варианты и ускорять перебор.\n* Несмотря на неэффективность, переборные алгоритмы полезны для тестирования и понимания структуры задач.\n"])</script><script nonce="">self.__next_f.push([1,"71:T2e56,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберётесь с жадными алгоритмами — стратегиями, которые на каждом шаге выбирают «самое выгодное» решение в надежде на общий успех. Мы увидим, когда такая тактика действительно работает, а когда — приводит к ошибкам. На примере задачи о бронировании переговорок вы научитесь оценивать и доказывать корректность жадных решений.\n\n## Ключевые вопросы параграфа\n\n* Что такое жадный алгоритм и в чём его идея?\n* Почему не всякая жадная стратегия приводит к оптимальному решению?\n* Как формализовать и доказать корректность жадного алгоритма?\n\n## Итерационный принцип алгоритмов\n\nМногие алгоритмы — это итерационные процедуры: с каждым повтором они делают выбор из определенного количества вариантов.\n\nНапример, для кассира задача «Размен» может быть представлена как последовательность решений: какую монету (из $d$ ценностей) вернуть первой, какую второй и так далее. Некоторые из этих вариантов приведут к правильному ответу, а некоторые — нет.\n\n### Принцип работы жадного алгоритма\n\nПри каждом повторе жадный алгоритм выбирает «самый привлекательный» вариант. Например, самый большой номинал из доступных монет. В случае с американскими деньгами ``Change`` использует номиналы четвертак (25 центов), дайм (10 центов), никель (5 центов) и пенни (1 цент), чтобы выдать сдачу, в данном порядке. Разумеется, мы показывали, как такой «жадный» подход приводит к неправильным результатам при добавлении монет некоторых новых номиналов.\n\n#### Пример с телефоном\n\nВ примере с телефоном «жадная» стратегия состояла бы в том, чтобы идти на звук, пока вы его не найдете. Но есть проблема: между вами и телефоном может оказаться стена (или хрупкая ваза). К сожалению, такие сложности часто возникают и в реальных задачах.\n\nВо многих случаях «жадный» подход выглядит естественным и очевидным, но может оказаться неправильным.\n\n#### Задача «Бронирование переговорки»\n\nВ задаче «Бронирование переговорки» вам дается несколько временных отрезков, и нужно выбрать как можно больше отрезков таким образом, чтобы ни один из них не пересекался с другим (отрезки пересекаются, если у них есть общая точка).\n\nНазвание задачи основано на следующей гипотетической ситуации. Представьте, что у вас есть зал для переговоров, и вам присылают заявки на бронирование 11 компаний.\n\n\u003ctable\u003e\n\u003ctr\u003e\n    \u003ctd\u003e1\u003c/td\u003e\n    \u003ctd\u003e01:00PM—05:00PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e2\u003c/td\u003e\n    \u003ctd\u003e01:45PM—03:00PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e3\u003c/td\u003e\n    \u003ctd\u003e01:00PM—02:00PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e4\u003c/td\u003e\n    \u003ctd\u003e05:45PM—06:15PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e5\u003c/td\u003e\n    \u003ctd\u003e01:45PM—02:15PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e6\u003c/td\u003e\n    \u003ctd\u003e04:00PM—04:30PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e7\u003c/td\u003e\n    \u003ctd\u003e03:00PM—04:00PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e8\u003c/td\u003e\n    \u003ctd\u003e03:00PM—05:45PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e9\u003c/td\u003e\n    \u003ctd\u003e01:30PM—03:15PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e10\u003c/td\u003e\n    \u003ctd\u003e02:30PM—03:30PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd\u003e11\u003c/td\u003e\n    \u003ctd\u003e04:45PM—05:30PM\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\nНельзя удовлетворить все запросы (так как некоторые из них пересекаются), но мы хотим удовлетворить как можно больше. Для этого мы представим входные данные более удобным способом.\n\n![ne_ochen_2_dbb705e077.svg](https://yastatic.net/s3/education-portal/media/ne_ochen_2_dbb705e077_f9bd6402c4.svg)\n\nТак как мы говорим о «жадных» стратегиях, давайте поэкспериментируем с разными «наиболее выгодными» подходами. Интуиция может нам подсказать, что нужно выбрать самый короткий отрезок, удалить пересекающиеся отрезки и повторить данное действие.\n\n\u003e **Остановитесь и подумайте**:\n\u003e Всегда ли это приведет к оптимальному решению?\n\n{% cut \"Ответ\" %}\n\nНе факт. В примере ниже такая «жадная» стратегия предлагает решение из одного отрезка посередине. Однако есть и решение из двух отрезков, которые не накладываются друг на друга.\n\n{% endcut %}\n\n![ne_ochen_3_ce1b90271e.svg](https://yastatic.net/s3/education-portal/media/ne_ochen_3_ce1b90271e_c15414ffff.svg)\n\nВозможно, логичнее было бы выбрать отрезок слева (тот, что начинается раньше всех), убрать все остальные и повторить данное действие.\n\n\u003e **Остановитесь и подумайте**:\n\u003e Всегда ли это приведет к оптимальному решению?\n\n{% cut \"Ответ\" %}\n\nУвы, но нет.\n\n{% endcut %}\n\n![ne_ochen_4_4130b9adb1.svg](https://yastatic.net/s3/education-portal/media/ne_ochen_4_4130b9adb1_a7bda24d45.svg)\n\n\u003e **Остановитесь и подумайте:**\n\u003e Может, есть и другие «жадные» подходы?\n\n{% cut \"Ответ\" %}\n\nСкажем, что $[l,r]$ — «чемпионский отрезок», если значение его правой границы самое маленькое из всех: для любого другого интервала $[l',r']$, будет актуально $r \\le r'$.\n\n{% endcut %}\n\nОказывается, что следующий «жадный» алгоритм максимизирует количество непересекающихся отрезков: выбрать чемпионский отрезок, убрать все пересекающиеся с ним отрезки, повторить выбор.\n\n### Упражнение\n\nДокажите, что если набор непересекающихся отрезков не содержит чемпионский отрезок,  то при замене первого отрезка в этом наборе на чемпионский мы получаем набор непересекающихся отрезков.\n\nВот мы и нашли оптимальную «жадную» стратегию. И действительно, если существует решение задачи, включающее в себя чемпионский интервал, мы можем выбрать этот интервал на первом шаге и решить задачу выбора непересекающихся отрезков из оставшихся.\n\nВ нашем примере алгоритм работает следующим образом.\n\n* Выбрать сегмент $3$ и отбросить сегменты $1$, $2$, $5$, и $9$.\n* Выбрать сегмент $10$ и отбросить сегменты $7$ и $8$.\n* Выбрать сегмент $6$.\n* Выбрать сегмент $11$.\n* Выбрать сегмент $4$.\n\n![ne_ochen_5_5397d5a742.svg](https://yastatic.net/s3/education-portal/media/ne_ochen_5_5397d5a742_348a1dff84.svg)\n\n## Что дальше\n\nТеперь вы понимаете, как устроены жадные алгоритмы и почему они могут быть одновременно простыми и опасными. Вы научились проверять, работает ли жадная стратегия в конкретной задаче, и даже доказывать её оптимальность.\n\nДалее — динамическое программирование. Это подход, который позволяет решать сложные задачи, разбивая их на подзадачи и используя уже найденные решения. Вы узнаете, как избежать повторных вычислений и добиться эффективности там, где перебор и жадность не справляются.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/79922) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Жадный алгоритм на каждом шаге выбирает наиболее выгодный вариант, не заглядывая вперёд. Такой подход прост и работает быстро, но не всегда даёт оптимальное решение.\n* Чтобы жадная стратегия была корректной, необходимо доказать, что локальный выбор всегда ведёт к глобально лучшему результату.\n* В некоторых задачах — например, при выборе максимального числа непересекающихся отрезков — удаётся найти и обосновать корректную жадную стратегию.\n"])</script><script nonce="">self.__next_f.push([1,"72:T2ae1,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы узнаете, как разбивать задачу на подзадачи и не пересчитывать одно и то же. Мы разберём, как с помощью таблицы хранить промежуточные результаты и ускорять алгоритмы. На примере игры «Камни» вы увидите, как динамическое программирование помогает найти выигрышную стратегию и заметить закономерности.\n\n## Ключевые вопросы параграфа\n\n* Как работает динамическое программирование и зачем оно нужно?\n* Как разбивать задачу на подзадачи и переиспользовать решения?\n* Когда стоит выбрать универсальный алгоритм, а когда — частный и быстрый?\n\n## Что такое динамическое программирование\n\nНекоторые алгоритмы разбивают задачу на более мелкие подзадачи и используют решения подзадач, чтобы собрать решение для главной. Во время этого процесса количество подзадач может стать очень большим, и некоторые алгоритмы решают одну и ту же подзадачу многократно, что чрезмерно увеличивает время выполнения.\n\nДинамическое программирование упорядочивает вычисления и позволяет не вычислять уже известные значения повторно. Зачастую это экономит массу времени.\n\n### Игра в «Камни»\n\nЗадача со звонящим телефоном не подразумевает решения с помощью динамического программирования, поэтому мы рассмотрим другую.\n\nПредставьте, что вместо ответа на звонок вы решаете поиграть в «Камни»: игру для двух игроков с двумя наборами камней по десять штук.\n\nС каждым ходом один игрок может взять один камень (из любого набора) или два камня (по одному из обоих). Когда камень забрали, он выходит из игры. Побеждает игрок, который заберет последний камень. Первый ход за вами.\n\nЧтобы найти стратегию для выигрыша в игре на $10+10$, мы можем составить таблицу, которую мы назовем $R$ ([рис.](#Placeholder-1-6)).\n\nВместо того, чтобы решать задачу с $10$ камнями в каждом из наборов, мы решим более общую задачу с $n$ камней в одном наборе и $m$ камней в другом (игра на $n + m$), где $n$ и $m$ — это произвольные целые неотрицательные числа.\n\n* Если игрок 1 может гарантированно выигрывать игру на $n + m$, тогда мы будем говорить, что $R(n,m) = W$.\n* Если у игрока 1 нет стратегии для выигрыша против игрока, который всегда делает правильные ходы, мы будем писать $R(n,m) = L$.\n\nВычисление $R(n,m)$ для произвольных $n$ и $m$ может звучать сложно, но мы воспользуемся результатами вычислений для меньших значений.\n\nНекоторые варианты игры, — в особенности $R(0,1)$, $R(1,0)$ и $R(1,1)$, — явно приведут к победе игрока 1, так как игрок 1 может выиграть первым ходом. Таким образом, мы заполняем ячейки $(1, 1)$, $(0, 1)$ и $(1, 0)$ как $W$. [рис. (a)](#Placeholder-1-6)\n\n![A_V_L_3_6225d05257.svg](https://yastatic.net/s3/education-portal/media/A_V_L_3_6225d05257_b328489074.svg)\n\nЗаполнив ячейки $(0, 1)$, $(1, 0)$ и $(1, 1)$, можно попробовать заполнить другие.\n\nНапример, в случае с $(2, 0)$ единственный ход, который может сделать игрок 1, приводит к $(1, 0)$ — это выигрышный вариант для оппонента. Аналогичный анализ применим к случаю $(0, 2)$, что приводит к таблице из рис. [рис. (b)](#Placeholder-1-6).\n\nВ случае $(2, 1)$ игрок 1 может сделать три разных хода, которые приведут к $(1, 1)$, $(2, 0)$ и $(1, 0)$ соответственно.\n\n* Один из этих случаев, $(2, 0)$, приводит к проигрышной позиции оппонента.\n* Соответственно, $(2, 1)$ — это выигрышная позиция.\n* Случаи $(1, 2)$ и $(2, 1)$ симметричны, поэтому мы получаем таблицу из рис. [рис. (c)](#Placeholder-1-6).\n\nТеперь мы можем заполнить $R(2,2)$.\n\nВ случае $(2, 2)$ игрок 1 может сделать три разных хода, которые приведут к ячейкам $(2, 1)$, $(1, 2)$ и $(1, 1)$. Эти ячейки — выигрышные позиции для оппонента. Так, $R(2,2) = L$: см рис. [рис. (d)](#Placeholder-1-6).\n\nМы можем продолжить заполнять $R$, обращая внимание на то, что ячейка $(i, j)$ будет $L$, если ячейки сверху, слева и слева по диагонали будут $W$. Эти ячейки ($(i - 1, j)$, $(i - 1, j - 1)$ и $(i, j - 1)$) соответствуют трем ходам, которые может сделать игрок 1. См. рис. [рис. (e)](#Placeholder-1-6)\n\n### Алгоритм ``Rocks``\n\nАлгоритм ``Rocks`` определяет, выиграет игрок 1 или нет. Если игрок 1 выигрывает $n +m$, то ``Rocks`` выдаст $W$. Если игрок 1 проигрывает, то ``Rocks`` выдаст $L$. Мы ввели искусственное начальное условие, $R(0,0) = L$, чтобы упростить псевдокод.\n\n```cpp\nRocks(n, m):\n    R(0,0) = L\n    for i from 1 to n:\n        if R(i-1,0) = W:\n            R(i,0) = L\n        else:\n            R(i,0) = W\n    for j from 1 to m:\n        if R(0,j-1) = W:\n            R(0,j) = L\n        else:\n            R(0,j) = W\n    for i from 1 to n:\n        for j from 1 to m:\n            if R(i-1,j-1)=W and R(i,j-1)=W and R(i-1,j)=W:\n                R(i,j) = L\n            else:\n                R(i,j) = W\n    return R(n,m)\n```\n\nБолее быстрый алгоритм для решения этой головоломки опирается на простую закономерность в $R$ и проверяет, чётные $n$ и $m$ или нет. Если оба числа чётные, то игрок проигрывает (см. таблицу выше).\n\n```cpp\nFastRocks(n, m):\n    if n % 2== 0 and m % 2 == 0: // оба числа чётные\n        return L\n    else:\n        return W\n```\n\nТем не менее, хотя ``FastRocks`` и эффективнее, чем ``Rocks``, изменить его для схожих вариантов игры может быть сложно. Например, вариант, в котором игрок может убирать до трёх камней из наборов. Перед нами пример того, как более медленный алгоритм может быть полезнее, чем быстрый.\n\n## Что дальше\n\nТеперь вы знаете, как динамическое программирование помогает ускорять решение задач за счёт переиспользования уже найденных ответов. Вы научились формулировать подзадачи, заполнять таблицы и избегать лишних вычислений.\n\nДалее — рекурсивные алгоритмы. Мы разберём, как строить решение через самого себя, почему рекурсия бывает полезной и когда она может привести к проблемам.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/79927) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Динамическое программирование позволяет решать задачи быстрее за счёт повторного использования подзадач.\n* Вместо того чтобы пересчитывать, мы сохраняем уже найденные решения и используем их повторно.\n* Метод особенно полезен, когда подзадачи пересекаются и их много.\n* Иногда универсальный, но медленный алгоритм оказывается практичнее, чем быстрый, но узкоспециализированный.\n"])</script><script nonce="">self.__next_f.push([1,"73:T3cc8,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с одним из самых мощных и простых приёмов в программировании — рекурсией. Мы разберём, как функция может вызывать саму себя и как при этом решаются задачи. На примере головоломки «Ханойские башни» вы увидите, как с помощью рекурсии можно элегантно описать сложный процесс и почему такие решения могут работать долго.\n\n## Ключевые вопросы параграфа\n\n* В чём сила и в чём слабость рекурсии по сравнению с итеративным подходом?\n* Как разложение задачи на подзадачи помогает описывать решения?\n* Что показывает пример «Ханойских башен» о возможностях и ограничениях рекурсивных алгоритмов?\n\n## Что такое рекурсия\n\nРекурсия — одно из самых распространенных алгоритмических понятий. Если говорить просто, то рекурсивным алгоритм становится, если вызывает сам себя.\n\n\u003c!-- (\\href{https://discrete-math-puzzles.github.io/puzzles/hanoi-towers/index.html}{попробуйте решить ее онлайн!}) --\u003e\n\n### Головоломка «Ханойские башни»\n\nГоловоломка «Ханойские башни» состоит из трёх стержней, пронумеруем их слева направо: 1, 2 и 3. Также в головоломке используется стопка дисков с отверстием посередине. Радиус дисков уменьшается снизу вверх.\n\n1. Изначально диски расположены на левом стержне (стержень 1), самый большой диск находится внизу.\n2. Диски в игре перемещаются по одному со стержня на стержень.\n3. Диск можно надеть на стержень, только если он пустой или верхний диск на нём большего размера, чем перемещаемый.\n\nЦель головоломки — перенести все диски со стержня 1 на стержень 3. Попробуйте нашу интерактивную версию «Ханойских башен» и узнайте, как переместить все диски с одного стержня на другой.\n\nВывод списка действий, необходимых для решения головоломки «Ханойские башни».\n\n* Входные данные: Целое число $n$.\n* Выходные данные: Последовательность ходов для решения головоломки «Ханойские башни» из $n$ дисков.\n\n### Решение головоломки\n\nРешить головоломку с одним диском легко — просто переместите его на правый стержень. Головоломка на два диска ненамного сложнее. Сначала нужно переместить маленький диск на стержень посередине, а большой — на стержень справа. Затем переместить маленький диск на большой на правом стержне.\n\nВерсия на три диска чуть сложнее, но и ее можно решить с помощью следующих семи шагов:\n\n* Переместить диск со стержня 1 на стержень 3\n* Переместить диск со стержня 1 на стержень 2\n* Переместить диск со стержня 3 на стержень 2\n* Переместить диск со стержня 1 на стержень 3\n* Переместить диск со стержня 2 на стержень 1\n* Переместить диск со стержня 2 на стержень 3\n* Переместить диск со стержня 1 на стержень 3\n\n![algorithms6.4.1.gif](https://yastatic.net/s3/education-portal/media/algorithms6_4_1_39f0dca0bb.gif)\n\n### Подсчёт количества шагов для решения версии на четыре диска\n\nТеперь давайте посчитаем, сколько шагов потребуется для решения версии на четыре диска.\n\n1. Нам нужно обязательно переместить самый большой диск, но для этого придётся сперва поместить все остальные диски на пустой стержень.\n2. Если у нас не три диска, а четыре, то нужно переложить три верхних диска на пустой стержень (7 действий), а затем переместить самый большой диск (1 действие).\n3. Теперь нужно снова переместить три диска с «временного» стержня на самый большой диск (еще 7 действий). Весь процесс будет состоять из $7 + 1 + 7 = 15$ действий.\n\n### Обобщим\n\n1. Чтобы переместить $n$ дисков с левого стержня на правый, сначала необходимо переместить $n - 1$ дисков на стержень посередине.\n2. Затем, когда диск под номером $n$, самый большой, оказывается на правом стержне, нужно переместить на него оставшиеся диски со стержня посередине.\n3. Чтобы переместить $n-1$ дисков со стержня посередине направо, нужно сначала переместить $n-2$ дисков на стержень слева, затем переместить $(n-1)$-й диск вправо, потом переместить $n-2$ дисков с левого стержня на правый и так далее.\n\n### Рекурсивный алгоритм в решении головоломки\n\nНа первый взгляд задача «Ханойские башни» может показаться сложной. Тем не менее данный рекурсивный алгоритм находит нужные перемещения дисков всего за 8 строк!\n\n```cpp\n HanoiTowers(n,fromPeg,toPeg)\n    if n = 1:\n        output “Move disk from peg fromPeg to peg toPeg”\n        return\n    unusedPeg = 6 - fromPeg - toPeg\n    HanoiTowers(n−1,fromPeg,unusedPeg)\n    output “Move disk from peg fromPeg to peg toPeg”\n    HanoiTowers(n−1,unusedPeg,toPeg)\n```\n\nПеременные $fromPeg, toPeg$ и $unusedPeg$ указывают на три разных стержня.\n\nТаким образом, `HanoiTowers(n, 1, 3)` перемещает диски ($n$ шт.) с первого стержня на третий. Переменная $unusedPeg$ указывает, какой из трёх стержней можно использовать для временного хранения первых ($n-1$) дисков.\n\nОбратите внимание, что $fromPeg+toPeg+unusedPeg$ всегда равняется $1+2+3 = 6$. Таким образом, значение переменной $unusedPeg$ можно определить как $6 - fromPeg - toPeg$.\n\nПредставленная таблица показывает результаты $6 - fromPeg - toPeg$ для всех возможных переменных $fromPeg$ и $toPeg$.\n\n#|\n||\n\nfromPeg\n\n|\n\ntoPeg\n\n|\n\nunusedPeg\n\n||\n||\n\n1\n\n|\n\n2\n\n|\n\n3\n\n||\n||\n\n1\n\n|\n\n3\n\n|\n\n2\n\n||\n||\n\n2\n\n|\n\n1\n\n|\n\n3\n\n||\n||\n\n2\n\n|\n\n3\n\n|\n\n1\n\n||\n||\n\n3\n\n|\n\n1\n\n|\n\n2\n\n||\n||\n\n3\n\n|\n\n2\n\n|\n\n1\n\n||\n|#\n\nОпределив $unusedPeg$ как $6 - fromPeg - toPeg$, операторы выполняют более простую задачу: они сначала перемещают $n-1$ дисков на временный стержень, затем перекладывают большой диск, а потом складывают на него оставшиеся $n-1$ дисков.\n\n```cpp\nHanoiTowers(n−1,fromPeg,unusedPeg)\noutput “Move disk from peg fromPeg to peg toPeg”\nHanoiTowers(n−1,unusedPeg,toPeg)\n```\n\nОбратите внимание, что нет необходимости указывать, какой диск игрок должен переложить с $fromPeg$ на $toPeg$: перемещается всегда тот диск, что является верхним на $fromPeg$.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Сколько нужно действий, чтобы переместить $6$ дисков?\n\n### Рекурсивное дерево в головоломке\n\nХотя решение Ханойских башен можно уложить в 9 строк псевдокода, его выполнение займет на удивление много времени. Решение головоломки на пять дисков состоит из 31 действия. А в решении башни из сотни дисков количество действий будет исчисляться “страшными” нонилионами.\n\nТакое резкое увеличение числа действий для `HanoiTowers` неудивительно. Заметим, что каждый раз, когда вызывается `HanoiTowers(n, 1, 3)`, алгоритм дважды вызывает сам себя для перемещения $n-1$ дисков, что запускает четыре вызова для перемещения $n-2$ дисков и так далее.\n\nЭто можно проиллюстрировать с помощью рекурсивного дерева, изображенного на [рис.](#Placeholder-1-15). Вызов `HanoiTowers(4, 1, 3)` приводит к вызовам `HanoiTowers(3, 1, 2)` и `HanoiTowers(3, 2, 3)`; каждый из них вызывает `HanoiTowers(2, 1, 3)`, `HanoiTowers(2, 3, 2)` и `HanoiTowers(2, 2, 1)`, `HanoiTowers(2, 1, 3)` и так далее. Каждый вызов подпрограммы `HanoiTowers` занимает определенное время. Мы хотим узнать, сколько времени уйдёт на такой алгоритм.\n\n![rekursiya](https://yastatic.net/s3/education-portal/media/rekursiya_0008_00e69b0a23_9d3d871a78.svg)\n\n### Вычисление времени на алгоритм в головоломке\n\nЧтобы вычислить время выполнения `HanoiTowers` размера $n$, мы введём в рассмотрение функцию $T(n)$ — количество перемещений дисков, которые выполняет `HanoiTowers(n)`. Получается следующее уравнение:\n\n$$T (n) = 2 \\cdot T (n - 1) + 1 \\, .\n$$\n\nНачиная с $T (1) = 1$, это рекуррентное соотношение задаёт последовательность:\n\n$$1, 3, 7, 15, 31, 63,\n$$\n\nи так далее. Мы можем вычислить $T (n)$, прибавив 1 с обеих сторон и обнаружив, что\n\n$$T (n) + 1 = 2 \\cdot T (n - 1) + 1 + 1 = 2\\cdot(T (n - 1) + 1) \\, .\n$$\n\nЕсли мы введём новое обозначение, $U(n) = T (n) + 1$, то $U(n) = 2 \\cdot U(n - 1)$. Таким образом, нужно решить следующее рекуррентное соотношение:\n\n$$U(n) = 2 \\cdot U(n - 1) \\, .\n$$\n\nНачиная с $U(1) = 2$, получаем последовательность\n\n$$2, 4, 8, 16, 32, 64, \\dotsc\n$$\n\nТо есть, $U(n) = 2^n$ и $T(n) = U(n) - 1 =2^n - 1$. Следовательно, `HanoiTowers(n)` — экспоненциальный алгоритм.\n\n## Что дальше\n\nТеперь вы знаете, как работает рекурсия и почему она может быть мощным инструментом для построения алгоритма. Вы научились разбивать задачу на шаги, каждый из которых решается тем же способом, что и вся задача целиком.\n\nДалее — алгоритмы «Разделяй и властвуй». Мы разберём, как делить задачу на независимые части, решать каждую по отдельности и собирать общее решение. Вы увидите, как этот подход ложится в основу быстрой сортировки и других эффективных алгоритмов.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/79930) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Рекурсия — это подход, при котором функция вызывает саму себя для решения подзадачи.\n* Чтобы рекурсивное решение работало, важно определить базовый случай и убедиться, что каждый шаг приближает нас к нему.\n* Задача «Ханойские башни» — классический пример, в котором рекурсивная стратегия описывает процесс из десятков или сотен шагов с минимальным кодом.\n* Количество операций в рекурсивных алгоритмах может расти экспоненциально — это важно учитывать при выборе метода решения задачи."])</script><script nonce="">self.__next_f.push([1,"74:T3076,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с подходом «Разделяй и властвуй». Он помогает решать сложные задачи, разбивая их на части, обрабатывая каждую отдельно и объединяя результаты.\n\nВажно не путать этот подход с рекурсией: рекурсия — это технический приём, когда функция вызывает саму себя, а «Разделяй и властвуй» — стратегия проектирования алгоритмов, которая почти всегда реализуется рекурсивно, но включает ещё шаг объединения решений. На примере MergeSort вы увидите, как эта стратегия используется для быстрой сортировки.\n\n## Ключевые вопросы параграфа\n\n* В чём суть подхода «Разделяй и властвуй» и как он помогает ускорить решение задач?\n* Как работает MergeSort и чем он отличается от наивных алгоритмов сортировки?\n* Почему объединение результатов подзадач — не менее важный шаг, чем их решение?\n\n## Алгоритм «Разделяй и властвуй»\n\nОдна большая задача может казаться трудной. Но если разделить её на две задачи в два раза меньше, она станет намного проще. Для таких случаев хорошо подходят алгоритмы «разделяй и властвуй».\n\nОни так и работают: разделяют задачу на более мелкие подзадачи, независимо находят решения для них и соединяют результаты в решение изначальной задачи. Конечно, реальные ситуации бывают более сложными, чем мы описали.\n\nПосле разделения одной задачи на подзадачи, алгоритм обычно делит их на ещё более мелкие под-подзадачи и так далее. Он продолжает это делать, пока не дойдёт до точки, где в рекурсии уже нет необходимости.\n\n\u003e Важнейший шаг в работе с алгоритмами «разделяй и властвуй» — это соединить решения подзадач в решение изначальной задачи.\n\nВ качестве примера алгоритма «разделяй и властвуй» приведём задачу сортировки:\n\n### Задача сортировки и метод `SelectionSort`\n\nСортировка: Отсортируйте набор целых чисел.\n\n* Входные данные: Список из $n$ разных чисел $a = (a_1, a_2, \\dotsc , a_n)$.\n* Выходные данные: Отсортированный список целых чисел. Измененный порядок $(b_1, b_2, \\dotsc , b_n)$ целых чисел от $a$, где $b_1 \u003c b_2 \u003c \\dotsb \u003c b_n$.\n\n`SelectionSort` — это простой итерационный метод решения задачи по сортировке.\n\n1. Сначала он находит самый маленький элемент в $a$, а затем меняет его местами с первым элементом (то есть с $a_1$).\n2. Затем он находит второй самый маленький элемент в $a$ и переставляет его на второе место, меняя элемент местами с $a_2$.\n3. Повторяя это действие в $i$-й раз, `SelectionSort` находит $i$-й самый маленький элемент в $a$ и переставляет его на $i$-е место.\n\nЕсли $a = (7, 92, 87, 1, 4, 3, 2, 6)$,\n`SelectionSort(a)` будет состоять из следующих семи шагов:\n\n![algorithms6.5.1.gif](https://yastatic.net/s3/education-portal/media/algorithms6_5_1_ec67459887.gif)\n\nВремя выполнения `SelectionSort` квадратично, то есть $O(n^2)$: используется $n$ итераций, для каждого из которых требуется время, чтобы просканировать не более $n$ элементов и найти самый большой из них для суффикса $a$.\n\n\u003e Обратите внимание, что $n^2$ — это завышенная оценка времени выполнения, так как при $i$-м повторе `SelectionSort` сканирует суффикс размером $n-i+1$: при первой итерации находится максимальное значение в массиве размера $n$, при второй итерации сканируется массив размера $n-1$ и так далее.\n\nТем не менее общее время выполнения растёт как $n^2$:\n\n$$n+(n-1)+(n-2)+\\dotsb+2+1=\\frac{n(n+1)}{2}$$\n\n## Алгоритм `MergeSort`\n\n`MergeSort` — классический пример алгоритма «разделяй и властвуй» для сортировки. Он намного быстрее, чем `SelectionSort`.\n\nНачнём с задачи слияния, в которой нам нужно будет объединить два отсортированных списка — $List_1$ и $List_2$ — в один отсортированный список.\n\n![algorithms6.5.2.gif](https://yastatic.net/s3/education-portal/media/algorithms6_5_4_af71a77fd9.gif)\n\nАлгоритм `Merge` объединяет два отсортированных списка в один за время $O(|List_1| + |List_2|)$. Для этого алгоритм повторно выбирает самый маленький элемент из оставшихся в $List_1$ и $List_2$ и перемещает его в растущий отсортированный список.\n\n```cpp\nMerge(List_1,List_2):\n    SortedList = ... // empty list\n    while both List_1 and List_2 are non-empty:\n    if the smallest element in List_1 is smaller than the smallest element in List_2:\n        move the smallest element from List_1 to the end of SortedList\n    else:\n        move the smallest element from List_2 to the end of SortedList\n    move any remaining elements from either List_1 or List_2 to the end of SortedList\n    return SortedList\n```\n\n`Merge` — полезный инструмент для сортировки произвольного списка, если мы знаем, как разделить неотсортированный список на две отсортированные половины.\n\nВам может показаться, что мы вернулись к тому, с чего начали, только теперь нам нужно отсортировать два меньших списка вместо одного большого. Но сортировка двух мелких списков — более предпочтительная алгоритмическая задача. Чтобы понять, почему это так, мы рассмотрим алгоритм `MergeSort`. Он разделяет неотсортированный список на две части и использует рекурсию для выполнения мелких задач перед тем, как объединить отсортированные списки.\n\n```cpp\nMergeSort(List):\n     if List consists of a single element:\n        return List\n     FirstHalf = first half of List\n     SecondHalf = second half of List\n     SortedFirstHalf = MergeSort(FirstHalf)\n     SortedSecondHalf = MergeSort(SecondHalf)\n     SortedList = Merge(SortedFirstHalf,SortedSecondHalf)\n     return SortedList\n```\n\n\u003e **Остановитесь и подумайте**:\n\u003e Каково время выполнения MergeSort?\n\nНа [рис.](#Placeholder-1-18) изображено рекурсивное дерево `MergeSort`, состоящее из $\\log_2 n$ уровней, где $n$ — размер изначального неотсортированного списка.\n\n1. На нижнем уровне нам нужно объединить два отсортированных списка размером примерно в $n /2$ элементов, что займёт $O(n /2 + n /2)  = O(n)$ времени.\n2. На следующем самом высоком уровне нам нужно объединить четыре списка из $n /4$ элементов, что потребует $O(n /4 + n /4 + n /4 + n /4)  = O(n)$ времени.\n\nТакой шаблон можно описать следующим образом: $i$-й уровень состоит из $2^i$ списков, каждый из которых включает в себя приблизительно $n /2^i$ элементов и занимает $O(n)$ времени для объединения.\n\nТак как в рекурсивном дереве $\\log_2 n$ уровней, выполнение `MergeSort` потребует в общем $O(n   \\log_2 n)$ времени, что даёт нам большое ускорение по сравнению с более наивным $O(n^2)$ алгоритмом сортировки.\n\n![algorithms6.5.3.gif](https://yastatic.net/s3/education-portal/media/algorithms6_5_3_4b60c4cd2f.gif)\n\n## Что дальше\n\nТеперь вы знаете, как работает подход «Разделяй и властвуй» и как с его помощью ускорить решение задач. Вы научились использовать рекурсию, объединять подзадачи и применять это к сортировке.\n\nДалее — рандомизированные алгоритмы. Вы увидите, как случайность может стать преимуществом в вычислениях, и узнаете, почему некоторые вероятностные алгоритмы работают быстрее, чем детерминированные.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/79935) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Подход «Разделяй и властвуй» помогает решать задачи, разбивая их на части и объединяя решения.\n* Алгоритм MergeSort сортирует список за O(n log n) благодаря рекурсивному делению и слиянию.\n* Такие алгоритмы часто быстрее наивных и хорошо масштабируются.\n"])</script><script nonce="">self.__next_f.push([1,"75:T3af6,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы узнаете, как случайность помогает ускорять алгоритмы. Один из классических примеров — RandomizedQuickSort, разновидность быстрой сортировки, где опорный элемент выбирается случайно. Такой подход снижает вероятность неудачного разбиения массива и делает работу алгоритма в среднем значительно быстрее.\n\n## Ключевые вопросы параграфа\n\n* Что такое рандомизированные алгоритмы и как они работают?\n* В чём разница между худшим и ожидаемым временем выполнения?\n* Зачем алгоритмам случайность и когда она даёт преимущество?\n\n## Что такое рандомизированные алгоритмы\n\nЕсли у вас есть монетка, то прежде чем начать искать телефон, вы можете подбросить её и решить, откуда начать поиск: если выпадет решка, то сначала ищем на первом этаже, если орёл — на втором.\n\nА для выбора конкретной комнаты можно использовать игральный кубик. Хотя бросать монеты и кубики весело, этот подход однозначно не интуитивен. К тому же непонятно, даёт ли это алгоритмическое преимущество по сравнению с детерминированным алгоритмом.\n\nНаши задачи помогут разобраться, в каких ситуациях вероятностные алгоритмы будут лучше детерминированных.\n\n### Быстрый метод сортировки — `QuickSort`\n\nЧтобы продемонстрировать пример вероятностного алгоритма, обсудим сначала быстрый метод сортировки, который называется `QuickSort`. Для упрощения будем считать, что все элементы данного массива $c$ разные.\n\n`QuickSort` выбирает элемент $m$ (например, первый) из $c$ и просто разделяет массив на два подмассива: $c_{small}$, в который входят все элементы $c$ меньше $m$; и $c_{large}$, в который входят все элементы больше $m$.\n\nЭто разделение можно выполнить за линейное время, далее, следуя стратегии «разделяй и властвуй», `QuickSort` рекурсивно сортирует каждый подмассив. Итоговый отсортированный список может быть легко получен с помощью конкатенации отсортированного $c_{small}$, элемента $m$ и отсортированного $c_{large}$.\n\n```cpp\nQuickSort(c):\n     if |c| = 1: // только один элемент\n        return c\n     m = c[1] // возьмем первый элемент c\n     // определим элементы c_small меньше m\n     // определим элементы c_large больше m\n     QuickSort(c_small)\n     QuickSort(c_large)\n     // объединим c_small, m и c_large в сортированный список c_sorted\n     return c_sorted\n```\n\nДля данного подхода требуется выделить дополнительную память, в которой будут храниться массивы $c_{small}$ и $c_{large}$. Лучший подход — переставить элементы входного массива на месте, чтобы набор $c_{small}$ шёл первым, затем $m$, а затем $c_{large}$ (см. ниже) — однако неясно, как это сделать.\n\n### Упражнение\n\nНико Ломуто предложил изящный алгоритм, позволяющий выполнить такую перестановку элементов на месте. Рисунок ниже показывает, как работает разбиение Ломуто. Посмотрите на рисунок. Сможете ли вы воссоздать логику подхода Ломуто?\n\n![algorithms6.6.1](https://yastatic.net/s3/education-portal/media/algorithms6_6_1_0bc87a377b.gif)\n\nОказывается, что время выполнения `QuickSort` зависит от нашей удачи при отборе элемента $m$. Если мы выберем $m$ так, что массив $c$ разделяется на две равные части (то есть $|c_{small}| = |c_{large}|$), тогда\n\n$$T(n) = 2T\\left(\\frac{n}{2}\\right) + a \\cdot n,\n$$\n\nгде $T(n)$ означает время, которое требуется `QuickSort` для сортировки массива из $n$ чисел, и $a \\cdot n$ означает время, которое потребуется для разделения массива длины $n$ на две части; $a$ — положительная константа. Это абсолютно такое же рекуррентное соотношение, как и в `MergeSort`, соответствующее времени выполнения $O(n \\log n)$.\n\nТем не менее если мы выберем $m$ так, что $c$ разделится неровно (например, возникает крайний случай, когда набор $c_{small}$ пуст, а в наборе $c_{large}$ $n-1$ элементов), тогда рекуррентное соотношение будет\n\n$$T(n) = T(n - 1) + a \\cdot n .\n$$\n\nЭто соотношение и приводит к времени выполнения $O(n^2)$, а этого мы пытаемся избежать. Сортировка массива $(n, n - 1, \\dotsc , 2, 1)$ с помощью `QuickSort` действительно занимает квадратичное время. Что ещё хуже, на обработку $(1, 2, \\dotsc , n -1, n)$ требуется время $O(n^2)$. Это выглядит излишним, ведь массив уже отсортирован.\n\n### Алгоритмы `QuickSort` и `MergeSort`\n\nПока что алгоритм `QuickSort` похож на плохую имитацию `MergeSort`. Однако если мы сможем выбрать хороший «разделитель» $m$, который разбивает массив на две равные части, мы сможем улучшить время выполнения.\n\nНа самом деле, не обязательно пытаться достичь идеального разделения (50/50), чтобы получить время выполнения $O(n \\log n)$. Например, также подойдет разделение на примерно равные части (скажем, 51/49). Фактически можно доказать, что алгоритм будет иметь время выполнения $O(n \\log n)$ при условии, что оба набора $c_{small}$ и $c_{large}$ больше, чем $n/4$.\n\nИз этого следует, что из $n$ возможных вариантов для $m$, выбранного в качестве элементов массива $c$, как минимум $\\frac{3n}{4}-\\frac{n}{4}=\\frac{n}{2}$ хорошо подойдут для разделения!\n\nДругими словами, если мы возьмем $m$ случайным образом (вероятность выбрать любой из элементов $c$ одинакова), то у нас будет шанс 50% получить хорошее разделение. Такой вывод ложится в основу следующего вероятностного алгоритма:\n\n```cpp\nRandomizedQuickSort(c):\n     if |c| = 1: //  только один элемент\n        return c\n     m = ... // возьмем случайный элемент из c\n     // определим элементы c_small меньше m\n     // определим элементы c_large больше m\n     RandomizedQuickSort(c_small)\n     RandomizedQuickSort(c_large)\n     // объединим c_small, m и c_large в сортированный список c_sorted\n     return c_sorted\n```\n\n### `RandomizedQuickSort` — быстрый алгоритм\n\nНа практике `RandomizedQuickSort` — это быстрый алгоритм. Однако его худшее время выполнения остается $O(n^2)$, так как все еще есть вероятность, что он выберет плохой разделитель. При одном и том же вводе поведение вероятностного алгоритма отличается от одного выполнения к другому. Тем не менее мы можем доказать, что его ожидаемое время выполнения — $O(n\\log n)$.\n\nСлово «ожидаемое» подмечает следующий эффект.  Так как `RandomizedQuickSort` — это вероятностный алгоритм, два разных запуска (при одинаковом вводе) могут занять разное количество времени: некоторые будут быстрыми, некоторые — медленными.\n\nТаким образом, время выполнения вероятностного алгоритма — это случайная величина. Разработчики нередко интересуются средним значением этой случайной величины, что и называется ожидаемым временем выполнения. Можно продемонстрировать, что для каждого массива размером в $n$ ожидаемое время выполнения `RandomizedQuickSort` будет $O(n\\log n)$.\n\n## Преимущество вероятностных алгоритмов\n\nГлавное преимущество вероятностных алгоритмов — это производительность. Вероятностные алгоритмы решают многие реальные задачи быстрее (с точки зрения ожидаемого времени выполнения), чем детерминированные алгоритмы. Еще одна привлекательная особенность — это их простота. Она демонстрируется, например, в `RandomizedQuickSort`.\n\nМы подчеркиваем, что хотя `RandomizedQuickSort` и принимает решения случайным образом, он всегда выдаёт правильное решение задачи сортировки. Единственный изменяющийся параметр от одного прогона к другому — это время выполнения, но не результат. В противоположность этому, другие вероятностные алгоритмы обычно приводят к неправильным (или точнее, приблизительным) решениям. Вероятностные алгоритмы, которые всегда дают верные решения, называются «Лас-Вегас». Алгоритмы, которые не приводят к верным решениям — «Монте-Карло».\n\n## Что дальше\n\nТеперь вы познакомились с разными подходами к построению алгоритмов — от рекурсии до динамического программирования, от «Разделяй и властвуй» до рандомизированных стратегий. Вы научились оценивать, насколько эффективен алгоритм, и выбирать подходящий метод в зависимости от задачи.\n\nВ следующем параграфе мы подведём итоги и сравним основные стратегии: где срабатывает жадность, где помогает случайность, а где лучше хранить промежуточные результаты. Это поможет вам научиться видеть за конкретной задачей типовую структуру — и сразу подбирать подходящий алгоритм.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/79936) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Рандомизированные алгоритмы используют случайность для ускорения решения задач.\n* Алгоритм RandomizedQuickSort в среднем работает за O(n log n), хотя в худшем случае даёт O(n²).\n* Ожидаемое время выполнения может быть надёжным ориентиром, даже если поведение алгоритма меняется от запуска к запуску."])</script><script nonce="">self.__next_f.push([1,"76:T7ac,"])</script><script nonce="">self.__next_f.push([1,"В шестой главе вы познакомились с основными стратегиями проектирования алгоритмов — от полного перебора до вероятностных методов. Вы увидели, как по-разному можно подходить к одной и той же задаче, и научились выбирать подход в зависимости от условий и ограничений.\n\nТеперь вы умеете:\n\n* Применять метод полного перебора и оптимизировать его с помощью сокращения пространства решений.\n* Использовать жадные алгоритмы, доказывать их корректность или искать контрпримеры.\n* Решать задачи с помощью динамического программирования, запоминая результаты подзадач и избегая лишних вычислений.\n* Строить рекурсивные алгоритмы и понимать их временную сложность.\n* Применять подход «Разделяй и властвуй» — разбивать задачи, решать части и объединять результат.\n* Оценивать эффективность рандомизированных алгоритмов и понимать, как случайность может дать преимущество.\n\nЭти стратегии составляют основу алгоритмического мышления. В следующей главе вы перейдёте к жадным алгоритмам — и научитесь принимать решения на каждом шаге так, чтобы получить лучший возможный результат."])</script><script nonce="">self.__next_f.push([1,"77:T2abe,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с одной из самых известных жадных задач — разменом денег. Нужно уметь разложить сумму по монетам так, чтобы их количество оказалось минимальным. На первый взгляд достаточно всегда брать наибольший подходящий номинал, но такой метод работает не для любых наборов монет. Поэтому важно понять, в каких случаях жадная стратегия действительно гарантирует оптимальный результат. Этот подход ляжет в основу всех задач этой главы.\n\n## Ключевые вопросы параграфа\n\n- Как работает жадный алгоритм в задаче про размен монет и чем он отличается от полного перебора?\n- Почему важно обосновывать правильность жадных решений и как это сделать?\n\n## Простой жадный алгоритм\n\nДавайте реализуем простой жадный алгоритм, которым пользуются кассиры по всему миру.\n\nПредположим, что у кассира есть бесконечное количество монет всех номиналов.\n\n- Входные данные: Целое число $money$.\n- Выходные данные: Минимальное количество монет номиналами $1$, $5$, $10$, чтобы выдать сдачу $money$.\n- Ограничения: $1 \\le money \\le 10^3$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\n\n|\n\n2\n\n||\n|#\n\n- $2=1+1$.\n\n#### Пример 2\n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n28\n\n|\n\n6\n\n||\n|#\n\n- $28=10+10+5+1+1+1$.\n\n- Ограничение по времени (с): 1 секунда.\n- Ограничение по памяти: 512 Mb.\n\n### Решение\n\nРассмотрим основную идею решения. Пока сдача положительна $money\u003e0$, мы выбираем монету с самым большим номиналом, не превышающем $money$, отнимаем значение номинала выбранной монеты от $money$ и увеличиваем количество монет:\n\n```cpp\nChange(money):\n    numCoins = 0\n    while money\u003e0:\n        if money \u003e= 10:\n            money = money − 10\n        else if money \u003e= 5:\n            money = money − 5\n        else:\n            money = money − 1\n        numCoins = numCoins + 1\n    return numCoins\n```\n\nТакже эту задачу можно решить в одну строку:\n\n```cpp\nreturn floor(money/10) + floor((money mod 10)/5) + (money mod 5)\n```\n\n### Доказательство в жадном алгоритме\n\nПроектировать жадные алгоритмы просто, но вот доказывать их правильность — нередко сложная задача. И возможно, вас интересует, почему мы тратим время, чтобы доказать работоспособность очевидного алгоритма ``Change``. Дождитесь, пока мы попадем в алгоритмическую ловушку, и она убедит вас, что доказательство ниже — не трата времени.\n\nЧтобы доказать, что этот жадный алгоритм работает правильно, мы покажем, что выбор монеты с самым большим номиналом соответствует некому оптимальному решению.\n\nТо есть нам нужно доказать, что для каждого положительного целого числа $money$ существует оптимальный способ выдать сдачу с $money$, который использует как минимум одну монету с номиналом $D$, где $D$ — самое большое число из $1,5,10$, не превышающее $money$. Чтобы доказать это, мы рассмотрим несколько примеров.\n\nВ каждом из примеров мы выбираем оптимальное решение (то есть конкретную сдачу с $money$) и преобразовываем его так, что количество монет не увеличивается и содержит как минимум одну монету с номиналом $D$. Мы также получаем $оптимальный$ способ выдать сдачу с $money$, который содержит монету $D$, если начинаем с $оптимального$ подхода к сдаче $money$.\n\n- $1 \\le money \\lt 5$. В этом случае $D=1$, и единственный способ выдать сдачу с $money$ — это использовать $money$ монет номиналом 1.\n- $5 \\le money \\lt 10$. В таком случае $D=5$. Безусловно, любая сдача с money будет состоять только из монет с номиналами 1 и 5. Если в неё не входит монета с номиналом 5, то входят как минимум пять монет номиналом 1 (так как $money \\ge 5$). Заменив их на одну монету номиналом 5, мы улучшим это решение.\n- $10 \\le money$. В таком случае $D=10$. Рассмотрим способ выдать сдачу с $money$ и предположим, что в нём не используется монета номиналом 10. Простое, но важное замечание: сумма некой подгруппы использованных монет — 10. Это можно продемонстрировать, рассмотрев количество монет номиналом 5 в данном решении: если таких монет нет, тогда есть как минимум десять монет номиналом 1, и мы заменяем их на одну 10; если есть лишь одна монета номиналом 5, тогда есть как минимум пять монет по 1, и мы снова заменяем все монеты на одну монету номиналом 10; если есть хотя бы две монеты по 5, тогда их снова можно заменить.\n\nХотя это доказательство длинное и довольно скучное, каждый раз, когда вы придумываете жадный алгоритм, вам нужно доказательство! Следующее упражнение показывает более компактный способ доказать правильность алгоритма выше.\n\n### Упражнение\n\nПродемонстрируйте, что money mod 5 монет номиналом 1 необходимы для любого решения, а остальные следует заменить монетами номиналами 10 и максимум одной монетой номиналом 5.\n\n**Время выполнения.** Время выполнения алгоритма ``Change`` — $O(money)$, но его однострочная версия требует лишь несколько арифметических операций.\n\n## Что дальше\n\nТеперь вы знаете, как устроена жадная стратегия и как она работает в задаче размена. Вы увидели, что можно принимать решения, не заглядывая вперёд, — и при этом получить оптимальный результат. А ещё убедились, что даже простая стратегия требует проверки и не всегда даёт правильный ответ.\n\nДалее — новая задача: как выбрать самые ценные предметы, если ресурсы ограничены. Здесь используется жадный отбор по плотности: ценность на единицу веса или объёма. Вы познакомитесь с жадным отбором по плотности и научитесь использовать этот подход, когда важно получить максимум от доступного.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n- Отметьте, что урок прочитан, при помощи кнопки ниже.\n- Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n- Перейдите к [задачам](https://new.contest.yandex.ru/contest/80765) этого параграфа и потренируйтесь.\n- Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n- Жадный алгоритм принимает решение на каждом шаге, выбирая наиболее выгодный вариант здесь и сейчас.\n- В задаче размена такая стратегия работает, если номиналы монет удовлетворяют определённым условиям.\n- Даже для простых на вид задач важно доказывать корректность жадного подхода, а не полагаться на интуицию.\n- Жадные алгоритмы просты и быстры, но требуют проверки: в некоторых задачах они могут давать неверный результат.\n"])</script><script nonce="">self.__next_f.push([1,"78:T2b99,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы решите задачу о выборе предметов с наибольшей ценностью при ограниченной вместимости — это типичный пример применения жадных алгоритмов. Вы узнаете, как определить, что брать в первую очередь, и как доказать, что выбранная стратегия действительно даёт оптимальный результат.\n\n## Ключевые вопросы параграфа\n\n* Как работает жадный алгоритм в задаче выбора по критерию «цена за единицу веса»?\n* Почему важно доказывать корректность жадной стратегии, даже если она кажется очевидной?\n* Как оформить решение, чтобы избежать ошибок округления и сохранить точность при работе с вещественными числами?\n\n## Выбор предметов с наибольшей ценностью при ограниченной вместимости\n\nВор пробрался в лавку специй и нашёл там четыре фунта шафрана, три фунта ванили и пять фунтов корицы. В его рюкзак можно сложить до девяти фунтов, поэтому забрать всё он не сможет.\n\nПредположим, что цены на шафран, ваниль и корицу $5000, $200 и $10 соответственно. Как унести максимально дорогую добычу? Если вор заберёт $u_1$ фунтов шафрана, $u_2$ фунтов ванили и $u_3$ фунтов корицы, общая ценность украденного составит $5000\\cdot \\dfrac{u_1}{4} + 200\\cdot \\dfrac{u_2}{3} + 10\\cdot \\dfrac{u_3}{5}$. Вор хотел бы найти максимальное значение этого выражения при следующих ограничениях: $u_1 \\le 4$, $u_2 \\le 3$, $u_3 \\le 5$, $u_1+u_2+u_3 \\le 9$.\n\n* Входные данные: Первая строка ввода содержит $n$ специй и вместимость рюкзака $W$. Следующие $n$ строк указывают цену и вес специй. $i$-я строка включает в себя цену $c_i$ и вес $w_i$ $i$-й специи.\n* Выходные данные: Максимальное значение специй, которые вместятся в рюкзак.\n* Ограничения: $1 \\le n \\le 10^3$, $0 \\le W \\le 2 \\cdot 10^6$; $0 \\le c_i \\le 2 \\cdot 10^6$, $0 \u003c w_i \\le 2 \\cdot 10^6$ для всех $1 \\le i \\le n$. Все числа — целые.\n* В дополнение: Хотя ввод для этой задачи состоит из целых чисел, вывести необходимо нецелое число. Таким образом, абсолютное значение разницы между ответом вашей программы и оптимальным значением не должно превышать $10^{-3}$. Для этого ваш ответ должен содержать не меньше четырёх цифр в дробной части (иначе даже правильно вычисленный ответ может стать неправильным из-за проблем с округлением).\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3 50\u003cbr\u003e60 20\u003cbr\u003e100 50\u003cbr\u003e120 30\n\n|\n\n180\\.0000\n\n||\n|#\n\nЧтобы получить значение $180$, вор возьмёт и первую, и третью специи полностью.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1 10\u003cbr\u003e500 30\n\n|\n\n166\\.6667\n\n||\n|#\n\nВору нужно забрать десять фунтов единственной доступной специи.\n\n**Совет**: по возможности старайтесь избегать чисел с плавающей дробной частью.\n\n### Решение\n\nОпределим стоимость специи $i$ как $\\frac{c_i}{w_i}$. Естественной стратегией для вора было бы брать как можно больше самой дорогой специи.\n\nЧтобы доказать, что эта стратегия приводит к оптимальному решению, рассмотрим самую дорогую специю $m$. Каков максимальный объём $a$ $m$-й специи, который вор может положить в рюкзак?\n\nВо-первых, она должна уместиться в рюкзак: $a \\le W$.\n\nВо-вторых, она не должна превышать доступный объём $m$-й специи: $a \\le w_m$.\n\nСледовательно, $a=\\min\\{w_m, W\\}$. Мы утверждаем, что существует оптимальное решение, включающее в себя $a$ фунтов $m$-й специи.\n\nЧтобы это доказать, рассмотрим оптимальное решение $u_1,\\dotsc,u_n$, при котором мы получаем максимальное количество $u_m$ самой дорогой $m$-й специи из всех оптимальных решений ($u_i$ означает количество $i$-й специи). Если $u_m=a$, то ничего доказывать не нужно. Иначе $u_m \\lt a$. Поэтому $u_m \\lt w_m$ и $u_m \\lt W$.\n\nРассмотрим два варианта.\n\n* При нынешнем решении $u_1+u_2+\\dotsc+u_n \\lt W$ рюкзак заполнен не до конца. Так как $u_m \\le w_m$, можно взять немного больше $m$-й специи: так, мы получаем новое решение, которое лучше и оптимальнее нынешнего.\n* Рюкзак заполнен до конца: $u_1+\\dotsc+u_m=W$. Так как $u_m \\lt W$, при подборе $i \\neq m$ можно получить $u_i \\gt 0$. Так, вместо маленького количества $i$-й специи, можно взять такое же количество $m$-й специи. Таким образом мы сохраним общий вес, но увеличим общую ценность и количество самой дорогой $m$-й специи в рюкзаке. Это противоречит идее, что в изначальном решении был максимум $m$-й специи.\n\nДоказав, что мы можем взять самой дорогой специи столько, сколько получится, мы можем спроектировать жадный алгоритм: взять как можно больше самой дорогой специи и повторить. Мы прекратим, когда больше не останется специй или когда рюкзак будет заполнен до конца. В псевдокоде, приведённом ниже, $Weight$ и $Cost$ — массивы, содержащие значения веса и цены.\n\n```cpp\nMaximumLoot(W, Weight, Cost)\n    if W=0 or Weight is empty:\n        return 0\n    m = the index of the most expensive item\n    amount = min(Weight[m], W)\n    value = Cost[m] / Weight[m] * amount\n    remove the m-th element from Weight and Cost\n    return value + MaximumLoot(W - amount, Weight, Cost)\n```\n\n**Время выполнения.** Время выполнения этого алгоритма — $O(n^2)$. При каждой итерации сканируется список специй и находится самая дорогая. Максимальное количество итераций — $n$, так как каждая итерация снижает количество рассматриваемых специй.\n\n## Что дальше\n\nТеперь вы знаете, как устроена жадная стратегия и как она работает в задаче размена. Вы увидели, что можно принимать решения, не заглядывая вперёд, и при этом получить оптимальный результат. А ещё убедились, что даже простая стратегия требует проверки и не всегда даёт правильный ответ.\n\nДалее — новая задача: как выбрать самое выгодное, если ресурсы ограничены. Вы познакомитесь с жадным отбором по плотности и научитесь использовать этот подход, когда важно получить максимум от доступного.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80766) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Жадный алгоритм принимает решение на каждом шагу, выбирая наиболее выгодный вариант здесь и сейчас.\n* В задаче размена такая стратегия работает, если номиналы монет удовлетворяют определённым условиям.\n* Даже для простых на вид задач важно доказывать корректность жадного подхода, а не полагаться на интуицию.\n* Жадные алгоритмы просты и быстры, но требуют проверки: в некоторых задачах они могут давать неверный результат.\n"])</script><script nonce="">self.__next_f.push([1,"79:T24bb,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте задачу о том, как с максимальной пользой заполнить ограниченное пространство или ограниченный бюджет. Это пример задачи с дробным выбором: можно взять часть объекта, чтобы извлечь максимум выгоды. Здесь используется жадный отбор по плотности, и важно уметь доказывать, что такая стратегия действительно оптимальна.\n\n## Ключевые вопросы параграфа\n\n* Как работает жадный алгоритм в задаче выбора по критерию «прибыль за ресурс»?\n* Почему важно доказывать корректность жадного подхода, а не полагаться только на интуицию?\n* Как оформить решение, чтобы оно было корректным, понятным и быстрым?\n\n## Дробный выбор\n\n![Algoritmy_5_126dc40255.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_5_126dc40255_0d9f9de72d.svg)\n\nПредставим, что вы владелец популярной страницы в интернете, на которой есть $n=3$ рекламных мест. Вы хотите продать их рекламодателям, которые рассчитывают на $clicks_1=10$, $clicks_2=20$ и $clicks_3=30$ кликов в день и при этом готовы платить $price_1=2$, $price_2=3$ и $price_3=5$ за клик. Как подобрать пары рекламных мест и рекламодателей так, чтобы получить максимальную прибыль? Например, доход от отмеченных голубым цветом пар, приведённых выше, составит $10 \\cdot 5 + 20 \\cdot 2 + 30 \\cdot 3 = 180$ долларов; от отмеченных чёрным — $10\\cdot 3 + 20 \\cdot 5 + 30 \\cdot 2=190$.\n\n* Входные данные: В первой строке приведено целое число $n$, во второй — последовательность целых чисел $price_1, \\dotsc, price_n$, в третьей — последовательность целых чисел $clicks_1, \\dotsc, clicks_n$.\n* Выходные данные: Максимальное значение $(price_1 \\cdot c_1 + \\dotsm + price_n \\cdot c_n)$, где $c_1, \\dotsc, c_n$ — это перестановка $clicks_1, \\dotsc, clicks_n$.\n* Ограничения: $1 \\le n \\le 10^3$; $0 \\le price_i,clicks_i \\le 10^5$ для всех $1 \\le i \\le n$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\u003cbr\u003e23\u003cbr\u003e39\n\n|\n\n897\n\n||\n|#\n\n$897=23 \\cdot 39$.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr\u003e2 3 9\u003cbr\u003e7 4 2\n\n|\n\n79\n\n||\n|#\n\n$79=7 \\cdot 9 + 2 \\cdot 2 + 3 \\cdot 4$.\n\n### Решение\n\nСуть решения заключается в том, чтобы отдать самое популярное рекламное место самому дорогому объявлению. Вас вряд ли удивит, что жадный подход даст максимальную прибыль.\n\nПредположим, что $clicks_p$ и $price_q$ — самые большие элементы: $clicks_p \\ge clicks_i$ и $price_q \\ge price_i$ для всех $i=1,\\dotsc,n$. Мы утверждаем, что существует оптимальное решение, объединяющее $clicks_p$ с $price_q$.\n\nЧтобы доказать это, возьмём оптимальное решение и предположим, что в нём объединены $clicks_p$ и $price_{q'}$ для $q' \\neq q$ и $price_q$ и $clicks_{p'}$ для $p' \\neq p$. Покажем, что замена пар $(p,q')$ и $(p',q)$ на пары $(p,q)$ и $(p',q')$ только повысит прибыль.\n\nДавайте оценим, как такая замена повлияет на общую прибыль. До замены рассматриваемые элементы давали следующую прибыль:\n\n$$\nclicks_p\\cdot price_{q'}+clicks_{p'}\\cdot price_{q}\n$$\n  \nПосле замены:\n\n$$\nclicks_{p}\\cdot price_{q}+clicks_{p'}\\cdot price_{q'}\n$$\n\nТаким образом, замена увеличивает общую прибыль на  \n\n$$\nclicks_{p} \\cdot price_{q}+clicks_{p'}\\cdot price_{q'} - clicks_p\\cdot price_{q'}-clicks_{p'}\\cdot price_{q}=(clicks_{p}-clicks_{p'})\\cdot(clicks_{q}-clicks_{q'}) \\ge 0\n$$\n\nЭто приводит нас к алгоритму, который объединяет рекламное объявление с максимальным количеством кликов за максимальную цену, исключает их из вариантов на рассмотрение и повторяет то же самое.\n\n```cpp\nRevenue(Click,Price):\n     revenue = 0\n     while clicks is not empty:\n        p = index with largest Click[p]\n        q = index with largest Price[q]\n        revenue = revenue+Clicks[p]⋅Price[q]\n        remove p-th element of Click\n        remove q-th element of Price\n     return revenue\n```\n\n**Время выполнения.**\n\nВремя выполнения этого алгоритма — $O(n^2)$. В каждой из $n$ итераций мы проводим линейное сканирование и находим два самых больших элемента. Также можно отсортировать эти два списка заранее, чтобы не искать самый большой элемент с нуля при каждой итерации. Это приводит нас к решению с временем выполнения $O(n\\log n)$.\n\n## Что дальше\n\nТеперь вы знаете, как работать с задачами, где допускается дробный выбор, и почему жадный отбор по плотности гарантирует оптимальное решение. Вы также увидели, что при работе с вещественными числами важно следить за точностью вычислений и оформлением кода.\n\nДалее — задача с другим типом постановки: нужно покрыть набор отрезков минимальным числом точек. Такой приём встречается, например, в планировании размещения рекламных щитов вдоль трассы или выборе минимального числа дат для встреч, чтобы все участники могли присутствовать. Это ещё один пример, где жадный алгоритм работает эффективно, — если правильно обосновать его корректность.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80767) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* В задачах с «дробным» выбором можно брать часть объекта, чтобы максимизировать результат — это принципиально отличается от дискретных задач.\n* Жадная стратегия по убыванию плотности гарантирует оптимальное решение именно в дробном случае, но не всегда работает для целочисленных вариантов.\n* Доказательство оптимальности помогает понять границы применения жадных алгоритмов и увидеть, где они перестают работать.\n* Работа с вещественными числами требует особой аккуратности, чтобы избежать ошибок округления и потери точности."])</script><script nonce="">self.__next_f.push([1,"7a:T266b,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте ещё один вариант задачи с ограниченными ресурсами. Но в отличие от предыдущего примера, где критерий выбора был простым и однозначным, здесь придётся искать более тонкую стратегию: оценивать выгоду на единицу ресурса. Это позволяет использовать жадный алгоритм там, где «просто отсортировать» уже недостаточно. Главная цель задачи — научиться доказывать, что выбранный критерий действительно ведёт к оптимальному решению.\n\n## Ключевые вопросы параграфа\n\n* Чем задача «Сбор подписей» отличается от других задач с ограниченными ресурсами?\n* Почему стратегия «максимальная прибыль на единицу ресурса» оказывается оптимальной?\n* Как корректно оформить и проверить такое решение?\n\n![Algoritmy_7.4_1](https://yastatic.net/s3/education-portal/media/Algoritmy_6_e9b5ca9eb1_47980c467a.svg)\n\n## Максимальная выгода при ограниченных ресурсах\n\nНа этот раз ваша задача — собрать подписи со всех жильцов дома. Вам известно время, в которое каждый из них будет у себя. Естественно, вам хочется собрать все подписи, заходя в дом минимальное количество раз. Для простоты давайте предположим, что вы, зайдя в дом, собираете подписи сразу со всех жильцов, которые на месте.\n\nВ дальнейшем под сегментом будем понимать интервал времени нахождения жильца в доме. Количество жильцов будет соответствовать количеству сегментов.\n\n* Входные данные: Количество сегментов в первой строке — $n$. Каждая из следующих $n$ строк содержит два целых числа $l_i$ и $r_i$ (разделены пробелом), которые указывают на координаты границ $i$-го сегмента.\n* Выходные данные: Минимальное количество $k$ точек на первой строке и координаты $k$ точек целыми числами (разделены пробелом) на второй строке. Выводить точки можно в любом порядке. При наличии нескольких наборов точек, можно вывести любой из них.\n* Ограничения: $1 \\le n \\le 100$; $0 \\le l_i \\le r_i \\le 10^9$ для всех $i$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr\u003e1 3\u003cbr\u003e2 5\u003cbr\u003e3 6\n\n|\n\n1\u003cbr\u003e3\n\n||\n|#\n\nВсе три сегмента $[1,3]$, $[2,5]$, $[3,6]$ содержат точку с координатами 3.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n4\u003cbr\u003e4 7\u003cbr\u003e1 3\u003cbr\u003e2 5\u003cbr\u003e5 6\n\n|\n\n2\u003cbr\u003e3 6\n\n||\n|#\n\nВторой и третий сегменты содержат точку с координатами $3$, в то время как первый и четвертый содержат точку с координатами $6$. Одной точкой покрыть все сегменты нельзя, так как $[1,3]$ и $[5,6]$ не пересекаются. В этом случае есть еще одно верное решение — точки 2 и 5.\n\n### Решение\n\nРешение заключается в выявлении сегмента с наименьшим значением правой границы.\n\nСамое маленькое значение границы сегмента: $r_m=\\min\\{r_1, \\dotsc, r_n\\}$. Мы утверждаем, что существует оптимальное решение, включающее в себя точку $r_m$. Чтобы доказать это, возьмём оптимальное решение $S$. Оно должно покрывать сегмент $[l_m,r_m]$, поэтому $S$ содержит точку $x$, что приводит к $l_m \\le x \\le r_m$. Если $x=r_m$, то наша работа закончена. Иначе $x \\lt r_m$. В этом случае мы можем заменить $x$ на $r_m$ в $S$.\n\n![Algosy_7.4_2](https://yastatic.net/s3/education-portal/media/Algosy_6_3_2_1fc544b9aa.svg)\n\nПонятно, что это не меняет размер решения $S$. Чтобы доказать, что $S$ всё ещё является решением, подойдём от противного и предположим, что некий сегмент $[l_i,r_i]$ покрывается $x$, но не покрывается $r_m$. Это означает $l_i \\le x \\le r_i \u003c r_m$ и противоречит тому, что $r_m$ — самое маленькое значение правой границы.\n\nТаким образом, мы приходим к следующему алгоритму:\n\n* добавить в решение минимальное значение правой границы $r_m$,\n* отбросить все сегменты, покрытые $r_m$,\n* повторить.\n\n```cpp\nSegmentsCover(segments):\n    points←empty set\n    while segments is not empty:\n        r_m = minimum right endpoint of a segment from segments\n        add r_m points\n        remove segments covered by r_m from the set segments\n    return points\n```\n\nНа рисунке ниже показан пример.\n\n![Algoritmy_7.4_3](https://yastatic.net/s3/education-portal/media/Algoritmy_8_648f5034e9_b2a5a00662.svg)\n\nВремя выполнения составит $O(n^2)$, где $n=|segments|$, так как используется не более $n$ итераций цикла **while** (при каждой итерации отбрасывается как минимум один сегмент), и каждая итерация сводится к проверке списка $segments$ (одним сканированием находится значение $r$, а другим убираются сегменты, покрываемые $r$).\n\nЭтот алгоритм уже достаточно быстрый, чтобы успешно пройти оценку. Однако можно дополнительно сократить время выполнения с $O(n^2)$ до $O(n\\log n)$, если отсортировать сегменты от малых до больших значений правой границы и затем просто просканировать список один раз.\n\n## Что дальше\n\nТеперь вы умеете применять жадные алгоритмы, когда нужно максимизировать результат при ограниченном ресурсе, используя критерий эффективности на единицу ресурса.\n\nДалее — задача с другим типом цели: теперь ресурс нужно распределить так, чтобы увеличить количество получателей. Вы узнаете, как простая сортировка помогает достичь справедливого распределения и почему жадный подход оказывается удачным и в этой ситуации.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80768) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Жадный алгоритм может работать не только с абсолютными значениями, но и с относительными критериями, например «выгода на единицу ресурса».\n* Оптимальность жадного критерия нужно обосновывать — иначе легко получить неверное решение.\n* Работа с вещественными числами требует особой аккуратности в сравнении и реализации."])</script><script nonce="">self.__next_f.push([1,"7b:T1b5e,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте задачу, в которой нужно раздать ограниченное количество конфет максимально возможному числу призёров, соблюдая строгий порядок награждения. Это пример нестандартной задачи, которую можно решить с помощью жадного подхода и внимательного анализа. Вы научитесь строить возрастающие последовательности и использовать арифметические свойства для оптимального распределения.\n\n## Ключевые вопросы параграфа\n\n* Как спланировать последовательность наград, чтобы максимизировать число получателей?\n* Почему здесь работает жадный подход и как доказать его корректность?\n* Как использовать свойства суммы арифметической прогрессии при решении алгоритмических задач?\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_6_5_1_c964476899_f29fc8d130.svg)\n\n## Нестандартная задача и жадный алгоритм\n\nВы занимаетесь организацией соревнований для детей, и у вас есть $n$ конфет, которые собираетесь раздать в качестве призов. Вы хотите отдать эти конфеты тем, кто займёт первые $k$ мест в соревнованиях, и распределить конфеты так, чтобы за более высокое место всегда выходило больше конфет. Чтобы порадовать как можно больше детей, вам понадобится найти самое большое значение $k$, при котором это возможно.\n\n* Входные данные: Целое число $n$.\n* Выходные данные: Первая строка содержит максимальное число $k$, при котором $n$ можно представить как сумму $k$ пар неповторяющихся положительных целых чисел. Вторая строка — $k$ пар неповторяющихся положительных целых чисел, сумма которых будет $n$ (если есть несколько таких вариантов, то можно использовать любой из них).\n* Ограничения: $1 \\le n \\le 10^9$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n6\n\n|\n\n3\u003cbr\u003e1 2 3\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n8\n\n|\n\n3\u003cbr\u003e1 2 5\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\n\n|\n\n1\u003cbr\u003e2\n\n||\n|#\n\n### Упражнение\n\nМожно ли представить 8 как сумму четырёх неповторяющихся положительных целых чисел?\n\nНетрудно понять, что ответ на этот вопрос: «Нет». Предположим, что $8=a_1+a_2+a_3+a_4$ и $a_1 \\lt a_2 \\lt a_3 \\lt a_4$ . Тогда $a_1 \\ge 1$, $a_2 \\ge 2$, $a_3 \\ge 3$ и $a_4 \\ge 4$. Однако тогда $a_1+a_2+a_3+a_4 \\ge 10$.\n\nПо этой же причине, если $n$ равно сумме $k$ неповторяющихся положительных целых чисел $a_1, \\dots, a_k$, то $n=a_1+\\dots+a_k \\ge 1+\\dots+k = \\frac{k(k+1)}{2}$. Верно и обратное: если $n \\ge \\frac{k(k+1)}{2}$, то можно представить $n$ как сумму $k$ неповторяющихся целых чисел.\n\nДействительно, пусть $\\delta=n - \\frac{k(k+1)}{2} \\ge 0$. Тогда $n$ будет равно сумме следующих целых чисел: $1, 2, \\dots, k-1,k+\\delta$. Несложно заметить, что все они отличаются друг от друга.\n\nАлгоритм состоит в нахождении самого большого значения $k$, при котором $\\frac{k(k+1)}{2} \\le n$.\n\nВремя выполнения — $O(k)$ или $O(\\sqrt{n})$.\n\n## Что дальше\n\nТеперь вы умеете применять жадные алгоритмы для распределения ограниченного ресурса и знаете, в каких случаях такая стратегия приводит к оптимальному решению.\n\nДалее — финальная задача главы. Она покажет, что даже на собеседовании можно столкнуться с подводными камнями жадной стратегии: чтобы получить максимальный «оклад», придётся сравнивать не числа, а строки.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80770) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Жадные алгоритмы хорошо работают в задачах распределения, когда нужно покрыть максимум с минимальными затратами.\n* Иногда достаточно отсортировать входные данные и обрабатывать их по порядку — это уже даёт оптимальный результат.\n* Простые стратегии требуют точной формулировки и аккуратной реализации — особенно при работе с ограничениями."])</script><script nonce="">self.__next_f.push([1,"7c:T2023,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте нестандартную задачу на сортировку, которая проверяет не только знание алгоритмов, но и умение формулировать правильные правила сравнения. Она известна как классическая головоломка: из набора чисел нужно составить такое, которое даёт наибольшее значение при конкатенации.\n\nНа первый взгляд кажется, что достаточно отсортировать числа по убыванию. Но именно здесь скрыта ловушка: простая сортировка не приведёт к верному ответу. Главный вызов задачи — не сама сортировка, а корректное определение критерия, по которому строки должны сравниваться между собой. Это отличный пример того, что в алгоритмах важна не только техника реализации, но и точность в постановке правил.\n\n## Ключевые вопросы параграфа\n\n* Почему обычная сортировка по убыванию не работает для составления максимального числа?\n* Как сравнивать строки чисел, чтобы результат был действительно максимальным?\n* Какие ошибки чаще всего возникают при реализации таких задач — и как их избежать?\n\n## Вопрос на собеседовании\n\nПеред вами, возможно, самая важная задача в хендбуке. В качестве последнего вопроса на собеседовании будущий начальник даёт вам пять бумажек с одним числом на каждой и просит составить из них самое большое число. Получившееся число — ваша зарплата, поэтому мотивация, чтобы решить эту задачу, зашкаливает.\n\nВспомните алгоритм для этой задачи, который работает с однозначными числами.\n\n```cpp\nLargestConcatenate(Numbers):\n    yourSalary = \"\" # пустая строка\n    while Numbers is not empty:\n        maxNumber = -infinity\n        for each number in Numbers:\n            if number \u003e= maxNumber:\n                maxNumber = number\n        yourSalary = yourSalary + maxNumber # добавляем число в конец\n        Numbers.remove(maxNumber) # удалить из рассмотрения число maxNumber\n    return yourSalary\n```\n\nТакой алгоритм не всегда будет приводить к самой большой зарплате: например, при вводе из двух целых чисел 23 и 3 он выдаст 233, в то время как самое большое число — 323.\n\nНе беспокойтесь, чтобы получить самую большую зарплату, вам всего лишь нужно заменить строку\n\n```cpp\nif number \u003e= maxNumber:\n```\n\nна следующую:\n\n```cpp\nif IsBetter(number, maxNumber):\n```\n\nДля надлежаще реализованной функции ``IsBetter`` нужно учесть порядок цифр и их количество. Функции ``IsBetter(first, second)`` должна возвращать булеву величину сооветствующую ответу на вопрос: нужно ли ставить число ``first`` раньше числа ``second``. Например, ``IsBetter(3, 23)`` выдаст ``True``.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Как бы вы реализовали ``IsBetter``?\n\n* Входные данные:  Первая строка ввода содержит целое число $n$. Вторая строка содержит целые числа $a_1, \\dotsc, a_n$.\n* Выходные данные: Самое большое возможное число, которое состоит из $a_1, \\dotsc, a_n$.\n* Ограничения: $1 \\le n \\le 100$; $1 \\le a_i \\le 10^3$ для всех $1 \\le i \\le n$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\u003cbr/\u003e 21 2\n\n|\n\n221\n\n||\n|#\n\nОбратите внимание, что в этом случае приведённый выше алгоритм также выдаёт неправильный ответ 212.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5\u003cbr/\u003e9 4 6 1 9\n\n|\n\n99641\n\n||\n|#\n\nВвод состоит только из однозначных чисел, поэтому алгоритм выше выдаёт правильный ответ.\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr/\u003e23 39 92\n\n|\n\n923923\n\n||\n|#\n\nТем не менее алгоритм ``LargestConcatenate`` (неверный) в этом случае приводит к правильному результату — ещё одно напоминание, что всегда стоит проверять правильность жадных алгоритмов!\n\n## Что дальше\n\nТеперь вы знаете, как применять жадную стратегию не только к числам, но и к строкам. Вы научились сравнивать строки так, чтобы получить максимальное число, — и поняли, что простой порядок убывания не всегда работает. Эта задача — отличный пример того, как важно выбрать правильный критерий сравнения, даже если идея кажется простой.\n\nДалее — подведение итогов. Вы вспомните, какие приёмы жадных алгоритмов вы освоили, в чём их сила и в чём ограничения.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80771) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* В некоторых задачах важно уметь сравнивать строки нестандартным способом — не по алфавиту, а по результату объединения.\n* Простая сортировка не всегда даёт правильный результат: нужно чётко задать правило, по которому элементы упорядочиваются.\n* Жадные стратегии применимы и к строкам, но требуют особенно внимательной формулировки критерия выбора."])</script><script nonce="">self.__next_f.push([1,"7d:T79c,"])</script><script nonce="">self.__next_f.push([1,"В седьмой главе вы познакомились с одним из самых простых и мощных инструментов алгоритмики — жадными стратегиями. Вы увидели, что такие алгоритмы могут быть эффективны даже в задачах с ограничениями, если правильно выбрать критерий выбора и обосновать его корректность.\n\nТеперь вы умеете:\n\n* Решать задачи с помощью жадного выбора — например, размена монет, отбора по плотности, покрытия отрезков и распределения призов.\n* Проверять, работает ли жадная стратегия в конкретной задаче, и доказывать её корректность — или находить контрпример.\n* Использовать сортировку, аккуратное округление и учёт ограничений при реализации решений.\n* Разделять ситуации, когда жадный алгоритм даёт оптимальный результат и когда нужно искать другие подходы.\n\nЖадные алгоритмы — это быстрый способ получить решение. Но важно помнить: не всякая задача им поддаётся. В следующей главе вы познакомитесь с другим фундаментальным методом — динамическим программированием, которое помогает эффективно решать задачи с перекрывающимися подзадачами и накоплением оптимальных решений."])</script><script nonce="">self.__next_f.push([1,"7e:T3a31,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе мы реализуем разные алгоритмы динамического программирования и увидим, как они решают задачи, которые не поддавались решению с использованием «жадных» алгоритмов и подхода «Разделяй и властвуй». Вы увидите, как сложную задачу можно разбить на подзадачи, сохранить их решения и на основе этого построить общий ответ. На примере подсчёта путей и кратчайших маршрутов вы научитесь проектировать алгоритмы с повторным использованием вычислений.\n\nВ итоге вы узнаете, как одна идея позволяет автоматически исправлять орфографические ошибки и при этом находить разницу между двумя вариантами одного и того же текста.\n\n## Ключевые вопросы параграфа\n\n* В чём суть динамического программирования и как оно отличается от других стратегий?\n* Как выделить подзадачи и сформулировать рекуррентное соотношение?\n* Как реализовать и оптимизировать алгоритм, чтобы он работал быстро и экономно?\n\n## Алгоритмы динамического программирования\n\nДинамическое программирование на практике применяется в большом числе случаев. Оно подходит и для поиска похожих страниц в интернете, и для предсказывания генов в последовательностях ДНК.\n\n## Основная идея\n\n### Количество путей\n\nДля понимания идеи, которая используется в подходе динамического программирования, предлагаем вам попробовать решить следующую головоломку.\n\n**Интерактивная головоломка «Количество путей».**\n\nВ нижеприведённой сети есть множество путей ведущих от $s$ к $t$, — например: $s \\to b \\to e \\to t$ и $s \\to a \\to c \\to d \\to t$. Каково общее количество путей?\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_1_dc4717fb38_ff87308508.svg)\n\nТак как мы начинаем с $s$, существует уникальный способ добраться до $s$. Давайте запишем:\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_2_b38c28d142_7ff18bd012.svg)\n\nДля $a$ и $b$ также существует просто один путь.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_3_69c3974821_103f16eca1.svg)\n\nТак как существует только один путь к $a$ и только один к $b$, количество путей к $c$ составляет $1+1=2$ ($s \\to a \\to c$ и $s \\to b \\to c$).\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_4_3c44e226f0_1b2646f2d7.svg)\n\nАналогичным образом для достижения $d$ необходимо прийти либо к $a$, либо к $c$. Существует только один путь до $a$ и два пути до $c$. Так количество путей, которые ведут к $d$, составляет $1+2=3$ ($s\\to a \\to d$, $s\\to a \\to c \\to d$ и $s\\to b \\to c \\to d$).\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_5_9e85a123cb_49657c3ef6.svg)\n\nКоличество путей, заканчивающихся на $e$, равно $1$, так как к $e$ можно прийти только от $b$.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_6_d7332d41bb_1caceef1f6.svg)\n\nДо $c$ есть два пути, до $d$ — три пути, до $e$ — один. Выходит, что путей до $t$ существует $2+3+1=6$.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_7_8c4539b003_c7b7b8e2e2.svg)\n\n### Динамическое программирование\n\nРассмотрим наше решение головоломки «Количество путей» и изложим основные идеи динамического программирования. Для узла $v$ — $paths(v)$ будет количеством путей от стартового узла $s$ к узлу $v$. Несомненно, $paths(s)=1$. Это называется базовый случай. Соответствующее значение для всех других узлов можно найти с помощью рекуррентного соотношения:\n\n$$paths(v)= \\sum_{\\text{все предшествующие $w$ от $v$}} paths(w) \\,\n$$\n\nгде предшественник $v$ — это узел, связанный ребром с $v$.\n\nМногие алгоритмы динамического программирования используют одну схему:\n\n— Вместо того, чтобы решать изначальную задачу, алгоритм решает несколько подзадач такого же типа.\\\n— Алгоритм вычисляет решение для каждой подзадачи с помощью рекуррентного соотношения, в которое входят решения более мелких подзадач.\\\n— Алгоритм сохраняет решения подзадач и таким образом избегает перевычисления.\n\n### Ориентированный ациклический граф: кратчайший путь\n\nТеперь рассмотрим взвешенный граф, в котором у каждого ребра $e$ обозначена длина $length(e)$. Длина пути в таком графе определяется суммой длины рёбер.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_9_0259340995_0d93311fcf.svg)\n\nНапример, длина пути $s \\to b \\to e \\to t$ составляет $5+7+4=16$. Какова минимальная длина пути от $s$ до $t$?\n\nТак как каждый путь от $s$ до $t$ проходит через $c$, $d$ или $e$ перед тем, как прийти к $t$,\n\n$$length(t)=\\min \\{length(c)+6, length(d)+8, length(e)+4\\}\\,\n$$\n\nгде $length(v)$ — минимальная длина пути от $s$ до $v$. Расстояния до $c$, $d$ и $e$ можно найти с помощью похожих рекуррентных соотношений:\n\n$$\\begin{matrix}\n        length(c)=\\min \\{length(a)+4, length(b)+1\\}\\,, \\\\\n        length(d)=\\min \\{length(a)+7, length(c)+2\\}\\,, \\\\\n        length(e)=length(b)+7\\,.\n\\end{matrix}\n$$\n\nПриведём рекуррентные соотношения для $a$ и $b$:\n\n$$\\begin{matrix}\n        length(a)=length(s)+4\\,,\\\\\n        length(b)=length(s)+5\\,.\n\\end{matrix}\n$$\n\nНаконец, базовый случай — это $length(s)=0$. С его помощью можно найти расстояние до всех узлов сети, включая наш узел $t$. Для этого нужно использовать вышеприведённые рекуррентные соотношения, которые можно записать в компактной форме:\n\n$$        length(v)= \\min_{\\text{все предшествующие $w$ от $v$}}\n        \\{length(w) + length(w, v) \\}.\n$$\n\nДля модельной ситуации удобно записывать результаты по мере того, как мы выполняем вычисления, прямо на изображении. Мы получаем следующие результаты.\n\n![algosy_8_1_10_d448bcee07_419f976eca.svg](https://yastatic.net/s3/education-portal/media/algosy_8_1_10_d448bcee07_419f976eca_0ebe4def15.svg)\n\n\u003e **Остановитесь и подумайте:**\n\u003e Минимальная длина пути от $s$ до $t$ составляет $12$. Можете понять, как находится путь такой длины?\n\nВ алгоритме динамического программирования для этого выполняется бэктрекинг («поиск с возвратом») решений, которые привели к оптимальному результату. В особенности отметим один из трёх выборов, который приводит нас к значению $length(t)$.\n\n$$length(t) = \\min \\{length(c)+6, length(d)+8, length(e)+4\\} = \\min\\{12,16,16\\}=12.\n$$\n\nИсходя из этого, мы можем заключить, что последнее ребро оптимального пути — это $c \\to t$. Аналогично,\n\n$$length(c) = \\min \\{length(a)+4, length(b)+1\\} = \\min\\{8,6\\}=6 \\,\n$$\n\nтак мы приходим от $b$ к $c$. Таким образом, путь от $s$ до $t$ длиной $12$ составляет\n\n$$s \\to b \\to c \\to t.$$\n\nУ вышеприведённой сети есть удобное свойство. Оно заключается в том, что мы можем определять порядок её узлов, что обеспечивает следующее: каждый узел идет после всех предшествующих — то есть узлы, которые указывают на текущий узел (например, $c$, $d$ и $e$ предшествуют $t$). Сети с таким свойством называются ориентированные ациклические графы. Мы увидим, что многие алгоритмы динамического программирования используют ориентированные ациклические графы — явно или неявно.\n\n## Проектирование алгоритмов динамического программирования\n\nТеперь, когда вы познакомились с несколькими алгоритмами динамического программирования, подведём итог и повторим основные шаги для проектирования таких алгоритмов.\n\n1. **Определить подпроблемы.** Первый и самый важный шаг — это идентифицировать подпроблемы и записать рекуррентное соотношение (с базовым случаем). Как правило, это делается через анализ структуры оптимального решения или через оптимизацию решения, использующего исчерпывающий поиск.\n2. **Спроектировать рекурсивный алгоритм.** Сделать из рекуррентного соотношения рекурсивный алгоритм:\n   * сохранить решение каждой подзадачи в таблице;\n   * перед решением подзадачи проверить, нет ли уже в таблице её решения (мемоизация).\n\n3. **Спроектировать итерационный алгоритм.** Сделать из рекурсивного алгоритма итерационный алгоритм:\n   * инициализировать таблицу;\n   * продвигаться от мелких подзадач к большим.\n\n4. **Оценить время выполнения.** Доказать верхнее ограничение времени выполнения. Обычно произведение количества подпроблем и времени, необходимого для решения подзадачи, предоставляет верхнее ограничение времени выполнения.\n5. **Обнаружить решение.** Обнаружить оптимальное решение, используя бэктрекинг рекуррентного соотношения.\n6. **Экономить место.** Использовать обычную структуру таблицы, чтобы проверить, можно ли сэкономить место по сравнению с более прямым решением.\n\n## Что дальше\n\nТеперь вы знаете, как работает динамическое программирование, — от базовых случаев и рекурсии до оптимизированных решений с таблицами и перебором подзадач. Вы познакомились с идеей сохранения промежуточных результатов, научились вычислять количество путей в графе и находить кратчайшие маршруты. Этот подход ляжет в основу всех задач этой главы.\n\nДалее — задача «Размен-2». Вы увидите, как динамическое программирование позволяет находить минимальное количество монет, даже когда жадный алгоритм не справляется.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n"])</script><script nonce="">self.__next_f.push([1,"7f:T2bea,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы узнаете, почему жадная стратегия не всегда подходит для задачи сдачи и как динамическое программирование помогает найти оптимальное решение. Вы разберётесь с рекуррентной формулой, научитесь строить эффективный алгоритм с мемоизацией и поймёте, как ускорить его с помощью табличного подхода.\n\n## Ключевые вопросы параграфа\n\n* Почему жадный алгоритм не справляется с задачей оптимальной сдачи?\n* Как составить рекуррентное соотношение для минимального числа монет?\n* В чём отличие мемоизации от табличного (bottom-up) подхода?\n* Как реализовать решение задачи с помощью динамического программирования?\n\n## Сдача\n\nКак нам уже известно, естественный «жадный» подход к этой задаче работает неправильно при любом наборе номиналов. Например, при номиналах $1$, $3$ и $4$ «жадный» алгоритм разменяет $6$ центов тремя монетами ($4+1+1$), хотя это возможно сделать всего лишь двумя ($3+3$). Ваша цель — использовать динамическое программирование для решения задачи «Сдача» с номиналами $1$, $3$ и $4$.\n\n* Входные данные: Целое число $money$.\n* Выходные данные: Минимальное количество монет номиналами $1$, $3$, $4$, чтобы выдать сдачу с $money$.\n* Ограничения: $1 \\le money \\le 10^3$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n34\n\n|\n\n9\n\n||\n|#\n\n* $34=3+3+4+4+4+4+4+4+4$.\n\n### Решение\n\nДля оптимального варианта сдачи с $26$ необходимо семь монет. Рассмотрим произвольный поднабор оптимального решения — например, если сложить четыре монеты из приведённого ниже прямоугольника, то получится $15$.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Сможете разменять $15$ центов тремя монетами?\n\n{% cut \"Ответ на этот вопрос\" %}\n\nНет. Если бы размен $15$ был возможен тремя монетами, то можно было бы заменить выделенные четыре монеты и получить сдачу с $26$ шестью монетами, а не семью.\n\n{% endcut %}\n\nТакая ситуация показывает нам важную особенность динамического программирования — решение задачи содержит решения всех её мелких подзадач.\n\nЭта особенность позволяет найти решение задачи, сначала выполняя мелкие подзадачи.\n\nПусть $change(money)$ — это минимальное количество монет номиналами $1$, $3$ и $4$, которые нужны для сдачи с $money$, а $(c_1,\\dotsc,c_k)$ — оптимальная сдача с $money$. В таком случае\n\n$$c_1+\\dotsb+c_k=money .\n$$\n\nТогда\n\n$$c_1+\\dotsb+c_{k-1}=money-c_k.\n$$\n\nСледовательно, $change(money-c_k)=k-1$. Таким образом, для решения задачи при $money$ достаточно решить её при $money-c_k$ и добавить единицу.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Мы закончили?\n\n{% cut \"Ответ\" %}\n\nПроблема в том, что мы не знаем значение $c_k$.\n\n{% endcut %}\n\nТем не менее мы знаем, что $c_k$ равняется или $1$, или $3$, или $4$. Так $change(money)$ равно одному из следующих вариантов: $change(money-1)+1$, $change(money-3)+1$ и $change(money-4)+1$.\n\nТак как мы ищем оптимальный способ выдать сдачу, $money$ равно минимальному из этих трёх выражений. В итоге мы получаем следующее рекуррентное соотношение:\n\n$$change(money)=1+\\min(change(money-c) \\colon c \\in {1, 3, 4},\\, c \\le money).\n$$\n\nПри небольших аргументах это соотношение выражает значение $change$ рекурсивным образом через собственные значения. Для такой нисходящей рекурсии нам необходимо указать базовый случай. У нас это будет $money=0$: $change(0)=0$.\n\nУравнение выше — самая важная часть алгоритма динамического программирования, так как из него легко сделать рекурсивный алгоритм.\n\n```cpp\nChange(money):\n    if money=0:\n        return 0\n    else:\n        result = +infinity\n        for c=1,3,4:\n        if c \u003c= money:\n            result = min(result,1+Change(money-c))\n        return result\n```\n\nУ этого алгоритма есть серьёзная проблема: он становится крайне медленным, потому что вызывает `Change(money)` снова и снова для одного и того же значения $money$.\n\nМемоизация — стандартный способ избежать этого: при вычислении `Change(money)` мы можем использовать сохранение в таблице и тогда нам не придётся делать перевычисление.\n\n```cpp\ntable=associative array\n    \nChange(money):\n    if table[money] is not yet computed:\n    if money=0:\n        table[money]←0\n    else:\n        result = +infinity\n        for c=1,3,4:\n        if c \u003c= money:\n            result = min(result,1+Change(money-c))\n        table[money] = result\n    return table[money]\n```\n\nНа практике такой алгоритм уже достаточно хорош, хотя у него есть проблемы с эффективностью: рекурсивные вызовы и уточняющие запросы для ассоциативного массива приводят к замедлению. Заметив, что все вычисляемые значения — это последовательные целые числа, мы можем реализовать улучшенный подход, в котором используется массив для хранения решений всех задач.\n\n```cpp\nChange(money):\n    table[0..money] = [+infinity,…,+infinity]\n    table[0] = 0\n    \n    for m from 1 to money:\n        for c=1,3,4:\n        if c \u003c= m:\n            table[m] = min(table[m],1+table[m-c])\n    return table[money]\n```\n\nВремя выполнения этого алгоритма составляет $O(money)$, так как каждая итерация внешнего цикла **for** проходит за постоянное время.\n\n\u003e Обратите внимание, что описанный выше алгоритм неявно находит кратчайший путь в ориентированном ациклическом графе, приведённом ниже (при $money=12$). Рассчитайте время выполнения алгоритма для самого короткого пути в аналогичном графе при произвольном значении $money$.\n\n## Что дальше\n\nТеперь вы умеете использовать динамическое программирование для нахождения оптимального числа монет при сдаче. Вы поняли, почему жадный подход может давать неверный результат, научились строить рекурсивные решения с мемоизацией и ускорять их с помощью таблицы. А ещё увидели, что даже простая задача может быть связана с кратчайшими путями в графах.\n\nДалее — задача на построение выражения с минимальной стоимостью вычислений. Вы научитесь определять порядок операций, который экономит ресурсы, и познакомитесь с динамическим программированием на интервалах.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80777) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Жадный подход может давать неоптимальные решения в задаче размена.\n* Динамическое программирование позволяет учитывать все варианты и выбирать наилучший.\n* Рекурсия с мемоизацией помогает избежать повторных вычислений, но может быть медленной.\n* Табличный (bottom-up) подход эффективнее и позволяет решать задачу за линейное время.\n* Такие задачи часто можно представить как поиск кратчайшего пути в графе."])</script><script nonce="">self.__next_f.push([1,"80:T2718,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы научитесь строить оптимальную последовательность операций, которая позволяет получить заданное число, начиная с 1. На первый взгляд кажется разумным всегда делить число пополам, если это возможно, — но такой жадный подход не гарантирует кратчайшего пути. Мы разберём, как динамическое программирование позволяет найти действительно минимальную последовательность шагов.\n\n## Ключевые вопросы параграфа\n\n* Почему жадная стратегия не гарантирует оптимальный результат при построении последовательности операций?\n* Как использовать динамическое программирование для поиска минимального числа шагов?\n* Как восстановить оптимальную последовательность действий из таблицы значений?\n\n## Вводная информация по задаче\n\nУ вас есть калькулятор, который выполняет с целым числом $x$ только следующие операции: сложить $x$ и $1$, умножить $x$ на $2$ или умножить $x$ на $3$. Имея положительное целое число $n$, вы должны найти минимальное количество операций, необходимых для получения числа $n$ из числа $1$.\n\nПопробуем решить эту задачу с помощью «жадной» стратегии: если текущее число не превышает $\\frac{n}{3}$, то умножим его на 3; если оно больше $\\frac{n}{3}$, но не больше $\\frac{n}{2}$, то умножим его на 2; в остальных случаях добавим к нему 1. Это приводит к следующему псевдокоду.\n\n```cpp\nGreedyCalculator(n):\n    numOperations = 0\n    currentNumber = 1\n    while currentNumber\u003cn:\n        if currentNumber \u003c= n/3:\n            currentNumber = 3*currentNumber\n        else if currentNumber \u003c= n/2:\n            currentNumber = 2*currentNumber\n        else: \n            currentNumber = 1+currentNumber\n        numOperations = numOperations+1\n    return numOperations\n```\n\n\u003e **Остановитесь и подумайте:**\n\u003e Сможете ли вы найти такое число $n$, при котором ``GreedyCalculator(n)`` приводит к неправильному ответу?\n\n* Входные данные: Целое число $n$.\n* Выходные данные: В первой строке: $k$ — минимальное число необходимых операций для получения $n$ из $1$. Во второй строке: последовательность промежуточных чисел. Так, вторая строка должна содержать положительные целые числа $a_0, a_1, \\dotsc, a_{k}$, при которых $a_0=1$, $a_{k}=n$, и для всех $1 \\le i \\le k$ $a_{i}$ равно $a_{i-1}+1$, $2 a_{i-1}$ или $3a_{i-1}$. Если таких последовательностей много, то можно вывести любую из них.\n* Ограничения: $1 \\le n \\le 10^6$.\n\n#### Пример 1\n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\n\n|\n\n0\u003cbr\u003e1\n\n||\n|#\n\n#### Пример 2\n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n96234\n\n|\n\n14\u003cbr\u003e1 3 9 10 11 22 66 198 594 1782 5346 16038 16039 32078 96234\n\n||\n|#\n\n* Ещё один корректный вывод в этом случае — это «1 3 9 10 11 33 99 297 891 2673 8019 16038 16039 48117 96234».\n\n### Решение\n\nРассмотрим решение задачи. Пусть $calculator(n)$ — минимальное количество операций, необходимых для получения числа $n$ из числа $1$. Так как последняя операция в оптимальной последовательности — это «$+1$», «$\\times 2$» или «$\\times 3$», мы получаем следующее рекуррентное соотношение для $n \\ge 1$:\n\n$$calculator(n)=1+\\min\n\\begin{cases}\n    calculator(n-1), \u0026\\\\\n    calculator(n/2), \u0026 \\text{если $n$ кратно $2$,}\\\\\n    calculator(n/3), \u0026 \\text{если $n$ кратно $3$.}\\\\\n\\end{cases}$$\n\nДанное рекуррентное соотношение, вместе с базовым случаем $calculator(1)=1$, можно трансформировать в рекурсивный, а затем в итерационный алгоритм.\n\n```cpp\nCalculator(n):\n    table[1..n]←[+infinity,…,+infinity]\n    table[1] = 0\n\n    for k from 2 to n:\n        table[k]=1+table[k−1]\n        if k is divisible by 2:\n            table[k]=min(table[k],1+table[k/2])\n        if k is divisible by 3:\n            table[k]=min(table[k],1+table[k/3])\n    return table[n]\n```\n\nПомните, что помимо оптимального значения необходимо вывести оптимальную последовательность операций. Для этого обратим внимание на то, что мы можем найти последнюю операцию следующим образом:\n\n* это «$+1$», если $calculator(n)=1+calculator(n-1)$;\n* это «$\\times 2$», если $n$ можно разделить на $2$ и $calculator(n)=1+calculator(n/2)$;\n* это «$\\times 3$», если $n$ можно разделить на $3$ и $calculator(n)=1+calculator(n/3)$.\n\nЭти действия позволяют нам выявить оптимальную последовательность:\n\n1. найти последнюю операцию;\n2. заменить $n$ на $n-1$, $\\frac{n}{2}$ или $\\frac{n}{3}$ (в зависимости от того, какой это из трёх случаев выше);\n3. повторить (пока $n\u003e1$).\n\n```cpp\nCalculator(n):\n    table[1..n]←[+infinity,…,+infinity]\n    table[1] = 0\n\n    for k from 2 to n:\n        table[k]=1+table[k−1]\n        if k is divisible by 2:\n            table[k]=min(table[k],1+table[k/2])\n        if k is divisible by 3:\n            table[k]=min(table[k],1+table[k/3])\n\n    operations = empty list\n    while n \u003e 1:\n        append n to operations\n        if table[n]=1+table[n−1]:\n            n = n - 1\n        else if n is divisible by 2 and table[n]=1+table[n/2]:\n            n = n/2\n        else if n is divisible by 3 and table[n]=1+table[n/3]:\n            n = n/3\n    return operations\n```\n\nВремя выполнения алгоритма составляет $O(n)$.\n\n## Что дальше\n\nТеперь вы знаете, как находить минимальную последовательность операций для получения заданного числа, используя динамическое программирование. Вы научились строить таблицу значений и восстанавливать по ней путь — от цели к началу. А ещё убедились, что жадный подход может подвести, даже если кажется логичным.\n\nДалее — задача на редактирование строк. Вы узнаете, как рассчитать расстояние между двумя строками, используя матрицу изменений, и зачем это нужно в задачах на сравнение, поиск и коррекцию.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80778) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Жадный алгоритм может не давать оптимальный результат — даже если кажется разумным.\n* Динамическое программирование позволяет найти кратчайшую последовательность операций с минимальными затратами.\n* Чтобы восстановить путь, нужно не только посчитать значения, но и зафиксировать переходы.\n* Умение строить такие цепочки важно для задач, где нужно не только посчитать, но и объяснить, как получить ответ.\n"])</script><script nonce="">self.__next_f.push([1,"81:T3e68,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с классической задачей, широко применяемой в анализе текстов, биоинформатике и других сферах. Вы узнаете, как находить минимальное количество операций (вставок, удалений и замен), чтобы превратить одну строку в другую, — и как вычислить это число эффективно с помощью динамического программирования.\n\n## Ключевые вопросы параграфа\n\n* Что такое редакционное расстояние и как оно используется на практике?\n* Как устроена рекурсивная формулировка задачи и почему мемоизация помогает?\n* Как динамически находить расстояние между всеми префиксами двух строк?\n* Как оптимизировать решение по памяти и находить выравнивание?\n\n![algorithms_8.4.1](https://yastatic.net/s3/education-portal/media/Algosy_8_4_1_fccd77c53a.svg)\n\n## Варианты применения задачи\n\nЕсть множество вариантов, как применить задачу «Расстояние редактирования». Она подойдёт для обработки текстов на естественном языке, проверки правописания и других направлений. К примеру, биологи зачастую вычисляют редакционное расстояние, когда ищут мутации, вызывающие болезни.\n\nРедакционное расстояние между двумя строками определяется как минимальное число односимвольных вставок, удалений и замен, необходимых для преобразования одной строки в другую.\n\n* **Входные данные:** Две строки, состоящие из строчных букв латинского алфавита.\n* **Выходные данные:** Редакционное расстояние между строками.\n* **Ограничения:** Длина обеих строк не меньше $1$ и не больше $100$.\n\n#### Пример 1\n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nshort\u003cbr\u003eports\n\n|\n\n3\n\n||\n|#\n\n* Вторую строку можно получить из первой, удалив s, заменив h на p и вставив s. Это можно компактно продемонстрировать следующим выравниванием.\n\n![algorithms_8.4.2](https://yastatic.net/s3/education-portal/media/11_070b2ec127_fa36a0a031.webp)\n\n#### Пример 2\n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nediting\u003cbr\u003edistance\n\n|\n\n5\n\n||\n|#\n\n* Удалить e, вставить s после i, заменить i на a, заменить g на c, вставить e в конце.\n\n![algorithms_8.4.3](https://yastatic.net/s3/education-portal/media/12_57f900c730_22ce824c60.webp)\n\n#### Пример 3\n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nab\u003cbr\u003eab\n\n|\n\n0\n\n||\n|#\n\n* Совет: будьте осторожны с рекурсией.\n\n### Решение\n\nРассмотрим решение задачи. Выравнивание двух строк в двухрядной матрице осуществляется таким образом, чтобы первый (второй) ряд содержал упорядоченные символы первой (второй) строки, которые перемежаются пробелами («$-$»).\nВ колонке не может быть два пробела одновременно в обеих строках.\n\n## Упражнение\n\nВычислите количество разных пар выравненных строк длиной $n$ и $m$.\n\nМы классифицируем колонки выравнивания следующим образом (первый символ из верхней строки, второй — из нижней):\n\n— колонка с символом и пробелом\n\n```— это удаление;```\n\n— колонка с пробелом и символом\n\n```— вставка;```\n\n— колонка с двумя одинаковыми символами\n\n```— совпадение;```\n\n— колонка с двумя разными символами\n\n```— это несоответствие.```\n\nМы ищем выравнивание, при котором минимизируется общее количество несоответствий, удалений и вставок.\n\nВыравнивание считается оптимальным по сравнению со всеми другими возможными вариантами, если оно содержит минимум несоответствий, удалений и вставок.\nСтоит обратить внимание, что может быть несколько различных оптимальных выравниваний.\n\n## Упражнение\n\nДокажите, что задача на редакционное расстояние может быть сведена к поиску оптимального выравнивания двух строк.\n\nВ примере выше последняя колонка — это вставка. Отбросив эту колонку, мы получаем оптимальное выравнивание первой строки и префикса второй.\n\nРассмотрим идею рассчитать редакционное расстояние между каждой парой префиксов двух строк. Это более общая постановка задачи, но важно отметить, что, решив её, мы найдём ответ и на интересующий нас вопрос.\n\n### Решение\n\nИмея строки $A[1\\dotsc n]$ и $B[1 \\dotsc m]$, мы рассмотрим их префиксы $A[1\\dotsc i]$ и $B[1 \\dotsc j]$ длиной $i$ и $j$ и обозначим их редакционное расстояние $EditDistance(i,j)$.\n\nТак как последняя колонка оптимального выравнивания $A[1 \\dotsc i]$ и $B[1 \\dotsc j]$ — это или вставка, или удаление, или несоответствие, или совпадение, имеем,\n\n$$\n    EditDistance(i,j) = \\min \\begin{cases}\n    {EditDistance(i,j-1)+1}\\\\\n    {EditDistance(i-1,j)+1}\\\\\n    {EditDistance(i-1,j-1)+1}  \u0026\\text{if }A[i]\\neq B[j]\\\\\n    {EditDistance(i-1,j-1)}  \u0026\\text{if }A[i]=B[j]\\\\\n\\end{cases}\n$$\n\nБазовый случай для этого рекуррентного соотношения — $i=0$ и $j=0$:\n\n$$\nEditDistance(0,j)=j \\quad \\text{и} \\quad EditDistance(i,0)=i \\, .\n$$\n\nЭто можно выразить более кратко: если $i=0$ или $j=0$, тогда\n\n$$\nEditDistance(i,j)=\\max\\{i,j\\}.\n$$\n\nПсевдокод ниже делает из этого рекуррентного соотношения рекурсивный алгоритм и использует мемоизацию для избежания перевычислений.\n\n```cpp\ntable = associative array\n    \nEditDistance(A,B,i,j):\n    if table[i,j] is not yet computed:\n        if i=0 or j=0:\n            table[i,j] = max(i,j)\n        else:\n            insertion = EditDistance(A,B,i,j−1)+1\n            deletion = EditDistance(A,B,i−1,j)+1\n            match = EditDistance(A,B,i−1,j−1)\n            mismatch = EditDistance(A,B,i−1,j−1)+1\n            if A[i]=B[j]:\n                table[i,j] = min(insertion,deletion,match)\n            else:\n                table[i,j] = min(insertion,deletion,mismatch)\n    return table[i,j]\n```\n\nВремя выполнения этого алгоритма составляет $O(nm)$, так как выполняется не больше $nm$ рекурсивных вызовов, которые добавляют значения в `table`.\n\n## Рекурсивный алгоритм\n\nРекурсивный алгоритм вычисляет $EditDistance(i,j)$ для всех $0 \\le i \\le n$ и $0 \\le j \\le m$. Из рекурсивного алгоритма можно сделать итерационный, который будет сохранять решения всех подзадач в двумерной таблице. Таблица заполняется по рядам проходами. Это гарантирует, что когда мы вычислим значение клетки $(i,j)$, значения клеток $(i,j-1)$, $(i-1,j)$ и $(i-1,j-1)$ будут уже готовы.\n\n```cpp\nEditDistance(A[1…n],B[1…m]):\n    table = 2d array of size (n+1) * (m+1)\n    table[0][j] = j for all i,j\n    for i from 1 to n:\n        for j from 1 to m:\n            insertion = table[i][j−1]+1\n            deletion = table[i−1][j]+1\n            match = table[i−1][j−1]\n            mismatch = table[i−1][j−1]+1\n            if A[i]=B[j]:\n                table[i][j] = min(insertion,deletion,match)\n            else:\n                table[i][j] = min(insertion,deletion,mismatch)\n    return table[n][m]\n```\n\nИтоговая таблица для нашего примера изображена на рисунке ниже. Значение каждой клетки вычисляется, исходя из значений соседних клеток сверху, слева и слева-сверху. У каждой клетки входящие стрелки указывают на один или несколько случаев (вставка, удаление, несоответствие, или совпадение), которые приводят к значению этой клетки.\n\n![algorithms_8.4.4](https://yastatic.net/s3/education-portal/media/Algosy_8_4_2_5eb41667af.svg)\n\nТаблица соответствует ориентированному ациклическому графу, в котором все рёбра, за исключением синих, имеют длину $1$. А синие ребра соответствуют совпадающим символам и имеют длину $0$. Алгоритм находит на графе самый короткий путь от узла слева сверху до узла справа снизу.\n\nВремя выполнения алгоритма составляет $O(nm)$. Ему требуется $O(nm)$ ячеек памяти для хранения двумерного массива ``table``. Расход места может быть снижен до $O(m)$ (и даже до $O(\\min\\{n,m\\})$), если мы обратим внимание на то, что при заполнении текущего ряда таблицы нам нужны только клетки из текущего и предыдущего. Таким образом, вместо хранения всей таблицы достаточно сохранить текущий и предыдущие ряды.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Вы рассчитали редакционное расстояние между editing и distance. Но как найти пять операций для того, чтобы преобразовать editing в distance?\n\nОтметим, что любой путь от $(0, 0)$ до $(n,m)$ на рисунке образовывает оптимальное выравнивание строк $A$ и $B$.\n\n### Упражнение\n\nПуть, изображённый на рисунке ниже, соответствует оптимальному выравниванию editing и distance. Сколько в этом выравнивании вставок, удалений, совпадений и несоответствий? Постройте оптимальное выравнивание, соответствующее этому пути.\n\n![algorithms_8.4.5](https://yastatic.net/s3/education-portal/media/Algosy_8_4_3_ab039283a8.svg)\n\nОптимальное выравнивание можно обнаружить с помощью перехода по стрелкам в обратную сторону от нижнего правого угла вдоль любого пути, приводящего к верхнему левому углу.\n\n## Что дальше\n\nТеперь вы умеете вычислять редакционное расстояние — минимальное число правок, необходимых для преобразования одной строки в другую. Вы поняли, как формулируется задача рекурсивно, как работает динамическое программирование с таблицей и даже как найти оптимальное выравнивание.\n\nДалее — задача на поиск наибольшей общей подпоследовательности (LCS). Вы увидите, как похожие идеи помогают решать другую важную задачу сравнения строк, и научитесь отличать LCS от редакционного расстояния.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80779) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Редакционное расстояние — это минимальное число вставок, удалений и замен для превращения одной строки в другую.\n* Его можно вычислить с помощью динамического программирования, заполняя таблицу расстояний между префиксами.\n* Переходы в таблице соответствуют операциям редактирования и дают кратчайший путь в сетке выравнивания.\n* Можно восстановить оптимальное выравнивание, двигаясь по таблице в обратную сторону.\n* Решение можно оптимизировать по памяти, если хранить только два ряда таблицы одновременно.\n"])</script><script nonce="">self.__next_f.push([1,"82:T3067,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте задачу поиска наибольшей общей подпоследовательности (LCS) двух или трёх последовательностей. Такие задачи встречаются в системах контроля версий, биоинформатике и при сравнении текстов. Вы узнаете, как построить динамическое решение, которое работает значительно быстрее перебора, и как аккуратно реализовать алгоритм для двух и трёх строк.\n\n## Ключевые вопросы параграфа\n\n* Что такое наибольшая общая подпоследовательность и как её находить?\n* Почему простой перебор работает медленно и как ускорить решение с помощью динамического программирования?\n* Как устроен алгоритм LCS для двух и трёх последовательностей и как реализовать его эффективно?\n\n## Наибольшая общая подпоследовательность из двух последовательностей\n\n![Algoritmy_24_463cd84be9.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_24_463cd84be9_a7dc9e730b.svg)\n\nМы имеем две последовательности $A=(a_1, a_2, \\dotsc, a_n)$ и $B=(b_1, b_2, \\dotsc, b_m)$, их общая подпоследовательность длиной $p$ — это набор $p$ индексов\n\n$$\n \\begin{matrix}\n1 \\leq i_1 \u003c i_2 \u003c  \\dotsb \u003c  i_p \\leq n \\,,\\\\\n1 \\leq j_1 \u003c j_2 \u003c  \\dotsb \u003c  j_p \\leq m \\,.\n  \\end{matrix}\n$$\n\nпри котором\n\n$$\n \\begin{matrix}\na_{i_1} =~b_{j_1}\\,, \\\\\na_{i_2} =~b_{j_2}\\,, \\\\\n\\vdots  \\\\\na_{i_p} =~b_{j_p}\\, .\\\\\n  \\end{matrix}\n$$\n\nНаибольшая общая подпоследовательность — общая подпоследовательность, которая обладает наибольшей длиной из всех подпоследовательностей.\n\nТакая задача может применяться, например:\n— в сопоставлении данных — утилита diff, операция слияния в разных системах управления версиями;\n— в биоинформатике — поиск сходств в генах разных видов;\n— в проверке орфографии.\n\n* **Входные данные:** Первая строка: количество элементов первой подпоследовательности $n$. Вторая строка: $a_1, a_2, \\dotsc, a_n$. Третья строка: количество элементов второй подпоследовательности $m$. Четвёртая строка: $b_1, b_2, \\dotsc, b_m$.\n* **Выходные данные:** $p$.\n* **Ограничения:** $1 \\le n, m \\le 100$; $-10^9 \\le a_i,b_i  \\le 10^9$ для всех $i$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr\u003e2 7 5 \u003cbr\u003e2\u003cbr\u003e2 5\n\n|\n\n2\n\n||\n|#\n\n* Общая подпоследовательность длиной 2 — это $(2,5)$.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\u003cbr\u003e7 \u003cbr\u003e4\u003cbr\u003e1 2 3 4\n\n|\n\n0\n\n||\n|#\n\n* У двух последовательностей нет общих элементов.\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n4\u003cbr\u003e2 7 8 3 \u003cbr\u003e4\u003cbr\u003e5 2 8 7\n\n|\n\n2\n\n||\n|#\n\n* Одна общая подпоследовательность — $(2,7)$. Ещё одна — $(2,8)$.\n\n### Решение\n\nРассмотрим наибольшую общую подпоследовательность $C=(c_1,\\dotsc,c_p)$, определённую индексами $1 \\le i_1 \u003c i_2 \u003c \\dotsb \u003c i_p \\le n$ и $1 \\le j_1 \u003c j_2 \u003c \\dotsb \u003c j_p \\le m$ (так, для каждого $1 \\le q \\le p$, $a_{i_q}=b_{j_q}=c_q$):\n— Последние символы $A$ и $B$ приводятся в $C$. В этом случае $i_p=n$ и $j_p=m$. Тогда $(c_1,\\dotsc, c_{p-1})$ — это наибольшая общая подпоследовательность от $(a_1, \\dotsc, a_{n-1})$ и $(b_1, \\dotsc, b_{m-1})$.\n— Как минимум один из последних символов $A$ и $B$ не приводится в $C$. В этом случае или $i_p\u003cn$, или $j_p\u003cm$. Тогда $(c_1,\\dotsc, c_{p-1})$ находится полностью в $(a_1, \\dotsc, a_{n-1})$ или $(b_1, \\dotsc, b_{m-1})$.\n\nТаким образом, мы сводим задачу с изначальными строками $A$ и $B$ до такой же задачи с их префиксами. Пусть $LCS(i,j)$ — длина наибольшей общей подпоследовательности $A[1\\dotsc i]$ и $B[1 \\dotsc j]$. Выходит, что эта функция удовлетворяет следующее рекуррентное соотношение:\n\n$$\nLCS(i,j) = \\max \\begin{cases}\n    LCS(i-1,j)\\\\\n    LCS(i,j-1)\\\\\n    LCS(i-1,j-1)+1  \u0026\\text{if }A[i]= B[j]\\\\\n\\end{cases}\n$$\n\nБазовый случай для этого рекуррентного соотношения — $i=0$ или $j=0$:\n\n$$\nLCS(0,j)=LCS(i,0)=0 \\, .\n$$\n\nПолученный алгоритм приведён ниже. Его время выполнения составляет $O(nm)$.\n\n```cpp\nLCS(A[1…n],B[1…m]):\n    table = 2d array of size (n+1)×(m+1)\n    table[i][0] = 0 and table[0][j] = 0 for all i,j\n    for i from 1 to n:\n        for j from 1 to m:\n            table[i][j] = table[i−1][j]\n            table[i][j] = max(table[i][j], table[i][j−1])\n            if A[i]=B[j]:\n                table[i][j] = max(table[i][j], table[i−1][j−1]+1)\n    return table[n][m]\n```\n\n\u003e **Остановитесь и подумайте:**\n\u003e Получится ли у вас свести задачу «Наибольшая общая подпоследовательность» до задачи «Редакционное расстояние»?\n\n{% cut \"Подсказка:\" %}\n\nНаибольшая общая подпоследовательность $A=(7,2,9,3,1,5,9,4)$ и $B=(2,8,1,3,9,7)$ получается путём удаления определённых символов из $A$ и $B$.\n\n{% endcut %}\n\nТак задача «Наибольшая общая подпоследовательность» — всего лишь задача «Редакционное расстояние», в которой запрещены операции «замены».\n\n## Наибольшая общая подпоследовательность из трёх последовательностей\n\n![Algoritmy_27_d705fc05eb.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_27_d705fc05eb_26be911d40.svg)\n\nИмея три последовательности: $A=(a_1, a_2, \\dotsc, a_n)$, $B=(b_1, b_2, \\dotsc, b_m)$ и $C=(c_1, c_2, \\dotsc, c_l)$ — нужно найти длину наибольшей общей подпоследовательности для них, то есть наибольшее неотрицательное целое число $p$, при котором существуют индексы\n\n$$\n \\begin{matrix}\n1 \\leq i_1 \u003c i_2 \u003c  \\dotsb \u003c  i_p \\leq n \\,,\\\\\n1 \\leq j_1 \u003c j_2 \u003c  \\dotsb \u003c  j_p \\leq m \\,,\\\\\n1 \\leq k_1 \u003c k_2 \u003c  \\dotsb \u003c  k_p \\leq l\\\\\n  \\end{matrix}\n$$\n\nпри котором\n\n$$\n \\begin{matrix}\na_{i_1} =~b_{j_1} = c_{k_1}\\,, \\\\\na_{i_2} =~b_{j_2} = c_{k_2}\\,, \\\\\n ~~\\vdots\\\\\na_{i_p} =~b_{j_p} = c_{k_p} \\, .\\\\\n  \\end{matrix}\n$$\n\n* Входные данные: Первая строка: $n$. Вторая строка: $a_1, a_2, \\dotsc, a_n$. Третья строка: $m$. Четвёртая строка: $b_1, b_2, \\dotsc, b_m$. Пятая строка: $l$. Шестая строка: $c_1, c_2, \\dotsc, c_l$.\n* Выходные данные: $p$.\n* Ограничения: $1 \\le n,m,l \\le 100$; $-10^9 \\le a_i,b_i,c_i \\le 10^9$.  \n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr\u003e1 2 3\u003cbr\u003e3\u003cbr\u003e2 1 3\u003cbr\u003e3\u003cbr\u003e1 3 5\n\n|\n\n2\n\n||\n|#\n\n* Общая подпоследовательность длиной 2 — это $(1,3)$.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5\u003cbr\u003e8 3 2 1 7\u003cbr\u003e7\u003cbr\u003e8 2 1 3 8 10 7\u003cbr\u003e6\u003cbr\u003e6 8 3 1 4 7\n\n|\n\n3\n\n||\n|#\n\n* В этом случае одна общая подпоследовательность длиной 3 — это $(8, 3, 7)$. Ещё одна — $(8, 1, 7)$.\n\n### Решение\n\nПусть $LCS(i,j,k)$ — это максимальная длина общей подпоследовательности от $A[1\\dotsc i]$, $B[1 \\dotsc j]$ и $C[1 \\dotsc k]$.\n\nТогда\n\n$$\n        LCS(i,j,k) = \\max \\begin{cases}\n                                      LCS(i-1,j,k)\\\\\n                                      LCS(i,j-1,k)\\\\\n                                      LCS(i,j,k-1)\\\\\n                                      LCS(i-1,j-1,k-1)+1  \u0026\\text{if }A[i]= B[j]=C[k]\\\\\n        \\end{cases}\n$$\n\nБазовый случай:\n\n$$\nLCS(0,j,k)=LCS(i,0,k)=LCS(i,j,0)=0 .\n$$\n\nВремя выполнения соответствующего алгоритма составляет $O(nmk)$.\n\n## Что дальше\n\nТеперь вы умеете находить наибольшую общую подпоследовательность двух или трёх строк с помощью алгоритма динамического программирования. Вы увидели, как рекурсивные зависимости помогают выразить решение через подзадачи, и научились реализовывать алгоритм так, чтобы он был быстрым и устойчивым на практике.\n\nДалее — задача о рюкзаке. Вы узнаете, как использовать похожие техники динамики, чтобы выбирать оптимальное подмножество предметов с максимальной суммарной ценностью при ограниченном объёме.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80780) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* LCS — это задача поиска самой длинной общей подпоследовательности двух или трёх строк.\n\n* Полный перебор всех подпоследовательностей даёт экспоненциальную сложность, но динамическое программирование решает задачу за $O(nm)$ или $O(nml)$.\n* Решение строится на сравнении последних символов и рекурсивном переходе к префиксам строк.\n* Алгоритм можно реализовать итеративно с таблицей и дополнительно восстановить саму подпоследовательность.\n"])</script><script nonce="">self.__next_f.push([1,"83:T4985,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте одну из самых известных задач на динамическое программирование — задачу о рюкзаке. Вы узнаете, почему жадная стратегия здесь не срабатывает, и научитесь формулировать рекуррентные зависимости, чтобы находить оптимальное решение. Также вы сравните итерационный и рекурсивный подходы с мемоизацией и поймёте, в чём их плюсы и минусы.\n\n## Ключевые вопросы параграфа\n\n* Почему жадный алгоритм не подходит для задачи о рюкзаке?\n* Как с помощью рекурсии и мемоизации находить решение без перебора всех подмножеств?\n* В чём разница между рекурсивной и итерационной реализациями алгоритма?\n\n## Условие\n\n![Algoritmy_28_cebcfecefe.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_28_cebcfecefe_43d09b8dcd.svg)\n\nВы нашли несколько золотых слитков. Ваша цель — положить как можно больше золота в рюкзак вместимостью $W$ фунтов. Каждый слиток существует только в одном экземпляре. При этом можно либо взять слиток целиком, либо не брать его вовсе. И хотя все слитки на рисунке выше выглядят одинаково, они обладают разным весом — он приведён ниже.\n\n![Algoritmy_29_0092f2020e.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_29_0092f2020e_77a5300b7b.svg)\n\nЕстественная жадная стратегия — взять самый тяжелый слиток, на который хватает вместимости рюкзака, и повторно проверить, а осталось ли место на ещё один слиток.\n\nПри наборе слитков, приведённом выше, и рюкзаке вместимостью $20$ «жадный» алгоритм выбирает слитки весом $10$ и $9$. Однако оптимальное решение — использовать слитки весом 4, 6 и 10!\n\n* Входные данные: Первая строка ввода содержит целое число $W$ (вместимость рюкзака) и количество золотых слитков $n$. В следующей строке приведены $n$ целых чисел $w_1,\\dotsc,w_{n}$, которые определяют вес золотых слитков.\n* Выходные данные: Максимальный вес золотых слитков, который можно уместить в рюкзак вместимостью $W$.\n* Ограничения: $1 \\le W \\le 10^4$; $1 \\le n \\le 300$; $0 \\le w_1,\\dotsc,w_{n} \\le 10^5$.  \n  \n#### Пример 1  \n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n10 3\u003cbr\u003e1 4 8\n\n|\n\n9\n\n||\n|#\n\nСумма веса первого и последнего слитков равна $9$.  \n  \nВместо решения изначальной задачи проверим, можно ли выбрать поднабор слитков с общим весом $W$, если имеем $n$ слитков весом $w_0, \\dotsc, w_{n-1}$ (мы перешли на отсчёт с нуля)?\n\n## Упражнение\n\nПродемонстрируйте, как можно использовать это решение для выполнения задачи «Максимальное количество золота».\n\n### Первый вариант решения\n\nПредположим, что заполнить рюкзак до конца действительно возможно: существует набор $S \\subseteq \\{w_0, \\dotsc, w_{n-1}\\}$ с общим весом $W$. Включает ли он в себя последний слиток с весом $w_{n-1}$?\n\n* Случай 1: Если $w_{n-1} \\not \\in S$, тогда рюкзак вместимостью $W$ может быть заполнен первыми $n-1$ слитками.\n* Случай 2: Если $w_{n-1} \\in S$, тогда мы можем убрать слиток с весом $w_{n-1}$ из рюкзака, и вес оставшихся слитков составит $W-w_{n-1}$. Таким образом, рюкзак с вместимостью $W-w_{n-1}$ можно полностью заполнить первыми $n-1$ слитками.\n\nВ обоих случаях мы свели задачу к практически такой же, но с меньшим количеством слитков и меньшей вместимостью рюкзака. Так, переменная $pack(w, i)$ будет иметь значение ${\\tt true}$, если существует возможность заполнить рюкзак с вместимостью $w$ первыми $i$ слитками, и значение ${\\tt false}$ в остальных случаях. Анализ двух вышеприведённых случаев приводит нас к следующему рекуррентному соотношению для $i\u003e0$:\n\n$$\npack(w,i)=pack(w,i-1) \\text{ или } pack(w-w_{i-1},i-1) .\n$$\n\n\u003e Обратите внимание, что при $w_{i-1} \u003e w$ второе выражение не имеет смысла.\n\nКроме того, $pack(0, 0) = {\\tt true}$ и $pack(0,w) = {\\tt false}$ для любого $w \u003e 0$.\n\nВ целом\n\n$$\npack(w,i)=\n\\begin{cases}\n{\\tt true} \u0026\\text{если $i=0$ и $w=0$}\\\\\n{\\tt false} \u0026\\text{если $i=0$ и $w\u003e0$}\\\\\npack(w,i-1) \u0026\\text{если $i\u003e0$ и $w_{i-1} \u003e w$}\\\\\npack(w,i-1) \\text{ или } pack(w-w_{i-1},i-1) \u0026\\text{в остальных случаях}\n\\end{cases}\n$$\n\nТак как значения $i$ варьируются между 0 и $n$, а значения $w$ — между 0 и $W$, мы имеем $O(nW)$ переменных. Так как $pack(w,i)$ зависит от $pack(w,i-1)$, мы обрабатываем все переменные в возрастающем порядке $i$. В приведённом ниже псевдокоде мы используем двумерный массив pack размера $(W+1) \\times (n+1)$, а $pack[w][i]$ сохраняет значение $pack(w,i)$. Время выполнения данного решения составляет $O(nW)$.\n\n```cpp\nKnapsack([w[0],…,w[n−1]],W):\n    pack = two-dimensional array of size (W+1)×(n+1)\n    initialize all elements of pack to false\n    pack[0][0] = true\n    for i from 1 to n:\n        for w from 0 to W:\n            if w[i-1] \u003e w:\n                pack[w][i] = pack[w][i−1]\n            else:\n                pack[w][i]←pack[w][i−1] OR pack[w−w[i−1]][i−1]\n    return pack[W][n]\n```\n\nВ приведённой ниже двумерной таблице представлены результаты вызова ``Knapsack([1,3,4], 8``. F и T означают значения **false** и **true**.\n\n![13_47974a9fe4.webp](https://yastatic.net/s3/education-portal/media/13_47974a9fe4_cbf58db48f.webp)\n\n### Второй вариант решения\n\nДругое решение будет заключаться в анализе поднаборов всех слитков. Наша цель — найти поднабор из $n$ слитков с общим весом $W$.\n\nПростой подход к такой задаче —  просматривать все поднаборы и проверять, есть ли поднабор с весом $W$. Так как каждый слиток можно или пропустить, или взять, каждый поднабор из трёх слитков, который мы анализируем ($w_0 = 1$, $w_1 = 3$, $w_2 = 4$), можно представить сине-красным бинарным вектором:\n\n![Algoritmy_30_4d1d347fa5.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_30_4d1d347fa5_f2e0b20bb0.svg)\n\nТеперь мы представим каждый поднабор слитков как путь, начинающийся от узла $(0,0)$ сетки $(n+1)\\times (W+1)$.\n\n* Если первый бит — синий, то он соответствует синему горизонтальному сегменту сетки, связывающему $(0,0)$ с $(0,1)$.\n* Если первый бит — красный, то он соответствует красному сегменту сетки, связывающему $(0,0)$ с $(1,w_0)$.\n* Обработав первые $i$ битов, мы получаем сине-красный путь от $(0,0)$ до некого узла $(i,w)$ на сетке.\n* Если следующий бит — синий, мы связываем $(i,w)$ с $(i+1,w)$.\n* Если следующий бит — красный, мы связываем $(i,w)$ с $(i+1,w+w_i)$, как показано ниже для вектора 101:\n\n![Algoritmy_32_8e2e80c810.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_32_8e2e80c810_d844841e0c.svg)\n\nРисунок ниже демонстрирует пути, которые соответствуют всем восьми бинарным векторам с длиной 3.\n\n![Algoritmy_33_bb172459e6.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_33_bb172459e6_20a4840070.svg)\n\nТеперь мы накладываем все эти восемь путей на одну сетку:\n\n![Algoritmy_31_e25d17d7a3.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_31_e25d17d7a3_a2e4fa2a0d.svg)\n\nМы классифицируем узел $(i,w)$ на сетке как истинный («true») при наличии пути от $(0,0)$ к $(i,w)$ на рисунке выше. В других случаях — ложный («false»). Теперь мы можем полностью заполнить рюкзак с вместимостью $w$ поднабором из первых $i$ слитков, если узел $(i,w)$ — истинный («true»). Узел будет истинным в случаях, если в него проходит или синее, или красное ребро. То есть, если $(i-1,w)$ или $(i-1,w-w_{i-1})$ истинны. Это наблюдение приводит нас к предыдущему рекуррентному соотношению и к такому же решению с динамическим программированием.\n\n### Третий вариант решения\n\nА вот ещё один вариант решения, который основан на мемоизации. Приведённый ниже псевдокод рекурсивно вычисляет рекуррентное соотношение из решения 1:\n\n```cpp\nRecursiveKnapsack([w[0],…,w[n−1]],w,i):\n    if i=0 and w=0:\n        return true\n    else if i=0 and w\u003e0:\n        return false\n    else if i\u003e0 and w_[i-1]\u003ew:\n        return RecursiveKnapsack([w[0],…,w[n−1]],w,i−1)\n    else:\n        return RecursiveKnapsack([w[0],…,w[n−1]],w,i−1) OR   RecursiveKnapsack([w[0],…,w[n−1]],w−w[i−1],i−1)\n```\n\nВызов ``RecursiveKnapsack([w_0, ..., w_{n-1}],W, n)`` решает задачу, но он сильно замедлен из-за необходимости перевычислять одни и те же значения снова и снова.\n\nЧтобы это продемонстрировать, рассмотрим рюкзак с вместимостью $W=4$ и $n=3$ слитков с весом $w_0=1$, $w_2=1$, $w_3=1$. Вызов ``RecursiveKnapsack([1, 1, 1], 4, 3)`` создаёт рекурсивное дерево, приведённое ниже — каждый узел показывает значения $(w,i)$.\n\nДаже в этом простом примере значение $(w,i)=(3,1)$ вычисляется дважды. С 20 слитками рекурсивное дерево может достичь гигантских размеров — одно и то же значение может вычисляться миллионы раз.\n\n![Algoritmy_25_20b8bc84b8.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_25_20b8bc84b8_22aacaeb40.svg)\n\nВо избежание такого рекурсивного взрыва мы «оборачиваем» код мемоизацией с помощью ассоциативного массива $pack$, который изначально пуст.\n\nАссоциативный массив — это абстрактный тип данных, в котором хранятся пары $key, value$. Он поддерживается многими языками программирования и, как правило, реализуется как хеш-таблица или дерево поиска.\n\nК примеру, в **C++** и **Java** ассоциативный массив называется картой («map»), а в **Python** — словарём («dictionary»). В реализации, приведённой ниже, ассоциативный массив $pack$ используется для хранения логических значений для пар $(w, i)$.\n\n```cpp\nMemoizedKnapsack([w[0],…,w[n−1]],pack,w,i):\n    if (w,i) is not in pack:\n        if i=0 and w=0:\n            pack[(w,i)] = true\n        else if i=0 and w\u003e0:\n            pack[(w,i)] = false\n        else if i\u003e0 and w_[i-1]\u003ew:\n            pack[(w,i)] = MemoizedKnapsack([w[0],…,w[n−1]],pack,w,i−1)\n        else: \n            pack[(w,i)] = MemoizedKnapsack([w[0],…,w[n−1]],pack,w,i−1) OR MemoizedKnapsack([w[0],…,w[n−1]],pack,w−w[i−1],i−1)\n    return pack[(w,i)]\n```\n\nВремя выполнения итогового решения составляет $O(nW)$, так как количество рекурсивных вызовов, не являющихся уточняющими запросами в ассоциативный массив, не превышает это число. Следовательно, это такое же время выполнения, как и у соответствующего итерационного алгоритма.\n\nНа практике же итерационное решение, как правило, быстрее, потому что в нём нет рекурсивных издержек и оно использует более простые структуры данных. Например, массив вместо хеш-таблицы.\n\nТем не менее с рассматриваемой задачей ситуация иная: при некоторых наборах данных, рекурсивная версия быстрее итерационной. К примеру, если мы умножим все весовые значения на $10$, то время выполнения итерационного алгоритма также умножится на $10$, в то время как время выполнения рекурсивного останется таким же.\n\nВ целом, если необходимо решить все возможные подзадачи, итерационный вариант обычно быстрее.\n\n## Что дальше\n\nТеперь вы умеете решать задачу о рюкзаке с помощью динамического программирования — как рекурсивно с мемоизацией, так и итерационно. Вы научились строить таблицу достижимости весов и поняли, почему простая жадность здесь не работает.\n\nДалее — задача про сувениры: вы узнаете, как свести динамическую задачу к более простой, если ограничен не вес, а количество предметов и целевая сумма. Новый подход позволит взглянуть на подмножества и веса под другим углом.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80780) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Жадная стратегия не даёт оптимального решения в задаче о рюкзаке — нужно перебрать возможные комбинации.\n* Решение строится через рекурсию с мемоизацией или итеративное заполнение таблицы достижимости.\n* Итерационный подход обычно быстрее, но рекурсивный с мемоизацией может быть удобнее в реализации.\n* Количество подзадач ограничено, поэтому решение работает за O(nW) — достаточно эффективно даже для больших входов.\n"])</script><script nonce="">self.__next_f.push([1,"84:T25ac,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы научитесь находить оптимальный способ расставить скобки в арифметическом выражении, чтобы получить наибольшее значение. Задача учит динамическому программированию с двумя таблицами — для минимальных и максимальных значений подвыражений. Вы увидите, как даже простое выражение требует аккуратного перебора всех вариантов и рекурсивного деления на подзадачи.\n\n## Ключевые вопросы параграфа\n\n* Почему результат арифметического выражения зависит от порядка скобок?\n* Как использовать динамическое программирование для перебора всех вариантов группировки?\n* Как устроены таблицы для хранения минимальных и максимальных значений подвыражений?\n\n## Условие задачи\n\n![Algoritmy](https://yastatic.net/s3/education-portal/media/Algoritmy_26_1_417706f2c4_79ce29bc0e.svg)\n\nТри пирата делят свою добычу, в которую входят $n$ предметов разной ценности. Получится у вас помочь разделить добычу поровну?\n\n* **Входные данные:** Первая строка содержит целое число $n$. Вторая строка содержит целые числа $v_1, v_2, \\dotsc, v_n$, разделённые пробелами.\n* **Выходные данные:** Вывести 1, если $v_1, v_2, \\dotsc, v_n$ можно разделить на три поднабора с одинаковыми суммами; в противном случае — вывести 0.\n* **Ограничения:** $1 \\le n \\le 20$, $1 \\le v_i \\le 30$ для всех $i$.\n\n**Пример 1**\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n4\u003cbr\u003e3 3 3 3\n\n|\n\n0\n\n||\n|#\n\n**Пример 2**\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\u003cbr\u003e30\n\n|\n\n0\n\n||\n|#\n\n**Пример 3**\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n13\u003cbr\u003e1 2 3 4 5 5 7 7 8 10 12 19 25\n\n|\n\n1\n\n||\n|#\n\n* $1+3+7+25=2+4+5+7+8+10=5+12+19$.\n\n### Решение\n\nРассмотрим решение задачи. Обозначим $v_1+v_2+\\dotsb+v_i$ как $\\operatorname{sum}(i)$.\n\n1. Разделить набор из $n$ предметов на три части возможно, только если их общая ценность делится на три. То есть $\\operatorname{sum}(n)=3V$, где $V$ — это целое число.\n2. Так, нам необходимо разделить $n$ чисел на три части, где сумма чисел в каждой части равна $V$.\n3. Одна из этих частей содержит $n$-й трофей (с ценностью $v_n$).\n4. Если мы его уберём, то получим разделение первых $n-1$ трофеев на три части таким образом, что ценность двух из них будет равна $V$, а сумма оставшейся части — $V-v_n$.\n\nВместо разделения всех $n$ предметов, попробуем решить более мелкую задачу, состоящую в делении первых $i$ предметов на части с ценностью $s_1$, $s_2$ и $\\operatorname{sum}(i)-s_1 - s_2$. Если такое разделение возможно, мы присваиваем $split(i,s_1,s_2)={\\tt true}$ (в противном случае — ${\\tt false}$) и отмечаем, что пираты могут разделить добычу честно, только если $split(n,V,V)={\\tt true}$.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Учитывая первые пять предметов, $split(5,4,13)={\\tt true}$. Найдите все значения $split(5,s_1,s_2)$, равные ${\\tt true}$.\n\u003e\n\u003e Представьте, что вы уже составили двоичный двумерный массив $split(i-1,s_1,s_2)$ для всевозможных значений $0 \\le s_1 \\le V$ и $0 \\le s_2 \\le V$. Сможете ли вы использовать этот массив, чтобы составить массив $split(i,s_1,s_2)$?\n\nПредположим, что $split(i,s_1,s_2) = {\\tt true}$. Тогда первые $i$ чисел можно разделить на три части таким образом, чтобы сумма чисел в первой части составляла $s_1$, а сумма чисел во второй части — $s_2$.\n\n* $i$-й предмет принадлежит первой части. Тогда $v_i \\le s_1$. Убрав его из первой части, мы разделим первые $i-1$ чисел на три части так, что сумма первых двух частей составит $s_1-v_i$ и $s_2$, то есть $split(i-1,s_1-v_i,s_2)={\\tt true}$.\n* $i$-й предмет принадлежит второй части. Как и в предыдущем случае, $v_i \\le s_2$ и $split(i-1,s_1,s_2-v_i)={\\tt true}$.\n* $i$-й предмет принадлежит третьей части. Тогда $split(i-1,s_1,s_2)= {\\tt true}$.\n\nТак, значение $split(i,s_1,s_2)$ можно вычислить, посмотрев на\n\n$$split(i-1,s_1-v_i,s_2),\\,\nsplit(i-1,s_1,s_2-v_i),\\,\nsplit(i-1,s_1,s_2).\n$$\n\nБазовый случай для этого рекуррентного соотношения: $split(0,0,0)={\\tt true}$ и $split(0,s_1,s_2)={\\tt false}$, если $s_1+s_2\u003e0$.\n\n```cpp\nSplit(v[1],…,v[n]):\n    if v[1] + … + v[n] не делится целочисленно на 3:\n        return false\n    V = (v[1] + … + v[n]) / 3\n    split = ... // массив размера (n+1) × (V+1) × (V+1)\n    // заполнить массив split значениями false\n    split[0][0][0] = true\n    for i from 1 to n:\n        for s1 from 0 to V:\n            for s2 from 0 to V:\n                split[i][s1][s2] = split[i−1][s1][s2]\n                if s1 \u003e= v[i]:\n                    split[i][s1][s2] = split[i][s1][s2] OR split[i - 1][s1 - v[i]][s2]\n                if s2 \u003e= v[i]:\n                    split[i][s1][s2] = split[i][s1][s2] OR split[i - 1][s1][s2 - v[i]]\n    return split[n][V][V]\n```\n\nВремя выполнения составляет $O(nV^2)$.\n\n## Что дальше\n\nТеперь вы умеете вычислять максимальное значение арифметического выражения, расставляя скобки в нужном порядке. Вы научились использовать динамическое программирование с запоминанием минимальных и максимальных значений и применять аккуратные рекурсивные формулы.\n\nДалее — финальный параграф главы. В нём мы кратко обобщим ключевые идеи, которые вы встретили, и покажем, как они складываются в систему.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80782) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Порядок выполнения операций влияет на результат арифметического выражения — важно правильно расставить скобки.\n* Можно эффективно найти максимальное значение, если сохранять минимумы и максимумы всех подвыражений в таблицах.\n* Динамическое программирование позволяет избежать повторных вычислений и уменьшает время работы с экспоненциального до кубического.\n* Даже при небольшом числе операций количество возможных расстановок скобок велико — поэтому важно автоматизировать перебор."])</script><script nonce="">self.__next_f.push([1,"85:T2eec,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы научитесь находить оптимальный способ расставить скобки в арифметическом выражении, чтобы получить наибольшее значение. Задача учит динамическому программированию с двумя таблицами — для минимальных и максимальных значений подвыражений. Вы увидите, как даже простое выражение требует аккуратного перебора всех вариантов и рекурсивного деления на подзадачи.\n\n## **Ключевые вопросы параграфа** {#klyuchevye-voprosy-paragrafa6}\n\n* Почему результат арифметического выражения зависит от порядка скобок?\n\n* Как использовать динамическое программирование для перебора всех вариантов группировки?\n\n* Как устроены таблицы для хранения минимальных и максимальных значений подвыражений?\n\n## Упражнение\n\nДля выражения $(3+2\\times 4)$ существуют два способа расставить скобки: $(3+(2\\times4))=11$ и $((3+2) \\times 4)=20$.\n\n### Условие упражнения\n\nДля максимального значения нужно поставить в скобки выражение $(5-8+7\\times4-8+9)$.\n\n* Входные данные: Ввод содержит только строку $s$ длиной $2n+1$ для некого $n$ с символами $s_0,s_1, \\dotsc, s_{2n}$. Каждый символ на чётной позиции $s$ — это цифра (то есть целое число от 0 до 9), а на нечетной позиции — одна из трёх операций из ${\\tt \\{+,-,*\\}}$.\n* Выходные данные: Максимальное значение данного арифметического выражения из всех возможных порядков арифметических операций.\n* Ограничения: $0 \\le n \\le 14$ — таким образом, строка содержит максимум $29$ символов.  \n\n**Пример 1**  \n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5-8\\+7\\*4-8\\+9\n\n|\n\n200\n\n||\n|#\n\n* $200=(5-((8+7)\\times(4-(8+9))))$\n\n### Решение\n\nРассмотрим решение задачи. Каждая из пяти операций в выражении\n\n$$\n(5-8+7\\times4-8+9)\n$$\n\nможет быть последней — внешней. Рассмотрим случай, в котором последняя операция — «$\\times$», то есть умножение. В этой ситуации нам необходимо поместить два *подвыражения* в скобки\n\n$$\n(5-8+7) \\text{ и } (4-8+9)\\,\n$$\n\nтаким образом, чтобы произведение значений было максимальным. Чтобы это выяснить, мы находим минимальные и максимальные значения данных двух подвыражений:\n\n$$\n\\begin{aligned}\n        \\min(5-8+7)\u0026=(5-(8+7))=\u0026-10,\\\\\n        \\max(5-8+7)\u0026=((5-8)+7)=\u00264,\\\\\n        \\min(4-8+9)\u0026=(4-(8+9))=\u0026-13,\\\\\n        \\max(4-8+9)\u0026=((4-8)+9)=\u00265.\\\\\n\\end{aligned}\n$$\n\nНа основании этих значений мы заключаем, что общее значение произведения составляет $130$.\n\nПредположим, что вводный набор данных имеет форму\n\n$$\nd_0\\quad op_0 \\quad d_1 \\quad op_1 \\quad \\dotsb \\quad op_{n-1} \\quad d_n\\, ,\n$$\n\nгде каждая $d_i$ — это цифра, а каждая $op_j \\in \\{+,-,\\times\\}$ — базовая арифметическая операция. Сказанное выше предполагает, что мы вычисляем минимальное и максимальное значение каждого подвыражения в форме\n\n$$\nE_{l,r}=d_l\\quad op_l\\quad d_{l+1}\\quad op_{l+1}\\quad \\dotsb \\quad op_{r-1}\\quad  d_r\\, ,\n$$\n\nгде $0 \\le l \\le r \\le n$. Пусть $minValue(l,r)$ и $maxValue(l,r)$ — минимальное и максимальное значение $E_{l,r}$ соответственно. Тогда\n\n$$\n\\begin{align*}\n    minValue(l,r)=\\min\\limits_{l \\le m \u003c r}\n    \u0026\\begin{cases}\n            minValue(l,m) \u0026 op_m\\quad  minValue(m+1,r)\\\\\n            minValue(l,m) \u0026 op_m\\quad  maxValue(m+1,r)\\\\\n            maxValue(l,m) \u0026 op_m\\quad  minValue(m+1,r)\\\\\n            maxValue(l,m) \u0026 op_m\\quad  maxValue(m+1,r)\\\\\n    \\end{cases}\\\\\n    maxValue(l,r)=\\max\\limits_{l \\le m \u003c r}\n    \u0026\\begin{cases}\n            minValue(l,m) \u0026 op_m\\quad  minValue(m+1,r)\\\\\n            minValue(l,m) \u0026 op_m\\quad  maxValue(m+1,r)\\\\\n            maxValue(l,m) \u0026 op_m\\quad  minValue(m+1,r)\\\\\n            maxValue(l,m) \u0026 op_m\\quad  maxValue(m+1,r)\\\\\n    \\end{cases}\\\\\n\\end{align*}\n$$\n\nБазовый случай — это $l=r$:\n\n$$\nminValue(l,l)=maxValue(l,l)=d_l .\n$$\n\nЭти два рекуррентных соотношения позволяют нам вычислить оптимальные значения $E_{l,r}$, изучив все возможные варианты разделения $E_{l,r}$ на два подвыражения $E_{l,m}$ и $E_{m+1,r}$.\n\nТогда наше рекуррентное соотношение говорит о том, что дерево состоит из корня и двух поддеревьев. Для нахождения оптимальной формы дерева мы анализируем все возможные корни (за это отвечает параметр $m$), а затем составляем дерево из двух оптимальных поддеревьев.\n\n## Как сделать из рекуррентного соотношения рекурсивный алгоритм\n\nКак обычно, сделать из рекуррентного соотношения рекурсивный алгоритм довольно просто. Рекурсивная процедура берёт индексы $l$ и $r$ в качестве параметров и использует их для вычисления минимального и максимального значения подвыражения $E_{l,r}$. \n\nПеред тем, как начать вычисления, проверяется, не сохранены ли уже эти значения в $table[l,r]$, где $table$ — это ассоциативный массив, хранящий уже вычисленные результаты.\n\nЕсли запись $table[l,r]$ отсутствует, рекурсивная процедура вычисляет два значения, используя рекуррентное соотношение, сохраняет их в таблицу и выдаёт их. Конечный ответ соответствует $l=0$ и $r=n$.\n\nВремя выполнения составляет $O(n^3)$: есть $O(n^2)$ возможных пар $(l,r)$, для каждой из которых рекурсивная процедура проверяет возможные значения для $l \\le m \u003c r$.\n\nДля переведения рекурсивного алгоритма в итерационный используются двумерные таблицы $mins[0..n][0..n]$ и $maxs[0..n][0..n]$, в которых хранятся минимальные и максимальные значения всех подвыражений. Заполняя данные таблицы, нам нужно убедиться, что к окончанию вычислений оптимальных значений для $E_{l,r}$ оптимальные значения $E_{l,m}$ и $E_{m+1,r}$ для всех $m$ уже вычислены.\n\nОдин из способов сделать это — перечислить все пары $(l,r)$ в порядке возрастания значения $r-l$. Чтобы это сделать, в псевдокоде ниже используется параметр $s=r-l$.\n\n```cpp\nMaxValue(d[0],op[0],d[1],op[1],…d[n]):\n    mins, maxs = 2d-arrays of size (n+1)×(n+1)\n    fill mins with +infinity, fill maxs with -infinity\n    for i from 0 to n:\n        mins[i][i]=d[i], maxs[i][i]←d[i]​\n    for s from 1 to n:\n        for l from 1 to n-s:\n            r = l+s\n            for m from l to r-1:\n                a = mins[l][m] op[m] mins[m+1][r]\n                b = mins[l][m] op[m] maxs[m+1][r]\n                c = maxs[l][m] op[m] mins[m+1][r]\n                d = maxs[l][m] op[m] maxs[m+1][r]\n                mins[l][r] = min(mins[l][r],a,b,c,d)\n                maxs[l][r] = max(maxs[l][r],a,b,c,d)\n    return maxs[0][n]\n```\n\n## Что дальше\n\nТеперь вы умеете вычислять максимальное значение арифметического выражения, расставляя скобки в нужном порядке. Вы научились использовать динамическое программирование с запоминанием минимальных и максимальных значений и применять аккуратные рекурсивные формулы.\n\nДалее — финальный параграф главы. В нём мы кратко обобщим ключевые идеи, которые вы встретили, и покажем, как они складываются в систему.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80783) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Порядок выполнения операций влияет на результат арифметического выражения — важно правильно расставить скобки.\n* Можно эффективно найти максимальное значение, если сохранять минимумы и максимумы всех подвыражений в таблицах.\n* Динамическое программирование позволяет избежать повторных вычислений и уменьшает время работы с экспоненциального до кубического.\n* Даже при небольшом числе операций количество возможных расстановок скобок велико — поэтому важно автоматизировать перебор.\n"])</script><script nonce="">self.__next_f.push([1,"86:T620f,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с алгоритмом двоичного поиска — фундаментальным инструментом в мире алгоритмов. Вы узнаете, как эффективно искать элементы в отсортированных массивах, почему этот подход работает в логарифмическое время и как избежать типичных ошибок при реализации.\n\n## Ключевые вопросы параграфа\n\n* Как работает стратегия «Разделяй и властвуй» и как она применяется в двоичном поиске?\n* Почему двоичный поиск так эффективен и в чём его отличие от линейного поиска?\n* Как корректно реализовать двоичный поиск и что важно учесть при работе с границами и условиями?\n\n## Разделяй и властвуй\n\nВ этом параграфе вы узнаете об алгоритмах «разделяй и властвуй», которые помогают выполнять поиск по огромным базам данных в миллион раз быстрее, чем алгоритмы исчерпывающего поиска. Вооружившись этой техникой, вы узнаете, что стандартный способ умножать числа (которому вас учили в начальной школе) далеко не самый быстрый. Затем мы применим подход «разделяй и властвуй», чтобы спроектировать быстрые алгоритмы для сортировки. Вы узнаете, что эти алгоритмы оптимальны — то есть даже легендарный ученый Алан Тьюринг не смог бы спроектировать алгоритм сортировки быстрее!\n\n### Основная идея\n\nЕсли вы хотите решить задачу с помощью стратегии «разделяй и властвуй», вам нужно подумать о следующих трёх шагах:\n* Разделение задачи на подзадачи поменьше.\n* Рекурсивное решение каждой подзадачи.\n* Объединение выполненных подзадач в решение изначальной задачи.\n\nПервые два шага — это и есть «разделяй», а последний — «властвуй». Мы продемонстрируем такой подход в нескольких примерах, сложность которых будет возрастать.\n\n### Угадать число\n\nИгра «Угадать число» состоит в том, что оппонент загадывает целое число $1 \\le x \\le n$. Вы задаёте вопрос: «$x=y$?». Оппонент отвечает либо «да», либо «$x\u003cy$» (то есть «мое число меньше»), либо «$x\u003ey$» (то есть «мое число больше»). Ваша задача — получить ответ «да», задав минимальное количество вопросов.\n\nПусть $n=3$: ваша задача — угадать $1 \\le x \\le 3$, задав не больше двух вопросов.\n\nВы можете спросить: «$x=1$?». Если ответ положительный, то вы победили.Но оппонент может ответить: «$x\u003e1$». Вы решаете, что $x$ равен $2$ или $3$, но у вас остаётся только один вопрос. Точно так же вы можете спросить: «$x=3$?». Тогда ваш оппонент может ответить: «$x\u003c3$». В этом случае вы не сможете получить желаемый положительный ответ, задав лишь один вопрос.\n\nПосмотрим, что будет, если вы сначала спросите: «$x=2$?».\n\n1. Если оппонент отвечает, что $x=2$, тогда игра окончена.\n2. Если ответ — $x\u003c2$, то вы уже знаете, что $x=1$. Следовательно, второй раз вы просто спрашиваете: «$x=1$?». И теперь вы получаете положительный ответ.\n3. Если оппонент ответит, что $x\u003e2$, то вы спрашиваете: «$x=3$?». Ответ на него: «Да».\n\n### Упражнение\n\nУгадать целое число $1 \\le x \\le 7$, задав не больше трёх вопросов.\n\nВы уже могли догадаться, что мы начнём с вопроса: «$x=4$?». Дело в том, что в обоих случаях — $x\u003c4$ и $x\u003e4$ — мы сокращаем пространство поиска с 7 до 3 вариантов (нам уже известно, как решить задачу с $3$ возможными вариантами):\n\n* если $x\u003c4$, то $x$ будет 1, 2 или 3;\n* если $x\u003e4$, то $x$ будет 5, 6 или 7.\n\nЭто означает, что в обоих случаях вы можете воспользоваться решением разобранного ранее случая $n=3$. Получившийся протокол вопросов показан на рисунке.\n\n### Функция `query`\n\nСледующий код имитирует процесс угадывания. Функция ``query`` «знает» целое число $x$. Вызов ``query(y)`` сообщает нам: $x=y$, или $x\u003cy$, или $x\u003ey$. Функция ``guess()`` находит число $x$ с помощью вызова ``query()``. Она вызывается с двумя параметрами: ``lower`` и ``upper``— так, чтобы\n\n$$\n\\texttt{lower} \\le x \\le \\texttt{upper},\n$$\n\nто есть $x$ находится в сегменте $[\\texttt{lower},\\, \\texttt{upper}]$. Сначала она рассчитывает середину (``middle``) сегмента $[\\texttt{lower},\\, \\texttt{upper}]$, затем вызывает $\\texttt{query(middle)}$. Если $x\u003c\\texttt{middle}$, тогда она продолжает работать с интервалом $[\\texttt{lower},\\, \\texttt{middle - 1}]$. Если $x\u003e\\texttt{middle}$, тогда она переходит к интервалу $[\\texttt{middle}+1,\\, \\texttt{upper}]$.\n\n```cpp\nquery(y):\n    x = 1618235\n    if x == y:\n        return 'equal'\n    if x \u003c y:\n        return 'smaller'\n    else:\n        return 'greater'\n\n\nguess(lower, upper):\n    middle = (lower + upper) / 2 // целочисленное деление\n    answer = query(middle)\n    // можно напечатать запрос и соответствующий результат\n    if answer == 'equal':\n        return\n    if answer == 'smaller':\n        guess(lower, middle - 1)\n    else:\n        guess(middle + 1, upper)\n\n\nguess(1, 2097151) // начальный возможный диапазон значений\n```\n\nРеализуйте этот алгоритм, измените значение $x$ и запустите код, чтобы увидеть последовательность вопросов  (удостоверьтесь, что $x$ находится в сегменте, который используется при вызове ``guess``).\n\nВ целом стратегия, угадывающая целое число $1 \\le x \\le n$, потребует около $\\log_2 n$ вопросов. Напомним, что $\\log_2 n$ равняется $b$, если $2^b=n$. Это значит, что если мы продолжим делить $n$ на 2, пока не получим 1, будет около $\\log_2 n$ операций деления. Важно здесь то, что $\\log_2 n$ — медленно растущая функция. К примеру, если $n \\le 10^9$, то $\\log_2 n \u003c 30$.\n\n### Поиск по отсортированным данным\n\nМетод, который мы использовали для угадывания числа, известен как двоичный поиск. Пожалуй, самый важный случай применения двоичного поиска — это поиск по отсортированным данным.\n\nПоиск — фундаментальная задача: имея последовательность и элемент $x$, мы хотим проверить, входит ли $x$ в последовательность. Например, 3 входит в последовательность $(7, 2, 5, 6, 11, 3, 2, 9)$, а 4 — не входит. Зная о важности задачи по поиску, неудивительно, что методы для её решения есть почти во всех языках программирования.\n\n```py\nprint(3 in [7, 2, 5, 6, 11, 3, 2, 9])\nprint(4 in [7, 2, 5, 6, 11, 3, 2, 9])\n```\n\nЧто происходит внутри, когда мы вызываем метод **in**? Ожидаемо, **Python** выполняет линейное сканирование. На это требуется $n$ сравнений при последовательности длиной $n$. Если в последовательность не входит $x$, нам необходимо просканировать все элементы: если мы будем пропускать, то мы не можем точно знать, отсутствует ли $x$.\n\nСитуация кардинально меняется, если полученные данные отсортированы, то есть составляют собой отсортированную последовательность $a_0, \\dotsc, a_{n-1}$ в порядке возрастания.\n\nОказывается, что в этом случае достаточно около $\\log_2 n$ сравнений! Это значительное ускорение: линейный поиск по отсортированному массиву с миллиардом элементов потребует миллиарда сравнений, двоичному же поиску будет достаточно не больше $\\log_210^9\u003c30$!\n\n## Двоичный поиск\n\n![Algoritmy_13_e9bbfbf4d6.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_13_e9bbfbf4d6_0d32d91800.svg)\n\nВаша задача — найти индекс элемента в сортированной последовательности равного $q$.\n\n* Формат ввода: Отсортированный массив $K$ неповторяющихся целых чисел и целое число $q$. Первые две строки ввода содержат целое число $n$ и последовательность $k_0 \u003c k_1 \u003c \\dotsc \u003c k_{n-1}$ из $n$ неповторяющихся положительных целых чисел в возрастающем порядке. Следующая строка содержит целое число $q$.\n* Формат вывода: Позиция элемента в $K$ равного $q$ или $-1$ при отсутствии такого элемента.\n* Ограничения: $1 \\le n \\le 3 \\cdot 10^4$; $1 \\le k_i \\le 10^9$ для всех $0 \\le i \u003c n$; $1 \\le q \\le 10^9$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7\u003cbr\u003e1 3 7 8 9 12 15\u003cbr\u003e8\n\n|\n\n3\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7\u003cbr\u003e1 3 7 8 9 12 15\u003cbr\u003e12\n\n|\n\n5\n\n||\n|#\n\nМожно решить эту задачу примитивным способом — просканировать массив $K$ (время выполнения составит $O(n)$). Время решения этой задачи для алгоритма ``BinarySearch`` — $O(\\log n)$. Он инициализируется при присвоении $minIndex$ значения 0 и $maxIndex$ значения $n-1$. Сначала алгоритм присваивает $midIndex$ значение $(minIndex + maxIndex)/2$, а затем проверяет, больше $q$, чем $K[midIndex]$, или нет.\n\nЕсли $q$ больше, чем это значение, то ``BinarySearch`` проводит итерацию на подмассиве $K$ от minIndex до $midIndex-1$. В ином случае он проводит итерацию на подмассиве $K$ от $midIndex + 1$ до $maxIndex$. В конечном счёте алгоримт определит, находится $q$ в $K$ или нет.\n\n```cpp\nBinarySearch(K[0..n−1], q)\n    minIndex = 0\n    maxIndex = n−1\n    while maxIndex \u003e= minIndex:\n        midIndex = (minIndex+maxIndex) / 2 // целочисленное деление\n        if K[midIndex] = q:\n            return midIndex\n        else K[midIndex] \u003c q:\n            minIndex = midIndex + 1\n        else:\n            maxIndex = midIndex - 1\n    return -1\n```\n\nНапример, если $q = 9$ и $K = [1, 3, 7, 8, 9, 12, 15]$, ``BinarySearch`` сначала задаст следующее: $minIndex=0$, $maxIndex=6$ и $midIndex=3$. Так как $q$ больше, чем $K[midIndex] = 8$, мы рассматриваем подмассив, элементы которого больше $K[midIndex]$, установив $minIndex=4$, и таким образом $midIndex$ перевычисляется как $(4+6)/2 = 5$. В этот раз $q$ меньше, чем $K[midIndex] = 12$, поэтому мы рассматриваем подмассив, элементы которого ниже этого значения. Этот подмассив состоит из одного элемента — $q$.\n\nВремя выполнения ``BinarySearch`` составляет $O(\\log n)$, так как алгоритм снижает длину подмассива минимум в два раза при каждой итерации цикла ``while``.\n\n\u003e Обратите внимание: наша система оценки не может знать, использовали вы быстрый алгоритм с трудоёмкостью $O(\\log n)$ для поиска в отсортированном массиве или примитивный алгоритм с трудоёмкостью $O(n)$.\n\nДело в том, что любой программе требуется линейное время для чтения данных ввода. По этой причине мы предлагаем вам решить следующую более общую задачу.\n\n## Множественный поиск ключей в отсортированной последовательности\n\n* **Вывод**: При каждом $q_i$ необходимо проверить, входит ли $q_i$ в $K$.\n* Формат ввода: Отсортированный массив $K$ неповторяющихся целых чисел и массив целых чисел\n$Q=[q_0,\\dotsc,q_{m-1}]$. Первые две строки ввода содержат целое число $n$ и последовательность $k_0\u003ck_1\u003c \\dotsc \u003c k_{n-1}$ из $n$ неповторяющихся положительных целых чисел в возрастающем порядке. Следующие две строки содержат целое число $m$ и $m$ положительных целых чисел $q_0, q_1, \\dotsc, q_{m-1}$.\n* Формат вывода: Для всех $i$ от $0$ до $m-1$ выведите индекс $0 \\le j \\le n-1$, чтобы $k_j=q_i$ или $-1$ при отсутствии такого индекса.\n* Ограничения: $1 \\le n \\le 3 \\cdot 10^4$; $1 \\le m \\le 10^5$; $1 \\le k_i \\le 10^9$ для всех $0 \\le i \u003c n$; $1 \\le q_j \\le 10^9$ для всех $0 \\le j \u003c m$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7\u003cbr\u003e1 3 7 8 9 12 15\u003cbr\u003e1\u003cbr\u003e8\n\n|\n\n3\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7\u003cbr\u003e1 3 7 8 9 12 15\u003cbr\u003e3\u003cbr\u003e1 12 3\n\n|\n\n0\u003cbr\u003e5\u003cbr\u003e1\n\n||\n|#\n\n* Совет: не используйте встроенный двоичный поиск\n\n## Двоичный поиск с дублированием\n\nКак пишет автор книги «Искусство программирования» Дональд Кнут: «Хотя основная идея двоичного поиска относительно проста, детали могут быть на удивление сложными». Он подразумевает изменённую версию классической задачи двоичного поиска:\n\nКогда Кнут попросил профессиональных программистов из таких ведущих компаний, как IBM, реализовать эффективный алгоритм двоичного поиска с дублированием, в 90\\% из них были баги — год за годом. И правда, хотя первый алгоритм двоичного поиска был опубликован в 1946 году, первый алгоритм для поиска с дублированием, в котором не было багов, впервые опубликовали только в 1962 году.\n\nПо аналогии с предыдущей задачей здесь мы предлагаем найти $m$ целых чисел, а не одно.\n\n* Формат ввода: Первые две строки ввода содержат целое число $n$ и последовательность $k_0 \\le k_1 \\le \\dotsb \\le k_{n-1}$ из $n$ положительных целых чисел в неубывающем порядке. Следующие две строки содержат целое число $m$ и $m$ положительных целых чисел $q_0, q_1, \\dotsc, q_{m-1}$.\n* Формат вывода: Для всех $i$ от $0$ до $m-1$ вывод индекса $0 \\le j \\le n-1$ первого встречающегося $q_i$ (то есть $k_j=q_i$) или $-1$ — если такого индекса нет.\n* Ограничения: $1 \\le n \\le 3 \\cdot 10^4$; $1 \\le m \\le 10^5$; $1 \\le k_i \\le 10^9$ для всех $0 \\le i \u003c n$; $1 \\le q_j \\le 10^9$ для всех $0 \\le j \u003c m$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7\u003cbr\u003e2 4 4 4 7 7 9\u003cbr\u003e4\u003cbr\u003e9 4 5 2\n\n|\n\n6\u003cbr\u003e1\u003cbr\u003e-1\u003cbr\u003e0\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr\u003e1 1 1\u003cbr\u003e3\u003cbr\u003e1 2 3\n\n|\n\n0\u003cbr\u003e-1\u003cbr\u003e-1\n\n||\n|#\n\n* Совет: не используйте встроенный двоичный поиск\n\n### Решение\n\nУ вас есть ключ $q$ и вам необходимо найти первое, самое раннее место, где этот ключ встречается в массиве $K$. Например, если $K=\\{3, 6, 6, 7, 7, 7, 7, 9\\}$ и ключ $q$ — это $7$, тогда первое место, где он встречается, — это индекс $3$. Разумеется, вы можете найти одно из мест, просто начав двоичный поиск. Чтобы найти первое место, где ключ встречается, вы можете последовательно проверять элемент перед позицией того, который был найден, — что и демонстрируется в выделенных голубым строках приведенного ниже псевдокода.\n\n```cpp\nNaiveBinarySearchWithDuplicates(K[0..n−1], q)\n    minIndex = 0\n    maxIndex = n−1\n    while maxIndex \u003e= minIndex:\n        midIndex = (minIndex + maxIndex) / 2\n        if K[midIndex] = q:\n            top = midIndex\n            while top \u003e 0 and K[top − 1] = K[top]:\n                top = top - 1\n            return top\n        if K[midIndex] \u003c q:\n            minIndex = midIndex + 1\n        else:\n            maxIndex = midIndex − 1\n    return -1\n```\n\n\u003e **Остановитесь и подумайте:**\n\u003e Каково время выполнения этого алгоритма?\n\nЭтот алгоритм может существенно замедлиться при массиве с большим количеством повторов. Например, если повторяющийся элемент занимает половину массива, то ``NaiveBinarySearchWithDuplicates`` потребует линейное время $O(n)$ вместо логарифмического времени $O(\\log n)$. Эта проблема устранена в псевдокоде ниже.\n\n```cpp\nNaiveBinarySearchWithDuplicates(K[0..n−1], q)\n    minIndex = 0\n    maxIndex = n−1\n    result = -1\n    while maxIndex \u003e= minIndex:\n        midIndex = (minIndex + maxIndex) / 2\n        if K[midIndex] = q:\n            maxIndex = midIndex - 1\n            result = midIndex\n        else if K[midIndex] \u003c q:\n            minIndex = midIndex + 1\n        else:\n            maxIndex = midIndex − 1\n    return result\n```\n\n## Что дальше\n\nТеперь вы знаете, как работает двоичный поиск — быстрый и надёжный способ находить элементы в отсортированных структурах. Вы научились реализовывать его корректно, аккуратно обращаться с границами и условиями, а также оценивать его эффективность.\n\nДалее — задача на определение доминирующего элемента. Представьте, что в базе заказов вам нужно быстро определить, какой товар покупают чаще всего и действительно ли он занимает больше половины всех покупок. Эта задача покажет, как использовать стратегию «Разделяй и властвуй» для анализа последовательностей и комбинировать рекурсию с постобработкой для точного результата.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80772) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Двоичный поиск — это способ найти элемент в отсортированной последовательности за логарифмическое время.\n* Корректная реализация требует аккуратной работы с границами, особенно при вычислении середины.\n* Ошибки в условиях цикла или смещении границ — частая причина багов, особенно на больших входах.\n* Двоичный поиск можно адаптировать для решения более сложных задач — например, нахождения первого/последнего вхождения или границы условий.\n"])</script><script nonce="">self.__next_f.push([1,"87:T226a,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с улучшенной версией одного из самых популярных алгоритмов сортировки — быстрой сортировки. Вы узнаете, как адаптировать её под случаи с большим числом повторяющихся элементов и как добиться устойчивого времени выполнения даже на «неудобных» входах.\n\n## Ключевые вопросы параграфа\n\n* Почему стандартная быстрая сортировка может работать медленно на массивах с повторяющимися элементами?\n* Как изменить алгоритм так, чтобы избежать деградации производительности?\n* Как реализовать трёхчастное разбиение и почему оно даёт прирост в эффективности?\n\n## Проверка последовательности\n\nВаша задача — проверить, содержит ли данная последовательность элемент, который встречается более половины раз.\n\n* Формат ввода: Первая строка содержит целое число $n$, следующая — последовательность $n$ целых неотрицательных чисел $a_0, \\dotsc, a_{n-1}$.\n* Формат вывода: Выведите $1$, если в последовательности содержится элемент, который встречается больше, чем $n/2$ раз, и $0$ в противном случае.\n* Ограничения: $1 \\le n \\le 10^5$; $0 \\le a_i \\le 10^9$ для всех $0 \\le i \u003c n$.\n* Примеры:\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5\u003cbr\u003e2 3 9 2 2\n\n|\n\n1\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n4\u003cbr\u003e1 2 3 1\n\n|\n\n0\n\n||\n|#\n\n* В первом примере $2$ — доминирующий элемент.\n* Во втором примере у последовательности нет доминирующего элемента. Обратите внимание, что элемент $1$ — не доминирующий.\n\n### Решение\n\nЗдесь приведён примитивный алгоритм, который решает задачу «Поиск доминирующего элемента» за квадратичное время:\n\n```cpp\nMajorityElement(A[1..n]):\n    for i from 1 to n:\n        currentElement = A[i]\n        count = 0\n        for j from 1 to n:\n            if A[j] = currentElement:\n                count = count + 1\n        if count \u003e n/2:\n            return 1\n    return 0\n```\n\nНа практике входную последовательность можно просканировать и сохранить число вхождений каждого элемента в ассоциативном массиве. Время выполнения этого решения зависит от конкретной реализации ассоциативного массива. Если реализация представляет собой сбалансированное дерево поиска, тогда каждый уточняющий запрос в массиве занимает $O(\\log n)$, а общее время выполнения составляет $O(n\\log n)$. Для хеш-таблиц уточняющие запросы эффективны на практике, хотя и могут варьироваться в зависимости от вводных данных.\n\n### Стратегия «Разделяй и властвуй»\n\nСтратегия «разделяй и властвуй» приводит к простому алгоритму с временем выполнения $O(n \\log n)$. Несложная, но невероятно важная вещь: если $e$ — это доминирующий элемент последовательности, тогда $e$ должен быть доминирующим элементом как минимум в одной из половин.\n\nОднако обратите внимание, что обратное неверно: обе половины последовательности $(2, 3, 3, 7, 5, 7)$ содержат доминирующие элементы ($3$ и $7$ соответственно), но ни один из них не является доминирующим элементом изначальной последовательности.\n\nЭто приводит нас к следующему алгоритму:  найти доминирующий элемент в обоих половинах с помощью рекурсии и для каждой из половин проверить количество вхождений в изначальную последовательность.\n\nДля последнего шага нам необходимо ещё раз сделать линейное сканирование, что может занять время $O(n)$. Следовательно, время выполнения $T(n)$ удовлетворяет $T(n) \\le 2T(n/2)+O(n)$, поэтому $T(n)=O(n\\log n)$.\n\n## Упражнение\n\nСможете ли вы спроектировать еще более быстрый алгоритм с временем выполнения $O(n)$? В основе лежит следующая идея. Разделить вводные элементы на пары. Рассмотреть каждую пару: если два элемента различны, отбросить оба; в противном случае отбросить один из них.\n\n## Что дальше\n\nТеперь вы умеете модифицировать быструю сортировку так, чтобы она работала эффективно даже на массивах с повторяющимися элементами. Вы узнали, как устроено трёхчастное разбиение, и научились избегать худших случаев, когда обычная реализация деградирует до квадратичного времени.\n\nДалее — задача на подсчёт инверсий. Вы увидите, как можно сочетать сортировку и рекурсию, чтобы решать аналитические задачи быстрее, чем простым перебором.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80773) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Стратегия «Разделяй и властвуй» позволяет находить доминирующий элемент за $O(n \\log n)$ , разбивая задачу на части.\n* Элемент считается доминирующим, если он встречается больше чем в половине элементов последовательности.\n* Проверки в обеих половинах не гарантируют общий результат — требуется финальное сканирование.\n* Можно спроектировать и более быстрый алгоритм за $O(n)$, если использовать идею попарного сравнения и отбрасывания.\n"])</script><script nonce="">self.__next_f.push([1,"88:T1dc4,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте, почему стандартная реализация быстрой сортировки может работать медленно на массивах с повторяющимися элементами. Вы узнаете, как изменить алгоритм, чтобы избежать деградации производительности, и научитесь реализовывать трёхчастное разбиение, которое делает сортировку устойчивой даже в сложных случаях.\n\n## Ключевые вопросы параграфа\n\n* Почему стандартная быстрая сортировка может работать медленно на массивах с повторяющимися элементами?\n* Как изменить алгоритм так, чтобы избежать деградации производительности?\n* Как реализовать трёхчастное разбиение и почему оно даёт прирост в эффективности?\n\n## Псевдокод\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_7_3_1_c539fd6b16_647b19827a.svg)\n\n```cpp\nRandomizedQuickSort(c):\n     if |c| \u003c= 1: # тут и сортировать нечего\n        return c\n     m = random_choice(c) # выбираем случайный элемент из массива\n     определяем элементы c_small меньшие m \n     определяем элементы c_large большие m\n     RandomizedQuickSort(c_small) # рекурсивный вызов алгоритма\n     RandomizedQuickSort(c_large)\n     объединяем c_small, m и c_large в итоговый массив c_sorted\n     return c_sorted\n```\n\nВ этом псевдокоде подразумевается, что все элементы массива разные. Ожидаемое время выполнения алгоритма составляет $O(n \\log n)$.\n\n## Изменение массива\n\nАлгоритм легко изменить для случая, когда в этом массиве есть повторы. Чтобы это сделать, пусть в $c_{small}$ содержатся все элементы со значением не более $m$, а не элементы со значением менее $m$. Тем не менее такая модификация становится медленной даже относительно ожидаемого времени выполнения. Например, если все элементы $c$ одинаковы, $c$ разделяется на две части: размер $c_{small}$ составляет $n-1$, а в $c_{{large}}$ нет элементов. Так как это разделение требует от `RandomizedQuickSort` времени $a\\cdot n$, общее время выполнения составляет:\n\n$$a \\cdot n+a \\cdot (n-1)+a \\cdot (n-2)+\\dotsb = a \\cdot \\frac{n \\cdot (n+1)}{2} \\,\n$$\n\nто есть $O(n^2)$ вместо $O(n \\log n)$.\n\nВаша цель — изменить описанный выше алгоритм `RandomizedQuickSort` так, чтобы даже при последовательностях с множеством повторяющихся элементов ожидаемое время выполнения стало $O(n \\log n)$.\n\n* Формат ввода: Первая строка содержит целое число $n$. В следующей строке содержится последовательность из $n$ целых чисел $a_0, a_1, \\dotsc, a_{n-1}$.\n* Формат вывода: Вывод последовательности в неубывающем порядке.\n* Ограничения: $1 \\le n \\le 10^5$; $1 \\le a_i \\le 10^9$ для всех $0 \\le i \u003c n$.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5\u003cbr\u003e2 3 9 2 2\n\n|\n\n2 2 2 3 9\n\n||\n|#\n\n\u003e Совет: не используйте встроенные алгоритмы сортировки.\n\n### Решение\n\nДля ускорения `RandomizedQuickSort` мы разделим входной массив на три подмассива: элементы меньше опорного, равные ему и элементы больше. В более простом подходе достаточно сканировать массив трижды и собрать необходимые элементы.\n\n### Упражнение\n\nПродемонстрируйте, как разделить массив на три части (меньше опорного элемента m, равняется ему и больше него) на месте— без использования дополнительной памяти.\n\n## Что дальше\n\nТеперь вы умеете модифицировать быструю сортировку так, чтобы она оставалась эффективной даже при наличии большого числа одинаковых элементов. Вы освоили идею трёхчастного разбиения и поняли, как оно помогает избежать худших сценариев и ускорить работу алгоритма.\n\nДалее — задача на подсчёт инверсий. Вы узнаете, как можно сочетать сортировку и рекурсию, чтобы вычислять количество нарушений порядка быстрее, чем простым перебором.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80775) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Стандартная быстрая сортировка может деградировать $O(n^2)$, если в данных много одинаковых значений.\n* Модификация с трёхчастным разбиением (на меньше, равные и больше опорного) делает сортировку стабильной по времени.\n* Случайный выбор опорного элемента помогает избежать худших случаев.\n* Алгоритм остаётся простым, но работает существенно быстрее в практических задачах."])</script><script nonce="">self.__next_f.push([1,"89:T3932,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы познакомитесь с задачей на определение количества инверсий в массиве — то есть пар элементов, стоящих в неправильном порядке. Вы узнаете, как решать эту задачу не полным перебором, а гораздо быстрее — с помощью модифицированной сортировки слиянием. Этот подход поможет вам понять, как сочетать сортировку и вычисления в одном алгоритме.\n\n## Ключевые вопросы параграфа\n\n* Что такое инверсии и как их находить?\n* Почему перебор всех пар работает медленно и как это ускорить?\n* Как работает алгоритм подсчёта инверсий на основе сортировки слиянием?\n\n## Количество инверсий в последовательности\n\n![algosy_7_4_1_cbcbdf8c04.svg](https://yastatic.net/s3/education-portal/media/algosy_7_4_1_cbcbdf8c04_5e298701a5.svg)\n\nКоличество инверсий в последовательности — показатель того, насколько последовательность отсортирована. Например, в неубывающей последовательности не будет инверсий, а последовательность в порядке убывания содержит $n(n-1)/2$ инверсий (каждые два элемента образуют инверсию).\n\nРешая задачу «Количество инверсий», примитивный алгоритм просматривает все возможные пары $(i,j)$, что требует времени выполнения $O(n^2)$. Чтобы решить эту задачу за время $O(n\\log n)$ с помощью алгоритма «разделяй и властвуй», мы разделяем вводный массив на две половины и делаем рекурсивный вызов обоих из них. Остаётся только вычислить количество инверсий, которые образованы двумя элементами из разных частей.\n\nЕсли делать это примитивным образом, то мы снова придём к времени выполнения $O(n^2)$, так как общее количество таких пар составляет $\\frac{n}{2} \\cdot \\frac{n}{2}=\\frac{n^2}{4}=O(n^2)$. Оказывается, что если обе части уже отсортированы, количество инверсий из элементов разных половин можно вычислить за время $O(n)$.\n\nЭто подсказывает нам, что вместо решения изначальной задачи, нам стоит решить более общую: вычислить количество инверсий в заданном массиве и в то же время отсортировать его.\n\n### Упражнение\n\nИзмените алгоритм ``MergeSort`` для решения этой задачи.\n\n* Формат ввода: Первая строка содержит целое число $n$, следующая — последовательность целых чисел $a_0, \\dotsc, a_{n-1}$.\n* Формат вывода: Количество инверсий в последовательности.\n* Ограничения: $1 \\le n \\le 30\\,000$, $1 \\le a_i \\le 10^9$ для всех $0 \\le i \\le n-1$.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5\u003cbr\u003e2 3 9 2 9\n\n|\n\n2\n\n||\n|#\n\n* В примере две инверсии: $(2,4)$ ($a_2=3 \u003e 2=a_4$) и\n$(3,4)$ ($a_3=9 \u003e 2=a_4$).\n\n* Совет: используйте полуоткрытые интервалы для рекурсивных реализаций\n\n### Решение\n\nПопробуем использовать самый распространённый подход к методу «разделяй и властвуй»: разделим вводную последовательность на две половины, ``LeftHalf`` и ``RightHalf``, и выполним рекурсивный вызов для каждой. Это позволит нам вычислить все инверсии, находящиеся в одной и той же половине. Однако это не подскажет нам количество разделённых инверсий, то есть количество пар $(a_i,a_j)$, при которых $a_i$ находится в левой половине, $a_j$ находится в правой, а $a_i \u003e a_j$.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Возьмём элемент $x$ в $LeftHalf$. Каково количество разделённых инверсий, в которые входит $x$?\n\nДаны массив $List$ и целое число $x$. Пусть $List_x$ будет количеством элементов $List$, которые меньше $x$. Так как ответ на вопрос выше — это $RightHalf_x$, наша задача заключается в том, чтобы быстро вычислить $List_x$.\n\nТаким образом, мы приходим к следующей задаче: имея последовательность целых чисел $List$ и целое число $x$, нам нужно найти в $List$ количество элементов, которые меньше $x$. В случае неотсортированного массива это можно сделать за время $O(|List|)$, так как необходимо проверить каждый элемент массива. В варианте же отсортированного за время $O(\\log |List|)$, если использовать двоичный поиск.\n\n### Упражнение\n\nПродемонстрируйте, как реализовать метод ``CountSmaller(List, x)`` для подсчёта количества элементов $List$ со значением меньше $x$ за время $O(\\log_2|List|)$.\n\nТак мы приходим к следующему алгоритму «разделяй и властвуй».\n\n```cpp\nCountInversions(List):\n    if ∣List∣ \u003c= 1:\n        return 0\n    inversions = 0\n    // в случае нечётной длины\n    // центральный элемент может быть и слева, и справа\n    LeftHalf = левая половина List   \n    RightHalf = правая половина List \n    inversions = inversions + CountInversions(LeftHalf)\n    inversions = inversions + CountInversions(RightHalf)\n    sort(RightHalf) // необходимо для двоичного поиска\n    for x in LeftHalf:\n        inversions = inversions + CountSmaller(RightHalf,x)\n    return inversions\n```\n\nВремя выполнения $T(n)$ (где $n$ — длина $List$) удовлетворяет рекуррентному соотношению\n\n$$\nT(n) \\le 2T(n/2) + O(n\\log n) \\, .\n$$\n\nСлагаемое $O(n\\log n)$ включает в себя два шага: сортировку $RightHalf$ и ответ на $n/2$ запросов ``CountSmaller``. Эту рекуррентное соотношение нельзя напрямую вставить в основную теорему о рекуррентных соотношениях, так как элемент $O(n\\log n)$ не имеет форму $O(n^d)$ при константе $d$.\n\nОднако мы можем проанализировать её таким же образом: рекурсивное дерево содержит $\\log_2 n$ уровней, общий размер всех задач на каждом уровне равен $n$, а общее затраченное время на каждом уровне составляет $O(n\\log n)$. В итоге общее время выполнения составляет $O(n\\log^2n)$. Вместо того, чтобы формально это доказывать, мы улучшим вышеприведённый алгоритм так, чтобы он затрачивал время $O(n\\log n)$.\n\nМожно быстро найти все разделённые инверсии, если наряду с подсчётом инверсий сортировать входную последовательность. То есть можно предположить, что алгоритм ``CountInversionsAndSort(List)`` возвращает количество инверсий в $List$ и сортирует $List$. После двух рекурсивных вызовов обе половины $List$ отсортированы. На данном этапе нам нужно сделать две вещи: отсортировать всю последовательность $List$ и вычислить количество разделённых инверсий. Мы уже знаем, как достичь первой цели: этим занимается процедура $Merge$. Это выглядит следующим образом.Пусть $l$ и $r$ будут первыми элементами отсортированных последовательностей $LeftHalf$ и $RightHalf$. Далее выбирается самый маленький из них и перемещается в увеличивающийся отсортированный список.\n\n\u003e **Остановитесь и подумайте:**\n\u003e Можете ли вы найти количество разделённых инверсий, которые образует перемещаемый элемент?\n\nРассмотрим два случая.\n\n* $l \\le r$. В этом случае $l$ не больше каждого элемента $RightHalf$, и поэтому не образует разделённых инверсий.\n* $l \u003e r$. В этом случае $r$ меньше всех элементов $LeftHalf$, и поэтому образует разделённую инверсию с каждым из них.\n\nЭто приводит нас к следующему расширению метода ``Merge``.\n\n```cpp\nMerge(LeftHalf, RightHalf):\n    SortedList = empty list\n    inversions = 0\n    while both LeftHalf and RightHalf are non-empty:\n        l = первый элемент LeftHalf\n        r = первый элемент RightHalf\n        if l \u003c= r:\n            переместить l в SortedList\n            l = следующий элемент в LeftHalf\n        else:\n            переместить r в SortedList\n            r = следующий элемент в RightHalf\n            // учитываются только не перемещенные элементы\n            inversions = inversions + ∣LeftHalf∣\n    добавить все оставшиеся элементы LeftHalf и RightHalf в SortedList\n    return SortedList, inversions\n```\n\nИ окончательная версия алгоритма ``CountInversions``.\n\n```cpp\nCountInversions(List):\n    // список List будет отсортирован\n    if ∣List∣ \u003c= 1:\n        return 0\n    LeftHalf = левая половина List\n    RightHalf = правая половина List\n    leftInv = CountInversions(LeftHalf)\n    rightInv = CountInversions(RightHalf)\n    List, splitInv = Merge(LeftHalf, RightHalf)\n    return leftInv + rightInv + splitInv\n```\n\n## Что дальше\n\nТеперь вы умеете находить количество инверсий в массиве с помощью модифицированной сортировки. Вы увидели, как объединять рекурсивное деление с анализом данных и использовать «побочные эффекты» сортировки для аналитических целей.\n\nДалее — последняя задача главы: вы узнаете, как найти пару ближайших точек на плоскости за $O(n\\log n)$, используя те же идеи — сортировку, деление и точный контроль над шагами объединения.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80775) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Инверсии — это пары элементов в неправильном порядке: $i \u003c j$  и  $a_i \u003e a_j$.\n* Полный перебор всех пар даёт сложность $O(n^2)$, но можно улучшить до $O(n\\log n)$, используя сортировку слиянием.\n* Во время слияния двух отсортированных частей можно одновременно считать количество инверсий.\n* Такой подход позволяет комбинировать сортировку и подсчёт статистик за одно и то же время.\n"])</script><script nonce="">self.__next_f.push([1,"8a:T3196,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте классическую задачу вычислительной геометрии: как найти пару ближайших точек на плоскости. Вы узнаете, почему полный перебор всех пар неэффективен, и научитесь решать эту задачу за $O(n \\log n)$, применяя стратегию «Разделяй и властвуй». Такой подход часто встречается в олимпиадных и прикладных задачах на двумерные данные.\n\n## Ключевые вопросы параграфа\n\n* Почему перебор всех пар точек работает медленно и как этого избежать?\n* Как устроен алгоритм поиска ближайшей пары с помощью деления и сканирования полосы?\n* Как добиться точного и стабильного результата при вычислениях с вещественными числами?\n\n![Algoritmy_17_44e92fd3cc.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_17_44e92fd3cc_781c551b9a.svg)\n\n## Задача\n\nВаша задача — найти ближайшую пару точек из заданного множества.\n\nВ компьютерных графике и зрении есть множество вариантов применения этой задачи из вычислительной геометрии.  Примитивный алгоритм с квадратичным временем выполнения делает итерации, проходя через все пары точек, чтобы найти ближайшие друг к другу. Ваша цель — спроектировать алгоритм «разделяй и властвуй», время выполнения которого составит $O(n\\log n)$.\n\n### Решение\n\n* Чтобы решить эту задачу за время $O(n\\log n)$, разобьём с помощью правильно подобранной вертикальной линии данные $n$ точек пополам — множества $S_1$ и $S_2$ размера $\\frac{n}{2}$.\n* Ради простоты предположим, что все координаты $x$ для данных точек различные и количество точек чётное.\n* С помощью двух рекурсивных вызовов с параметрами $S_1$ и $S_2$ мы находим минимальные расстояния $d_1$ и $d_2$ в этих поднаборах. Пусть $d=\\min\\{d_1, d_2\\}$.\n\n![Algoritmy_18_59cd80e923.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_18_59cd80e923_920223a60b.svg)\n\nОстаётся проверить, существуют ли такие точки $p_1 \\in S_1$ и $p_2 \\in S_2$, при которых расстояние между ними меньше $d$. Мы не можем себе позволить проверять все возможные такие пары, так как их $\\frac{n}{2} \\cdot \\frac{n}{2}=\\Theta(n^2)$. Для более быстрой проверки мы отбросим все точки из $S_1$ и $S_2$, расстояние которых от центральной линии по $x$ больше, чем $d$. Таким образом, мы сосредотачиваемся на следующей полосе:\n\n![Algoritmy_19_be157f5fb2.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_19_be157f5fb2_24f0bda377.svg)\n\n\u003e **Остановитесь и подумайте:**\n\u003e Почему мы можем сузиться до этой полосы?\n\nТеперь отсортируем точки из полосы по координатам $y$ и обозначим получившийся отсортированный список $P=[p_0,\\dotsc, p_{k-1}]$. Оказывается, что если $|i-j|\u003e7$, то расстояние между точками $p_i$ и $p_j$ однозначно будет больше $d$. Упражнение ниже это демонстрирует.\n\n### Упражнение\n\nРазделите полосу на $d \\times d$ квадратов, как показано ниже, и продемонстрируйте, что каждый из таких квадратов содержит максимум четыре точки ввода.\n\n![Algoritmy_20_ddb168de68.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_20_ddb168de68_a2db494129.svg)\n\nЭто приводит к следующему алгоритму.\n\n1. Сначала мы сортируем данные нам $n$ точек по их координатам $x$, затем делим получившийся отсортированный список на две половины $S_1$ и $S_2$ размера $\\frac{n}{2}$.\n2. Находим минимальные расстояния $d_1$ и $d_2$ с помощью рекурсивных вызовов для каждого из наборов $S_1$ и $S_2$. Пусть $d=\\min\\{d_1,d_2\\}$.\n3. Тем не менее наша работа ещё не закончена, потому что нам также нужно найти минимальное расстояние между точками из разных наборов (то есть точкой из $S_1$ и точкой из $S_2$) и проверить, ниже ли это расстояние, чем $d$.\n4. Чтобы в этом убедиться, мы отфильтруем изначальный набор и оставим только точки с дистанцией по $x$ до средней линии, не превышающей $d$.\n5. После этого мы сортируем набор точек в получившейся линии по координатам $y$ и сканируем получившийся список.\n6. Вычислим расстояние от каждой точки до семи последующих точек списка и вычислим $d'$ — минимальное расстояние, которое нам встретилось во время сканирования.\n7. Затем выведем $\\min\\{d,d'\\}$.\n\nВремя выполнения алгоритма соответствует рекуррентному соотношению.\n\n$$\nT(n)=2 \\cdot T\\left(\\frac{n}{2}\\right) + O(n \\log n) \\,\n$$\n\n$O(n\\log n)$ — результат сортировки точек в полосе по координате $y$ при каждой итерации.\n\n### Упражнение\n\nПроанализируйте рекурсивное дерево алгоритма и докажите, что $T(n)=O(n\\log^2 n)$.\n\n### Упражнение\n\nПродемонстрируйте, как избежать сортировки при каждом рекурсивном вызове и понизить время выполнения до $O(n \\log n)$.*\n\n* Формат ввода: Первая строка содержит $n$ точек. Каждая из следующих $n$ строк определяет точку $(x_i,y_i)$.\n* Формат вывода: Минимальное расстояние.\n* Ограничения: $2 \\le n \\le 10^5$; $-10^9 \\le x_i,y_i \\le 10^9$ — целые числа.\n* Примеры\n\n#### Пример 1\n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\u003cbr/\u003e0 0\u003cbr/\u003e3 4\n\n|\n\n5\\.0\n\n||\n|#\n\n#### Пример 2\n\n#|\n\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n11\u003cbr/\u003e-2 4\u003cbr/\u003e-2 -2\u003cbr/\u003e4 4\u003cbr/\u003e2 3\u003cbr/\u003e-3 -4\u003cbr/\u003e-4 0\u003cbr/\u003e-1 3\u003cbr/\u003e3 -1\u003cbr/\u003e1 1\u003cbr/\u003e-1 -1\u003cbr/\u003e-4 2\n\n|\n\n1\\.414213\n\n||\n|#\n\n* Во втором примере самое маленькое расстояние — $\\sqrt{2}$. Есть две пары точек на этом расстоянии. Ниже они выделены голубым и красным: $(-1,-1)$ и $(-2,-2)$; $(-2,4)$ и $(-1,3)$.\n\n![Algoritmy_21_9177b21c56.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_21_9177b21c56_8e1aea64eb.svg)\n\nПомните, что расстояние между точками $(x_1,y_1)$ и $(x_2,y_2)$ равно $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$. Так, хотя ввод и содержит только целые числа, ответ не обязательно будет целым числом, и потому вам нужно обратить внимание на точность при выводе результатов. Абсолютное значение разницы между ответом вашей программы и оптимальным значением не должно превышать $10^{-3}$. Для этого ваш ответ должен содержать не меньше четырех цифр в дробной части. Иначе даже правильно вычисленный результат может не пройти нашу систему проверки из-за ошибок при округлении.\n\n\u003e Совет: по возможности старайтесь избегать использования чисел с плавающей дробной частью, при необходимости используйте встроенные алгоритмы для сортировки.\n\n✅ Получилось разобраться, как найти пару ближайших точек быстрее, чем за $O(n^2)$?\n\n👉 [Оценить этот параграф](https://forms.yandex.ru/surveys/academy/?proekt=handbooks)\n\n## Что дальше\n\nТеперь вы умеете находить пару ближайших точек на плоскости с помощью алгоритма «Разделяй и властвуй». Вы увидели, как сортировка, аккуратное разбиение и сканирование узкой полосы позволяют снизить сложность задачи до $O(n \\log n)$, сохранив точность вычислений.\n\nДалее — заключительный параграф главы: мы кратко подведём итоги и соберём воедино все стратегии, с которыми вы познакомились.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/47636) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/python/article/python-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Задачу нахождения пары ближайших точек можно решить не за $O(n^2)$, а за $O(n \\log n)$, если использовать стратегию «Разделяй и властвуй».\n* Алгоритм включает сортировку точек по координате, рекурсивное деление множества и слияние с анализом узкой полосы шириной $2 d$.\n* При слиянии достаточно проверить не все пары, а только точки в полосе, отсортированные по второй координате, — это снижает число сравнений.\n* Точная реализация требует аккуратности: важно корректно обрабатывать базовые случаи, следить за порядком точек и не упустить минимум.\n"])</script><script nonce="">self.__next_f.push([1,"8b:T1965,"])</script><script nonce="">self.__next_f.push([1,"В этой главе вы освоили один из самых мощных приёмов в алгоритмах — стратегию «Разделяй и властвуй». Вы увидели, как сложную задачу можно разбить на более простые части, решить их рекурсивно и аккуратно объединить результат.\n\nТеперь вы умеете:\n\n* применять двоичный поиск для быстрого нахождения элемента в отсортированном массиве и корректно реализовывать его с учётом границ и условий;\n* находить доминирующий элемент в массиве, комбинируя рекурсивное деление с финальной проверкой результата;\n* модифицировать быструю сортировку, чтобы избежать деградации при повторяющихся значениях, используя трёхчастное разбиение и случайный выбор опорного элемента;\n* считать инверсии в массиве с помощью сортировки слиянием, совмещая упорядочивание с вычислением статистик;\n* находить пару ближайших точек на плоскости за $O(n \\log n)$ аккуратно обрабатывая центральную полосу после деления.\n\nЭти техники особенно полезны, когда задача слишком сложна для полного перебора, но имеет чёткую структуру и допускает разбиение. Вы освоили ключевые алгоритмические приёмы, лежащие в основе программирования и анализа данных. Научились решать задачи по шагам: от формализации условия до выбора стратегии и оценки производительности решения. Познакомились со структурами данных, методами перебора, жадными алгоритмами, динамическим программированием и базовыми приёмами работы с графами.\n\nСпасибо, что прошли этот путь вместе с нами. Освоение алгоритмов требует настойчивости, времени и внимания к деталям, и мы искренне восхищаемся вашей решимостью дойти до конца.\n\nЗа время работы с хендбуком вы сформировали системное представление об алгоритмах — от базовых принципов до практических приёмов их реализации.\n\n* В главе 1 мы познакомились с устройством хендбука, разобрались, как пользоваться системой проверки и как оценивать корректность и эффективность алгоритмов.\n* В главе 2 освоили основные структуры данных и научились работать с массивами, списками, стеками, очередями и словарями.\n* В главе 3 попробовали силы на практических задачах: от полного перебора до первых приёмов оптимизации решений.\n* В главе 4 на примерах рекурсии увидели, как строятся элегантные и мощные последовательные алгоритмы.\n* В главе 5 познакомились с графами, их представлениями и базовыми алгоритмами работы.\n* В главе 6 перешли к техникам проектирования алгоритмов: научились строить решения через разбиение задач, поиск инвариантов и другие приёмы.\n* В главе 7 исследовали жадные алгоритмы: их простоту, ограничения и способы доказательства корректности.\n* В главе 8 шаг за шагом освоили динамическое программирование, научились разбивать задачи на подзадачи и находить оптимальные решения.\n* В главе 9 отработали стратегию «Разделяй и властвуй», реализовали двоичный поиск и увидели, как этот подход помогает строить быстрые алгоритмы.\n\n### Что дальше\n\n* Хотите закрепить базовые навыки — начните с курса **«Основы Python»**, где разберёте синтаксис и ключевые библиотеки.\n* Интересно попробовать другой язык и глубже понять устройство памяти — подойдут **«Основы C\\+\\+»**.\n* Чтобы расширить математический фундамент и подготовиться к анализу данных и ML, пройдите курс **«Математика для анализа данных»**.\n* Для практического выхода в разработку приложений есть **Flutter** и кросс-платформенные решения.\n* Следующий серьёзный шаг — **машинное обучение**, где алгоритмическое мышление соединяется с современными моделями и нейросетями.\n\nАлгоритмы дали вам системный взгляд и уверенность в решении задач. Теперь выберите направление, которое ближе к вашим целям, и продолжайте развивать свои навыки."])</script><script nonce="">self.__next_f.push([1,"1c:[\"$\",\"$L56\",null,{\"bookSlug\":\"algorithms\",\"articleSlug\":\"zadacha-kolichestvo-prizov\",\"children\":[\"$\",\"$L57\",null,{\"articleName\":\"7.5 Задача «Количество призов»\",\"children\":[\"$\",\"$L58\",null,{\"chapters\":[{\"id\":28,\"Name\":\"1. Введение\",\"Articles\":[{\"Name\":\"algo | 1.1 Прежде чем начать\",\"Slug\":\"algo-kak-polzovatsia-khendbukom\",\"createdAt\":\"2024-08-27T11:36:31.304Z\",\"updatedAt\":\"2026-01-10T12:07:06.788Z\",\"publishedAt\":\"2024-08-27T11:36:40.156Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$59\",\"Title\":\"Прежде чем начать\",\"LikesCount\":27,\"Quiz\":[{\"answers\":[{\"text\":\"Закладка в хендбуке — это метка для сохранения места в тексте.\",\"generated_as_correct\":true},{\"text\":\"Закладка в хендбуке — это специальный символ, который вставляется в текст для украшения и выделения важных фрагментов.\",\"generated_as_correct\":false},{\"text\":\"Закладка в хендбуке относится к способу организации закладок в браузере для быстрого доступа к веб-страницам.\",\"generated_as_correct\":false},{\"text\":\"Закладка в хендбуке используется для скрытия определённых разделов текста.\",\"generated_as_correct\":false}],\"question\":\"Что такое закладка в хендбуке и для чего она используется?\"},{\"answers\":[{\"text\":\"Закладки помогают сохранять прогресс чтения и быстро находить нужные разделы в объёмных материалах.\",\"generated_as_correct\":true},{\"text\":\"Закладки полезны только для того, чтобы украсить страницы книги и сделать их более эстетичными, они не влияют на эффективность изучения материалов.\",\"generated_as_correct\":false},{\"text\":\"Закладки помогают организовать физическое пространство на рабочем столе, позволяя держать нужные документы и бумаги в порядке во время изучения материалов.\",\"generated_as_correct\":false},{\"text\":\"Закладки нужны только для того, чтобы предотвратить загибание страниц и сохранить книгу в хорошем состоянии.\",\"generated_as_correct\":false}],\"question\":\"Почему использование закладок может быть полезным при изучении объёмных материалов?\"},{\"answers\":[{\"text\":\"Закладки сохраняют место в тексте, чтобы можно было быстро вернуться к чтению.\",\"generated_as_correct\":true},{\"text\":\"Закладки автоматически сохраняют весь прочитанный текст, позволяя пользователям возвращаться к любому месту в хендбуке без необходимости запоминать, где они остановились.\",\"generated_as_correct\":false},{\"text\":\"Закладки помогают структурировать заметки и комментарии к тексту, что облегчает анализ и обсуждение прочитанного.\",\"generated_as_correct\":false},{\"text\":\"Закладки удаляют пройденные разделы текста, чтобы не возвращаться к ним повторно.\",\"generated_as_correct\":false}],\"question\":\"Как закладки помогают сохранять прогресс чтения?\"},{\"answers\":[{\"text\":\"Функция «Изменение статуса главы» отмечает главы как прочитанные и отображает это в прогресс-баре.\",\"generated_as_correct\":true},{\"text\":\"Функция «Изменение статуса главы» позволяет изменять порядок глав в хендбуке, что влияет на отображение страниц и прогресс-бара.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» используется для изменения формата текста в главах хендбука и не влияет на отображение прогресса.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» позволяет скрывать главы из хендбука.\",\"generated_as_correct\":false}],\"question\":\"Что позволяет делать функция «Изменение статуса главы»?\"},{\"answers\":[{\"text\":\"Функция «Изменение статуса главы» помогает отслеживать прогресс изучения материала, помечая прочитанные главы.\",\"generated_as_correct\":true},{\"text\":\"Функция «Изменение статуса главы» предоставляет возможность сохранять заметки к каждой главе, что помогает лучше запоминать материал.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» используется для изменения порядка глав в хендбуке, что может быть полезно при организации материала по важности или приоритету.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» нужна для того, чтобы скрывать уже изученные главы из списка содержания.\",\"generated_as_correct\":false}],\"question\":\"Как функция «Изменение статуса главы» помогает в изучении материала?\"},{\"answers\":[{\"text\":\"Изменение статуса главы отображается на странице содержания и в прогресс-баре.\",\"generated_as_correct\":true},{\"text\":\"Изменение статуса главы фиксируется в отдельном разделе «История», где пользователь может просмотреть хронологию своих действий, но это не влияет на отображение прогресса.\",\"generated_as_correct\":false},{\"text\":\"Изменение статуса главы связано с возможностью редактирования контента и доступно только авторам хендбука для управления структурой документа.\",\"generated_as_correct\":false},{\"text\":\"Изменение статуса главы влияет на рейтинг пользователя и отображается в его профиле.\",\"generated_as_correct\":false}],\"question\":\"Где отражается изменение статуса главы и как это может быть полезно для пользователя?\"},{\"answers\":[{\"text\":\"Система навигации внутри страниц — это инструмент для быстрого перемещения по разделам хендбука.\",\"generated_as_correct\":true},{\"text\":\"Система навигации внутри страниц — это метод автоматического прокручивания текста, который не требует от пользователя никаких действий для перемещения по хендбуку.\",\"generated_as_correct\":false},{\"text\":\"Система навигации внутри страниц связана с алгоритмами машинного обучения, которые анализируют поведение пользователя и предлагают ему наиболее релевантные разделы хендбука.\",\"generated_as_correct\":false},{\"text\":\"Система навигации внутри страниц — это функция для печати разделов хендбука без возможности перемещения по ним.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой система навигации внутри страниц?\"},{\"answers\":[{\"text\":\"Эффективная навигация ускоряет доступ к нужным разделам материала.\",\"generated_as_correct\":true},{\"text\":\"Эффективная навигация упрощает процесс изучения материала за счёт использования сложных алгоритмов, которые автоматически подбирают наиболее подходящие разделы для чтения в зависимости от интересов пользователя.\",\"generated_as_correct\":false},{\"text\":\"Эффективная навигация важна для улучшения структуры веб-сайта, поскольку она помогает поисковым системам лучше индексировать страницы и повышать их ранжирование.\",\"generated_as_correct\":false},{\"text\":\"Эффективная навигация усложняет изучение материала из-за избытка функций.\",\"generated_as_correct\":false}],\"question\":\"Почему эффективная навигация упрощает процесс изучения материала?\"},{\"answers\":[{\"text\":\"Система навигации ускоряет поиск нужных разделов благодаря элементам управления на странице.\",\"generated_as_correct\":true},{\"text\":\"Система навигации предоставляет пользователю список всех разделов в виде длинного перечня в начале страницы, что требует от него тщательного изучения этого списка для поиска нужного раздела.\",\"generated_as_correct\":false},{\"text\":\"Система навигации важна для определения структуры сайта и его визуального оформления, но не оказывает значительного влияния на скорость нахождения разделов на странице.\",\"generated_as_correct\":false},{\"text\":\"Система навигации замедляет поиск нужных разделов, так как требует дополнительного времени на изучение её структуры.\",\"generated_as_correct\":false}],\"question\":\"Как система навигации может помочь пользователю быстро находить нужные разделы на странице?\"},{\"answers\":[{\"text\":\"Коммьюнити хендбука — это сообщество для обмена опытом и помощи в изучении материала.\",\"generated_as_correct\":true},{\"text\":\"Коммьюнити хендбука — это группа экспертов, которые предоставляют платные консультации по вопросам, связанным с хендбуком.\",\"generated_as_correct\":false},{\"text\":\"Коммьюнити хендбука — это набор инструментов и ресурсов для создания собственных учебных материалов, не предполагающий взаимодействия между пользователями.\",\"generated_as_correct\":false},{\"text\":\"Коммьюнити хендбука — это площадка для продажи учебных материалов и книг.\",\"generated_as_correct\":false}],\"question\":\"Что такое коммьюнити хендбука?\"},{\"answers\":[{\"text\":\"Участие в коммьюнити хендбука углубляет понимание материала благодаря обмену опытом и взаимной помощи в решении сложных задач.\",\"generated_as_correct\":true},{\"text\":\"Участие в коммьюнити хендбука не влияет на понимание материала, поскольку взаимодействие между пользователями сводится к обмену общими впечатлениями без какой-либо практической пользы.\",\"generated_as_correct\":false},{\"text\":\"Участие в коммьюнити хендбука помогает улучшить навыки коммуникации, но не оказывает значительного влияния на понимание самого материала.\",\"generated_as_correct\":false},{\"text\":\"Участие в коммьюнити хендбука мешает пониманию материала из-за большого количества отвлекающей информации.\",\"generated_as_correct\":false}],\"question\":\"Почему участие в коммьюнити хендбука способствует более глубокому пониманию материала?\"},{\"answers\":[{\"text\":\"Коммьюнити хендбука помогает в изучении материала через обмен опытом и взаимной поддержкой при решении сложных задач.\",\"generated_as_correct\":true},{\"text\":\"Коммьюнити хендбука — это онлайн-сервис, где пользователи могут загружать свои решения сложных задач и получать за них баллы, которые можно обменять на дополнительные учебные материалы.\",\"generated_as_correct\":false},{\"text\":\"Коммьюнити хендбука — это группа экспертов, которые разрабатывают новые методики обучения и создают хендбуки для различных дисциплин.\",\"generated_as_correct\":false},{\"text\":\"Коммьюнити хендбука предоставляет готовые решения для сложных задач, которые можно использовать без дополнительного анализа.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать коммьюнити хендбука для решения сложных задач при изучении материала?\"}],\"StoreCardId\":null,\"numberInCourse\":\"1.1\"},{\"Name\":\"algo | 1.2. Как работать с системой проверки заданий\",\"Slug\":\"algo-kak-rabotat-s-sistemoi-proverki-zadanii\",\"createdAt\":\"2024-08-27T11:35:34.340Z\",\"updatedAt\":\"2026-01-10T12:07:06.854Z\",\"publishedAt\":\"2024-08-27T11:35:44.053Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$5a\",\"Title\":\"Как работать с системой проверки заданий\",\"LikesCount\":22,\"Quiz\":[{\"answers\":[{\"text\":\"Описание задачи находится в левой части экрана, а поле для написания кода — в правой.\",\"generated_as_correct\":true},{\"text\":\"В левой части экрана интерфейса системы проверки задач находятся кнопки управления, а в правой — результаты выполнения кода.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс системы проверки задач включает в себя элементы для настройки параметров выполнения кода и отображения статистики по решению задач.\",\"generated_as_correct\":false},{\"text\":\"В левой части экрана находится поле для написания кода, а в правой — кнопки управления.\",\"generated_as_correct\":false}],\"question\":\"Какие элементы интерфейса системы проверки задач расположены в левой и правой частях экрана?\"},{\"answers\":[{\"text\":\"Разделение описания задачи и поля для кода улучшает восприятие информации и концентрацию, ускоряя решение задачи.\",\"generated_as_correct\":true},{\"text\":\"Разделение описания задачи и поля для написания кода в интерфейсе необходимо для того, чтобы пользователь мог одновременно видеть весь код и всё описание задачи, что якобы улучшает понимание структуры кода.\",\"generated_as_correct\":false},{\"text\":\"Разделение описания задачи и поля для написания кода в интерфейсе важно для оптимизации работы серверов, на которых выполняется код, так как это позволяет более эффективно распределять ресурсы.\",\"generated_as_correct\":false},{\"text\":\"Разделение описания задачи и поля для кода усложняет восприятие информации и замедляет процесс решения задачи.\",\"generated_as_correct\":false}],\"question\":\"Почему разделение описания задачи и поля для написания кода в интерфейсе способствует более эффективной работе?\"},{\"answers\":[{\"text\":\"Интерфейс системы проверки задач упрощает работу, разделяя описание задачи и редактор кода на экране.\",\"generated_as_correct\":true},{\"text\":\"Интерфейс системы проверки задач предоставляет только описание задачи и не имеет функционала для написания кода, что делает его бесполезным для программиста.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс системы проверки задач используется для визуализации результатов выполнения кода и не влияет на процесс решения программистских задач.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс системы проверки задач только отображает готовые решения задач и не помогает в процессе их решения.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать интерфейс системы проверки задач для улучшения процесса решения программистских задач?\"},{\"answers\":[{\"text\":\"Описание задачи включает условие, формат ввода/вывода, пример и ограничения.\",\"generated_as_correct\":true},{\"text\":\"Описание задачи содержит только условие и пример решения, без дополнительных форматов и ограничений.\",\"generated_as_correct\":false},{\"text\":\"Описание задачи связано с определением переменных, используемых в алгоритме, и их типами данных.\",\"generated_as_correct\":false},{\"text\":\"Описание задачи ограничивается условием и форматом ввода данных.\",\"generated_as_correct\":false}],\"question\":\"Что включает в себя описание задачи?\"},{\"answers\":[{\"text\":\"Полное описание задачи помогает понять требования и подготовиться к решению.\",\"generated_as_correct\":true},{\"text\":\"Полное описание задачи нужно только для того, чтобы усложнить процесс решения и запутать пользователя, так как все необходимые данные можно получить без него.\",\"generated_as_correct\":false},{\"text\":\"Полное описание задачи полезно для составления алгоритма, но не оказывает значительного влияния на успешность выполнения задания, важнее навыки программирования и опыт решающего.\",\"generated_as_correct\":false},{\"text\":\"Полное описание задачи не нужно для успешного выполнения задания, достаточно иметь общие представления о теме.\",\"generated_as_correct\":false}],\"question\":\"Почему полное описание задачи важно для успешного выполнения задания?\"},{\"answers\":[{\"text\":\"Описание задачи даёт понимание требований к решению, включая форматы и ограничения, что помогает в подготовке к реализации.\",\"generated_as_correct\":true},{\"text\":\"Описание задачи предоставляет лишь общее представление о проблеме, не включая конкретные форматы ввода/вывода или примеры, что делает подготовку к реализации решения менее эффективной.\",\"generated_as_correct\":false},{\"text\":\"Описание задачи помогает пользователю выбрать подходящий язык программирования для реализации решения, хотя это не всегда напрямую связано с содержанием самого описания.\",\"generated_as_correct\":false},{\"text\":\"Описание задачи служит только для общего ознакомления с проблемой и не содержит информации, необходимой для подготовки к реализации решения.\",\"generated_as_correct\":false}],\"question\":\"Как описание задачи помогает пользователю подготовиться к реализации решения?\"},{\"answers\":[{\"text\":\"После отправки решения система тестирует код на разных входных данных, сравнивая результаты с эталонными.\",\"generated_as_correct\":true},{\"text\":\"После отправки решения система сохраняет код в базе данных и ожидает ручного запуска тестирования со стороны пользователя.\",\"generated_as_correct\":false},{\"text\":\"После отправки решения система проводит анализ сложности алгоритма и оценивает его эффективность с точки зрения времени выполнения и использования памяти.\",\"generated_as_correct\":false},{\"text\":\"После отправки решения система только сохраняет код для последующего просмотра пользователем.\",\"generated_as_correct\":false}],\"question\":\"Что происходит после отправки решения в системе?\"},{\"answers\":[{\"text\":\"Система тестирует код на разных входных данных и сравнивает результаты с ожидаемым выводом.\",\"generated_as_correct\":true},{\"text\":\"Система проверяет правильность решения задачи путём подсчёта количества строк кода и сравнения их с заранее определённым эталонным количеством.\",\"generated_as_correct\":false},{\"text\":\"Система анализирует комментарии в коде и оценивает их соответствие стандартам оформления, что позволяет определить качество решения задачи.\",\"generated_as_correct\":false},{\"text\":\"Система определяет правильность решения задачи по времени выполнения кода.\",\"generated_as_correct\":false}],\"question\":\"Как система определяет правильность решения задачи при тестировании?\"},{\"answers\":[{\"text\":\"Автоматическое тестирование ускоряет проверку правильности кода путём сравнения его результатов с ожидаемыми значениями.\",\"generated_as_correct\":true},{\"text\":\"Автоматическое тестирование решений заключается в ручной проверке кода программистом на соответствие заданным критериям без использования входных данных.\",\"generated_as_correct\":false},{\"text\":\"Автоматическое тестирование решений помогает оптимизировать алгоритмы машинного обучения, улучшая их точность и скорость работы.\",\"generated_as_correct\":false},{\"text\":\"Автоматическое тестирование решений усложняет процесс разработки, так как требует дополнительного времени на настройку тестовых данных.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается преимущество автоматического тестирования решений?\"},{\"answers\":[{\"text\":\"Система выдаёт статусы «Решена полностью» или «Решена неверно».\",\"generated_as_correct\":true},{\"text\":\"Система может выводить три статуса: «Решена верно», «Решена с ошибками» и «Не решена».\",\"generated_as_correct\":false},{\"text\":\"Система использует статусы для классификации типов задач и их сложности, например, «Простая», «Средняя» или «Сложная».\",\"generated_as_correct\":false},{\"text\":\"Система выдаёт статус «Выполнено частично» для всех решённых задач.\",\"generated_as_correct\":false}],\"question\":\"Какие статусы решения может выводить система в зависимости от результата проверки?\"},{\"answers\":[{\"text\":\"Статус решения показывает, правильно ли выполнено задание, что помогает пользователю понять, нужно ли корректировать решение.\",\"generated_as_correct\":true},{\"text\":\"Статус решения отображает время, затраченное на выполнение задания, показывая «Быстро выполнено» или «Медленно выполнено», что помогает пользователю оценить свою продуктивность.\",\"generated_as_correct\":false},{\"text\":\"Статус решения используется для классификации типов заданий в системе, показывая «Теоретическое» или «Практическое», что помогает организовать задания по категориям.\",\"generated_as_correct\":false},{\"text\":\"Статус решения указывает на уровень сложности задания, что помогает пользователю выбрать, над каким заданием работать дальше.\",\"generated_as_correct\":false}],\"question\":\"Какую роль играет статус решения для пользователя?\"},{\"answers\":[{\"text\":\"Пользователь использует статус решения, чтобы понять, правильно ли выполнено задание и нужно ли корректировать код.\",\"generated_as_correct\":true},{\"text\":\"Пользователь может использовать статус решения для оценки эффективности своего алгоритма: если статус «Решена полностью», это означает, что алгоритм оптимален и не требует улучшений.\",\"generated_as_correct\":false},{\"text\":\"Пользователь может использовать информацию о статусе решения для анализа времени выполнения программы и оптимизации её производительности.\",\"generated_as_correct\":false},{\"text\":\"Пользователь использует статус решения для сравнения своего кода с кодами других участников и копирования лучших решений.\",\"generated_as_correct\":false}],\"question\":\"Как пользователь может использовать информацию о статусе решения для улучшения своего кода или решения?\"},{\"answers\":[{\"text\":\"Вердикт по решению — это результат проверки кода, который может быть «OK» или содержать информацию об ошибке, например, «CE», «WA», «RE», «TL», «ML».\",\"generated_as_correct\":true},{\"text\":\"Вердикт по решению — это комментарий, который пользователь оставляет к своему коду, описывая логику и особенности его работы. Возможные вердикты включают «Отлично», «Нужно доработать», «Не работает».\",\"generated_as_correct\":false},{\"text\":\"Вердикт по решению — это метод анализа производительности кода, который определяет, насколько эффективно код использует ресурсы компьютера. Вердикт может быть представлен в виде графиков и таблиц, показывающих время выполнения и использование памяти.\",\"generated_as_correct\":false},{\"text\":\"Вердикт по решению — это финальная версия кода, готовая к запуску на сервере.\",\"generated_as_correct\":false}],\"question\":\"Что такое вердикт по решению в контексте проверки кода?\"},{\"answers\":[{\"text\":\"Вердикт по решению — это результат проверки кода, который может быть «OK» или указывать на ошибку, например, «CE», «WA», «RE», «TL», «ML».\",\"generated_as_correct\":true},{\"text\":\"Вердикт по решению — это оценка качества кода, которая включает в себя такие результаты, как «Отлично», «Хорошо», «Удовлетворительно», «Неудовлетворительно». Эти оценки показывают, насколько хорошо код соответствует стандартам написания.\",\"generated_as_correct\":false},{\"text\":\"Вердикт по решению — это процесс анализа данных, который используется для определения эффективности алгоритмов и принятия решений на основе полученных результатов.\",\"generated_as_correct\":false},{\"text\":\"Вердикт по решению — это комментарий к коду, который указывает на его стиль и читаемость.\",\"generated_as_correct\":false}],\"question\":\"Какие виды вердиктов по решению существуют и что они означают?\"},{\"answers\":[{\"text\":\"Вердикт по решению — это результат проверки кода, который помогает программисту выявить и исправить ошибки.\",\"generated_as_correct\":true},{\"text\":\"Вердикт по решению — это комментарий, который автоматически добавляется к коду после его написания. Он не связан с проверкой кода на соответствие требованиям задачи и не помогает выявить ошибки.\",\"generated_as_correct\":false},{\"text\":\"Вердикт по решению — это инструмент для анализа производительности кода, который показывает, насколько быстро код выполняется на разных устройствах. Он не связан с выявлением ошибок в коде.\",\"generated_as_correct\":false},{\"text\":\"Вердикт по решению — это инструкция для программиста по написанию кода, которая не связана с его проверкой на ошибки.\",\"generated_as_correct\":false}],\"question\":\"Как вердикт по решению помогает программисту в процессе разработки кода?\"}],\"StoreCardId\":null,\"numberInCourse\":\"1.2\"},{\"Name\":\"algo | 1.3 Введение\",\"Slug\":\"algo-vvedenie\",\"createdAt\":\"2024-07-03T08:26:03.434Z\",\"updatedAt\":\"2026-01-10T12:07:06.920Z\",\"publishedAt\":\"2024-07-03T08:26:04.672Z\",\"ContestURL\":null,\"Lead\":\"Перед вами хендбук по алгоритмам от авторов, увлечённых красотой и элегантностью математики.\",\"Content\":\"$5b\",\"Title\":\"Введение\",\"LikesCount\":27,\"Quiz\":[{\"answers\":[{\"text\":\"Алгоритмизация — это превращение мыслей в последовательность действий для достижения результата.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмизация — это метод создания визуальных схем, которые помогают представить структуру данных в программе.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмизация — это способ организации данных в базах данных для ускорения доступа к ним.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмизация — это процесс создания математических моделей для прогнозирования будущих событий.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритмизация?\"},{\"answers\":[{\"text\":\"Алгоритмизация позволяет структурировать подходы к решению задач в программировании, что помогает выбирать оптимальные решения.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмизация важна в программировании, потому что она позволяет автоматически генерировать код без участия программиста, что значительно ускоряет процесс разработки.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмизация играет ключевую роль в теории графов и математическом моделировании, но её значение в программировании ограничено и не имеет практического применения.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмизация нужна в программировании только для создания сложных математических моделей, не влияющих на процесс разработки ПО.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритмизация важна в программировании и разработке программного обеспечения?\"},{\"answers\":[{\"text\":\"Алгоритмы помогают структурировать и оценивать эффективность подходов к решению задач.\",\"generated_as_correct\":true},{\"text\":\"Знание алгоритмов полезно только для теоретического анализа задач и не имеет практического применения в оценке эффективности решений.\",\"generated_as_correct\":false},{\"text\":\"Знание алгоритмов помогает в создании математических моделей для прогнозирования рыночных тенденций, что не связано напрямую с оценкой эффективности подходов к решению задач.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы не влияют на оценку эффективности подходов к решению задач.\",\"generated_as_correct\":false}],\"question\":\"Как знание алгоритмов помогает оценивать эффективность различных подходов к решению задач?\"},{\"answers\":[{\"text\":\"Эффективность алгоритма — это способность решать задачу быстро и с минимальными ресурсами.\",\"generated_as_correct\":true},{\"text\":\"Эффективность алгоритма определяется исключительно количеством строк кода: чем меньше строк, тем эффективнее алгоритм.\",\"generated_as_correct\":false},{\"text\":\"Эффективность алгоритма связана с его способностью генерировать случайные числа и не зависит от времени выполнения или используемых ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Эффективность алгоритма определяется только временем его выполнения, без учёта использованных ресурсов.\",\"generated_as_correct\":false}],\"question\":\"Что такое эффективность алгоритма?\"},{\"answers\":[{\"text\":\"Эффективность алгоритма важна, так как она позволяет быстро обрабатывать большие объёмы данных с минимальными ресурсами.\",\"generated_as_correct\":true},{\"text\":\"Эффективность алгоритма важна только для сложных математических вычислений и не играет роли при обработке больших объёмов данных в других областях, таких как анализ текста или изображений.\",\"generated_as_correct\":false},{\"text\":\"Эффективность алгоритма важна для улучшения пользовательского интерфейса и повышения удобства использования программ, но не оказывает значительного влияния на обработку больших объёмов данных.\",\"generated_as_correct\":false},{\"text\":\"Эффективность алгоритма важна только при работе с ограниченными ресурсами, но не имеет значения для обработки больших объёмов данных.\",\"generated_as_correct\":false}],\"question\":\"Почему эффективность алгоритма важна при работе с большими объёмами данных?\"},{\"answers\":[{\"text\":\"Знание об эффективности алгоритма помогает оптимизировать ресурсы и ускорить выполнение программ.\",\"generated_as_correct\":true},{\"text\":\"Знание об эффективности алгоритма позволяет предсказать, сколько памяти потребуется для хранения данных, что помогает оптимизировать работу программ.\",\"generated_as_correct\":false},{\"text\":\"Знание об эффективности алгоритма полезно для улучшения пользовательского интерфейса и повышения удобства использования программ.\",\"generated_as_correct\":false},{\"text\":\"Знание об эффективности алгоритма позволяет увеличить объём используемых ресурсов в программе.\",\"generated_as_correct\":false}],\"question\":\"Как знание об эффективности алгоритма может помочь в оптимизации работы программ?\"},{\"answers\":[{\"text\":\"«Очередь (FIFO) — структура данных, где элементы обрабатываются в порядке их добавления: первый пришёл — первый вышел».\",\"generated_as_correct\":true},{\"text\":\"«Очередь (FIFO) — это структура данных, в которой элементы могут быть добавлены и удалены только с одной стороны, без учёта порядка их добавления».\",\"generated_as_correct\":false},{\"text\":\"«Очередь (FIFO) — это концепция, используемая в теории графов для определения кратчайшего пути между двумя точками».\",\"generated_as_correct\":false},{\"text\":\"«Очередь (FIFO) — структура данных, где новые элементы обрабатываются перед теми, которые были добавлены раньше».\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой структура данных «очередь» (FIFO)?\"},{\"answers\":[{\"text\":\"Принцип FIFO важен, так как обеспечивает обработку элементов очереди в порядке их добавления.\",\"generated_as_correct\":true},{\"text\":\"Принцип «первый пришёл — первый вышел» важен для работы очереди, так как он позволяет приоритетно обрабатывать наиболее важные элементы, независимо от времени их добавления.\",\"generated_as_correct\":false},{\"text\":\"Принцип «первый пришёл — первый вышел» используется в сетевых протоколах для определения приоритетности передачи данных, что не связано напрямую с работой очереди.\",\"generated_as_correct\":false},{\"text\":\"Принцип FIFO важен, потому что позволяет обрабатывать элементы очереди в обратном порядке их добавления.\",\"generated_as_correct\":false}],\"question\":\"Почему принцип «первый пришёл — первый вышел» важен для работы очереди?\"},{\"answers\":[{\"text\":\"Очередь (FIFO) используется для обработки данных в порядке их поступления в системах обслуживания клиентов и программировании.\",\"generated_as_correct\":true},{\"text\":\"Очередь (FIFO) применяется для хранения данных без учёта порядка их добавления, что особенно полезно в системах, где требуется случайный доступ к информации.\",\"generated_as_correct\":false},{\"text\":\"Очередь (FIFO) важна для организации сетевых протоколов, хотя её применение ограничено системами, где данные должны передаваться в зашифрованном виде.\",\"generated_as_correct\":false},{\"text\":\"Очередь (FIFO) нужна для обработки данных в порядке убывания их приоритета.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях или системах может быть полезно применение очереди?\"},{\"answers\":[{\"text\":\"Решение практических задач позволяет применить теорию на практике и лучше понять алгоритмы.\",\"generated_as_correct\":true},{\"text\":\"Решение практических задач полезно только для закрепления навыков работы с определёнными программами, но не влияет на понимание алгоритмов и теоретических основ.\",\"generated_as_correct\":false},{\"text\":\"Решение практических задач важно для развития коммуникативных навыков, так как требует обсуждения подходов к решению в команде.\",\"generated_as_correct\":false},{\"text\":\"Решение практических задач не влияет на закрепление знаний и понимание алгоритмов, оно нужно только для получения оценки.\",\"generated_as_correct\":false}],\"question\":\"Почему решение практических задач считается ключевым методом закрепления знаний и понимания алгоритмов?\"},{\"answers\":[{\"text\":\"Решение практических задач помогает студентам применять теорию на практике и развивать навыки анализа алгоритмов.\",\"generated_as_correct\":true},{\"text\":\"Решение практических задач по алгоритмам позволяет студентам улучшить свои навыки в области математики, но не оказывает значительного влияния на умение решать задачи и анализировать подходы.\",\"generated_as_correct\":false},{\"text\":\"Решение практических задач по алгоритмам развивает навыки работы с определёнными программными продуктами и инструментами, но не влияет на понимание алгоритмов и подходов к их решению.\",\"generated_as_correct\":false},{\"text\":\"Решение практических задач по алгоритмам улучшает только навыки программирования, не влияя на анализ и понимание алгоритмов.\",\"generated_as_correct\":false}],\"question\":\"Какие навыки могут развить студенты, регулярно решая практические задачи по алгоритмам?\"},{\"answers\":[{\"text\":\"Решение практических задач закрепляет теоретические знания и развивает навыки анализа алгоритмов.\",\"generated_as_correct\":true},{\"text\":\"Применение теоретических знаний на практике в изучении алгоритмов и программирования не имеет значения, так как всё можно выучить исключительно через чтение учебников и лекций.\",\"generated_as_correct\":false},{\"text\":\"Применение теоретических знаний на практике помогает улучшить коммуникативные навыки и умение работать в команде, что косвенно влияет на изучение алгоритмов и программирования.\",\"generated_as_correct\":false},{\"text\":\"Теоретические знания в алгоритмах и программировании лучше всего усваиваются через пассивное чтение без практики.\",\"generated_as_correct\":false}],\"question\":\"Как применение теоретических знаний на практике помогает в изучении алгоритмов и программирования?\"},{\"answers\":[{\"text\":\"Корректность алгоритма — это его способность давать правильные результаты для любых входных данных.\",\"generated_as_correct\":true},{\"text\":\"Корректность алгоритма заключается в его способности быстро обрабатывать большие объёмы данных. Это важно для повышения скорости выполнения задач.\",\"generated_as_correct\":false},{\"text\":\"Корректность алгоритма связана с его способностью адаптироваться к изменениям в окружающей среде и оптимизировать свои параметры для достижения лучших результатов.\",\"generated_as_correct\":false},{\"text\":\"Корректность алгоритма — это его способность работать быстро и эффективно при любых условиях.\",\"generated_as_correct\":false}],\"question\":\"Что подразумевается под корректностью алгоритма и почему это важно?\"},{\"answers\":[{\"text\":\"Анализ трудоёмкости помогает оценить, как алгоритм справится с большими объёмами данных и его эффективность.\",\"generated_as_correct\":true},{\"text\":\"Анализ трудоёмкости алгоритма нужен для определения количества строк кода в алгоритме и его читабельности, что помогает оценить, насколько легко его можно будет модифицировать в будущем.\",\"generated_as_correct\":false},{\"text\":\"Анализ трудоёмкости алгоритма связан с изучением его устойчивости к внешним воздействиям и способности работать в условиях ограниченного доступа к ресурсам, что важно для систем реального времени.\",\"generated_as_correct\":false},{\"text\":\"Анализ трудоёмкости нужен для определения времени, необходимого алгоритму для компиляции кода.\",\"generated_as_correct\":false}],\"question\":\"Для чего проводится анализ трудоёмкости алгоритма и как он помогает оценить его эффективность?\"},{\"answers\":[{\"text\":\"Анализ корректности гарантирует правильность алгоритма, а анализ трудоёмкости — его эффективность при обработке больших объёмов данных.\",\"generated_as_correct\":true},{\"text\":\"Анализ корректности и трудоёмкости алгоритмов заключается в определении количества строк кода и объёма памяти, необходимого для выполнения алгоритма. Это помогает выбрать алгоритм с наименьшими требованиями к ресурсам.\",\"generated_as_correct\":false},{\"text\":\"Анализ корректности и трудоёмкости алгоритмов используется для определения сложности математических моделей, лежащих в основе алгоритмов, и их применимости в различных областях науки и техники.\",\"generated_as_correct\":false},{\"text\":\"Анализ корректности показывает скорость работы алгоритма, а анализ трудоёмкости — правильность его результатов.\",\"generated_as_correct\":false}],\"question\":\"Как анализ корректности и трудоёмкости алгоритмов может быть применён на практике при выборе алгоритма для решения задачи с большими объёмами данных?\"}],\"StoreCardId\":null,\"numberInCourse\":\"1.3\"},{\"Name\":\"algo | 1.4 Алгоритмы и сложность\",\"Slug\":\"algoritmy-i-slozhnost\",\"createdAt\":\"2024-07-03T08:26:55.082Z\",\"updatedAt\":\"2026-01-10T12:07:07.051Z\",\"publishedAt\":\"2024-07-03T08:26:56.328Z\",\"ContestURL\":null,\"Lead\":\"Для анализа алгоритма необходимо ответить на два важных вопроса: «Правильно ли он работает?» и «Сколько времени занимает его выполнение?». В этом параграфе мы познакомимся с характеристиками алгоритмов и задач, которые они решают.\",\"Content\":\"$5c\",\"Title\":\"Алгоритмы и сложность\",\"LikesCount\":17,\"Quiz\":[{\"answers\":[{\"text\":\"Алгоритм — это последовательность шагов для решения задачи.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм — это математическая формула, используемая для вычисления определённых значений без необходимости выполнения последовательных шагов.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм — это термин, используемый в программировании для описания структуры данных, которая хранит информацию о состоянии системы.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм — это метод случайного подбора решений для неопределённых задач.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритм и для чего он нужен?\"},{\"answers\":[{\"text\":\"Точная формулировка алгоритма нужна для однозначной интерпретации и правильного выполнения.\",\"generated_as_correct\":true},{\"text\":\"Точная формулировка алгоритма важна, поскольку она позволяет алгоритму самостоятельно выбирать наиболее оптимальные методы решения задачи в зависимости от входных данных.\",\"generated_as_correct\":false},{\"text\":\"Точная формулировка алгоритма важна для его успешного применения в различных областях, таких как теория графов и криптография, где требуется высокая степень формализации и строгости.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм должен быть сформулирован расплывчато, чтобы его можно было применять для решения широкого круга задач без конкретизации.\",\"generated_as_correct\":false}],\"question\":\"Почему важно, чтобы алгоритм был точно сформулирован?\"},{\"answers\":[{\"text\":\"Алгоритм — это последовательность шагов для преобразования ввода в вывод.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм используется для случайного преобразования данных без чёткой последовательности указаний, что позволяет получить различные результаты при одном и том же вводе.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм применяется для создания визуальных представлений данных, таких как графики и диаграммы, что помогает в анализе и интерпретации информации.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм — это метод случайного подбора решений для задач без чёткой структуры.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать алгоритм для преобразования ввода в вывод в различных задачах?\"},{\"answers\":[{\"text\":\"Псевдокод — это способ описания алгоритмов, игнорирующий детали языков программирования.\",\"generated_as_correct\":true},{\"text\":\"Псевдокод — это специальный вид комментариев в коде программы, который помогает другим разработчикам понять структуру и логику программы, но не влияет на её выполнение.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод — это метод шифрования данных, который используется для защиты информации при передаче по сети. Он не имеет отношения к описанию алгоритмов или программированию.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод — это язык программирования, используемый для создания мобильных приложений.\",\"generated_as_correct\":false}],\"question\":\"Что такое псевдокод и для чего он используется разработчиками?\"},{\"answers\":[{\"text\":\"Псевдокод описывает алгоритмы, игнорируя детали, необходимые в языках программирования.\",\"generated_as_correct\":true},{\"text\":\"Псевдокод — это неформализованный набор инструкций, похожий на естественные языки, который не имеет структуры и не позволяет понять логику работы алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод используется для создания визуальных схем алгоритмов и не имеет отношения к языкам программирования, так как представляет собой графический способ описания процессов.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод требует строгого соблюдения синтаксических правил, как и языки программирования.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается основное отличие псевдокода от языков программирования?\"},{\"answers\":[{\"text\":\"Псевдокод помогает объяснить алгоритм, представляя его в виде упрощённой последовательности шагов.\",\"generated_as_correct\":true},{\"text\":\"Псевдокод служит для объяснения работы алгоритма, однако он представляет собой набор математических формул, которые сложно интерпретировать без глубоких знаний в области математики.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод используется в качестве инструмента для тестирования алгоритмов на различных языках программирования перед их реализацией в коде.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод используется для создания готовых программ, которые можно сразу запустить на компьютере.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить псевдокод для объяснения работы алгоритма другим людям?\"},{\"answers\":[{\"text\":\"Задача — это класс возможных входных данных, экземпляр задачи — конкретный ввод этого класса.\",\"generated_as_correct\":true},{\"text\":\"Задача и экземпляр задачи — это одно и то же, просто разные названия для одного понятия, связанного с вводом данных.\",\"generated_as_correct\":false},{\"text\":\"Задача — это математическое уравнение, а экземпляр задачи — это решение этого уравнения.\",\"generated_as_correct\":false},{\"text\":\"Задача — это конкретный ввод данных, экземпляр задачи — общий класс таких вводов.\",\"generated_as_correct\":false}],\"question\":\"Что такое задача и чем она отличается от экземпляра задачи?\"},{\"answers\":[{\"text\":\"Задача — класс возможных входных данных, экземпляр задачи — конкретный ввод этого класса.\",\"generated_as_correct\":true},{\"text\":\"Задача — это общий алгоритм решения, а экземпляр задачи — это набор правил, по которым работает алгоритм.\",\"generated_as_correct\":false},{\"text\":\"Различение задачи и экземпляра задачи важно для разработки алгоритмов машинного обучения, так как это помогает определить, какие данные использовать для обучения модели.\",\"generated_as_correct\":false},{\"text\":\"Задача и экземпляр задачи — синонимы, обозначающие одно и то же.\",\"generated_as_correct\":false}],\"question\":\"Почему важно различать задачу и экземпляр задачи при анализе проблем?\"},{\"answers\":[{\"text\":\"Задача описывает класс возможных входных данных, а экземпляр задачи — конкретный ввод такого класса. Это помогает в анализе и решении практических задач, например, в финансах.\",\"generated_as_correct\":true},{\"text\":\"Понимание различия между задачей и экземпляром задачи не имеет практического применения в финансах, так как эти понятия описывают только теоретические аспекты без связи с реальными ситуациями.\",\"generated_as_correct\":false},{\"text\":\"Понимание различия между задачей и экземпляром задачи может быть полезно для разработки новых финансовых продуктов, но это не связано напрямую с решением практических задач в области финансов.\",\"generated_as_correct\":false},{\"text\":\"Задача и экземпляр задачи — это одно и то же, и понимание этого не помогает в решении практических задач в финансах.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать понимание различия между задачей и экземпляром задачи для решения практических задач, например, в области финансов?\"},{\"answers\":[{\"text\":\"Корректный алгоритм всегда выдаёт правильный результат для любого ввода.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм является корректным, если его выполнение завершается за определённое количество шагов, независимо от входных данных.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм называется корректным, если он использует минимальное количество памяти и вычислительных ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Корректный алгоритм — это алгоритм, который работает быстро и эффективно.\",\"generated_as_correct\":false}],\"question\":\"Что означает, что алгоритм является корректным?\"},{\"answers\":[{\"text\":\"Алгоритм некорректен, если есть ввод, приводящий к неправильному выводу.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм считается некорректным, если он не может обработать ввод данных в определённом формате, даже если для других форматов он работает правильно.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм может считаться некорректным, если его сложность превышает допустимые пределы или если он использует недопустимые математические операции.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм некорректен, если он не останавливается на любом вводе.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритм может считаться некорректным?\"},{\"answers\":[{\"text\":\"Алгоритм считается корректным, если на любой ввод он даёт правильный результат.\",\"generated_as_correct\":true},{\"text\":\"Определение корректности алгоритма заключается в проверке, насколько быстро алгоритм обрабатывает входные данные. Если время обработки превышает заданный порог, алгоритм считается некорректным.\",\"generated_as_correct\":false},{\"text\":\"Определение корректности алгоритма связано с анализом сложности алгоритма и его способности работать с большими объёмами данных без ошибок.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм является корректным, если он работает быстро и эффективно независимо от введённых данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать определение корректности алгоритма для анализа работы конкретного алгоритма?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма определяется количеством необходимых операций.\",\"generated_as_correct\":true},{\"text\":\"Основным критерием для описания времени выполнения алгоритма является количество строк кода в его реализации.\",\"generated_as_correct\":false},{\"text\":\"Основным критерием для описания времени выполнения алгоритма является его сложность по памяти, то есть объём памяти, который алгоритм занимает во время работы.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма зависит от скорости процессора, на котором он выполняется.\",\"generated_as_correct\":false}],\"question\":\"Что является основным критерием для описания времени выполнения алгоритма согласно данному факту?\"},{\"answers\":[{\"text\":\"Количество операций лучше для сравнения эффективности алгоритмов, так как это показатель их внутренней сложности.\",\"generated_as_correct\":true},{\"text\":\"Сравнение количества операций менее информативно, поскольку оно не учитывает скорость процессора и объём оперативной памяти, которые существенно влияют на время выполнения алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Сравнение количества операций важно для понимания алгоритмической сложности, но для практической реализации более значимо учитывать потребление памяти и удобство интеграции алгоритма в существующую систему.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения на конкретном компьютере более информативно для сравнения алгоритмов, так как учитывает реальные условия эксплуатации.\",\"generated_as_correct\":false}],\"question\":\"Почему сравнение количества операций более информативно для оценки эффективности алгоритмов, чем время их выполнения на конкретном компьютере?\"},{\"answers\":[{\"text\":\"Алгоритм с меньшим количеством операций предпочтительнее для больших значений n.\",\"generated_as_correct\":true},{\"text\":\"Знание о количестве операций помогает выбрать алгоритм с наибольшим количеством операций, так как такие алгоритмы считаются более надёжными и точными при работе с большими объёмами данных.\",\"generated_as_correct\":false},{\"text\":\"Знание о количестве операций может помочь в оптимизации памяти, необходимой для выполнения алгоритма, что косвенно влияет на выбор алгоритма для задач с большими значениями n.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм с большим количеством операций лучше подходит для задач с большими значениями n.\",\"generated_as_correct\":false}],\"question\":\"Как знание о количестве операций, необходимых алгоритму, может помочь в выборе наиболее подходящего алгоритма для решения задачи с большими значениями n?\"},{\"answers\":[{\"text\":\"Экспоненциальные алгоритмы имеют время выполнения, растущее экспоненциально с размером ввода, а полиномиальные — ограниченное полиномом.\",\"generated_as_correct\":true},{\"text\":\"Основное различие между экспоненциальными и полиномиальными алгоритмами заключается в том, что экспоненциальные алгоритмы всегда выполняются быстрее полиномиальных независимо от размера ввода.\",\"generated_as_correct\":false},{\"text\":\"Основное различие между экспоненциальными и полиномиальными алгоритмами связано с их сложностью в реализации и количеством используемых переменных, а не с временем выполнения.\",\"generated_as_correct\":false},{\"text\":\"Экспоненциальные и полиномиальные алгоритмы отличаются тем, что первые всегда эффективнее вторых независимо от размера входных данных.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается основное различие между экспоненциальными и полиномиальными алгоритмами с точки зрения времени выполнения?\"},{\"answers\":[{\"text\":\"Время выполнения экспоненциальных алгоритмов растёт экспоненциально с увеличением размера данных, что делает их неэффективными для больших объёмов.\",\"generated_as_correct\":true},{\"text\":\"Экспоненциальные алгоритмы могут быть неэффективны из-за необходимости большого объёма памяти для хранения промежуточных результатов, а не из-за времени выполнения.\",\"generated_as_correct\":false},{\"text\":\"Экспоненциальные алгоритмы неэффективны из-за сложности их реализации на современных вычислительных системах, что затрудняет их применение в реальных проектах.\",\"generated_as_correct\":false},{\"text\":\"Экспоненциальные алгоритмы неэффективны, потому что они требуют большого объёма оперативной памяти для обработки данных.\",\"generated_as_correct\":false}],\"question\":\"Почему экспоненциальные алгоритмы могут быть неэффективны при обработке больших объёмов данных?\"},{\"answers\":[{\"text\":\"Полиномиальные алгоритмы предпочтительнее для задач с большим объёмом данных, так как их время выполнения растёт предсказуемо и управляемо.\",\"generated_as_correct\":true},{\"text\":\"Знание о времени выполнения полиномиальных алгоритмов полезно только для теоретических исследований и не влияет на практическую реализацию алгоритмов для решения конкретных задач.\",\"generated_as_correct\":false},{\"text\":\"Знание о времени выполнения полиномиальных алгоритмов помогает в анализе сложности алгоритмов, но не учитывает такие факторы, как объём доступной памяти и требования к точности результатов.\",\"generated_as_correct\":false},{\"text\":\"Экспоненциальные алгоритмы более предпочтительны для решения задач с большим объёмом данных, так как они обеспечивают более быстрое выполнение по сравнению с полиномиальными алгоритмами.\",\"generated_as_correct\":false}],\"question\":\"Как знание о времени выполнения полиномиальных алгоритмов может помочь в выборе алгоритма для решения конкретной задачи?\"}],\"StoreCardId\":null,\"numberInCourse\":\"1.4\"}]},{\"id\":29,\"Name\":\"2. Основные структуры данных\",\"Articles\":[{\"Name\":\"algo | 2.1. Односвязный список\",\"Slug\":\"odnosvyaznyj-spisok\",\"createdAt\":\"2024-07-03T17:28:49.612Z\",\"updatedAt\":\"2026-01-10T12:07:07.657Z\",\"publishedAt\":\"2024-07-03T17:28:50.974Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80784/problem\",\"Lead\":null,\"Content\":\"$5d\",\"Title\":\"Односвязный список\",\"LikesCount\":28,\"Quiz\":[{\"answers\":[{\"text\":\"Односвязный список — это структура данных из узлов с элементами и ссылками на следующий узел.\",\"generated_as_correct\":true},{\"text\":\"Односвязный список — это структура данных, в которой элементы расположены в памяти последовательно, как в классическом массиве, и каждый элемент содержит ссылку на следующий.\",\"generated_as_correct\":false},{\"text\":\"Односвязный список используется для реализации алгоритмов сортировки и поиска, где данные обрабатываются в определённом порядке.\",\"generated_as_correct\":false},{\"text\":\"Односвязный список — это структура данных, где элементы связаны ссылками на предыдущие узлы.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой односвязный список?\"},{\"answers\":[{\"text\":\"Односвязный список позволяет добавлять произвольное количество элементов и доступ к ним осуществляется последовательно, в отличие от массива с последовательным расположением элементов в памяти.\",\"generated_as_correct\":true},{\"text\":\"Односвязный список отличается от классического массива тем, что в нём элементы могут быть расположены хаотично в памяти, без какой-либо последовательности, и доступ к ним осуществляется случайным образом.\",\"generated_as_correct\":false},{\"text\":\"Односвязный список и классический массив отличаются методами сортировки данных, где односвязный список использует ссылки для упорядочивания элементов, а массив — индексы.\",\"generated_as_correct\":false},{\"text\":\"Односвязный список похож на классический массив тем, что элементы в нём расположены строго последовательно в памяти.\",\"generated_as_correct\":false}],\"question\":\"Чем односвязный список отличается от классического массива?\"},{\"answers\":[{\"text\":\"Доступ к элементам в односвязном списке последовательный, через ссылки между узлами.\",\"generated_as_correct\":true},{\"text\":\"Доступ к элементам в односвязном списке происходит аналогично доступу в массиве, где каждый элемент имеет уникальный индекс.\",\"generated_as_correct\":false},{\"text\":\"Доступ к элементам в односвязном списке зависит от алгоритма сортировки, который используется для упорядочивания данных в списке.\",\"generated_as_correct\":false},{\"text\":\"Доступ к элементам в односвязном списке прямой и осуществляется по индексу.\",\"generated_as_correct\":false}],\"question\":\"Как осуществляется доступ к элементам в односвязном списке?\"},{\"answers\":[{\"text\":\"Голова односвязного списка — это первый элемент списка.\",\"generated_as_correct\":true},{\"text\":\"Голова односвязного списка — это специальный указатель, который хранит адрес последнего элемента списка.\",\"generated_as_correct\":false},{\"text\":\"Голова односвязного списка связана с алгоритмами сортировки и используется для определения порядка элементов в списке.\",\"generated_as_correct\":false},{\"text\":\"Голова односвязного списка — это средний элемент списка.\",\"generated_as_correct\":false}],\"question\":\"Что такое голова в контексте односвязного списка?\"},{\"answers\":[{\"text\":\"Голова списка — это первый элемент, с которого начинается доступ к элементам односвязного списка.\",\"generated_as_correct\":true},{\"text\":\"Голова списка — это специальный указатель, который хранит адрес последнего элемента в односвязном списке.\",\"generated_as_correct\":false},{\"text\":\"Голова списка используется для определения размера списка и не имеет отношения к доступу к элементам.\",\"generated_as_correct\":false},{\"text\":\"Голова списка — это произвольный элемент, который выбирается для начала доступа к элементам списка.\",\"generated_as_correct\":false}],\"question\":\"Почему голова списка считается начальной точкой для доступа к его элементам?\"},{\"answers\":[{\"text\":\"Голова списка — это первый элемент, с которого начинается доступ к остальным элементам.\",\"generated_as_correct\":true},{\"text\":\"Голова списка — это специальный указатель, который хранит информацию обо всех элементах списка и позволяет выполнять операции над ними без прямого доступа к элементам.\",\"generated_as_correct\":false},{\"text\":\"Голова списка важна для определения размера списка и расчёта среднего значения элементов в нём.\",\"generated_as_correct\":false},{\"text\":\"Голова списка используется для хранения информации о количестве элементов в списке.\",\"generated_as_correct\":false}],\"question\":\"Как использование головы списка влияет на выполнение операций над элементами односвязного списка?\"},{\"answers\":[{\"text\":\"Хвост односвязного списка — это последний элемент с null-ссылкой.\",\"generated_as_correct\":true},{\"text\":\"Хвост (tail) односвязного списка — это любой элемент в середине списка, который имеет null-значение в качестве ссылки.\",\"generated_as_correct\":false},{\"text\":\"Хвост (tail) односвязного списка связан с операциями вставки элементов в начало списка и используется для организации циклических структур данных.\",\"generated_as_correct\":false},{\"text\":\"Хвост односвязного списка — это элемент, который указывает на следующий элемент в списке.\",\"generated_as_correct\":false}],\"question\":\"Что такое хвост (tail) односвязного списка?\"},{\"answers\":[{\"text\":\"Хвост односвязного списка содержит null-значение, чтобы указать на его окончание.\",\"generated_as_correct\":true},{\"text\":\"Хвост односвязного списка содержит null-значение в качестве ссылки, чтобы обозначить, что список является циклическим и замыкается сам на себя.\",\"generated_as_correct\":false},{\"text\":\"Хвост односвязного списка содержит null-значение, потому что это необходимо для реализации алгоритмов сортировки в списке.\",\"generated_as_correct\":false},{\"text\":\"Хвост односвязного списка содержит null-значение, чтобы обозначить начало списка.\",\"generated_as_correct\":false}],\"question\":\"Почему хвост односвязного списка содержит null-значение в качестве ссылки?\"},{\"answers\":[{\"text\":\"Хвост односвязного списка указывает на конец списка и используется при добавлении элементов в его конец.\",\"generated_as_correct\":true},{\"text\":\"Хвост односвязного списка используется для хранения дополнительных данных, не связанных с элементами списка, и не влияет на процесс добавления новых элементов.\",\"generated_as_correct\":false},{\"text\":\"Хвост односвязного списка служит для определения его длины и не участвует в процессе добавления новых элементов.\",\"generated_as_correct\":false},{\"text\":\"Хвост односвязного списка содержит ссылку на следующий элемент и используется при удалении элементов из списка.\",\"generated_as_correct\":false}],\"question\":\"Как используется хвост односвязного списка при добавлении новых элементов?\"},{\"answers\":[{\"text\":\"Добавление элемента в односвязный список — это создание узла и его вставка в начало, конец или после определённого элемента списка.\",\"generated_as_correct\":true},{\"text\":\"Операция добавления элемента в односвязный список осуществляется путём вставки элемента в произвольное место списка без учёта его структуры, что требует перестроения всего списка.\",\"generated_as_correct\":false},{\"text\":\"Операция добавления элемента в односвязный список связана с изменением указателей в двусвязном списке и требует пересчёта индексов всех элементов.\",\"generated_as_correct\":false},{\"text\":\"Добавление элемента в односвязный список возможно только путём вставки в середину списка.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция добавления элемента в односвязный список и где она может быть выполнена?\"},{\"answers\":[{\"text\":\"Сложность добавления элемента в начало или конец односвязного списка — O(1), так как операция выполняется за фиксированное время.\",\"generated_as_correct\":true},{\"text\":\"Сложность операции добавления элемента в начало или конец односвязного списка составляет O(1) из-за необходимости сортировки элементов списка после вставки нового элемента.\",\"generated_as_correct\":false},{\"text\":\"Сложность операции добавления элемента в односвязный список зависит от алгоритма поиска элемента в списке, который используется перед вставкой.\",\"generated_as_correct\":false},{\"text\":\"Сложность добавления элемента в начало или конец односвязного списка — O(n), поскольку требуется просмотреть весь список.\",\"generated_as_correct\":false}],\"question\":\"Почему сложность операции добавления элемента в начало или конец односвязного списка составляет O(1)?\"},{\"answers\":[{\"text\":\"Добавление элемента в односвязный список включает создание узла и его связывание со списком, сложность добавления в начало или конец — O(1).\",\"generated_as_correct\":true},{\"text\":\"Добавление элемента в односвязный список требует полного перебора всех элементов списка для определения позиции вставки, что делает операцию сложной и времязатратной.\",\"generated_as_correct\":false},{\"text\":\"Добавление элемента в односвязный список влияет на его структуру, но для выполнения этой операции необходимо учитывать размер выделенной памяти и возможности операционной системы.\",\"generated_as_correct\":false},{\"text\":\"Добавление элемента в односвязный список всегда требует перестройки всей структуры данных, что делает операцию сложной.\",\"generated_as_correct\":false}],\"question\":\"Как процесс добавления элемента в односвязный список влияет на структуру данных и какие шаги требуются для выполнения этой операции?\"},{\"answers\":[{\"text\":\"Удаление элемента из односвязного списка требует нахождения узла и перенаправления ссылки с предыдущего элемента на следующий.\",\"generated_as_correct\":true},{\"text\":\"Операция удаления элемента из односвязного списка подразумевает удаление всех элементов после удаляемого узла, что приводит к изменению структуры списка.\",\"generated_as_correct\":false},{\"text\":\"Операция удаления элемента из односвязного списка связана с изменением значений элементов в списке и не требует перенаправления ссылок.\",\"generated_as_correct\":false},{\"text\":\"Удаление элемента из односвязного списка происходит путём изменения значения удаляемого элемента на null.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция удаления элемента из односвязного списка?\"},{\"answers\":[{\"text\":\"Сложность удаления элемента из односвязного списка — O(n), так как нужно найти элемент, пройдя по списку.\",\"generated_as_correct\":true},{\"text\":\"Сложность операции удаления элемента из односвязного списка составляет O(n), так как для удаления элемента необходимо выполнить n операций независимо от его положения в списке.\",\"generated_as_correct\":false},{\"text\":\"Сложность операции удаления элемента из односвязного списка составляет O(n), потому что это связано с необходимостью перерасчёта индексов всех последующих элементов после удаления.\",\"generated_as_correct\":false},{\"text\":\"Сложность удаления элемента из односвязного списка — O(n), потому что для удаления требуется n операций независимо от положения элемента.\",\"generated_as_correct\":false}],\"question\":\"Почему сложность операции удаления элемента из односвязного списка составляет O(n)?\"},{\"answers\":[{\"text\":\"При удалении элемента из односвязного списка перенаправляют ссылку с предыдущего элемента на следующий за удаляемым.\",\"generated_as_correct\":true},{\"text\":\"При удалении элемента из односвязного списка достаточно просто удалить узел без перенаправления ссылок, и список автоматически адаптируется.\",\"generated_as_correct\":false},{\"text\":\"При удалении элемента из односвязного списка важно учитывать сложность операции, которая составляет O(1), и не требует перенаправления ссылок.\",\"generated_as_correct\":false},{\"text\":\"При удалении элемента из односвязного списка перенаправляют ссылку с следующего элемента на предыдущий.\",\"generated_as_correct\":false}],\"question\":\"Как выполняется перенаправление ссылок при удалении элемента из односвязного списка?\"},{\"answers\":[{\"text\":\"Нахождение элемента в односвязном списке — это последовательный поиск с временной сложностью O(n).\",\"generated_as_correct\":true},{\"text\":\"Операция нахождения элемента в односвязном списке предполагает использование двоичного поиска для быстрого определения позиции элемента, что делает её эффективной даже для больших списков.\",\"generated_as_correct\":false},{\"text\":\"Операция нахождения элемента в односвязном списке связана с изменением структуры данных, например, добавлением или удалением элементов, что влияет на порядок их хранения.\",\"generated_as_correct\":false},{\"text\":\"Нахождение элемента в односвязном списке выполняется за постоянное время O(1) независимо от размера списка.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция нахождения элемента в односвязном списке?\"},{\"answers\":[{\"text\":\"Сложность O(n) при поиске в односвязном списке возникает из-за необходимости последовательного сравнения всех элементов.\",\"generated_as_correct\":true},{\"text\":\"Сложность операции нахождения элемента в односвязном списке составляет O(n), так как поиск осуществляется путём случайного выбора элементов списка до нахождения нужного значения.\",\"generated_as_correct\":false},{\"text\":\"Сложность операции нахождения элемента в односвязном списке связана с количеством операций, необходимых для вставки элемента в список.\",\"generated_as_correct\":false},{\"text\":\"Сложность O(n) при поиске в односвязном списке обусловлена использованием хеш-таблицы для хранения элементов списка.\",\"generated_as_correct\":false}],\"question\":\"Почему сложность операции нахождения элемента в односвязном списке составляет O(n)?\"},{\"answers\":[{\"text\":\"Операция нахождения элемента в односвязном списке нужна для поиска значения в последовательной структуре данных.\",\"generated_as_correct\":true},{\"text\":\"Операция нахождения элемента в односвязном списке используется для сортировки элементов в списке по определённому критерию, что позволяет эффективно упорядочивать данные.\",\"generated_as_correct\":false},{\"text\":\"Операция нахождения элемента в односвязном списке тесно связана с алгоритмами шифрования и может быть использована для создания криптографических ключей.\",\"generated_as_correct\":false},{\"text\":\"Операция нахождения элемента в односвязном списке позволяет быстро получить доступ к любому элементу по индексу.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить операцию нахождения элемента в односвязном списке в практических задачах программирования?\"},{\"answers\":[{\"text\":\"Подсчёт числа элементов по условию в односвязном списке — это подсчёт элементов, удовлетворяющих условию, со сложностью O(n).\",\"generated_as_correct\":true},{\"text\":\"Операция подсчёта числа элементов по условию в односвязном списке предполагает подсчёт всех элементов в списке без учёта какого-либо условия, что выполняется за постоянное время.\",\"generated_as_correct\":false},{\"text\":\"Операция подсчёта числа элементов по условию в односвязном списке связана с определением длины списка через рекурсивную функцию без учёта каких-либо условий.\",\"generated_as_correct\":false},{\"text\":\"Подсчёт числа элементов по условию в односвязном списке — это определение общего количества элементов в списке, независимо от условий, со сложностью O(1).\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция подсчёта числа элементов по условию в односвязном списке?\"},{\"answers\":[{\"text\":\"Сложность подсчёта элементов в односвязном списке — O(n), так как нужно пройти по каждому элементу.\",\"generated_as_correct\":true},{\"text\":\"Сложность операции подсчёта числа элементов в односвязном списке составляет O(n), поскольку для этого используется специальный алгоритм, который позволяет вычислить количество элементов без необходимости проходить по всему списку.\",\"generated_as_correct\":false},{\"text\":\"Сложность операции подсчёта числа элементов в односвязном списке связана с алгоритмами сортировки, которые применяются для упорядочивания элементов перед подсчётом.\",\"generated_as_correct\":false},{\"text\":\"Сложность подсчёта элементов в односвязном списке — O(n), потому что список уже отсортирован по умолчанию.\",\"generated_as_correct\":false}],\"question\":\"Почему сложность операции подсчёта числа элементов в односвязном списке составляет O(n)?\"},{\"answers\":[{\"text\":\"Подсчёт числа элементов по условию в односвязном списке используется для определения количества элементов, соответствующих заданному критерию.\",\"generated_as_correct\":true},{\"text\":\"Операция подсчёта числа элементов по условию применяется исключительно для определения длины списка, не учитывая при этом никаких дополнительных критериев или свойств элементов.\",\"generated_as_correct\":false},{\"text\":\"Операция подсчёта числа элементов по условию может быть использована для оптимизации алгоритмов сортировки, хотя на самом деле её применение в этом контексте не так распространено.\",\"generated_as_correct\":false},{\"text\":\"Подсчёт числа элементов по условию применяется для определения максимального значения в списке.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить операцию подсчёта числа элементов по условию в реальных задачах программирования?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.1\"},{\"Name\":\"algo | 2.2. Множество\",\"Slug\":\"mnozhestvo\",\"createdAt\":\"2024-07-03T17:29:39.827Z\",\"updatedAt\":\"2026-01-10T12:07:07.392Z\",\"publishedAt\":\"2024-07-03T17:29:41.019Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80785/problem\",\"Lead\":null,\"Content\":\"$5e\",\"Title\":\"Множество\",\"LikesCount\":26,\"Quiz\":[{\"answers\":[{\"text\":\"Множество — это контейнер для уникальных элементов без определённого порядка.\",\"generated_as_correct\":true},{\"text\":\"Множество в программировании представляет собой массив, элементы которого автоматически сортируются по возрастанию.\",\"generated_as_correct\":false},{\"text\":\"Множество в программировании связано с концепцией графов и используется для представления связей между узлами.\",\"generated_as_correct\":false},{\"text\":\"Множество — это структура данных для хранения повторяющихся элементов в определённом порядке.\",\"generated_as_correct\":false}],\"question\":\"Что такое множество в контексте программирования?\"},{\"answers\":[{\"text\":\"Множество содержит только уникальные элементы, без повторений.\",\"generated_as_correct\":true},{\"text\":\"Множество позволяет хранить повторяющиеся элементы, однако система автоматически удаляет все дубликаты при добавлении новых элементов.\",\"generated_as_correct\":false},{\"text\":\"Множества используются для хранения данных в виде пар «ключ-значение», где ключ должен быть уникальным.\",\"generated_as_correct\":false},{\"text\":\"В множествах могут быть повторяющиеся элементы, если они расположены в определённом порядке.\",\"generated_as_correct\":false}],\"question\":\"Почему в множествах не может быть повторяющихся элементов?\"},{\"answers\":[{\"text\":\"Множества упрощают алгоритмы обработки данных за счёт хранения уникальных элементов и быстрого выполнения операций.\",\"generated_as_correct\":true},{\"text\":\"Множества замедляют обработку данных, так как требуют дополнительной памяти для хранения информации о порядке элементов и их уникальных идентификаторах.\",\"generated_as_correct\":false},{\"text\":\"Множества используются исключительно для математических вычислений и не влияют на алгоритмы обработки данных в программировании.\",\"generated_as_correct\":false},{\"text\":\"Множества увеличивают вычислительную сложность из-за необходимости сортировки элементов при каждом добавлении.\",\"generated_as_correct\":false}],\"question\":\"Как использование множеств может повлиять на алгоритмы обработки данных и вычислительную сложность операций?\"},{\"answers\":[{\"text\":\"Мультимножество позволяет хранить повторяющиеся элементы.\",\"generated_as_correct\":true},{\"text\":\"Мультимножество — это метод сортировки данных, который позволяет упорядочивать элементы по частоте их повторения в наборе.\",\"generated_as_correct\":false},{\"text\":\"Мультимножество — это концепция в теории графов, используемая для определения количества рёбер между вершинами.\",\"generated_as_correct\":false},{\"text\":\"Мультимножество — это то же самое, что и множество, где все элементы уникальны.\",\"generated_as_correct\":false}],\"question\":\"Что такое мультимножество?\"},{\"answers\":[{\"text\":\"Мультимножество позволяет хранить повторяющиеся элементы, в отличие от множества.\",\"generated_as_correct\":true},{\"text\":\"Мультимножество отличается от обычного множества тем, что оно позволяет хранить только уникальные элементы, но в определённом порядке.\",\"generated_as_correct\":false},{\"text\":\"Мультимножество и обычное множество различаются по способам их визуализации в графовых структурах.\",\"generated_as_correct\":false},{\"text\":\"Мультимножество требует, чтобы все его элементы были уникальными, как и в обычном множестве.\",\"generated_as_correct\":false}],\"question\":\"Чем мультимножество отличается от обычного множества?\"},{\"answers\":[{\"text\":\"Мультимножество используют для хранения повторяющихся элементов данных.\",\"generated_as_correct\":true},{\"text\":\"Мультимножество целесообразно применять в ситуациях, когда требуется строго контролировать порядок элементов в структуре данных.\",\"generated_as_correct\":false},{\"text\":\"Мультимножество используется для оптимизации доступа к элементам по индексу в задачах, где важна скорость извлечения данных.\",\"generated_as_correct\":false},{\"text\":\"Мультимножество применяют для хранения уникальных элементов данных.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть полезно использовать мультимножество вместо других структур данных?\"},{\"answers\":[{\"text\":\"Упорядоченное множество — это множество с определённым порядком элементов.\",\"generated_as_correct\":true},{\"text\":\"Упорядоченное множество — это множество, в котором элементы расположены в алфавитном порядке, независимо от их типа или значения.\",\"generated_as_correct\":false},{\"text\":\"Упорядоченное множество — это концепция, используемая в теории графов для описания связей между узлами в графе.\",\"generated_as_correct\":false},{\"text\":\"Упорядоченное множество — это множество, где элементы расположены без какого-либо порядка.\",\"generated_as_correct\":false}],\"question\":\"Что такое упорядоченное множество?\"},{\"answers\":[{\"text\":\"Бинарное дерево поиска обеспечивает эффективное выполнение операций с упорядоченными множествами благодаря логарифмической сложности.\",\"generated_as_correct\":true},{\"text\":\"Бинарное дерево поиска эффективно для работы с неупорядоченными множествами, так как его структура позволяет быстро сортировать элементы при добавлении.\",\"generated_as_correct\":false},{\"text\":\"Бинарное дерево поиска используется для визуализации иерархических данных и не имеет прямого отношения к эффективности работы с упорядоченными множествами.\",\"generated_as_correct\":false},{\"text\":\"Бинарное дерево поиска неэффективно для работы с упорядоченными множествами из-за высокой сложности операций.\",\"generated_as_correct\":false}],\"question\":\"Почему использование бинарного дерева поиска эффективно для работы с упорядоченными множествами?\"},{\"answers\":[{\"text\":\"Упорядоченное множество ускоряет поиск, добавление и удаление элементов благодаря использованию структур данных с логарифмической сложностью.\",\"generated_as_correct\":true},{\"text\":\"Упорядоченное множество используется исключительно для хранения данных в определённом порядке и не влияет на скорость выполнения операций поиска, добавления и удаления элементов.\",\"generated_as_correct\":false},{\"text\":\"Упорядоченное множество применяется для сортировки данных в базах данных, но не оказывает влияния на оптимизацию операций поиска, добавления и удаления элементов.\",\"generated_as_correct\":false},{\"text\":\"Упорядоченное множество не влияет на скорость операций поиска, добавления и удаления элементов.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить упорядоченное множество для оптимизации операций поиска, добавления и удаления элементов?\"},{\"answers\":[{\"text\":\"Неупорядоченное множество — это множество без определённого порядка элементов.\",\"generated_as_correct\":true},{\"text\":\"Неупорядоченное множество — это множество, где элементы упорядочены по определённому ключу, что позволяет быстро выполнять операции поиска, но не гарантирует постоянную сложность для добавления и удаления.\",\"generated_as_correct\":false},{\"text\":\"Неупорядоченное множество — это концепция, используемая в теории графов для описания связей между узлами без учёта их последовательности.\",\"generated_as_correct\":false},{\"text\":\"Неупорядоченное множество — это множество, где элементы следуют друг за другом в определённой последовательности.\",\"generated_as_correct\":false}],\"question\":\"Что такое неупорядоченное множество?\"},{\"answers\":[{\"text\":\"Неупорядоченное множество не определяет порядок элементов, что обеспечивает эффективную реализацию с помощью хэш-таблиц.\",\"generated_as_correct\":true},{\"text\":\"Неупорядоченное множество — это множество, в котором элементы расположены в случайном порядке, который меняется каждый раз при выполнении операций добавления или удаления.\",\"generated_as_correct\":false},{\"text\":\"Неупорядоченное множество отличается от упорядоченного тем, что в нём нельзя использовать методы сортировки, так как они неприменимы к структурам данных, основанным на связных списках.\",\"generated_as_correct\":false},{\"text\":\"Неупорядоченное множество не имеет определённого порядка элементов, потому что его реализация основана на связных списках.\",\"generated_as_correct\":false}],\"question\":\"Почему в неупорядоченном множестве элементы не имеют определённого порядка?\"},{\"answers\":[{\"text\":\"Хэш-таблицы обеспечивают постоянную сложность операций с элементами в неупорядоченном множестве.\",\"generated_as_correct\":true},{\"text\":\"Использование хэш-таблиц в неупорядоченном множестве позволяет сортировать элементы по определённому ключу, что ускоряет операции поиска, но замедляет добавление и удаление элементов.\",\"generated_as_correct\":false},{\"text\":\"Использование хэш-таблиц в неупорядоченном множестве влияет на распределение памяти и может привести к фрагментации, что косвенно влияет на производительность операций с элементами.\",\"generated_as_correct\":false},{\"text\":\"Хэш-таблицы замедляют операции добавления и удаления элементов в неупорядоченном множестве из-за необходимости поддержания порядка.\",\"generated_as_correct\":false}],\"question\":\"Как использование хэш-таблиц влияет на операции с элементами в неупорядоченном множестве?\"},{\"answers\":[{\"text\":\"Добавление элемента во множество — это включение нового элемента в структуру данных, сложность которого зависит от типа множества.\",\"generated_as_correct\":true},{\"text\":\"Операция добавления элемента во множество состоит в изменении значения уже существующего элемента в множестве. Сложность такой операции одинакова для всех типов множеств и составляет O(n).\",\"generated_as_correct\":false},{\"text\":\"Операция добавления элемента во множество связана с алгоритмами сортировки и используется для упорядочивания элементов в списке.\",\"generated_as_correct\":false},{\"text\":\"Добавление элемента во множество — это процесс удаления элемента из структуры данных.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция добавления элемента во множество?\"},{\"answers\":[{\"text\":\"Сложность добавления элемента в неупорядоченное множество — O(1), в упорядоченное — O(log n) из-за необходимости поддержания порядка.\",\"generated_as_correct\":true},{\"text\":\"Сложность операции добавления элемента выше для неупорядоченного множества по сравнению с упорядоченным, так как в неупорядоченном множестве требуется дополнительное время на поиск места для нового элемента.\",\"generated_as_correct\":false},{\"text\":\"Сложность операции добавления элемента зависит от алгоритма сортировки, используемого для упорядочения элементов в множестве, и не имеет отношения к типу множества.\",\"generated_as_correct\":false},{\"text\":\"Сложность добавления элемента одинакова для упорядоченного и неупорядоченного множеств и составляет O(n).\",\"generated_as_correct\":false}],\"question\":\"Почему сложность операции добавления элемента различается для неупорядоченного и упорядоченного множества?\"},{\"answers\":[{\"text\":\"Сложность добавления элемента во множество (O(1) для неупорядоченного, O(log n) для упорядоченного) влияет на выбор типа множества в зависимости от требований задачи.\",\"generated_as_correct\":true},{\"text\":\"Сложность операции добавления элемента во множество всегда составляет O(1), независимо от типа множества, поэтому при выборе типа множества для конкретной задачи можно не учитывать этот фактор.\",\"generated_as_correct\":false},{\"text\":\"Знание о сложности операции добавления элемента важно для понимания принципов работы алгоритмов сортировки, которые могут быть применены к элементам множества после их добавления.\",\"generated_as_correct\":false},{\"text\":\"Сложность добавления элемента во множество одинакова для всех типов множеств и не влияет на выбор типа множества для задачи.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать знание о сложности операции добавления элемента при выборе типа множества для конкретной задачи?\"},{\"answers\":[{\"text\":\"Удаление элемента из множества — это исключение элемента из структуры данных, сложность зависит от типа множества.\",\"generated_as_correct\":true},{\"text\":\"Операция удаления элемента из множества состоит в замене указанного элемента другим значением в структуре данных множества. Сложность такой операции одинакова для всех типов множеств и составляет O(n).\",\"generated_as_correct\":false},{\"text\":\"Операция удаления элемента из множества тесно связана с алгоритмами сортировки и используется для оптимизации поиска элементов в структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Удаление элемента из множества — это процесс добавления элемента в структуру данных с фиксированной сложностью O(1).\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция удаления элемента из множества?\"},{\"answers\":[{\"text\":\"Сложность удаления элемента из неупорядоченного множества — O(1), из упорядоченного — O(log n).\",\"generated_as_correct\":true},{\"text\":\"Сложность операции удаления элемента выше для неупорядоченного множества по сравнению с упорядоченным, поскольку в неупорядоченном множестве требуется дополнительное время на поиск элемента перед удалением.\",\"generated_as_correct\":false},{\"text\":\"Сложность операции удаления элемента зависит от алгоритма сортировки, используемого в множестве, а не от его упорядоченности или неупорядоченности.\",\"generated_as_correct\":false},{\"text\":\"Сложность удаления элемента одинакова для всех типов множеств и составляет O(n).\",\"generated_as_correct\":false}],\"question\":\"Почему сложность операции удаления элемента отличается для неупорядоченного и упорядоченного множества?\"},{\"answers\":[{\"text\":\"При выборе типа множества учитывают сложность удаления: O(1) для неупорядоченного и O(log n) для упорядоченного.\",\"generated_as_correct\":true},{\"text\":\"Сложность операции удаления из множества всегда составляет O(1), независимо от типа множества, поэтому при выборе типа множества для задачи этот фактор не имеет значения.\",\"generated_as_correct\":false},{\"text\":\"Знание о сложности операции удаления полезно для оптимизации алгоритмов сортировки, так как позволяет определить, какой метод удаления элементов будет наиболее эффективным в контексте сортировки данных.\",\"generated_as_correct\":false},{\"text\":\"Сложность удаления из множества не зависит от его типа и всегда составляет O(n).\",\"generated_as_correct\":false}],\"question\":\"Как можно применить знание о сложности операции удаления при выборе типа множества для конкретной задачи?\"},{\"answers\":[{\"text\":\"Операция проверки наличия элемента в множестве определяет, есть ли элемент в множестве, и её сложность зависит от типа множества.\",\"generated_as_correct\":true},{\"text\":\"Операция проверки наличия элемента в множестве заключается в подсчёте количества вхождений указанного элемента в множество. Сложность этой операции составляет O(n) для всех типов множеств.\",\"generated_as_correct\":false},{\"text\":\"Операция проверки наличия элемента в множестве тесно связана с алгоритмами сортировки и используется для определения порядка элементов в множестве.\",\"generated_as_correct\":false},{\"text\":\"Операция проверки наличия элемента в множестве определяет количество элементов в множестве и имеет сложность O(n).\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция проверки наличия элемента в множестве?\"},{\"answers\":[{\"text\":\"Сложность проверки наличия элемента в неупорядоченном множестве — O(1), в упорядоченном — O(log n) из-за различий в структуре данных.\",\"generated_as_correct\":true},{\"text\":\"Сложность операции проверки наличия элемента выше для неупорядоченного множества по сравнению с упорядоченным, потому что в неупорядоченном множестве требуется перебирать все элементы, что даёт сложность O(n), в то время как для упорядоченного множества сложность составляет O(1).\",\"generated_as_correct\":false},{\"text\":\"Сложность операции проверки наличия элемента зависит от алгоритма сортировки, используемого для упорядочения множества, и не имеет отношения к типу множества.\",\"generated_as_correct\":false},{\"text\":\"Сложность проверки наличия элемента одинакова для обоих типов множеств и составляет O(n).\",\"generated_as_correct\":false}],\"question\":\"Почему сложность операции проверки наличия элемента отличается для неупорядоченного и упорядоченного множества?\"},{\"answers\":[{\"text\":\"При выборе структуры данных учитывают сложность проверки наличия элемента: O(1) для неупорядоченного множества на хэш-таблицах и O(log n) для упорядоченного.\",\"generated_as_correct\":true},{\"text\":\"Знание о сложности операции проверки наличия элемента в множестве важно только для теоретических исследований и не имеет практического применения при выборе структуры данных.\",\"generated_as_correct\":false},{\"text\":\"Знание о сложности операции проверки наличия элемента в множестве полезно для понимания принципов работы алгоритмов сортировки, но не влияет на выбор структуры данных.\",\"generated_as_correct\":false},{\"text\":\"Сложность проверки наличия элемента одинакова для всех структур данных и не влияет на их выбор.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать знание о сложности операции проверки наличия элемента в множестве при выборе структуры данных для конкретной задачи?\"},{\"answers\":[{\"text\":\"Объединение множеств — это создание нового множества из всех уникальных элементов двух множеств.\",\"generated_as_correct\":true},{\"text\":\"Объединение множеств — это процесс, при котором элементы одного множества заменяются элементами другого множества, создавая новое множество.\",\"generated_as_correct\":false},{\"text\":\"Объединение множеств связано с теорией графов и используется для определения связей между элементами в различных графах.\",\"generated_as_correct\":false},{\"text\":\"Объединение множеств — это выборка общих элементов из двух множеств.\",\"generated_as_correct\":false}],\"question\":\"Что такое объединение множеств?\"},{\"answers\":[{\"text\":\"Объединение множеств исключает повторения элементов, так как включает только уникальные элементы.\",\"generated_as_correct\":true},{\"text\":\"Объединение множеств приводит к созданию нового множества, в котором элементы из исходных множеств могут повторяться, если они встречаются в обоих исходных множествах.\",\"generated_as_correct\":false},{\"text\":\"Объединение множеств связано с теорией вероятностей и используется для определения вероятности наступления событий, которые могут происходить одновременно.\",\"generated_as_correct\":false},{\"text\":\"Объединение множеств допускает повторения элементов из исходных множеств.\",\"generated_as_correct\":false}],\"question\":\"Почему в результате объединения множеств не могут быть повторения элементов?\"},{\"answers\":[{\"text\":\"Объединение множеств объединяет данные из двух списков в одно множество с уникальными элементами.\",\"generated_as_correct\":true},{\"text\":\"Операция объединения множеств предполагает выбор только уникальных элементов из первого списка и игнорирование всех элементов из второго списка, что приводит к созданию нового множества, содержащего только часть исходных данных.\",\"generated_as_correct\":false},{\"text\":\"Операция объединения множеств используется для определения пересечений между двумя списками, что помогает выявить общие элементы и их количество в каждом из исходных множеств.\",\"generated_as_correct\":false},{\"text\":\"Объединение множеств создаёт новый список, включающий все элементы из обоих исходных списков, включая повторения.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить операцию объединения множеств для решения задачи по объединению данных из двух списков?\"},{\"answers\":[{\"text\":\"Пересечение множеств — это поиск общих элементов двух множеств.\",\"generated_as_correct\":true},{\"text\":\"Пересечение множеств — это операция определения уникальных элементов в каждом множестве, которые не повторяются в другом множестве.\",\"generated_as_correct\":false},{\"text\":\"Пересечение множеств связано с определением мощности множеств и вычислением количества элементов в каждом из них.\",\"generated_as_correct\":false},{\"text\":\"Пересечение множеств — это объединение всех элементов из разных множеств.\",\"generated_as_correct\":false}],\"question\":\"Что такое пересечение множеств?\"},{\"answers\":[{\"text\":\"Пересечение множеств выявляет общие элементы двух множеств.\",\"generated_as_correct\":true},{\"text\":\"Пересечение множеств — это операция, в результате которой формируется новое множество, содержащее уникальные элементы, которые есть только в одном из двух множеств.\",\"generated_as_correct\":false},{\"text\":\"Пересечение множеств связано с теорией вероятности и используется для определения возможных исходов событий.\",\"generated_as_correct\":false},{\"text\":\"Пересечение множеств создаёт множество, включающее все элементы из обоих множеств без исключения.\",\"generated_as_correct\":false}],\"question\":\"Почему в результате пересечения множеств могут получиться только те элементы, которые есть в обоих множествах?\"},{\"answers\":[{\"text\":\"Пересечение множеств выявляет общие элементы двух множеств.\",\"generated_as_correct\":true},{\"text\":\"Пересечение множеств помогает найти все возможные комбинации элементов из двух групп, объединяя их независимо от наличия в обоих множествах.\",\"generated_as_correct\":false},{\"text\":\"Пересечение множеств применяется для расчёта количества элементов в объединении двух множеств, не учитывая их общие элементы.\",\"generated_as_correct\":false},{\"text\":\"Пересечение множеств определяет уникальные элементы каждого из двух множеств.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить операцию пересечения множеств для решения задачи по определению общих свойств двух групп объектов?\"},{\"answers\":[{\"text\":\"Разность множеств — это множество элементов, уникальных для первого множества.\",\"generated_as_correct\":true},{\"text\":\"Разность множеств — это количество элементов, на которое одно множество больше другого.\",\"generated_as_correct\":false},{\"text\":\"Разность множеств связана с теорией графов и используется для определения связей между элементами в различных графах.\",\"generated_as_correct\":false},{\"text\":\"Разность множеств — это пересечение двух множеств.\",\"generated_as_correct\":false}],\"question\":\"Что такое разность множеств?\"},{\"answers\":[{\"text\":\"Разность множеств выделяет элементы, уникальные для первого множества и отсутствующие во втором.\",\"generated_as_correct\":true},{\"text\":\"Операция разности множеств применяется для объединения элементов двух множеств, что помогает выявить все возможные элементы, присутствующие в любом из множеств.\",\"generated_as_correct\":false},{\"text\":\"Операция разности множеств тесно связана с теорией графов и используется для определения связности между элементами в графах.\",\"generated_as_correct\":false},{\"text\":\"Разность множеств помогает найти общие элементы, присутствующие в обоих множествах.\",\"generated_as_correct\":false}],\"question\":\"Почему операция разности множеств важна для выделения уникальных элементов?\"},{\"answers\":[{\"text\":\"Разность множеств позволяет найти уникальные элементы первого множества, отсутствующие во втором.\",\"generated_as_correct\":true},{\"text\":\"Разность множеств помогает найти общие элементы, присутствующие в обоих множествах.\",\"generated_as_correct\":false},{\"text\":\"Разность множеств тесно связана с теорией графов и используется для определения пересечений множеств.\",\"generated_as_correct\":false},{\"text\":\"Разность множеств используется для объединения элементов двух множеств.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить операцию разности множеств для решения задачи по выделению элементов, которые есть в одном множестве, но отсутствуют в другом?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.2\"},{\"Name\":\"algo | 2.3. Словарь\",\"Slug\":\"slovar\",\"createdAt\":\"2024-07-03T17:30:15.623Z\",\"updatedAt\":\"2026-01-10T12:07:08.391Z\",\"publishedAt\":\"2024-07-03T17:30:17.623Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80786/problem\",\"Lead\":null,\"Content\":\"$5f\",\"Title\":\"Словарь\",\"LikesCount\":23,\"Quiz\":[{\"answers\":[{\"text\":\"словарь — это структура данных для хранения пар «ключ — значение» с уникальным ключом.\",\"generated_as_correct\":true},{\"text\":\"словарь — это структура данных, которая хранит только текстовые данные в виде списка, где каждый элемент имеет свой порядковый номер.\",\"generated_as_correct\":false},{\"text\":\"словарь — это инструмент для работы с текстовыми данными, который используется для поиска синонимов и определения значений слов.\",\"generated_as_correct\":false},{\"text\":\"словарь — это упорядоченная структура данных для хранения списков.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой структура данных «словарь»?\"},{\"answers\":[{\"text\":\"«Ключ в словаре должен быть уникальным для однозначного доступа к значению».\",\"generated_as_correct\":true},{\"text\":\"«Уникальность ключей в словаре важна для того, чтобы обеспечить упорядоченное хранение данных, так как ключи располагаются в алфавитном порядке».\",\"generated_as_correct\":false},{\"text\":\"«Уникальность ключа в словаре важна для обеспечения безопасности данных, поскольку это предотвращает несанкционированный доступ к информации».\",\"generated_as_correct\":false},{\"text\":\"«Ключ в словаре может повторяться, чтобы хранить несколько значений».\",\"generated_as_correct\":false}],\"question\":\"Почему в словаре ключ должен быть уникальным?\"},{\"answers\":[{\"text\":\"словари позволяют хранить пары «ключ — значение» и обеспечивают быстрый доступ к данным по ключу.\",\"generated_as_correct\":true},{\"text\":\"словари — это упорядоченная структура данных, в которой элементы хранятся в виде пар «ключ — значение», и доступ к ним возможен только по порядковому номеру ключа.\",\"generated_as_correct\":false},{\"text\":\"словари используются для сортировки данных по алфавиту и обеспечивают быстрый поиск по первым буквам ключей.\",\"generated_as_correct\":false},{\"text\":\"словари позволяют хранить только текстовые данные и обеспечивают доступ к ним по индексу.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать словари для организации и доступа к данным?\"},{\"answers\":[{\"text\":\"Мультисловарь (multimap) — структура данных, позволяющая хранить несколько значений под одним ключом.\",\"generated_as_correct\":true},{\"text\":\"Мультисловарь (multimap) — это структура данных, которая позволяет хранить только уникальные ключи, но при этом каждому ключу соответствует множество значений.\",\"generated_as_correct\":false},{\"text\":\"Мультисловарь (multimap) — это инструмент для работы с текстовыми данными, который используется для поиска и замены определённых слов или фраз в больших объёмах текста.\",\"generated_as_correct\":false},{\"text\":\"Мультисловарь (multimap) — это словарь, в котором каждому ключу соответствует только одно значение.\",\"generated_as_correct\":false}],\"question\":\"Что такое мультисловарь (multimap)?\"},{\"answers\":[{\"text\":\"Мультисловарь позволяет хранить несколько значений под одним ключом.\",\"generated_as_correct\":true},{\"text\":\"Мультисловарь — это особый вид словаря, который автоматически удаляет повторяющиеся ключи, оставляя только уникальные значения.\",\"generated_as_correct\":false},{\"text\":\"Мультисловарь используется для создания сложных математических моделей и не имеет отношения к хранению данных в виде ключ-значение.\",\"generated_as_correct\":false},{\"text\":\"Мультисловарь отличается от стандартного словаря тем, что требует уникальные ключи для каждого значения.\",\"generated_as_correct\":false}],\"question\":\"В чём основное отличие мультисловаря от стандартного словаря?\"},{\"answers\":[{\"text\":\"Мультисловарь позволяет хранить несколько значений под одним ключом.\",\"generated_as_correct\":true},{\"text\":\"Мультисловарь применяется для сортировки данных по значению, а не по ключу, что позволяет быстро находить нужные элементы в большом объеме данных.\",\"generated_as_correct\":false},{\"text\":\"Мультисловарь используется в алгоритмах машинного обучения для обработки текстовых данных и извлечения ключевых слов.\",\"generated_as_correct\":false},{\"text\":\"Мультисловарь предназначен для хранения уникальных пар «ключ-значение».\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях может быть полезно использовать мультисловарь?\"},{\"answers\":[{\"text\":\"Хэш-таблица — структура данных для быстрого доступа к элементам по ключу с помощью хэш-функций.\",\"generated_as_correct\":true},{\"text\":\"Хэш-таблица — это структура данных, предназначенная для сортировки элементов по ключу, что позволяет эффективно выполнять поиск, но с асимптотической сложностью O(n).\",\"generated_as_correct\":false},{\"text\":\"Хэш-таблица используется в криптографии для шифрования данных и обеспечивает высокий уровень безопасности при передаче информации.\",\"generated_as_correct\":false},{\"text\":\"Хэш-таблица — структура данных для последовательного хранения элементов, обеспечивающая медленный доступ по индексу.\",\"generated_as_correct\":false}],\"question\":\"Что такое хэш-таблица и для чего она используется?\"},{\"answers\":[{\"text\":\"Хэш-функции преобразуют ключ в индекс, обеспечивая быстрый доступ к элементам в хэш-таблице с асимптотической сложностью O(1).\",\"generated_as_correct\":true},{\"text\":\"Хэш-функции в хэш-таблицах обеспечивают быстрый доступ к элементам за счёт сортировки данных по ключу, что позволяет мгновенно находить нужные значения.\",\"generated_as_correct\":false},{\"text\":\"Хэш-таблицы используют хэш-функции для шифрования данных, что обеспечивает высокий уровень безопасности при хранении информации.\",\"generated_as_correct\":false},{\"text\":\"Хэш-функции замедляют доступ к элементам в хэш-таблицах из-за необходимости дополнительного вычисления.\",\"generated_as_correct\":false}],\"question\":\"Почему использование хэш-функций в хэш-таблицах позволяет обеспечить быстрый доступ к элементам?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность O(1) обеспечивает быстрый доступ к данным в хэш-таблицах независимо от их объёма.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность O(1) означает, что хэш-таблицы могут обрабатывать только ограниченный объём данных, после которого производительность резко падает.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность O(1) относится к алгоритму сортировки, который используется в хэш-таблицах для упорядочивания данных, что улучшает их поиск.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность O(1) приводит к замедлению работы с данными в хэш-таблицах при увеличении их объёма.\",\"generated_as_correct\":false}],\"question\":\"Как асимптотическая сложность O(1) влияет на эффективность работы с большими объёмами данных при использовании хэш-таблиц?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность операций со словарём — это оценка времени выполнения операций в зависимости от размера данных, O(1) означает независимость от размера.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность операций со словарём — это мера сложности алгоритмов, которые используются для сортировки элементов в словаре. Сложность O(1) указывает на то, что сортировка выполняется мгновенно, независимо от размера словаря.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность операций со словарём связана с анализом стабильности алгоритмов при изменении структуры данных и не зависит от времени выполнения операций.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность операций со словарём — это количество операций, необходимых для поиска элемента в словаре, и оно всегда равно размеру словаря.\",\"generated_as_correct\":false}],\"question\":\"Что такое асимптотическая сложность операций со словарём?\"},{\"answers\":[{\"text\":\"Словари эффективны благодаря асимптотической сложности O(1), которая обеспечивает быстрое выполнение операций независимо от размера данных.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность O(1) указывает на то, что время выполнения операций со словарём зависит от сложности структуры данных, а не от её размера, что делает словари менее эффективными по сравнению с другими структурами данных.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность O(1) относится к анализу сложности алгоритмов и не имеет прямого отношения к эффективности использования словарей в программировании.\",\"generated_as_correct\":false},{\"text\":\"Словари неэффективны, потому что асимптотическая сложность O(1) ограничивает размер данных, с которыми можно работать.\",\"generated_as_correct\":false}],\"question\":\"Почему асимптотическая сложность O(1) делает словари эффективными для использования в алгоритмах?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность O(1) означает, что время выполнения операций со словарём не зависит от размера данных.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность влияет на время выполнения операций так, что при увеличении размера данных время выполнения каждой операции увеличивается пропорционально квадрату размера данных.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность определяет сложность алгоритмов сортировки, которая не связана напрямую со временем выполнения операций со словарём.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность O(log n) означает, что время выполнения операций со словарём зависит от размера данных и увеличивается с их ростом.\",\"generated_as_correct\":false}],\"question\":\"Как асимптотическая сложность влияет на время выполнения операций со словарём при увеличении размера данных?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.3\"},{\"Name\":\"algo | 2.6. Дек (deque, double-ended queue)\",\"Slug\":\"dek-(veque-double-ended-queue)\",\"createdAt\":\"2024-07-03T17:32:19.603Z\",\"updatedAt\":\"2026-01-10T12:07:07.121Z\",\"publishedAt\":\"2024-07-03T17:32:20.937Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80789/problem\",\"Lead\":null,\"Content\":\"$60\",\"Title\":\"Дек\",\"LikesCount\":23,\"Quiz\":[{\"answers\":[{\"text\":\"Дэк — это структура данных с двумя концами для добавления и удаления элементов.\",\"generated_as_correct\":true},{\"text\":\"Дэк — это структура данных, в которой элементы могут быть добавлены или удалены из любого места внутри последовательности, а не только с концов.\",\"generated_as_correct\":false},{\"text\":\"Дэк — это метод сортировки данных, который использует два указателя для перемещения элементов в массиве.\",\"generated_as_correct\":false},{\"text\":\"Дэк — это структура данных, аналогичная стеку, где элементы можно добавлять и удалять только с одного конца.\",\"generated_as_correct\":false}],\"question\":\"Что такое дэк (deque) и чем он отличается от других структур данных?\"},{\"answers\":[{\"text\":\"Дэк универсален, так как позволяет добавлять и удалять элементы с обоих концов.\",\"generated_as_correct\":true},{\"text\":\"Дэк считается универсальной структурой данных, потому что он позволяет добавлять элементы в начало и середину структуры, а удалять — только из конца, что сочетает свойства стека и очереди.\",\"generated_as_correct\":false},{\"text\":\"Дэк считается универсальной структурой данных, потому что его можно использовать для хранения данных в виде связного списка, что обеспечивает гибкость при доступе к элементам.\",\"generated_as_correct\":false},{\"text\":\"Дэк универсален, так как позволяет добавлять элементы только в начало структуры, а удалять — из конца.\",\"generated_as_correct\":false}],\"question\":\"Почему дэк считается универсальной структурой данных, сочетающей свойства стека и очереди?\"},{\"answers\":[{\"text\":\"Деку стоит использовать, когда нужно добавлять и удалять элементы как в начало, так и в конец структуры.\",\"generated_as_correct\":true},{\"text\":\"Деку следует использовать, когда необходимо строго соблюдать принцип «первым пришёл — первым вышел» или «последним пришёл — первым вышел», как в случае со стеком или очередью.\",\"generated_as_correct\":false},{\"text\":\"Деку используют для хранения данных в виде связных списков, что позволяет эффективно осуществлять поиск элементов по ключу.\",\"generated_as_correct\":false},{\"text\":\"Деку целесообразно применять, когда требуется строго упорядочивать элементы по времени их добавления.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях использование дека может быть более эффективным по сравнению со стеком или очередью?\"},{\"answers\":[{\"text\":\"Вставка элемента в дек позволяет добавлять элемент в начало или конец последовательности.\",\"generated_as_correct\":true},{\"text\":\"Операция вставки элемента в дек предполагает возможность добавления элемента в любую позицию внутри последовательности, кроме начала и конца.\",\"generated_as_correct\":false},{\"text\":\"Операция вставки элемента в дек связана с изменением порядка элементов внутри последовательности без добавления новых элементов.\",\"generated_as_correct\":false},{\"text\":\"Вставка элемента в дек возможна только в фиксированную позицию внутри последовательности.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция вставки элемента в дек?\"},{\"answers\":[{\"text\":\"Добавление элементов в начало и конец дека обеспечивает гибкое управление данными.\",\"generated_as_correct\":true},{\"text\":\"Добавление элемента в дек возможно только в середину последовательности, что делает структуру удобной для определённых алгоритмов сортировки.\",\"generated_as_correct\":false},{\"text\":\"Возможность добавления элемента в дек важна для реализации алгоритмов поиска, так как это позволяет быстрее находить нужные элементы в структуре данных.\",\"generated_as_correct\":false},{\"text\":\"Добавление элементов только в конец дека делает структуру более эффективной для хранения данных.\",\"generated_as_correct\":false}],\"question\":\"Почему возможность добавления элемента как в начало, так и в конец дека считается его важной особенностью?\"},{\"answers\":[{\"text\":\"Дек удобен для динамического добавления элементов с обеих сторон.\",\"generated_as_correct\":true},{\"text\":\"Дек применяется исключительно для добавления элементов в начало последовательности, что делает его удобным для задач с односторонним потоком данных.\",\"generated_as_correct\":false},{\"text\":\"Дек используется в алгоритмах сортировки для временного хранения промежуточных результатов, не связанных с добавлением элементов с обеих сторон.\",\"generated_as_correct\":false},{\"text\":\"Дек используется только для добавления элементов в конец последовательности.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях может быть полезно использовать дек для динамического добавления элементов с обеих сторон?\"},{\"answers\":[{\"text\":\"В дэке удаление элемента возможно с обоих концов.\",\"generated_as_correct\":true},{\"text\":\"В дэке можно удалять элементы исключительно из начала последовательности, что ограничивает его применение в алгоритмах.\",\"generated_as_correct\":false},{\"text\":\"В дэке элементы можно добавлять и извлекать, но удаление возможно только при достижении определённого размера структуры данных.\",\"generated_as_correct\":false},{\"text\":\"В дэке удаление элементов возможно только из конца последовательности.\",\"generated_as_correct\":false}],\"question\":\"Где в дэке возможно удаление элемента?\"},{\"answers\":[{\"text\":\"Дэк универсален, так как позволяет удалять элементы с обоих концов.\",\"generated_as_correct\":true},{\"text\":\"Универсальность дэка обусловлена возможностью быстрого доступа к элементам в середине последовательности, что позволяет эффективно работать с данными в центре структуры.\",\"generated_as_correct\":false},{\"text\":\"Дэки используются для хранения данных в виде связных списков, что делает их полезными для реализации стеков и очередей, но не влияет на их универсальность как инструмента.\",\"generated_as_correct\":false},{\"text\":\"Дэк считается универсальным из-за возможности добавления элементов с обоих концов, но не их удаления.\",\"generated_as_correct\":false}],\"question\":\"Почему возможность удаления элементов с обоих концов делает дэк универсальным инструментом?\"},{\"answers\":[{\"text\":\"Дэк подходит для алгоритмов обработки очередей с приоритетами и поиска.\",\"generated_as_correct\":true},{\"text\":\"Дэк с возможностью удаления элементов с обоих концов используется исключительно для хранения данных в стековой структуре.\",\"generated_as_correct\":false},{\"text\":\"Дэк полезен для реализации алгоритмов шифрования и дешифрования данных благодаря своей структуре данных.\",\"generated_as_correct\":false},{\"text\":\"Дэк используется для реализации алгоритмов сортировки пузырьком.\",\"generated_as_correct\":false}],\"question\":\"Для реализации каких алгоритмов может быть полезно использование дэка с возможностью удаления элементов с обоих концов?\"},{\"answers\":[{\"text\":\"В дэке быстрый доступ O(1) к краям, медленный O(n) к середине из-за последовательного хранения.\",\"generated_as_correct\":true},{\"text\":\"Доступ ко всем элементам в дэке, включая первый, последний и средние, выполняется за константное время O(1), так как дэк использует специальную структуру данных для быстрого доступа ко всем позициям.\",\"generated_as_correct\":false},{\"text\":\"Доступ к элементам в дэке зависит от типа данных, которые хранятся в структуре, и от алгоритмов, используемых для их обработки.\",\"generated_as_correct\":false},{\"text\":\"В дэке доступ ко всем элементам выполняется за константное время O(1).\",\"generated_as_correct\":false}],\"question\":\"Почему доступ к первому и последнему элементу в дэке выполняется за константное время O(1), а к элементам в середине — за линейное время O(n)?\"},{\"answers\":[{\"text\":\"Дэк эффективен для задач с частым доступом к первому и последнему элементам.\",\"generated_as_correct\":true},{\"text\":\"Дэк эффективен для задач, требующих быстрого доступа ко всем элементам последовательности независимо от их положения.\",\"generated_as_correct\":false},{\"text\":\"Дэк используется для хранения данных в виде связного списка, что делает его полезным в алгоритмах сортировки.\",\"generated_as_correct\":false},{\"text\":\"Дэк наиболее эффективен для быстрого доступа к элементам в середине последовательности.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях использование дэка может быть особенно эффективным благодаря его характеристикам доступа к элементам?\"},{\"answers\":[{\"text\":\"Дэк предпочтителен для задач с частым доступом к первым и последним элементам благодаря быстрому доступу O(1) к краям последовательности.\",\"generated_as_correct\":true},{\"text\":\"Дэк обеспечивает быстрый доступ ко всем элементам независимо от их положения в структуре данных, что делает его универсальным решением для большинства задач.\",\"generated_as_correct\":false},{\"text\":\"Дэк используется для хранения данных в виде связного списка, где каждый элемент связан с предыдущим и следующим, что позволяет эффективно добавлять и удалять элементы с обоих концов.\",\"generated_as_correct\":false},{\"text\":\"Дэк оптимален для задач, требующих быстрого доступа к элементам в середине последовательности.\",\"generated_as_correct\":false}],\"question\":\"Как особенности доступа к элементам в дэке влияют на выбор этой структуры данных для решения задачи?\"},{\"answers\":[{\"text\":\"Дэк можно реализовать с помощью двух стеков или двусвязного списка.\",\"generated_as_correct\":true},{\"text\":\"Структура дэк обычно реализуется с применением хэш-таблиц и деревьев, что обеспечивает быстрый доступ к элементам.\",\"generated_as_correct\":false},{\"text\":\"Структура дэк тесно связана с концепцией графов и может быть представлена в виде сети узлов, соединённых рёбрами.\",\"generated_as_correct\":false},{\"text\":\"Дэк реализуется только с использованием односвязного списка.\",\"generated_as_correct\":false}],\"question\":\"Какими способами может быть реализована структура дэк?\"},{\"answers\":[{\"text\":\"Использование двух стеков или двусвязного списка для реализации дэка обеспечивает эффективность и гибкость.\",\"generated_as_correct\":true},{\"text\":\"Реализация дэка с использованием двух стеков или двусвязного списка считается неэффективной из-за сложности управления памятью и низкой скорости выполнения операций.\",\"generated_as_correct\":false},{\"text\":\"Реализация дэка эффективна благодаря использованию хэш-таблиц, которые обеспечивают быстрый доступ к элементам по ключу.\",\"generated_as_correct\":false},{\"text\":\"Реализация дэка с помощью односвязного списка эффективнее, так как требует меньше памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему реализация дэка с использованием двух стеков или двусвязного списка считается эффективной?\"},{\"answers\":[{\"text\":\"Выбор способа реализации дэка (например, с использованием двух стеков или двусвязного списка) зависит от требований и ограничений задачи.\",\"generated_as_correct\":true},{\"text\":\"Реализация дэка всегда осуществляется через использование массива, так как это наиболее простой и эффективный способ для всех типов задач.\",\"generated_as_correct\":false},{\"text\":\"Выбор способа реализации дэка может зависеть от предпочтений программиста и используемых языков программирования, а не от требований задачи.\",\"generated_as_correct\":false},{\"text\":\"Выбор способа реализации дэка определяется исключительно скоростью выполнения операций, независимо от требований и ограничений задачи.\",\"generated_as_correct\":false}],\"question\":\"Как выбор способа реализации дэка может зависеть от требований и ограничений задачи?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.4\"},{\"Name\":\"algo | 2.4. Стек\",\"Slug\":\"stek\",\"createdAt\":\"2024-07-03T17:30:59.540Z\",\"updatedAt\":\"2026-01-10T12:07:08.456Z\",\"publishedAt\":\"2024-07-03T17:31:00.890Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80787/problem\",\"Lead\":null,\"Content\":\"$61\",\"Title\":\"Стек\",\"LikesCount\":20,\"Quiz\":[{\"answers\":[{\"text\":\"принцип LIFO — последний добавленный элемент извлекается первым.\",\"generated_as_correct\":true},{\"text\":\"принцип LIFO в контексте структуры данных стек подразумевает, что элементы добавляются в случайном порядке, а извлекаются в порядке их добавления.\",\"generated_as_correct\":false},{\"text\":\"принцип LIFO используется в алгоритмах сортировки для определения порядка сравнения элементов.\",\"generated_as_correct\":false},{\"text\":\"принцип LIFO означает, что элементы извлекаются в порядке, обратном их добавлению, но добавляются с основания стека.\",\"generated_as_correct\":false}],\"question\":\"Что означает принцип LIFO в контексте структуры данных стек?\"},{\"answers\":[{\"text\":\"Стек удобен для задач с обратной последовательностью операций благодаря принципу LIFO.\",\"generated_as_correct\":true},{\"text\":\"Стек удобен для задач, требующих обратной последовательности операций, поскольку элементы в нём автоматически сортируются по убыванию, что позволяет извлекать их в нужном порядке.\",\"generated_as_correct\":false},{\"text\":\"Стек полезен в задачах, требующих обратной последовательности операций, так как его структура похожа на очередь, где элементы обрабатываются в порядке их добавления.\",\"generated_as_correct\":false},{\"text\":\"Стек удобен для задач с прямой последовательностью операций из-за принципа FIFO.\",\"generated_as_correct\":false}],\"question\":\"Почему стек считается удобным инструментом для задач, требующих обратной последовательности операций?\"},{\"answers\":[{\"text\":\"Стек работает по принципу LIFO, где элементы добавляются и извлекаются из вершины, обеспечивая извлечение последнего добавленного элемента первым.\",\"generated_as_correct\":true},{\"text\":\"Стек используется для организации данных по принципу «первым пришёл, последним ушёл», где элементы добавляются в конец структуры, а извлекаются из начала.\",\"generated_as_correct\":false},{\"text\":\"Стек применяется для хранения данных в виде связного списка, где каждый элемент содержит ссылку на следующий элемент в последовательности.\",\"generated_as_correct\":false},{\"text\":\"Стек организует данные так, что первый добавленный элемент извлекается первым, следуя принципу FIFO.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать стек для организации данных, чтобы последний добавленный элемент был извлечён первым?\"},{\"answers\":[{\"text\":\"Принцип LIFO — последний добавленный элемент извлекается первым.\",\"generated_as_correct\":true},{\"text\":\"Принцип LIFO предполагает, что элементы в стеке извлекаются в случайном порядке, независимо от того, когда они были добавлены.\",\"generated_as_correct\":false},{\"text\":\"Принцип LIFO используется в бухгалтерском учёте для определения порядка списания товаров и не имеет отношения к работе стека в программировании.\",\"generated_as_correct\":false},{\"text\":\"Принцип LIFO означает, что элементы извлекаются из стека в порядке их добавления.\",\"generated_as_correct\":false}],\"question\":\"Что означает принцип LIFO в контексте работы стека?\"},{\"answers\":[{\"text\":\"Принцип LIFO эффективен, так как последний добавленный элемент извлекается первым, что подходит для алгоритмов с обратной последовательностью действий.\",\"generated_as_correct\":true},{\"text\":\"Принцип LIFO работает по схеме «первый пришёл — первый вышел», что позволяет использовать его для алгоритмов, где важна последовательность добавления элементов.\",\"generated_as_correct\":false},{\"text\":\"Принцип LIFO используется в бухгалтерском учёте для управления запасами и не имеет отношения к алгоритмам, требующим обратной последовательности действий.\",\"generated_as_correct\":false},{\"text\":\"Принцип LIFO неэффективен для алгоритмов, требующих обратной последовательности, потому что он извлекает элементы в порядке их добавления.\",\"generated_as_correct\":false}],\"question\":\"Почему принцип LIFO считается эффективным для реализации алгоритмов, требующих обратной последовательности действий?\"},{\"answers\":[{\"text\":\"Принцип LIFO в программировании означает, что последний добавленный вызов функции обрабатывается первым.\",\"generated_as_correct\":true},{\"text\":\"Принцип LIFO предполагает, что функции выполняются в порядке их добавления в очередь, то есть первая добавленная функция выполняется первой.\",\"generated_as_correct\":false},{\"text\":\"Принцип LIFO используется в алгоритмах сортировки для определения порядка элементов в массиве, не связан с обработкой вызовов функций.\",\"generated_as_correct\":false},{\"text\":\"Принцип LIFO означает, что функции обрабатываются в порядке их добавления, первая добавленная — выполняется первой.\",\"generated_as_correct\":false}],\"question\":\"Как принцип LIFO применяется для обработки вызовов функций в программировании?\"},{\"answers\":[{\"text\":\"стек реализуется на массиве, односвязном или двусвязном списке.\",\"generated_as_correct\":true},{\"text\":\"стек реализуется только на массивах, поскольку другие структуры данных не позволяют эффективно управлять элементами.\",\"generated_as_correct\":false},{\"text\":\"стек тесно связан с концепцией очередей и используется в алгоритмах сортировки для организации данных в определённом порядке.\",\"generated_as_correct\":false},{\"text\":\"стек может быть реализован только на односвязном списке.\",\"generated_as_correct\":false}],\"question\":\"На каких структурах данных может быть реализован стек?\"},{\"answers\":[{\"text\":\"Выбор структуры данных для стека важен из-за влияния на производительность и удобство использования, например, односвязный список эффективен для добавления и удаления элементов.\",\"generated_as_correct\":true},{\"text\":\"Выбор структуры данных для стека важен только с точки зрения удобства использования, а производительность одинакова для всех структур данных.\",\"generated_as_correct\":false},{\"text\":\"Выбор структуры данных для стека зависит от предпочтений программиста и используемых языков программирования, а не от требований к производительности или удобству использования.\",\"generated_as_correct\":false},{\"text\":\"Выбор структуры данных для стека не важен, так как реализация на любом типе данных даёт одинаковые результаты.\",\"generated_as_correct\":false}],\"question\":\"Почему выбор структуры данных для реализации стека важен и от каких факторов он зависит?\"},{\"answers\":[{\"text\":\"Реализация стека на односвязном списке позволяет эффективно добавлять и удалять элементы из вершины.\",\"generated_as_correct\":true},{\"text\":\"Реализация стека на односвязном списке требует больше памяти и времени на выполнение операций добавления и удаления элементов по сравнению с реализацией на двусвязном списке.\",\"generated_as_correct\":false},{\"text\":\"Реализация стека на односвязном списке влияет на сложность алгоритмов сортировки, так как изменение структуры данных может потребовать дополнительных операций для поддержания порядка элементов.\",\"generated_as_correct\":false},{\"text\":\"Реализация стека на односвязном списке затрудняет выполнение операций добавления и удаления элементов из середины списка.\",\"generated_as_correct\":false}],\"question\":\"Как реализация стека на односвязном списке влияет на эффективность операций добавления и удаления элементов?\"},{\"answers\":[{\"text\":\"«Основные операции со стеком: push, pop, peek, isEmpty».\",\"generated_as_correct\":true},{\"text\":\"«Основные операции со стеком включают сортировку элементов по порядку их добавления (sort), поиск элемента по значению (find), добавление элемента в конец стека (append) и удаление всех элементов сразу (clear)».\",\"generated_as_correct\":false},{\"text\":\"«Основные операции со стеком связаны с изменением структуры данных, например, объединением двух стеков в один или разбиением стека на несколько частей».\",\"generated_as_correct\":false},{\"text\":\"«Основные операции со стеком: добавление элемента в начало (prepend), удаление элемента из середины (remove), поиск элемента (search)».\",\"generated_as_correct\":false}],\"question\":\"Какие основные операции выполняются со стеком?\"},{\"answers\":[{\"text\":\"стек эффективен, так как операции push, pop, peek и isEmpty выполняются за постоянное время O(1).\",\"generated_as_correct\":true},{\"text\":\"выполнение операций push, pop, peek и isEmpty делает стек эффективным, потому что они выполняются за время O(log n), что позволяет оптимизировать работу со стеком при большом объёме данных.\",\"generated_as_correct\":false},{\"text\":\"выполнение операций push, pop, peek и isEmpty за время O(1) важно для стека, так как это влияет на сложность алгоритмов сортировки, использующих стек в качестве вспомогательной структуры данных.\",\"generated_as_correct\":false},{\"text\":\"стек эффективен, потому что операции push, pop, peek и isEmpty выполняются за время, зависящее от количества элементов в стеке.\",\"generated_as_correct\":false}],\"question\":\"Почему выполнение операций push, pop, peek и isEmpty за время O(1) делает стек эффективным инструментом?\"},{\"answers\":[{\"text\":\"Стек эффективен для задач, использующих принцип LIFO, благодаря быстрым операциям push, pop, peek и isEmpty, выполняемым за O(1).\",\"generated_as_correct\":true},{\"text\":\"Операции со стеком позволяют эффективно решать задачи, требующие доступа к элементам в случайном порядке, так как стек обеспечивает быстрый доступ к любому элементу за постоянное время O(1).\",\"generated_as_correct\":false},{\"text\":\"Операции со стеком используются в алгоритмах сортировки для организации данных в определённом порядке, что позволяет эффективно решать задачи на поиск и сравнение элементов.\",\"generated_as_correct\":false},{\"text\":\"Стек применяется для решения задач, требующих доступа к элементам в порядке «первым пришёл — первым вышел» (FIFO).\",\"generated_as_correct\":false}],\"question\":\"Как можно применить операции со стеком для решения задач?\"},{\"answers\":[{\"text\":\"Указатель на вершину стека указывает на последний добавленный элемент и смещается при операциях push и pop.\",\"generated_as_correct\":true},{\"text\":\"Указатель на вершину стека — это статичный указатель, который всегда указывает на фиксированную позицию в стеке, независимо от добавления или удаления элементов.\",\"generated_as_correct\":false},{\"text\":\"Указатель на вершину стека используется для определения размера стека и не изменяется при добавлении или удалении элементов.\",\"generated_as_correct\":false},{\"text\":\"Указатель на вершину стека всегда указывает на первый элемент стека и не меняется при добавлении новых элементов.\",\"generated_as_correct\":false}],\"question\":\"Что такое указатель на вершину стека?\"},{\"answers\":[{\"text\":\"при добавлении элемента указатель на вершину стека смещается вперёд, при удалении — назад.\",\"generated_as_correct\":true},{\"text\":\"при добавлении нового элемента указатель на вершину стека перемещается на начало стека, а при удалении элемента — на конец стека.\",\"generated_as_correct\":false},{\"text\":\"указатель на вершину стека используется для определения размера стека и не изменяется при добавлении или удалении элементов.\",\"generated_as_correct\":false},{\"text\":\"при добавлении элемента указатель на вершину стека не изменяется, при удалении смещается вперёд.\",\"generated_as_correct\":false}],\"question\":\"Как изменяется положение указателя на вершину стека при добавлении или удалении элемента?\"},{\"answers\":[{\"text\":\"Указатель на вершину стека смещается при push к следующему элементу, при pop — к предыдущему.\",\"generated_as_correct\":true},{\"text\":\"Указатель на вершину стека служит для фиксирования среднего элемента в стеке и не изменяется при выполнении операций push и pop.\",\"generated_as_correct\":false},{\"text\":\"Указатель на вершину стека используется для определения размера стека и не влияет на выполнение операций push и pop, а только предоставляет информацию о количестве элементов в стеке.\",\"generated_as_correct\":false},{\"text\":\"Указатель на вершину стека остаётся неизменным при выполнении операций push и pop.\",\"generated_as_correct\":false}],\"question\":\"Как использование указателя на вершину стека влияет на выполнение операций push и pop?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.5\"},{\"Name\":\"algo | 2.5. Очередь с приоритетом\",\"Slug\":\"ochered-s-prioritetom\",\"createdAt\":\"2024-07-03T17:31:47.120Z\",\"updatedAt\":\"2026-01-10T12:07:07.591Z\",\"publishedAt\":\"2024-07-03T17:31:48.333Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80788/problem\",\"Lead\":null,\"Content\":\"$62\",\"Title\":\"Очередь с приоритетом\",\"LikesCount\":30,\"Quiz\":[{\"answers\":[{\"text\":\"«Очередь с приоритетом — структура данных, где элементы обрабатываются в порядке убывания их приоритетов».\",\"generated_as_correct\":true},{\"text\":\"«Очередь с приоритетом — это линейная структура данных, где элементы хранятся в виде связанного списка, и доступ к ним осуществляется строго по порядку их добавления, без учёта приоритетов».\",\"generated_as_correct\":false},{\"text\":\"«Очередь с приоритетом используется в теории графов для определения кратчайшего пути между узлами и не имеет отношения к управлению элементами на основе их приоритетов».\",\"generated_as_correct\":false},{\"text\":\"«Очередь с приоритетом — это структура данных, где элементы обрабатываются строго в порядке их добавления, независимо от приоритетов».\",\"generated_as_correct\":false}],\"question\":\"Что такое очередь с приоритетом?\"},{\"answers\":[{\"text\":\"В очереди с приоритетом элемент с высшим приоритетом обрабатывается первым из-за его более высокого значения приоритета.\",\"generated_as_correct\":true},{\"text\":\"В очереди с приоритетом элемент с высшим приоритетом обрабатывается раньше остальных, поскольку система случайным образом выбирает элементы для обработки, отдавая предпочтение тем, у которых выше приоритет.\",\"generated_as_correct\":false},{\"text\":\"В очереди с приоритетом элемент с высшим приоритетом обрабатывается раньше остальных благодаря алгоритму сортировки, который используется для упорядочивания всех элементов в структуре данных независимо от их приоритета.\",\"generated_as_correct\":false},{\"text\":\"В очереди с приоритетом элемент с высшим приоритетом обрабатывается после всех остальных элементов.\",\"generated_as_correct\":false}],\"question\":\"Почему в очереди с приоритетом элемент с высшим приоритетом обрабатывается раньше остальных?\"},{\"answers\":[{\"text\":\"Очередь с приоритетом полезна в алгоритмах и системах, где задачи обрабатываются по важности, например, в планировании процессов в ОС или в алгоритмах поиска пути.\",\"generated_as_correct\":true},{\"text\":\"Очередь с приоритетом используется исключительно в системах управления базами данных для оптимизации запросов, и её применение ограничено только этой областью.\",\"generated_as_correct\":false},{\"text\":\"Очередь с приоритетом — это концепция, применяемая в теории графов для определения кратчайших путей между узлами, и она не имеет отношения к алгоритмам планирования или диспетчеризации.\",\"generated_as_correct\":false},{\"text\":\"Очередь с приоритетом используется в системах, где все задачи имеют одинаковый приоритет и обрабатываются последовательно.\",\"generated_as_correct\":false}],\"question\":\"В каких системах или алгоритмах может быть полезно применение очереди с приоритетом и почему?\"},{\"answers\":[{\"text\":\"Вставка элемента с приоритетом — это добавление элемента в очередь с учётом его приоритета.\",\"generated_as_correct\":true},{\"text\":\"Вставка элемента с приоритетом — это метод сортировки элементов в очереди по их приоритетам, при котором все элементы автоматически перемещаются в начало очереди.\",\"generated_as_correct\":false},{\"text\":\"Вставка элемента с приоритетом относится к алгоритмам шифрования данных, где приоритет определяет порядок шифрования элементов.\",\"generated_as_correct\":false},{\"text\":\"Вставка элемента с приоритетом — это перемещение элемента в конец очереди независимо от его приоритета.\",\"generated_as_correct\":false}],\"question\":\"Что такое вставка элемента с приоритетом в контексте работы с очередями?\"},{\"answers\":[{\"text\":\"Эффективность вставки в очередь с приоритетом зависит от выбранной структуры данных.\",\"generated_as_correct\":true},{\"text\":\"Реализация очереди с приоритетом ухудшает эффективность операции вставки элемента, потому что для каждого добавления требуется полный перебор всех существующих элементов.\",\"generated_as_correct\":false},{\"text\":\"Реализация очереди с приоритетом влияет на скорость доступа к элементам, но не на эффективность операции вставки, так как приоритет определяется при извлечении элемента из очереди.\",\"generated_as_correct\":false},{\"text\":\"В очереди с приоритетом вставка элемента всегда выполняется за постоянное время, независимо от структуры данных.\",\"generated_as_correct\":false}],\"question\":\"Как реализация очереди с приоритетом влияет на эффективность операции вставки элемента?\"},{\"answers\":[{\"text\":\"Использовать очередь с приоритетом полезно при динамическом добавлении элементов с учётом их приоритетов.\",\"generated_as_correct\":true},{\"text\":\"Использовать очередь с приоритетом полезно для вставки элементов в ситуациях, когда требуется добавлять элементы исключительно в конец очереди, независимо от их приоритета.\",\"generated_as_correct\":false},{\"text\":\"Использовать очередь с приоритетом полезно для сортировки элементов в алфавитном порядке, что часто применяется в системах управления базами данных.\",\"generated_as_correct\":false},{\"text\":\"Использовать очередь с приоритетом полезно, когда необходимо добавлять элементы в случайном порядке без учёта их важности.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть полезно использовать очередь с приоритетом для вставки элементов?\"},{\"answers\":[{\"text\":\"Извлечение элемента с наивысшим приоритетом — это удаление элемента из очереди на основе его приоритета.\",\"generated_as_correct\":true},{\"text\":\"Операция извлечения элемента с наивысшим приоритетом в очереди — это процесс перемещения элемента с наивысшим приоритетом в начало очереди без его удаления.\",\"generated_as_correct\":false},{\"text\":\"Операция извлечения элемента с наивысшим приоритетом в очереди тесно связана с алгоритмами сортировки и используется для организации данных в порядке их важности.\",\"generated_as_correct\":false},{\"text\":\"Извлечение элемента с наивысшим приоритетом — это процесс добавления элемента в очередь в зависимости от его приоритета.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция извлечения элемента с наивысшим приоритетом в очереди?\"},{\"answers\":[{\"text\":\"Место извлечения элемента зависит от реализации очереди с приоритетом.\",\"generated_as_correct\":true},{\"text\":\"Место извлечения элемента из очереди определяется случайным образом, независимо от приоритета элемента или типа очереди.\",\"generated_as_correct\":false},{\"text\":\"Место извлечения элемента из очереди зависит от алгоритма сортировки, используемого для упорядочивания элементов в очереди.\",\"generated_as_correct\":false},{\"text\":\"Место извлечения элемента всегда фиксировано в начале очереди.\",\"generated_as_correct\":false}],\"question\":\"Почему место извлечения элемента (начало, середина или конец очереди) может различаться в зависимости от реализации?\"},{\"answers\":[{\"text\":\"Извлечение элемента с наивысшим приоритетом удаляет элемент из очереди в зависимости от его приоритета.\",\"generated_as_correct\":true},{\"text\":\"Операция извлечения элемента с наивысшим приоритетом приводит к перемещению всех элементов в очереди на одну позицию вперёд, не учитывая их приоритеты.\",\"generated_as_correct\":false},{\"text\":\"Операция извлечения элемента с наивысшим приоритетом влияет на структуру данных, но не изменяет порядок обработки элементов в обычной очереди без приоритетов.\",\"generated_as_correct\":false},{\"text\":\"Извлечение элемента с наивысшим приоритетом всегда удаляет последний элемент в очереди.\",\"generated_as_correct\":false}],\"question\":\"Как операция извлечения элемента с наивысшим приоритетом влияет на обработку элементов в очереди?\"},{\"answers\":[{\"text\":\"Операция просмотра элемента с наивысшим приоритетом — это доступ к элементу без его удаления из очереди.\",\"generated_as_correct\":true},{\"text\":\"Операция просмотра элемента с наивысшим приоритетом подразумевает изменение приоритета элемента на максимальный без возможности его последующего удаления из очереди.\",\"generated_as_correct\":false},{\"text\":\"Операция просмотра элемента с наивысшим приоритетом относится к методам сортировки данных в массиве по убыванию их приоритетов.\",\"generated_as_correct\":false},{\"text\":\"Операция просмотра элемента с наивысшим приоритетом — это удаление элемента из очереди.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция просмотра элемента с наивысшим приоритетом?\"},{\"answers\":[{\"text\":\"Элемент не удаляется при просмотре, чтобы сохранить структуру данных.\",\"generated_as_correct\":true},{\"text\":\"При операции просмотра элемента с наивысшим приоритетом элемент временно перемещается в другую структуру данных для анализа, а затем возвращается на исходное место.\",\"generated_as_correct\":false},{\"text\":\"При операции просмотра элемента с наивысшим приоритетом важно учитывать, что это действие может повлиять на время доступа к другим элементам в очереди, так как просмотр может изменять порядок элементов.\",\"generated_as_correct\":false},{\"text\":\"Элемент удаляется при просмотре, чтобы освободить место в очереди для новых элементов.\",\"generated_as_correct\":false}],\"question\":\"Почему при операции просмотра элемента с наивысшим приоритетом важно, что элемент не удаляется из очереди?\"},{\"answers\":[{\"text\":\"Просмотр элемента с наивысшим приоритетом полезен для анализа без удаления из очереди.\",\"generated_as_correct\":true},{\"text\":\"Операция просмотра элемента с наивысшим приоритетом используется для случайного выбора элемента из очереди без учёта его приоритета.\",\"generated_as_correct\":false},{\"text\":\"Операция просмотра элемента с наивысшим приоритетом применяется в алгоритмах сортировки для сравнения элементов между собой.\",\"generated_as_correct\":false},{\"text\":\"Просмотр элемента с наивысшим приоритетом нужен для его немедленного удаления из очереди.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть полезно использовать операцию просмотра элемента с наивысшим приоритетом без его удаления?\"},{\"answers\":[{\"text\":\"Поиск элемента с определённым приоритетом — это нахождение элемента в очереди по его приоритету.\",\"generated_as_correct\":true},{\"text\":\"Операция поиска элемента с определённым приоритетом в очереди — это метод добавления новых элементов в очередь на основе их приоритета.\",\"generated_as_correct\":false},{\"text\":\"Операция поиска элемента с определённым приоритетом в очереди связана с процессом шифрования данных и обеспечением их безопасности в системе.\",\"generated_as_correct\":false},{\"text\":\"Поиск элемента с определённым приоритетом — это изменение порядка элементов в очереди на основе их приоритетов.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой операция поиска элемента с определённым приоритетом в очереди?\"},{\"answers\":[{\"text\":\"Поиск элемента по приоритету важен для алгоритмов и приложений, так как обеспечивает быстрый доступ к нужным данным на основе их важности.\",\"generated_as_correct\":true},{\"text\":\"Операция поиска элемента по приоритету важна только для простых алгоритмов, в сложных системах она не используется и не приносит практической пользы.\",\"generated_as_correct\":false},{\"text\":\"Операция поиска элемента по приоритету связана с управлением памятью в операционных системах и не имеет прямого отношения к алгоритмам и приложениям.\",\"generated_as_correct\":false},{\"text\":\"Поиск элемента по приоритету не важен для алгоритмов и приложений, поскольку все элементы обрабатываются одинаково без учёта их приоритета.\",\"generated_as_correct\":false}],\"question\":\"Почему операция поиска элемента по приоритету может быть важна для алгоритмов и приложений?\"},{\"answers\":[{\"text\":\"Поиск элемента с определённым приоритетом полезен в алгоритмах, где требуется обработка данных в порядке их важности.\",\"generated_as_correct\":true},{\"text\":\"Операция поиска элемента с определённым приоритетом применяется для сортировки всех элементов в очереди по возрастанию или убыванию приоритета, что ускоряет доступ к данным.\",\"generated_as_correct\":false},{\"text\":\"Операция поиска элемента с определённым приоритетом тесно связана с алгоритмами шифрования и используется для обеспечения безопасности данных при их передаче.\",\"generated_as_correct\":false},{\"text\":\"Поиск элемента с определённым приоритетом используется для удаления всех элементов с одинаковым приоритетом из очереди.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить операцию поиска элемента с определённым приоритетом в реальных задачах обработки данных?\"},{\"answers\":[{\"text\":\"Основные способы реализации очереди с приоритетом — массивы, связанные списки, бинарные кучи и древовидные структуры.\",\"generated_as_correct\":true},{\"text\":\"Основные способы реализации очереди с приоритетом включают использование циклических буферов, двусвязных списков и графов. Выбор конкретного способа определяется требованиями к памяти и скорости доступа к элементам.\",\"generated_as_correct\":false},{\"text\":\"Основные способы реализации очереди с приоритетом связаны с применением алгоритмов сортировки, таких как быстрая сортировка и сортировка слиянием, которые обеспечивают эффективное упорядочивание элементов.\",\"generated_as_correct\":false},{\"text\":\"Основные способы реализации очереди с приоритетом — стеки, очереди и хэш-таблицы.\",\"generated_as_correct\":false}],\"question\":\"Какие основные способы реализации очереди с приоритетом существуют?\"},{\"answers\":[{\"text\":\"Выбор способа реализации очереди с приоритетом зависит от того, какие операции (вставка, извлечение, просмотр, поиск) и с какой скоростью нужно выполнять.\",\"generated_as_correct\":true},{\"text\":\"Выбор способа реализации очереди с приоритетом определяется исключительно объёмом памяти, который требуется для хранения данных, а не требованиями к эффективности операций.\",\"generated_as_correct\":false},{\"text\":\"Выбор способа реализации очереди с приоритетом зависит от языка программирования, на котором ведётся разработка, и его поддержки различных структур данных.\",\"generated_as_correct\":false},{\"text\":\"Выбор способа реализации очереди с приоритетом зависит только от количества элементов, которые планируется хранить в очереди.\",\"generated_as_correct\":false}],\"question\":\"Почему выбор способа реализации очереди с приоритетом зависит от требований к эффективности операций?\"},{\"answers\":[{\"text\":\"Выбор между массивами, связанными списками, бинарными кучами и древовидными структурами для очереди с приоритетом зависит от требований к операциям с элементами.\",\"generated_as_correct\":true},{\"text\":\"Очередь с приоритетом реализуется только с помощью бинарных куч, так как другие структуры данных не позволяют эффективно управлять приоритетами элементов.\",\"generated_as_correct\":false},{\"text\":\"Реализация очереди с приоритетом может быть основана на алгоритмах сортировки, таких как быстрая сортировка или сортировка слиянием, которые обеспечивают эффективное упорядочивание элементов.\",\"generated_as_correct\":false},{\"text\":\"Для реализации очереди с приоритетом всегда лучше использовать связанные списки, так как они наиболее эффективны для всех операций.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить различные способы реализации очереди с приоритетом в зависимости от конкретных задач?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.6\"},{\"Name\":\"algo | 2.7. Чему вы научились\",\"Slug\":\"chemu-vi-nauchilis-two\",\"createdAt\":\"2024-07-03T17:32:19.603Z\",\"updatedAt\":\"2025-09-11T19:15:54.728Z\",\"publishedAt\":\"2025-09-11T19:15:54.705Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$63\",\"Title\":\"Чему вы научились\",\"LikesCount\":23,\"Quiz\":null,\"StoreCardId\":null,\"numberInCourse\":\"2.7\"}]},{\"id\":30,\"Name\":\"3. Решение практических задач по программированию\",\"Articles\":[{\"Name\":\"algo | 3.1. Практические задания с автоматической проверкой\",\"Slug\":\"prakticheskie-zadaniya-s-avtomaticheskoj-proverkoj\",\"createdAt\":\"2024-07-03T08:32:50.721Z\",\"updatedAt\":\"2026-01-10T12:07:07.922Z\",\"publishedAt\":\"2024-07-03T08:32:51.884Z\",\"ContestURL\":null,\"Lead\":\"Сформулируем чеклист решения алгоритмической задачи: от\u0026nbsp;разбора условия до\u0026nbsp;анализа вердикта системы проверки.\",\"Content\":\"$64\",\"Title\":\"Практические задания с автоматической проверкой\",\"LikesCount\":23,\"Quiz\":[{\"answers\":[{\"text\":\"Пять основных шагов решения задач по программированию: разбор условия, проектирование алгоритма, реализация, тестирование и отладка, отправка на оценку.\",\"generated_as_correct\":true},{\"text\":\"Процесс решения задач по программированию включает пять основных этапов: выбор языка программирования, создание структуры данных, написание комментариев к коду, тестирование на соответствие стандартам и архивация проекта.\",\"generated_as_correct\":false},{\"text\":\"Процесс решения задач по программированию связан с изучением теоретических основ математики, разработкой спецификаций для аппаратного обеспечения и анализом рынка программных продуктов.\",\"generated_as_correct\":false},{\"text\":\"Пять основных шагов решения задач по программированию: выбор инструментов, написание кода, тестирование на совместимость, оптимизация и запуск программы.\",\"generated_as_correct\":false}],\"question\":\"Какие пять основных шагов включает в себя процесс решения задач по программированию?\"},{\"answers\":[{\"text\":\"Следование всем пяти шагам в программировании обеспечивает системный подход и повышает эффективность разработки.\",\"generated_as_correct\":true},{\"text\":\"Следование всем пяти шагам при решении задач по программированию не имеет значения, так как опытный разработчик может решить задачу, пропустив несколько шагов.\",\"generated_as_correct\":false},{\"text\":\"Следование пяти шагам при решении задач по программированию помогает улучшить навыки работы в команде и коммуникацию между разработчиками.\",\"generated_as_correct\":false},{\"text\":\"Следование первым трём шагам достаточно для решения задачи по программированию, тестирование и отладка необязательны.\",\"generated_as_correct\":false}],\"question\":\"Почему важно следовать всем пяти шагам при решении задач по программированию, а не пропускать некоторые из них?\"},{\"answers\":[{\"text\":\"Решение задачи по программированию включает разбор условия, проектирование алгоритма, реализацию, тестирование и отладку.\",\"generated_as_correct\":true},{\"text\":\"Чтобы решить задачу по программированию, достаточно внимательно прочитать условие задачи и написать код, после чего можно сразу отправлять программу на оценку без дополнительного тестирования или отладки.\",\"generated_as_correct\":false},{\"text\":\"Для решения задачи по программированию важно выбрать подходящий язык программирования и интегрированную среду разработки (IDE), которые обеспечат удобство работы и эффективность выполнения кода.\",\"generated_as_correct\":false},{\"text\":\"Для решения задачи по программированию достаточно написать код и отправить его на оценку.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить описанные шаги для решения конкретной задачи по программированию?\"},{\"answers\":[{\"text\":\"Первый шаг в решении задачи по программированию — разбор условия задачи.\",\"generated_as_correct\":true},{\"text\":\"Первый шаг в решении задачи по программированию — это выбор языка программирования и среды разработки.\",\"generated_as_correct\":false},{\"text\":\"Первый шаг в решении задачи по программированию связан с изучением алгоритмов сортировки и поиска.\",\"generated_as_correct\":false},{\"text\":\"Первый шаг в решении задачи по программированию — написание тестовых данных для проверки кода.\",\"generated_as_correct\":false}],\"question\":\"Что включает в себя первый шаг в решении задачи по программированию?\"},{\"answers\":[{\"text\":\"Понимание условий задачи позволяет верно выбрать метод решения и разработать алгоритм.\",\"generated_as_correct\":true},{\"text\":\"Понимание условий задачи важно только для того, чтобы определить, насколько задача интересна и стоит ли её решать, а выбор подхода к решению зависит исключительно от опыта программиста.\",\"generated_as_correct\":false},{\"text\":\"Понимание условий задачи помогает в составлении технического задания для проекта, но не влияет на выбор подхода к решению задачи по программированию.\",\"generated_as_correct\":false},{\"text\":\"Понимание условий задачи нужно только для того, чтобы убедиться, что задача решаема, но не для выбора подхода к решению.\",\"generated_as_correct\":false}],\"question\":\"Почему понимание условий задачи считается критически важным для выбора подхода к решению?\"},{\"answers\":[{\"text\":\"Анализ условий задачи помогает выбрать подходящий алгоритм.\",\"generated_as_correct\":true},{\"text\":\"Анализ формулировки задачи и ограничений по времени и памяти помогает определить только тип данных, с которыми предстоит работать, и не влияет на выбор алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Анализ формулировки задачи и ограничений по времени и памяти важен для определения сложности алгоритма, но не связан с выбором конкретных методов сортировки или поиска.\",\"generated_as_correct\":false},{\"text\":\"Анализ условий задачи определяет только входные данные для алгоритма.\",\"generated_as_correct\":false}],\"question\":\"Как анализ формулировки задачи, ограничений по времени и памяти помогает в разработке алгоритма?\"},{\"answers\":[{\"text\":\"Второй шаг — разработка алгоритма и доказательство его корректности с учётом ограничений по времени и памяти.\",\"generated_as_correct\":true},{\"text\":\"Второй шаг при проектировании алгоритма состоит в сборе данных для задачи и их предварительной обработке, включая очистку и нормализацию.\",\"generated_as_correct\":false},{\"text\":\"Второй шаг при проектировании алгоритма связан с выбором языка программирования и инструментов для реализации алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Второй шаг — написание кода алгоритма без учёта его сложности и ограничений по ресурсам.\",\"generated_as_correct\":false}],\"question\":\"Что включает в себя второй шаг при проектировании алгоритма?\"},{\"answers\":[{\"text\":\"Анализ сложности алгоритма важен, чтобы убедиться, что алгоритм укладывается в заданные ограничения по времени и памяти.\",\"generated_as_correct\":true},{\"text\":\"Анализ сложности алгоритма важен только для теоретических исследований и не имеет практического применения при проектировании алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Анализ сложности алгоритма важен для определения его устойчивости к изменениям входных данных и для оценки его способности адаптироваться к различным условиям выполнения.\",\"generated_as_correct\":false},{\"text\":\"Анализ сложности алгоритма важен только для определения количества операций, которые алгоритм выполняет на каждом шаге.\",\"generated_as_correct\":false}],\"question\":\"Почему анализ сложности алгоритма важен при его проектировании?\"},{\"answers\":[{\"text\":\"Информация о временных и программных ограничениях помогает при проектировании алгоритма учесть его сложность и соответствие ограничениям по времени и памяти.\",\"generated_as_correct\":true},{\"text\":\"Информация о временных и программных ограничениях нужна для определения начального и конечного этапов работы алгоритма, а также для выбора языка программирования.\",\"generated_as_correct\":false},{\"text\":\"Информация о временных и программных ограничениях важна для создания пользовательского интерфейса, который будет отображать прогресс выполнения алгоритма и предупреждать о возможных задержках.\",\"generated_as_correct\":false},{\"text\":\"Информация о временных и программных ограничениях нужна для выбора оптимального оборудования, на котором будет работать алгоритм.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать информацию о временных и программных ограничениях при разработке алгоритма?\"},{\"answers\":[{\"text\":\"Третий шаг — написание кода на выбранном языке программирования.\",\"generated_as_correct\":true},{\"text\":\"Третий шаг реализации алгоритма состоит в тестировании уже готового программного обеспечения на предмет соответствия требованиям и исправлении ошибок.\",\"generated_as_correct\":false},{\"text\":\"Третий шаг реализации алгоритма связан с анализом сложности алгоритма и выбором оптимальных структур данных для его реализации.\",\"generated_as_correct\":false},{\"text\":\"Третий шаг — составление технического задания для программиста.\",\"generated_as_correct\":false}],\"question\":\"Что включает в себя третий шаг реализации алгоритма?\"},{\"answers\":[{\"text\":\"Выбор языка программирования важен для эффективной работы алгоритма с данными и ресурсами.\",\"generated_as_correct\":true},{\"text\":\"Выбор языка программирования важен только с точки зрения удобства разработчика, а не эффективности работы программы.\",\"generated_as_correct\":false},{\"text\":\"Выбор языка программирования влияет на сложность отладки и тестирования алгоритма, но не на его реализацию.\",\"generated_as_correct\":false},{\"text\":\"Выбор языка программирования не влияет на работу алгоритма, главное — правильно разработать его структуру.\",\"generated_as_correct\":false}],\"question\":\"Почему важно внимательно подходить к выбору языка программирования при реализации алгоритма?\"},{\"answers\":[{\"text\":\"Выбор языка программирования влияет на реализацию алгоритма через доступность структур данных и управление ресурсами.\",\"generated_as_correct\":true},{\"text\":\"Влияние особенностей языка программирования на реализацию алгоритма заключается только в синтаксисе, который определяет, как будут выглядеть ключевые слова и операторы в коде.\",\"generated_as_correct\":false},{\"text\":\"Особенности работы языка программирования с данными и ресурсами влияют на выбор операционной системы для запуска программы, так как разные системы поддерживают разные языки.\",\"generated_as_correct\":false},{\"text\":\"Особенности языка программирования не влияют на реализацию алгоритма, главное — это правильность математической модели.\",\"generated_as_correct\":false}],\"question\":\"Как особенности работы языка программирования с данными и ресурсами могут повлиять на реализацию алгоритма?\"},{\"answers\":[{\"text\":\"Четвёртый шаг — тестирование и отладка программы на разных данных для поиска и исправления ошибок.\",\"generated_as_correct\":true},{\"text\":\"Четвёртый шаг в разработке программы — это процесс документирования кода и написания инструкций для пользователей, чтобы они могли лучше понять, как работает программа.\",\"generated_as_correct\":false},{\"text\":\"Четвёртый шаг в разработке программы связан с выбором подходящих инструментов и сред разработки для создания программного продукта.\",\"generated_as_correct\":false},{\"text\":\"Четвёртый шаг — написание кода для новых функций программы.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой четвёртый шаг в разработке программы, связанный с тестированием и отладкой?\"},{\"answers\":[{\"text\":\"Тестирование на разных наборах данных помогает обнаружить и устранить ошибки в программе.\",\"generated_as_correct\":true},{\"text\":\"Тестирование программы на разных наборах данных необходимо только для того, чтобы проверить её скорость работы и оптимизировать производительность, а не для обеспечения корректности.\",\"generated_as_correct\":false},{\"text\":\"Тестирование программы важно для определения её совместимости с различными операционными системами и устройствами, но не связано с обработкой данных.\",\"generated_as_correct\":false},{\"text\":\"Тестирование программы нужно только для проверки её интерфейса и удобства использования, а не для обеспечения корректной работы.\",\"generated_as_correct\":false}],\"question\":\"Почему тестирование программы на различных наборах данных важно для обеспечения её корректной работы?\"},{\"answers\":[{\"text\":\"Результаты тестирования и отладки помогают находить и исправлять ошибки в программе.\",\"generated_as_correct\":true},{\"text\":\"Результаты тестирования и отладки служат для демонстрации успешности работы программы на одном конкретном наборе данных, без учёта других возможных сценариев.\",\"generated_as_correct\":false},{\"text\":\"Результаты тестирования и отладки могут быть использованы для составления технического отчёта, который будет представлен на конференции по программированию.\",\"generated_as_correct\":false},{\"text\":\"Результаты тестирования и отладки нужны для подтверждения того, что программа работает без ошибок и не требует дополнительных изменений.\",\"generated_as_correct\":false}],\"question\":\"Как результаты тестирования и отладки могут быть использованы для улучшения программы?\"},{\"answers\":[{\"text\":\"Пятый шаг — отправка программы в систему автоматической оценки.\",\"generated_as_correct\":true},{\"text\":\"Пятый шаг в процессе оценки программы — это проведение внутреннего тестирования программы разработчиками перед её финальной публикацией.\",\"generated_as_correct\":false},{\"text\":\"Пятый шаг в процессе оценки программы связан с анализом пользовательского интерфейса и его соответствия стандартам дизайна.\",\"generated_as_correct\":false},{\"text\":\"Пятый шаг — это публикация программы в открытом доступе для пользователей.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой пятый шаг в процессе оценки программы?\"},{\"answers\":[{\"text\":\"Система автоматической оценки тестирует программу на наборе тестов, проверяя правильность результатов и соответствие ограничениям по времени и памяти.\",\"generated_as_correct\":true},{\"text\":\"Система автоматической оценки проверяет корректность программы путём сравнения её исходного кода с эталонным решением, не учитывая при этом ограничения по времени и памяти.\",\"generated_as_correct\":false},{\"text\":\"Система автоматической оценки определяет корректность программы с помощью анализа её документации и комментариев в коде.\",\"generated_as_correct\":false},{\"text\":\"Система автоматической оценки проверяет программу на соответствие синтаксическим правилам языка программирования.\",\"generated_as_correct\":false}],\"question\":\"Как система автоматической оценки проверяет корректность и соответствие программы ограничениям?\"},{\"answers\":[{\"text\":\"Результаты тестирования помогают найти и исправить ошибки в программе.\",\"generated_as_correct\":true},{\"text\":\"Результаты тестирования программы в системе автоматической оценки применяются исключительно для выставления итоговой оценки, не влияя на процесс доработки программы.\",\"generated_as_correct\":false},{\"text\":\"Результаты тестирования программы в системе автоматической оценки анализируются для определения её соответствия стандартам безопасности и защиты данных.\",\"generated_as_correct\":false},{\"text\":\"Результаты тестирования используются для демонстрации успешности программы и её готовности к запуску без доработок.\",\"generated_as_correct\":false}],\"question\":\"Как результаты тестирования программы в системе автоматической оценки могут быть использованы для улучшения программы?\"}],\"StoreCardId\":null,\"numberInCourse\":\"3.1\"},{\"Name\":\"algo | 3.2. Задача «Сумма двух чисел»\",\"Slug\":\"zadacha-summa-dvuh-chisel\",\"createdAt\":\"2024-07-03T08:33:46.678Z\",\"updatedAt\":\"2026-01-10T12:07:09.598Z\",\"publishedAt\":\"2024-07-03T08:33:47.898Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80761/problem\",\"Lead\":\"Что может быть проще поиска суммы двух чисел? Для решения задачи не потребуется продвинутых навыков программирования, поэтому сфокусируем внимание на оформлении алгоритма и системе автоматической проверки.\",\"Content\":\"$65\",\"Title\":\"Задача «Сумма двух чисел»\",\"LikesCount\":29,\"Quiz\":[{\"answers\":[{\"text\":\"Задача — найти сумму двух целых чисел \\\\(a\\\\) и \\\\(b\\\\), где \\\\(0 \\\\le a, b \\\\le 9\\\\).\",\"generated_as_correct\":true},{\"text\":\"Задача заключается в нахождении разности двух целых чисел \\\\(a\\\\) и \\\\(b\\\\), где \\\\(0 \\\\le a, b \\\\le 9\\\\). Это пример для изучения основ программирования и алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Задача заключается в анализе сложности алгоритма для нахождения суммы двух чисел, что является важным аспектом при изучении алгоритмов и структур данных.\",\"generated_as_correct\":false},{\"text\":\"Задача — найти произведение двух целых чисел \\\\(a\\\\) и \\\\(b\\\\), где \\\\(0 \\\\le a, b \\\\le 9\\\\).\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой задача нахождения суммы двух целых чисел \\\\(a\\\\) и \\\\(b\\\\), где \\\\(0 \\\\le a, b \\\\le 9\\\\)?\"},{\"answers\":[{\"text\":\"Задача нахождения суммы двух чисел — базовый пример для изучения программирования, так как демонстрирует реализацию простого алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Задача нахождения суммы двух чисел считается сложным примером для изучения основ программирования, потому что она требует глубоких знаний в области математического анализа и теории чисел.\",\"generated_as_correct\":false},{\"text\":\"Задача нахождения суммы двух чисел связана с разработкой пользовательских интерфейсов и не имеет отношения к изучению основ программирования и алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Задача нахождения суммы двух чисел не считается базовым примером для изучения программирования, поскольку требует сложных математических вычислений.\",\"generated_as_correct\":false}],\"question\":\"Почему задача нахождения суммы двух чисел считается базовым примером для изучения основ программирования и алгоритмов?\"},{\"answers\":[{\"text\":\"Алгоритм сложения двух чисел используется в базовых задачах программирования, например, для подсчёта суммы цифр.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм нахождения суммы двух чисел применяется исключительно для работы с отрицательными числами в специализированных финансовых приложениях.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм нахождения суммы двух чисел важен для понимания принципов работы сетевых протоколов и шифрования данных.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм нахождения суммы двух чисел применяется только для работы с дробными числами в научных расчётах.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм нахождения суммы двух чисел в реальных задачах программирования?\"},{\"answers\":[{\"text\":\"Псевдокод — это описание алгоритма без привязки к языку программирования, используется для представления его логики.\",\"generated_as_correct\":true},{\"text\":\"Псевдокод — это неформальный способ записи алгоритмов, который не имеет структуры и не требует логической последовательности, его основная цель — предоставить общее представление о возможных действиях алгоритма без конкретики.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод используется в математике для доказательства теорем и не имеет отношения к программированию или алгоритмам.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод — это язык программирования высокого уровня, который используется для создания приложений.\",\"generated_as_correct\":false}],\"question\":\"Что такое псевдокод и для чего он используется?\"},{\"answers\":[{\"text\":\"Псевдокод абстрагирован от конкретных языков программирования, чтобы сосредоточиться на логике алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Псевдокод не привязан к конкретному языку программирования, поскольку он является неформальным набором инструкций, который не требует строгой логики и может быть интерпретирован по-разному.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод не привязан к конкретному языку программирования, потому что его основная цель — создание визуальных схем алгоритмов для облегчения понимания их структуры.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод не привязан к конкретным языкам программирования, потому что он предназначен только для документирования уже написанного кода.\",\"generated_as_correct\":false}],\"question\":\"Почему псевдокод не привязан к конкретному языку программирования?\"},{\"answers\":[{\"text\":\"Псевдокод упрощает разработку алгоритмов, отвлекая от синтаксиса языков программирования.\",\"generated_as_correct\":true},{\"text\":\"Псевдокод используется для непосредственной компиляции и запуска алгоритмов на различных платформах без необходимости дополнительной переработки.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод применяется для создания визуальных схем алгоритмов, которые помогают в проектировании пользовательских интерфейсов.\",\"generated_as_correct\":false},{\"text\":\"Псевдокод служит для автоматического перевода алгоритмов на разные языки программирования.\",\"generated_as_correct\":false}],\"question\":\"Как псевдокод может помочь разработчикам при создании алгоритмов?\"},{\"answers\":[{\"text\":\"Языки программирования C++, Java и Python применяются для разработки программ и реализации алгоритмов.\",\"generated_as_correct\":true},{\"text\":\"Языки программирования, включая C++, Java и Python, предназначены исключительно для математических вычислений и научных исследований.\",\"generated_as_correct\":false},{\"text\":\"Языки программирования, такие как C++, Java и Python, важны для понимания принципов работы операционных систем, хотя сами по себе не используются для их создания.\",\"generated_as_correct\":false},{\"text\":\"Языки программирования C++, Java и Python используются для создания графических изображений и дизайна.\",\"generated_as_correct\":false}],\"question\":\"Для чего используются языки программирования, такие как C++, Java и Python?\"},{\"answers\":[{\"text\":\"Знание разных языков программирования даёт возможность выбрать оптимальный язык для реализации алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Знание нескольких языков программирования полезно только для того, чтобы усложнить процесс разработки и сделать код менее читаемым из-за смешения синтаксисов.\",\"generated_as_correct\":false},{\"text\":\"Знание нескольких языков программирования помогает в оптимизации работы серверов и улучшении безопасности приложений, но не влияет на реализацию алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Знание нескольких языков программирования не имеет значения при реализации алгоритмов, так как все языки предлагают одинаковые возможности.\",\"generated_as_correct\":false}],\"question\":\"Почему знание нескольких языков программирования может быть полезным при реализации алгоритмов?\"},{\"answers\":[{\"text\":\"Выбор языка программирования влияет на способы реализации алгоритма и процесс разработки программы.\",\"generated_as_correct\":true},{\"text\":\"Выбор языка программирования влияет только на внешний вид кода, но не на его функциональность или производительность программы.\",\"generated_as_correct\":false},{\"text\":\"Выбор языка программирования важен для определения цветовой схемы редактора кода и удобства работы с IDE.\",\"generated_as_correct\":false},{\"text\":\"Выбор языка программирования никак не влияет на процесс создания программы, главное — умение программиста.\",\"generated_as_correct\":false}],\"question\":\"Как выбор языка программирования влияет на процесс создания программы?\"},{\"answers\":[{\"text\":\"Ограничения по времени и памяти определяют, насколько быстро и эффективно должен работать алгоритм.\",\"generated_as_correct\":true},{\"text\":\"Ограничения по времени и памяти устанавливают максимальные размеры входных данных, которые алгоритм способен обработать, и не влияют на скорость выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Ограничения по времени и памяти связаны с физическими характеристиками аппаратного обеспечения и не оказывают влияния на логику работы алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Ограничения по времени и памяти задают минимальный объём ресурсов, необходимый для запуска алгоритма.\",\"generated_as_correct\":false}],\"question\":\"Что определяют ограничения по времени и памяти в контексте работы алгоритма?\"},{\"answers\":[{\"text\":\"Ограничения по времени и памяти обеспечивают быструю обработку данных и предотвращают перегрузку системы.\",\"generated_as_correct\":true},{\"text\":\"Ограничения по времени и памяти важны только для старых или маломощных устройств, на современных компьютерах они не имеют значения, так как программы могут использовать все доступные ресурсы без ущерба для производительности.\",\"generated_as_correct\":false},{\"text\":\"Ограничения по времени и памяти важны для оптимизации алгоритмов машинного обучения, так как они влияют на скорость обучения моделей и их способность адаптироваться к новым данным.\",\"generated_as_correct\":false},{\"text\":\"Ограничения по времени и памяти нужны только для того, чтобы усложнить разработку программ и сделать их менее эффективными.\",\"generated_as_correct\":false}],\"question\":\"Почему ограничения по времени и памяти важны для обеспечения эффективности программы?\"},{\"answers\":[{\"text\":\"Ограничения по времени и памяти влияют на скорость и эффективность обработки данных в реальном времени, их превышение может привести к задержкам.\",\"generated_as_correct\":true},{\"text\":\"Ограничения по времени и памяти могут ускорить обработку данных в реальном времени, так как они стимулируют программу использовать более эффективные алгоритмы.\",\"generated_as_correct\":false},{\"text\":\"Ограничения по времени и памяти важны для определения сложности алгоритма, но они не влияют на его способность обрабатывать данные в реальном времени, важнее качество кода и оптимизация.\",\"generated_as_correct\":false},{\"text\":\"Ограничения по времени и памяти никак не влияют на работу программы в реальном времени, главное — мощность процессора.\",\"generated_as_correct\":false}],\"question\":\"Как ограничения по времени и памяти могут повлиять на способность программы обрабатывать данные в реальном времени?\"},{\"answers\":[{\"text\":\"Функция `sum_of_digits` в C++, Java и Python суммирует два числа, принимая их в качестве аргументов.\",\"generated_as_correct\":true},{\"text\":\"Функция `sum_of_digits` в различных языках программирования предназначена для подсчёта количества цифр в числе, а не для их суммирования.\",\"generated_as_correct\":false},{\"text\":\"Функция `sum_of_digits` относится к методам обработки строк и используется для определения длины строки в разных языках программирования.\",\"generated_as_correct\":false},{\"text\":\"Функция `sum_of_digits` используется для нахождения максимального значения из двух чисел в разных языках программирования.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой функция `sum_of_digits` в разных языках программирования (C++, Java, Python)?\"},{\"answers\":[{\"text\":\"Функции для суммирования чисел упрощают организацию кода и его повторное использование.\",\"generated_as_correct\":true},{\"text\":\"Функции для суммирования чисел важны, потому что они позволяют выполнять операции с текстом и преобразовывать его в числовой формат.\",\"generated_as_correct\":false},{\"text\":\"Функции для суммирования чисел полезны для создания сложных математических моделей и прогнозирования временных рядов.\",\"generated_as_correct\":false},{\"text\":\"Функции для суммирования чисел нужны только для вывода результатов на экран.\",\"generated_as_correct\":false}],\"question\":\"Почему важно использовать функции для суммирования чисел в программировании?\"},{\"answers\":[{\"text\":\"Функция `sum_of_digits` упрощает код, позволяя суммировать два числа и повторно использовать этот алгоритм.\",\"generated_as_correct\":true},{\"text\":\"Функция `sum_of_digits` применяется для нахождения наибольшего общего делителя двух чисел, что помогает упростить код при работе с числовыми операциями.\",\"generated_as_correct\":false},{\"text\":\"Функция `sum_of_digits` может быть использована для анализа частоты встречаемости цифр в наборе данных, что не связано напрямую с суммированием чисел, но может быть полезным при обработке числовой информации.\",\"generated_as_correct\":false},{\"text\":\"Функция `sum_of_digits` предназначена для определения количества цифр в числе, что не упрощает работу с суммированием.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить функцию `sum_of_digits` для упрощения и организации кода при работе с суммированием чисел?\"}],\"StoreCardId\":null,\"numberInCourse\":\"3.2\"},{\"Name\":\"algo | 3.3. Задача «Максимальное произведение»\",\"Slug\":\"zadacha-maksimalnoe-proizvedenie\",\"createdAt\":\"2024-07-03T08:34:43.067Z\",\"updatedAt\":\"2026-01-10T12:07:08.723Z\",\"publishedAt\":\"2024-07-03T08:34:44.275Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80762/problem\",\"Lead\":\"Без ошибок практически невозможно написать программу. В этом параграфе мы рассмотрим подробнее, как их искать. А заодно поговорим о том, как подбирать корректные входные данные, чтобы проверить работоспособность алгоритма во всех сценариях.\",\"Content\":\"$66\",\"Title\":\"Задача «Максимальное произведение»\",\"LikesCount\":27,\"Quiz\":[{\"answers\":[{\"text\":\"Задача заключается в поиске максимального произведения двух различных элементов из последовательности неотрицательных чисел.\",\"generated_as_correct\":true},{\"text\":\"Задача нахождения максимального попарного произведения заключается в определении суммы двух наибольших элементов из заданной последовательности неотрицательных целых чисел.\",\"generated_as_correct\":false},{\"text\":\"Задача нахождения максимального попарного произведения связана с анализом частотности встречаемости пар чисел в заданной последовательности.\",\"generated_as_correct\":false},{\"text\":\"Задача нахождения максимального попарного произведения — это поиск максимального числа в последовательности неотрицательных целых чисел.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается задача нахождения максимального попарного произведения?\"},{\"answers\":[{\"text\":\"Необходимо анализировать все пары элементов, чтобы найти максимальное попарное произведение.\",\"generated_as_correct\":true},{\"text\":\"Для нахождения максимального попарного произведения можно выбрать два самых больших числа в последовательности и перемножить их, без анализа остальных пар.\",\"generated_as_correct\":false},{\"text\":\"Анализ всех возможных пар элементов важен для задач сортировки и поиска медианы в последовательности, но не имеет отношения к нахождению максимального попарного произведения.\",\"generated_as_correct\":false},{\"text\":\"Достаточно найти два наибольших числа в последовательности для решения задачи максимального попарного произведения.\",\"generated_as_correct\":false}],\"question\":\"Почему для решения задачи максимального попарного произведения необходимо анализировать все возможные пары элементов в последовательности?\"},{\"answers\":[{\"text\":\"Алгоритм нахождения максимального попарного произведения полезен в задачах оптимизации, например, для анализа финансовых данных или определения оптимальных маршрутов.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм нахождения максимального попарного произведения применяется для сортировки элементов в последовательности по возрастанию, что полезно в задачах, требующих упорядочивания данных.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм нахождения максимального попарного произведения может быть использован для анализа частоты встречаемости пар слов в текстовых данных, что применяется в задачах обработки естественного языка.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм нахождения максимального попарного произведения используется для вычисления среднего арифметического элементов в последовательности.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм нахождения максимального попарного произведения в реальных задачах?\"},{\"answers\":[{\"text\":\"Наивный подход — это перебор всех пар элементов для нахождения пары с наибольшим произведением.\",\"generated_as_correct\":true},{\"text\":\"Наивный подход предполагает сортировку всех элементов по возрастанию и выбор двух последних элементов в качестве пары с наибольшим произведением.\",\"generated_as_correct\":false},{\"text\":\"Наивный подход используется для определения среднего арифметического элементов в наборе данных путём их последовательного сложения и деления на количество элементов.\",\"generated_as_correct\":false},{\"text\":\"Наивный подход заключается в выборе первых двух элементов набора данных в качестве пары с наибольшим произведением.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой наивный подход при поиске пары элементов с наибольшим произведением?\"},{\"answers\":[{\"text\":\"Наивный подход имеет квадратичную сложность и неэффективен для больших наборов данных из-за перебора всех пар элементов.\",\"generated_as_correct\":true},{\"text\":\"Наивный подход неэффективен для больших наборов данных, потому что он основан на случайном выборе элементов без перебора всех возможных пар.\",\"generated_as_correct\":false},{\"text\":\"Наивный подход может быть неэффективным из-за сложности реализации вложенных циклов, что делает его неподходящим для использования в сложных математических моделях.\",\"generated_as_correct\":false},{\"text\":\"Наивный подход неэффективен, потому что требует большого объёма памяти для хранения данных.\",\"generated_as_correct\":false}],\"question\":\"Почему наивный подход может быть неэффективным для больших наборов данных?\"},{\"answers\":[{\"text\":\"Наивный подход — это перебор всех пар элементов с помощью вложенных циклов для нахождения пары с наибольшим произведением.\",\"generated_as_correct\":true},{\"text\":\"Наивный подход заключается в случайном выборе пар элементов и сравнении их произведений, что позволяет быстро найти пару с наибольшим произведением без использования вложенных циклов.\",\"generated_as_correct\":false},{\"text\":\"Наивный подход используется для сортировки элементов в массиве путём сравнения каждого элемента с каждым, что позволяет упорядочить данные по возрастанию или убыванию.\",\"generated_as_correct\":false},{\"text\":\"Наивный подход предполагает использование одного цикла для перебора элементов и нахождения пары с наибольшим произведением.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить наивный подход на практике для решения задачи перебора пар элементов?\"},{\"answers\":[{\"text\":\"Быстрый алгоритм находит произведение двух самых больших элементов массива за счёт двукратного сканирования.\",\"generated_as_correct\":true},{\"text\":\"Быстрый алгоритм для нахождения произведения двух самых больших элементов в массиве заключается в сортировке массива по возрастанию и умножении двух последних элементов.\",\"generated_as_correct\":false},{\"text\":\"Быстрый алгоритм — это метод, который используется для оптимизации поиска элементов в бинарном дереве, не имеющий отношения к нахождению произведения элементов в массиве.\",\"generated_as_correct\":false},{\"text\":\"Быстрый алгоритм находит произведение двух самых больших элементов массива путём однократного его сканирования.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой быстрый алгоритм для нахождения произведения двух самых больших элементов в массиве?\"},{\"answers\":[{\"text\":\"Быстрый алгоритм сканирует массив дважды — для нахождения наибольшего и второго по величине элементов, что сокращает количество операций.\",\"generated_as_correct\":true},{\"text\":\"Быстрый алгоритм сканирует массив дважды для нахождения среднего арифметического всех элементов, что позволяет сократить количество операций по сравнению с методом полного перебора.\",\"generated_as_correct\":false},{\"text\":\"Быстрый алгоритм использует метод двоичного поиска для нахождения двух самых больших элементов в массиве, что ускоряет процесс по сравнению с последовательным перебором.\",\"generated_as_correct\":false},{\"text\":\"Быстрый алгоритм сканирует массив один раз для нахождения наибольшего элемента и использует его для вычисления суммы всех элементов массива.\",\"generated_as_correct\":false}],\"question\":\"Почему быстрый алгоритм требует сканирования массива дважды и как это помогает сократить количество операций?\"},{\"answers\":[{\"text\":\"Быстрый алгоритм находит два наибольших элемента в массиве за два сканирования и возвращает их произведение.\",\"generated_as_correct\":true},{\"text\":\"Быстрый алгоритм находит произведение двух наибольших элементов в массиве путём однократного сканирования массива и сравнения каждого элемента с текущим максимальным значением.\",\"generated_as_correct\":false},{\"text\":\"Быстрый алгоритм может быть использован для сортировки массива по возрастанию, что позволяет легко определить два наибольших элемента и вычислить их произведение.\",\"generated_as_correct\":false},{\"text\":\"Быстрый алгоритм находит произведение наименьшего и наибольшего элементов в массиве за одно сканирование.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить быстрый алгоритм для решения задачи нахождения произведения двух наибольших элементов в массиве на практике?\"},{\"answers\":[{\"text\":\"Стресс-тестирование — это генерация тысяч случайных тестов для проверки алгоритма и сравнения результатов разных его реализаций.\",\"generated_as_correct\":true},{\"text\":\"Стресс-тестирование — это процесс, при котором алгоритм тестируется на небольшом наборе заранее определённых тестов для проверки его корректности.\",\"generated_as_correct\":false},{\"text\":\"Стресс-тестирование — это методика, используемая в психологии для оценки реакции человека на различные стрессовые ситуации, не имеющая отношения к алгоритмам.\",\"generated_as_correct\":false},{\"text\":\"Стресс-тестирование — это проверка алгоритма на одном заранее определённом тестовом сценарии.\",\"generated_as_correct\":false}],\"question\":\"Что такое стресс-тестирование в контексте проверки алгоритмов?\"},{\"answers\":[{\"text\":\"Стресс-тестирование генерирует множество случайных тестов и сравнивает результаты разных реализаций алгоритма для выявления ошибок.\",\"generated_as_correct\":true},{\"text\":\"Стресс-тестирование обнаруживает ошибки в алгоритмах путём визуального анализа кода и последующего сравнения с эталонными алгоритмами, без использования тестовых сценариев.\",\"generated_as_correct\":false},{\"text\":\"Стресс-тестирование используется для оценки производительности алгоритмов в условиях высокой нагрузки, но не помогает в выявлении логических ошибок в их работе.\",\"generated_as_correct\":false},{\"text\":\"Стресс-тестирование находит ошибки в алгоритмах путём однократного запуска алгоритма с заранее определёнными входными данными.\",\"generated_as_correct\":false}],\"question\":\"Каким образом стресс-тестирование помогает выявлять ошибки в алгоритмах?\"},{\"answers\":[{\"text\":\"Стресс-тестирование помогает выявлять ошибки в алгоритме путём сравнения результатов двух его реализаций на тысячах случайных тестов.\",\"generated_as_correct\":true},{\"text\":\"Стресс-тестирование используется для проверки работы алгоритма в идеальных условиях, что позволяет убедиться в его корректности и повысить надёжность.\",\"generated_as_correct\":false},{\"text\":\"Стресс-тестирование применяется для анализа производительности алгоритмов в условиях высокой нагрузки на аппаратное обеспечение, что не связано с выявлением ошибок в алгоритме.\",\"generated_as_correct\":false},{\"text\":\"Стресс-тестирование улучшает надёжность алгоритма путём проверки его работы на небольшом количестве заранее заданных тестов.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить стресс-тестирование для улучшения надёжности алгоритма?\"},{\"answers\":[{\"text\":\"Целочисленное переполнение — это превышение максимального значения типа данных при вычислении.\",\"generated_as_correct\":true},{\"text\":\"Целочисленное переполнение происходит, когда числовое значение достигает определённого порогового значения и автоматически преобразуется в другой тип данных.\",\"generated_as_correct\":false},{\"text\":\"Целочисленное переполнение связано с ошибками в алгоритмах сортировки и не влияет на результаты арифметических операций.\",\"generated_as_correct\":false},{\"text\":\"Целочисленное переполнение возникает при делении на ноль.\",\"generated_as_correct\":false}],\"question\":\"Что такое целочисленное переполнение?\"},{\"answers\":[{\"text\":\"Целочисленное переполнение происходит, когда результат вычислений превышает максимально возможное значение типа данных, что приводит к некорректным результатам.\",\"generated_as_correct\":true},{\"text\":\"Целочисленное переполнение случается, когда число становится слишком большим и автоматически преобразуется в другой тип данных, например, из int в float, что приводит к потере точности вычислений.\",\"generated_as_correct\":false},{\"text\":\"Целочисленное переполнение связано с ограничениями памяти на компьютере и может быть предотвращено путём увеличения объёма оперативной памяти, что позволит обрабатывать большие числа без ошибок.\",\"generated_as_correct\":false},{\"text\":\"Целочисленное переполнение — это ситуация, когда число округляется до ближайшего доступного значения в рамках используемого типа данных, что может привести к незначительным ошибкам в вычислениях.\",\"generated_as_correct\":false}],\"question\":\"Почему целочисленное переполнение может привести к некорректным результатам вычислений?\"},{\"answers\":[{\"text\":\"Используйте более крупные типы данных, например, int64_t.\",\"generated_as_correct\":true},{\"text\":\"Чтобы избежать целочисленного переполнения, достаточно округлить результат произведения до ближайшего меньшего значения, которое помещается в стандартный тип данных.\",\"generated_as_correct\":false},{\"text\":\"Чтобы предотвратить целочисленное переполнение, необходимо оптимизировать алгоритм вычисления максимального попарного произведения, используя методы динамического программирования.\",\"generated_as_correct\":false},{\"text\":\"Уменьшите входные числа перед вычислением произведения.\",\"generated_as_correct\":false}],\"question\":\"Как можно предотвратить целочисленное переполнение при вычислении максимального попарного произведения?\"}],\"StoreCardId\":null,\"numberInCourse\":\"3.3\"},{\"Name\":\"algo | 3.4. Чему вы научились\",\"Slug\":\"chemu-vi-nauchilis-thee\",\"createdAt\":\"2024-07-03T08:34:43.067Z\",\"updatedAt\":\"2025-09-11T18:34:18.113Z\",\"publishedAt\":\"2025-09-08T14:10:02.854Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$67\",\"Title\":\"Чему вы научились\",\"LikesCount\":27,\"Quiz\":null,\"StoreCardId\":null,\"numberInCourse\":\"3.4\"}]},{\"id\":32,\"Name\":\"4. Разминка. Последовательные алгоритмы\",\"Articles\":[{\"Name\":\"algo | 4.1 Задачи о числах Фибоначчи\",\"Slug\":\"zadachi-o-chislah-fibonachchi\",\"createdAt\":\"2024-07-03T08:35:12.632Z\",\"updatedAt\":\"2026-01-10T12:07:09.730Z\",\"publishedAt\":\"2024-07-03T08:35:13.751Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80763/problem\",\"Lead\":\"Прежде чем начать, коротко напомним, что числа Фибоначчи — числовой ряд, при котором каждое последющее число равно сумме двух предыдущих.\",\"Content\":\"$68\",\"Title\":\"Задачи о числах Фибоначчи\",\"LikesCount\":16,\"Quiz\":[{\"answers\":[{\"text\":\"Числовой ряд Фибоначчи — это последовательность, где каждое число равно сумме двух предыдущих: $F_n = F_{n-2} + F_{n-1}$.\",\"generated_as_correct\":true},{\"text\":\"Числовой ряд Фибоначчи определяется как последовательность чисел, где каждое следующее число равно удвоенному значению предыдущего числа, начиная с $F_0 = 0$ и $F_1 = 1$.\",\"generated_as_correct\":false},{\"text\":\"Числовой ряд Фибоначчи связан с теорией вероятностей и используется для расчёта случайных величин в статистическом анализе.\",\"generated_as_correct\":false},{\"text\":\"Числовой ряд Фибоначчи — это последовательность, где каждое число равно произведению двух предыдущих.\",\"generated_as_correct\":false}],\"question\":\"Как определяется числовой ряд Фибоначчи?\"},{\"answers\":[{\"text\":\"Числа Фибоначчи полезны для моделирования процессов и структур благодаря своей рекурсивной природе, где каждое число — сумма двух предыдущих.\",\"generated_as_correct\":true},{\"text\":\"Числа Фибоначчи применяются для моделирования процессов, так как они представляют собой случайный набор чисел, который можно использовать для описания любых систем без учёта их специфических закономерностей.\",\"generated_as_correct\":false},{\"text\":\"Числа Фибоначчи важны для моделирования, поскольку они тесно связаны с теорией вероятностей и используются для расчёта статистических данных в больших выборках.\",\"generated_as_correct\":false},{\"text\":\"Числа Фибоначчи применяются в моделировании, потому что они образуют арифметическую прогрессию, удобную для описания различных систем.\",\"generated_as_correct\":false}],\"question\":\"Почему числа Фибоначчи полезны для моделирования различных процессов и структур?\"},{\"answers\":[{\"text\":\"Числа Фибоначчи используются в математике и информатике для моделирования процессов.\",\"generated_as_correct\":true},{\"text\":\"Числа Фибоначчи применяются только в теории чисел и не имеют практического применения в других областях науки и практики.\",\"generated_as_correct\":false},{\"text\":\"Числа Фибоначчи играют важную роль в генетике и молекулярной биологии, помогая анализировать структуру ДНК.\",\"generated_as_correct\":false},{\"text\":\"Числа Фибоначчи применяются исключительно в экономике для прогнозирования финансовых рынков.\",\"generated_as_correct\":false}],\"question\":\"В каких областях науки и практики применяются числа Фибоначчи?\"},{\"answers\":[{\"text\":\"Рекурсивный алгоритм для вычисления чисел Фибоначчи — это метод, основанный на повторном вызове функции с меньшими аргументами до достижения базовых случаев.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный алгоритм для вычисления чисел Фибоначчи — это метод, который использует цикл для последовательного вычисления значений, начиная с \\\\( F_0 \\\\) и \\\\( F_1 \\\\), без повторных вызовов функции.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм для вычисления чисел Фибоначчи связан с использованием матриц для оптимизации вычислений и не требует вызова функции с меньшими аргументами.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм для вычисления чисел Фибоначчи — это метод, который всегда эффективен и не имеет проблем с повторными вычислениями.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой рекурсивный алгоритм для вычисления чисел Фибоначчи?\"},{\"answers\":[{\"text\":\"Рекурсивный алгоритм неэффективен для больших \\\\( n \\\\) из-за повторных вычислений.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный алгоритм становится неэффективным для больших значений \\\\( n \\\\) из-за необходимости хранить все промежуточные результаты в памяти, что быстро приводит к исчерпанию ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм может быть неэффективным из-за сложности его реализации и трудности понимания логики работы при увеличении количества вложенных вызовов.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм неэффективен для больших \\\\( n \\\\) из-за ограниченного размера стека вызовов.\",\"generated_as_correct\":false}],\"question\":\"Почему рекурсивный алгоритм может быть неэффективным для больших значений \\\\( n \\\\)?\"},{\"answers\":[{\"text\":\"Рекурсивный алгоритм подходит для вычисления чисел Фибоначчи, но может быть неэффективен для больших \\\\( n \\\\) из-за повторных вычислений.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный алгоритм используется для вычисления чисел Фибоначчи и всегда является наиболее эффективным методом по сравнению с итеративными подходами, независимо от величины \\\\( n \\\\).\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм часто используется в задачах сортировки и поиска, где его эффективность не зависит от повторных вычислений, а определяется структурой данных.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм всегда эффективен для вычисления чисел Фибоначчи независимо от величины \\\\( n \\\\).\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать рекурсивный алгоритм на практике, учитывая его особенности?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм вычисляет числа Фибоначчи последовательно, сохраняя промежуточные результаты.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм для вычисления чисел Фибоначчи — это метод, основанный на использовании матриц для быстрого возведения в степень, что позволяет получить результат без последовательного вычисления промежуточных значений.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм для вычисления чисел Фибоначчи связан с применением динамического программирования для решения задач оптимизации, не связанных напрямую с последовательностью Фибоначчи.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм вычисляет числа Фибоначчи путём многократного вызова функции без сохранения промежуточных результатов.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой итерационный алгоритм для вычисления чисел Фибоначчи?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм эффективнее рекурсивного, так как избегает повторных вычислений и экономит ресурсы.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм эффективнее рекурсивного для вычисления чисел Фибоначчи, потому что он использует более сложные математические формулы, которые позволяют быстрее достигать нужных значений.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм применяется в различных областях программирования для оптимизации вычислений, но его эффективность для вычисления чисел Фибоначчи обусловлена использованием специфических библиотек для работы с большими числами.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм требует больше ресурсов и времени для вычисления чисел Фибоначчи по сравнению с рекурсивным.\",\"generated_as_correct\":false}],\"question\":\"Почему итерационный алгоритм более эффективен для вычисления чисел Фибоначчи по сравнению с рекурсивным?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм экономит ресурсы при вычислении чисел Фибоначчи, избегая повторных вычислений.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм для вычисления чисел Фибоначчи требует больше памяти и времени по сравнению с рекурсивным алгоритмом, так как сохраняет все промежуточные результаты в памяти.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм используется для оптимизации вычислений в различных областях математики, включая теорию графов и комбинаторику, но его влияние на ресурсы при вычислении чисел Фибоначчи не является определяющим фактором.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм требует больше ресурсов для вычисления чисел Фибоначчи по сравнению с рекурсивным методом.\",\"generated_as_correct\":false}],\"question\":\"Как использование итерационного алгоритма может повлиять на ресурсы, необходимые для вычисления чисел Фибоначчи?\"},{\"answers\":[{\"text\":\"Мемоизация — техника сохранения вычисленных значений в рекурсивных алгоритмах.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация — это способ хранения исходных данных перед началом вычислений для последующего их использования в итеративных процессах.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это концепция, используемая в теории графов для оптимизации путей между узлами.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — метод увеличения времени вычислений за счёт хранения промежуточных результатов.\",\"generated_as_correct\":false}],\"question\":\"Что такое мемоизация?\"},{\"answers\":[{\"text\":\"Мемоизация экономит время, сохраняя ранее вычисленные значения чисел Фибоначчи.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация помогает оптимизировать вычисление чисел Фибоначчи за счёт использования дополнительных математических формул, которые упрощают вычисления.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация используется для улучшения визуального представления чисел Фибоначчи в графиках и диаграммах.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация усложняет алгоритм вычисления чисел Фибоначчи, добавляя ненужные операции.\",\"generated_as_correct\":false}],\"question\":\"Как мемоизация помогает оптимизировать вычисление чисел Фибоначчи?\"},{\"answers\":[{\"text\":\"Мемоизация ускоряет работу рекурсивных алгоритмов за счёт сохранения уже вычисленных значений.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация эффективна при работе с итеративными алгоритмами, где вычисленные значения могут быть использованы повторно, но не оказывает значительного влияния на рекурсивные алгоритмы.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация используется для оптимизации алгоритмов сортировки, позволяя сохранять промежуточные результаты и ускорять процесс сортировки больших объёмов данных.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация замедляет работу рекурсивных алгоритмов из-за необходимости дополнительного хранения данных.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение мемоизации может быть особенно полезным при работе с рекурсивными алгоритмами?\"},{\"answers\":[{\"text\":\"Период Пизано — это период повторения остатков от деления чисел Фибоначчи на число \\\\( m \\\\).\",\"generated_as_correct\":true},{\"text\":\"Период Пизано — это интервал времени, через который числа Фибоначчи достигают определённого максимального значения при делении на число \\\\( m \\\\).\",\"generated_as_correct\":false},{\"text\":\"Период Пизано связан с периодичностью появления простых чисел в последовательности Фибоначчи и используется в криптографии для генерации ключей.\",\"generated_as_correct\":false},{\"text\":\"Период Пизано — это количество чисел Фибоначчи, которые делятся на число \\\\( m \\\\) без остатка.\",\"generated_as_correct\":false}],\"question\":\"Что такое период Пизано?\"},{\"answers\":[{\"text\":\"Период Пизано позволяет оптимизировать вычисления с числами Фибоначчи по модулю \\\\( m \\\\), ускоряя алгоритмы.\",\"generated_as_correct\":true},{\"text\":\"Период Пизано важен для оптимизации вычислений с числами Фибоначчи, потому что он позволяет предсказывать точные значения чисел Фибоначчи без необходимости их вычисления.\",\"generated_as_correct\":false},{\"text\":\"Период Пизано связан с теорией чисел и используется в криптографии для создания сложных алгоритмов шифрования.\",\"generated_as_correct\":false},{\"text\":\"Период Пизано используется для прямого вычисления чисел Фибоначчи без использования рекурсии.\",\"generated_as_correct\":false}],\"question\":\"Почему период Пизано важен для оптимизации вычислений с числами Фибоначчи?\"},{\"answers\":[{\"text\":\"Период Пизано помогает ускорить вычисления с числами Фибоначчи по модулю \\\\( m \\\\) за счёт определения периода повторения их остатков.\",\"generated_as_correct\":true},{\"text\":\"Период Пизано применяется для вычисления точных значений чисел Фибоначчи без использования модуля \\\\( m \\\\), что ускоряет алгоритмы за счёт уменьшения количества операций.\",\"generated_as_correct\":false},{\"text\":\"Период Пизано связан с теорией чисел и может быть использован для анализа периодичности в последовательностях, не обязательно связанных с числами Фибоначчи.\",\"generated_as_correct\":false},{\"text\":\"Период Пизано используется для прямого вычисления чисел Фибоначчи без применения модуля \\\\( m \\\\).\",\"generated_as_correct\":false}],\"question\":\"Как можно применить период Пизано для ускорения алгоритмов, работающих с числами Фибоначчи по модулю \\\\( m \\\\)?\"},{\"answers\":[{\"text\":\"Метод быстрого возведения матрицы в степень позволяет вычислять числа Фибоначчи \\\\(F_n\\\\) по модулю \\\\(m\\\\), возводя матрицу \\\\(\\\\begin{bmatrix} 0 \u0026 1 \\\\\\\\ 1 \u0026 1 \\\\end{bmatrix}\\\\) в степень \\\\(n\\\\).\",\"generated_as_correct\":true},{\"text\":\"Метод быстрого возведения матрицы в степень для вычисления чисел Фибоначчи по модулю заключается в последовательном умножении матрицы \\\\(\\\\begin{bmatrix} 0 \u0026 1 \\\\\\\\ 1 \u0026 1 \\\\end{bmatrix}\\\\) на саму себя \\\\(n\\\\) раз без использования оптимизаций.\",\"generated_as_correct\":false},{\"text\":\"Метод быстрого возведения матрицы в степень для вычисления чисел Фибоначчи по модулю связан с применением теоремы Лапласа для вычисления определителей больших матриц.\",\"generated_as_correct\":false},{\"text\":\"Метод быстрого возведения матрицы в степень для вычисления чисел Фибоначчи по модулю заключается в возведении числа \\\\(n\\\\) в степень \\\\(m\\\\) и последующем делении на модуль.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой метод быстрого возведения матрицы в степень для вычисления чисел Фибоначчи по модулю?\"},{\"answers\":[{\"text\":\"Метод быстрого возведения матрицы в степень позволяет эффективно вычислять большие числа Фибоначчи по модулю за счёт оптимизации вычислений с использованием матриц.\",\"generated_as_correct\":true},{\"text\":\"Метод быстрого возведения матрицы в степень эффективен для вычисления больших чисел Фибоначчи по модулю благодаря использованию специальной матрицы, которая содержит первые два числа Фибоначчи и позволяет получить любое число последовательности путём умножения на константу.\",\"generated_as_correct\":false},{\"text\":\"Метод быстрого возведения матрицы в степень связан с вычислением определителей и собственных значений матриц, что может быть полезно для анализа систем линейных уравнений, но не имеет прямого отношения к вычислению чисел Фибоначчи.\",\"generated_as_correct\":false},{\"text\":\"Метод быстрого возведения матрицы в степень неэффективен для вычисления больших чисел Фибоначчи по модулю, так как требует слишком много памяти для хранения промежуточных результатов.\",\"generated_as_correct\":false}],\"question\":\"Почему метод быстрого возведения матрицы в степень эффективен для вычисления больших чисел Фибоначчи по модулю?\"},{\"answers\":[{\"text\":\"Метод быстрого возведения матрицы в степень позволяет эффективно вычислять большие числа Фибоначчи по модулю, возводя матрицу \\\\( \\\\begin{bmatrix} 0 \u0026 1 \\\\\\\\ 1 \u0026 1 \\\\end{bmatrix} \\\\) в степень \\\\( n \\\\).\",\"generated_as_correct\":true},{\"text\":\"Метод быстрого возведения матрицы в степень применяется для вычисления чисел Фибоначчи путём возведения числа \\\\( n \\\\) в степень матрицы \\\\( \\\\begin{bmatrix} 0 \u0026 1 \\\\\\\\ 1 \u0026 1 \\\\end{bmatrix} \\\\), что упрощает расчёты для больших значений \\\\( n \\\\).\",\"generated_as_correct\":false},{\"text\":\"Метод быстрого возведения матрицы в степень связан с вычислением определителей и может быть использован для решения систем линейных уравнений, что не имеет прямого отношения к числам Фибоначчи.\",\"generated_as_correct\":false},{\"text\":\"Метод быстрого возведения матрицы в степень используется для вычисления чисел Фибоначчи путём умножения матрицы на саму себя \\\\( n \\\\) раз без использования модульных операций.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить метод быстрого возведения матрицы в степень для решения задач, связанных с вычислением чисел Фибоначчи?\"},{\"answers\":[{\"text\":\"Сумма первых \\\\( n \\\\) чисел Фибоначчи: \\\\( S_n = F_{n+2} - 1 \\\\).\",\"generated_as_correct\":true},{\"text\":\"Сумма первых \\\\( n \\\\) чисел Фибоначчи равна произведению \\\\( n \\\\)-го числа Фибоначчи на \\\\( n \\\\), то есть \\\\( S_n = n \\\\cdot F_n \\\\).\",\"generated_as_correct\":false},{\"text\":\"Для вычисления суммы первых \\\\( n \\\\) чисел Фибоначчи можно использовать метод перебора всех чисел и их последовательного сложения, что может быть неэффективно для больших \\\\( n \\\\).\",\"generated_as_correct\":false},{\"text\":\"Сумма первых \\\\( n \\\\) чисел Фибоначчи: \\\\( S_n = F_n + 1 \\\\).\",\"generated_as_correct\":false}],\"question\":\"Как можно вычислить сумму первых \\\\( n \\\\) чисел Фибоначчи?\"},{\"answers\":[{\"text\":\"Формула \\\\( S_n = F_{n+2} - 1 \\\\) даёт сумму первых \\\\( n \\\\) чисел Фибоначчи напрямую.\",\"generated_as_correct\":true},{\"text\":\"Формула \\\\( S_n = F_{n+2} - 1 \\\\) позволяет вычислить сумму первых \\\\( n \\\\) чисел Фибоначчи путём умножения \\\\( n \\\\)-го числа на константу, что ускоряет вычисления.\",\"generated_as_correct\":false},{\"text\":\"Формула \\\\( S_n = F_{n+2} - 1 \\\\) используется для определения количества элементов в последовательности Фибоначчи и не имеет отношения к вычислению суммы чисел.\",\"generated_as_correct\":false},{\"text\":\"Формула \\\\( S_n = F_{n+2} - 1 \\\\) вычисляет \\\\( n \\\\)-е число Фибоначчи, а не сумму первых \\\\( n \\\\) чисел.\",\"generated_as_correct\":false}],\"question\":\"Почему формула \\\\( S_n = F_{n+2} - 1 \\\\) позволяет быстро вычислить сумму чисел Фибоначчи без перебора всех значений?\"},{\"answers\":[{\"text\":\"Формула $S_n = F_{n+2} - 1$ позволяет быстро вычислить сумму первых $n$ чисел Фибоначчи.\",\"generated_as_correct\":true},{\"text\":\"Формула $S_n = F_{n+2} - 1$ используется для определения $n$-го числа Фибоначчи в последовательности, что упрощает вычисления при больших значениях $n$.\",\"generated_as_correct\":false},{\"text\":\"Формула $S_n = F_{n+2} - 1$ может быть использована для анализа динамики финансовых рынков, где числа Фибоначчи применяются в техническом анализе.\",\"generated_as_correct\":false},{\"text\":\"Формула $S_n = F_{n+2} - 1$ используется для нахождения $n$-го члена последовательности Фибоначчи.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть полезно применение формулы для суммы чисел Фибоначчи \\\\( S_n = F_{n+2} - 1 \\\\)?\"},{\"answers\":[{\"text\":\"Сумма чисел Фибоначчи от \\\\(m\\\\) до \\\\(n\\\\) равна разности сумм до \\\\(n\\\\) и до \\\\(m-1\\\\).\",\"generated_as_correct\":true},{\"text\":\"Сумма чисел Фибоначчи в заданном диапазоне \\\\([m, n]\\\\) вычисляется путём сложения всех чисел Фибоначчи от \\\\(m\\\\) до \\\\(n\\\\) включительно без использования промежуточных сумм.\",\"generated_as_correct\":false},{\"text\":\"Сумма чисел Фибоначчи в заданном диапазоне может быть вычислена с помощью формулы для суммы арифметической прогрессии.\",\"generated_as_correct\":false},{\"text\":\"Сумма чисел Фибоначчи от \\\\(m\\\\) до \\\\(n\\\\) равна сумме всех чисел Фибоначчи, делённой на количество чисел в диапазоне.\",\"generated_as_correct\":false}],\"question\":\"Как вычисляется сумма чисел Фибоначчи в заданном диапазоне \\\\([m, n]\\\\)?\"},{\"answers\":[{\"text\":\"Частичная сумма чисел Фибоначчи \\\\([m, n]\\\\) вычисляется как разность сумм до \\\\(n\\\\) и до \\\\(m-1\\\\).\",\"generated_as_correct\":true},{\"text\":\"Для вычисления частичной суммы чисел Фибоначчи в диапазоне \\\\([m, n]\\\\) используется произведение сумм до \\\\(n\\\\) и до \\\\(m-1\\\\).\",\"generated_as_correct\":false},{\"text\":\"Для вычисления частичной суммы чисел Фибоначчи используется формула, основанная на свойствах логарифмов и показательных функций.\",\"generated_as_correct\":false},{\"text\":\"Частичная сумма чисел Фибоначчи \\\\([m, n]\\\\) вычисляется как сумма чисел до \\\\(n\\\\) и до \\\\(m-1\\\\).\",\"generated_as_correct\":false}],\"question\":\"Почему для вычисления частичной суммы чисел Фибоначчи используется разность между суммами до \\\\(n\\\\) и до \\\\(m-1\\\\)?\"},{\"answers\":[{\"text\":\"Сумма чисел Фибоначчи в диапазоне \\\\([m, n]\\\\) равна разности сумм до \\\\(n\\\\) и до \\\\(m-1\\\\).\",\"generated_as_correct\":true},{\"text\":\"Чтобы вычислить сумму чисел Фибоначчи в диапазоне \\\\([m, n]\\\\), необходимо сложить все числа Фибоначчи от \\\\(m\\\\) до \\\\(n\\\\) включительно, используя формулу для суммы арифметической прогрессии.\",\"generated_as_correct\":false},{\"text\":\"Утверждение о частичной сумме чисел Фибоначчи используется для анализа последовательности и выявления закономерностей в росте чисел, что может быть полезно при исследовании свойств числовых рядов.\",\"generated_as_correct\":false},{\"text\":\"Сумма чисел Фибоначчи в диапазоне \\\\([m, n]\\\\) вычисляется как сумма всех чисел Фибоначчи до \\\\(n\\\\), делённая на сумму всех чисел до \\\\(m\\\\).\",\"generated_as_correct\":false}],\"question\":\"Как можно применить утверждение о частичной сумме чисел Фибоначчи для решения задач, связанных с вычислением сумм в заданных диапазонах?\"},{\"answers\":[{\"text\":\"Сумма квадратов первых \\\\( n \\\\) чисел Фибоначчи равна \\\\( F_n \\\\cdot F_{n+1} \\\\).\",\"generated_as_correct\":true},{\"text\":\"Сумма квадратов первых \\\\( n \\\\) чисел Фибоначчи равна сумме \\\\( n \\\\)-го и \\\\( (n+1) \\\\)-го чисел Фибоначчи, то есть \\\\( F_n + F_{n+1} \\\\).\",\"generated_as_correct\":false},{\"text\":\"Сумма квадратов первых \\\\( n \\\\) чисел Фибоначчи связана с теорией вероятностей и используется для расчёта дисперсии случайных величин.\",\"generated_as_correct\":false},{\"text\":\"Сумма квадратов первых \\\\( n \\\\) чисел Фибоначчи равна \\\\( F_{n^2} \\\\).\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой сумма квадратов первых \\\\( n \\\\) чисел Фибоначчи согласно данному утверждению?\"},{\"answers\":[{\"text\":\"Формула суммы квадратов чисел Фибоначчи \\\\( F_n \\\\cdot F_{n+1} \\\\) ускоряет вычисления в математических задачах.\",\"generated_as_correct\":true},{\"text\":\"Формула суммы квадратов чисел Фибоначчи полезна, потому что она позволяет вычислить произведение двух последовательных чисел Фибоначчи, а не их сумму квадратов.\",\"generated_as_correct\":false},{\"text\":\"Формула суммы квадратов чисел Фибоначчи важна для понимания свойств последовательности Фибоначчи и её связи с золотым сечением, хотя это не всегда применимо в алгоритмах.\",\"generated_as_correct\":false},{\"text\":\"Формула суммы квадратов чисел Фибоначчи используется для нахождения следующего числа в последовательности.\",\"generated_as_correct\":false}],\"question\":\"Почему формула суммы квадратов чисел Фибоначчи считается полезной в математических задачах и алгоритмах?\"},{\"answers\":[{\"text\":\"Формула суммы квадратов первых \\\\( n \\\\) чисел Фибоначчи \\\\( F_n \\\\cdot F_{n+1} \\\\) помогает быстро вычислить эту сумму.\",\"generated_as_correct\":true},{\"text\":\"Формула суммы квадратов первых \\\\( n \\\\) чисел Фибоначчи используется для нахождения произведения двух последовательных чисел Фибоначчи, а не суммы их квадратов.\",\"generated_as_correct\":false},{\"text\":\"Формула суммы квадратов чисел Фибоначчи применяется для определения количества элементов в последовательности Фибоначчи, что полезно в задачах комбинаторики.\",\"generated_as_correct\":false},{\"text\":\"Формула суммы квадратов первых \\\\( n \\\\) чисел Фибоначчи позволяет найти сумму самих чисел Фибоначчи, а не их квадратов.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить формулу суммы квадратов чисел Фибоначчи для решения конкретной математической задачи?\"}],\"StoreCardId\":null,\"numberInCourse\":\"4.1\"},{\"Name\":\"algo | 4.2 Вычисление НОК и НОД\",\"Slug\":\"vychislenie-nok-i-nod\",\"createdAt\":\"2024-07-03T08:36:05.613Z\",\"updatedAt\":\"2026-01-10T12:07:08.523Z\",\"publishedAt\":\"2024-07-03T08:36:06.908Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80764/problem\",\"Lead\":null,\"Content\":\"$69\",\"Title\":\"Вычисление НОК и НОД\",\"LikesCount\":28,\"Quiz\":[{\"answers\":[{\"text\":\"НОД — это наибольшее число, на которое делятся два числа без остатка.\",\"generated_as_correct\":true},{\"text\":\"Наибольший общий делитель (НОД) двух положительных целых чисел — это любое число, которое делится на оба числа с остатком, меньшим единицы.\",\"generated_as_correct\":false},{\"text\":\"Наибольший общий делитель (НОД) — это концепция, используемая в геометрии для определения общих свойств фигур.\",\"generated_as_correct\":false},{\"text\":\"НОД — это наименьшее число, которое делится на два заданных числа без остатка.\",\"generated_as_correct\":false}],\"question\":\"Что такое наибольший общий делитель (НОД) двух положительных целых чисел?\"},{\"answers\":[{\"text\":\"НОД важен в теории чисел и криптографии, так как определяет наибольшее число, на которое делятся два числа без остатка.\",\"generated_as_correct\":true},{\"text\":\"Наибольший общий делитель (НОД) важен в теории чисел и криптографии, поскольку он позволяет найти наименьшее общее кратное двух чисел, что используется для построения криптографических систем.\",\"generated_as_correct\":false},{\"text\":\"Наибольший общий делитель (НОД) связан с теорией графов и используется для анализа связности графов в дискретной математике, что имеет косвенное отношение к теории чисел и криптографии.\",\"generated_as_correct\":false},{\"text\":\"НОД важен в теории чисел и криптографии, поскольку определяет наименьшее число, которое делится на два заданных числа.\",\"generated_as_correct\":false}],\"question\":\"Почему нахождение НОД важно в теории чисел и криптографии?\"},{\"answers\":[{\"text\":\"Алгоритм Евклида находит НОД двух чисел через последовательное деление и замену чисел остатком до достижения нулевого остатка.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Евклида заключается в последовательном сложении двух чисел и замене большего числа суммой, пока числа не станут равными. Полученное число и будет наибольшим общим делителем.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Евклида применяется для решения диофантовых уравнений и нахождения коэффициентов Безу, что связано с теорией чисел, но не имеет отношения к нахождению НОД двух чисел.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Евклида определяет наименьшее общее кратное двух чисел через последовательное вычитание меньшего числа из большего.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать алгоритм Евклида для нахождения НОД двух чисел?\"},{\"answers\":[{\"text\":\"Алгоритм Евклида — метод нахождения НОД двух чисел через последовательное вычитание или деление с остатком.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Евклида — это способ умножения двух чисел, который использует последовательное сложение одного числа само с собой столько раз, сколько указано вторым числом.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Евклида используется для построения геометрических фигур и определения их свойств в евклидовой геометрии.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Евклида применяется для нахождения суммы двух чисел.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм Евклида?\"},{\"answers\":[{\"text\":\"Алгоритм Евклида эффективен для нахождения НОД благодаря использованию последовательного вычитания или деления с остатком.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Евклида эффективен, потому что он использует метод умножения чисел для нахождения их наибольшего общего делителя, что делает его быстрым и точным способом вычисления НОД.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Евклида важен для теории чисел и используется в некоторых алгоритмах сортировки, что делает его полезным инструментом в программировании.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Евклида эффективен для нахождения НОД, потому что он основан на методе сложения чисел.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритм Евклида считается эффективным методом для нахождения наибольшего общего делителя?\"},{\"answers\":[{\"text\":\"Алгоритм Евклида важен в криптографии для вычисления наибольшего общего делителя.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Евклида применяется для нахождения наименьшего общего кратного двух чисел и важен в областях, связанных с финансовой аналитикой и бухгалтерским учётом.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Евклида используется в теории графов для определения кратчайших путей между узлами и имеет значение в областях логистики и сетевого планирования.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Евклида применяется в химии для расчёта молекулярных весов соединений.\",\"generated_as_correct\":false}],\"question\":\"В каких областях применяется алгоритм Евклида и почему он важен для них?\"},{\"answers\":[{\"text\":\"НОК — это наименьшее число, которое делится на два заданных целых числа.\",\"generated_as_correct\":true},{\"text\":\"Наименьшее общее кратное (НОК) для двух положительных целых чисел — это любое число, которое делится на одно из них без остатка.\",\"generated_as_correct\":false},{\"text\":\"Наименьшее общее кратное (НОК) — это концепция, используемая в геометрии для определения наименьшего возможного расстояния между двумя точками на плоскости.\",\"generated_as_correct\":false},{\"text\":\"НОК — это наибольший общий делитель двух чисел.\",\"generated_as_correct\":false}],\"question\":\"Что такое наименьшее общее кратное (НОК) для двух положительных целых чисел?\"},{\"answers\":[{\"text\":\"НОК — это наименьшее число, которое делится на два заданных числа. Оно помогает решать задачи с дробями и периодичностью.\",\"generated_as_correct\":true},{\"text\":\"Наименьшее общее кратное (НОК) — это среднее арифметическое двух заданных чисел. Оно используется для нахождения среднего значения в статистических задачах.\",\"generated_as_correct\":false},{\"text\":\"Наименьшее общее кратное (НОК) связано с понятием делимости чисел и используется в криптографии для генерации ключей.\",\"generated_as_correct\":false},{\"text\":\"НОК — это наибольшее число, которое делится на два заданных числа без остатка. Оно используется в задачах на сложение чисел.\",\"generated_as_correct\":false}],\"question\":\"Почему НОК является важным понятием в теории чисел и как оно связано с другими математическими задачами?\"},{\"answers\":[{\"text\":\"НОК помогает привести дроби к общему знаменателю.\",\"generated_as_correct\":true},{\"text\":\"Наименьшее общее кратное (НОК) помогает найти наибольший общий знаменатель для двух или более дробей, что упрощает их умножение.\",\"generated_as_correct\":false},{\"text\":\"Наименьшее общее кратное (НОК) используется в теории чисел для определения периодичности функций и не имеет отношения к дробям.\",\"generated_as_correct\":false},{\"text\":\"НОК используется для нахождения наибольшего общего делителя дробей.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить НОК для решения задач, связанных с дробями?\"},{\"answers\":[{\"text\":\"НОК двух чисел $a$ и $b$ можно найти по формуле: $\\\\operatorname{LCM}(a, b) = \\\\dfrac{a \\\\cdot b}{\\\\operatorname{GCD}(a, b)}$.\",\"generated_as_correct\":true},{\"text\":\"Наименьшее общее кратное (НОК) двух чисел равно сумме этих чисел, делённой на их наибольший общий делитель (НОД): $\\\\operatorname{LCM}(a, b) = \\\\dfrac{a + b}{\\\\operatorname{GCD}(a, b)}$.\",\"generated_as_correct\":false},{\"text\":\"Наименьшее общее кратное (НОК) двух чисел связано с их разложением на простые множители, но не имеет прямого отношения к наибольшему общему делителю (НОД).\",\"generated_as_correct\":false},{\"text\":\"НОК двух чисел равен их произведению, умноженному на НОД: $\\\\operatorname{LCM}(a, b) = a \\\\cdot b \\\\cdot \\\\operatorname{GCD}(a, b)$.\",\"generated_as_correct\":false}],\"question\":\"Как можно выразить наименьшее общее кратное (НОК) двух чисел через их наибольший общий делитель (НОД)?\"},{\"answers\":[{\"text\":\"Существует формула для вычисления НОК через НОД: $\\\\operatorname{LCM}(a, b) = \\\\dfrac{a \\\\cdot b}{\\\\operatorname{GCD}(a, b)}$.\",\"generated_as_correct\":true},{\"text\":\"Знание НОД двух чисел помогает вычислить их НОК путём сложения НОД с произведением этих чисел.\",\"generated_as_correct\":false},{\"text\":\"Знание НОД двух чисел важно для определения их взаимной простоты, что может быть полезно в криптографии, но не связано напрямую с вычислением НОК.\",\"generated_as_correct\":false},{\"text\":\"НОК двух чисел можно вычислить, умножив их НОД на разность этих чисел.\",\"generated_as_correct\":false}],\"question\":\"Почему знание НОД двух чисел позволяет быстро вычислить их НОК?\"},{\"answers\":[{\"text\":\"Соотношение между НОД и НОК помогает быстро вычислять НОК или НОД двух чисел.\",\"generated_as_correct\":true},{\"text\":\"Соотношение между НОД и НОК применяется для нахождения суммы двух чисел, если известны их наибольший общий делитель и наименьшее общее кратное.\",\"generated_as_correct\":false},{\"text\":\"Соотношение между НОД и НОК может быть использовано для определения количества делителей числа, что полезно при анализе функций делимости.\",\"generated_as_correct\":false},{\"text\":\"Соотношение между НОД и НОК используется для нахождения разности двух чисел.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях может быть полезно использовать соотношение между НОД и НОК для решения задач?\"}],\"StoreCardId\":null,\"numberInCourse\":\"4.2\"},{\"Name\":\"algo | 4.3. Чему вы научились\",\"Slug\":\"chemu-vi-nauchilis-four\",\"createdAt\":\"2024-07-03T08:36:05.613Z\",\"updatedAt\":\"2025-09-11T18:34:33.203Z\",\"publishedAt\":\"2025-09-08T14:18:09.666Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"Четвертая глава стала разминкой перед серьёзными алгоритмическими техниками. Вы начали с простых задач на числа — и шаг за шагом освоили первые приёмы, которые помогут вам писать эффективный и устойчивый код. Такие задачи часто кажутся тривиальными, но именно они формируют основу алгоритмического мышления: аккуратность, внимание к структуре, контроль за сложностью и типами данных.\\n\\nТеперь вы умеете:\\n\\n* Вычислять числа Фибоначчи с помощью рекурсии, итерации, мемоизации и по модулю.\\n* Использовать период Пизано для нахождения остатка от очень больших чисел.\\n* Оценивать эффективность решений и избегать переполнений при работе с большими числами.\\n* Применять алгоритм Евклида для нахождения наибольшего общего делителя.\\n* Связывать НОД и НОК и быстро вычислять оба значения даже для больших входов.\\n\\nДалее — глава о графах: вы познакомитесь с вершинами и рёбрами, научитесь представлять графы в коде и решать задачи на маршруты и связанность.\",\"Title\":\"Чему вы научились\",\"LikesCount\":28,\"Quiz\":null,\"StoreCardId\":null,\"numberInCourse\":\"4.3\"}]},{\"id\":37,\"Name\":\"5. Графы\",\"Articles\":[{\"Name\":\"algo | 5.1 Природа графа\",\"Slug\":\"priroda-grafa\",\"createdAt\":\"2024-07-03T17:33:14.101Z\",\"updatedAt\":\"2026-01-10T12:07:08.125Z\",\"publishedAt\":\"2024-07-03T17:33:15.322Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$6a\",\"Title\":\"Природа графа\",\"LikesCount\":24,\"Quiz\":[{\"answers\":[{\"text\":\"Теория графов — это математическая теория, изучающая графы и их структуры.\",\"generated_as_correct\":true},{\"text\":\"Теория графов — это метод в статистике, который используется для анализа временных рядов и прогнозирования. Она изучает зависимости между переменными и помогает строить математические модели для предсказания будущих событий.\",\"generated_as_correct\":false},{\"text\":\"Теория графов тесно связана с теорией чисел и используется для изучения свойств простых чисел и их распределений.\",\"generated_as_correct\":false},{\"text\":\"Теория графов — это область физики, изучающая движение объектов в пространстве.\",\"generated_as_correct\":false}],\"question\":\"Что такое теория графов и какие объекты она изучает?\"},{\"answers\":[{\"text\":\"Теория графов позволяет моделировать и анализировать взаимосвязи в сложных системах и сетях.\",\"generated_as_correct\":true},{\"text\":\"Теория графов используется исключительно для решения задач в области топологии и не имеет отношения к анализу сложных систем и сетей в других научных дисциплинах.\",\"generated_as_correct\":false},{\"text\":\"Теория графов тесно связана с теорией чисел и используется для доказательства математических теорем, что не имеет прямого отношения к анализу сложных систем и сетей.\",\"generated_as_correct\":false},{\"text\":\"Теория графов применяется только для решения задач оптимизации в логистике и не используется для анализа сложных систем и сетей.\",\"generated_as_correct\":false}],\"question\":\"Почему теория графов считается полезной для анализа сложных систем и сетей?\"},{\"answers\":[{\"text\":\"Теория графов применяется в компьютерных науках, физике, химии и биологии для анализа сложных систем.\",\"generated_as_correct\":true},{\"text\":\"Теория графов находит применение только в экономике и социологии для анализа финансовых рынков и социальных сетей.\",\"generated_as_correct\":false},{\"text\":\"Теория графов тесно связана с теорией вероятностей и используется для прогнозирования случайных событий в различных областях науки.\",\"generated_as_correct\":false},{\"text\":\"Теория графов используется только в геометрии для построения графиков функций.\",\"generated_as_correct\":false}],\"question\":\"В каких областях науки и техники может применяться теория графов?\"},{\"answers\":[{\"text\":\"Граф — это структура из вершин и рёбер, используемая для моделирования сетей и отношений.\",\"generated_as_correct\":true},{\"text\":\"Граф — это таблица, в которой строки и столбцы представляют вершины, а значения в ячейках — рёбра между ними.\",\"generated_as_correct\":false},{\"text\":\"Граф — это метод интегрирования функций, который используется в математическом анализе для нахождения площади под кривой.\",\"generated_as_correct\":false},{\"text\":\"Граф — это множество точек на плоскости, не связанных друг с другом.\",\"generated_as_correct\":false}],\"question\":\"Что такое граф в математике?\"},{\"answers\":[{\"text\":\"Графы важны для моделирования систем, так как представляют сети и отношения между объектами через вершины и рёбра.\",\"generated_as_correct\":true},{\"text\":\"Графы важны для моделирования систем, потому что они могут быть использованы для хранения больших объёмов данных, подобно базам данных, что делает их идеальными для анализа сложных структур.\",\"generated_as_correct\":false},{\"text\":\"Графы используются в теории чисел для анализа взаимосвязей между простыми числами и их распределения в числовом ряду.\",\"generated_as_correct\":false},{\"text\":\"Графы полезны для моделирования систем, потому что позволяют проводить сложные вычисления и решать уравнения.\",\"generated_as_correct\":false}],\"question\":\"Почему графы являются важным инструментом для моделирования и анализа различных систем?\"},{\"answers\":[{\"text\":\"Графы — это структуры из вершин и рёбер, используемые для моделирования сетей и карт.\",\"generated_as_correct\":true},{\"text\":\"Графы используются для представления временных рядов и прогнозирования будущих событий, а не для моделирования сетей или карт.\",\"generated_as_correct\":false},{\"text\":\"Графы применяются в теории чисел для доказательства теорем о простых числах и не имеют отношения к представлению сетей или карт.\",\"generated_as_correct\":false},{\"text\":\"Графы применяются только для решения задач в области криптографии и не используются для представления сетей или карт.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать графы для представления реальных сетей или карт?\"},{\"answers\":[{\"text\":\"Ориентированный граф — это граф с рёбрами, имеющими направление (дугами), в отличие от неориентированного графа.\",\"generated_as_correct\":true},{\"text\":\"Ориентированный граф — это граф, в котором все рёбра имеют одинаковую длину и направление, что отличает его от неориентированного графа, где длина рёбер может быть разной.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный граф используется для моделирования сетевых структур и алгоритмов поиска пути, в то время как неориентированный граф применяется для анализа связности компонентов в системе.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный граф отличается от неориентированного тем, что в нём рёбра могут иметь различную длину.\",\"generated_as_correct\":false}],\"question\":\"Что такое ориентированный граф и чем он отличается от неориентированного графа?\"},{\"answers\":[{\"text\":\"В ориентированном графе дуги имеют направление, поэтому движение по ним возможно только в заданном направлении.\",\"generated_as_correct\":true},{\"text\":\"В ориентированном графе движение по дуге возможно только в определённом направлении из-за ограничений, накладываемых алгоритмами поиска пути, которые определяют допустимые направления движения.\",\"generated_as_correct\":false},{\"text\":\"В ориентированном графе движение по дуге ограничено из-за особенностей его представления в памяти компьютера, таких как использование массивов или списков для хранения информации о вершинах и рёбрах.\",\"generated_as_correct\":false},{\"text\":\"В ориентированном графе движение по дуге возможно в любом направлении, так как дуги не имеют направления.\",\"generated_as_correct\":false}],\"question\":\"Почему в ориентированном графе движение по дуге возможно только в заданном направлении?\"},{\"answers\":[{\"text\":\"Ориентированный граф моделирует ситуации с учётом направления связей через дуги.\",\"generated_as_correct\":true},{\"text\":\"Ориентированный граф подходит для моделирования ситуаций с двусторонними связями, где направление не играет роли, а важна только возможность соединения между объектами.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный граф может быть использован для визуализации сетевых структур, но его применение ограничено задачами, не связанными с направлением связей, например, в анализе графов без учёта ориентации рёбер.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный граф используется для моделирования ситуаций без учёта направления связей.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать ориентированный граф для моделирования ситуаций, где важно учитывать направление связей между объектами?\"},{\"answers\":[{\"text\":\"Неориентированный граф — это граф без направленных рёбер.\",\"generated_as_correct\":true},{\"text\":\"Неориентированный граф — это граф, где каждое ребро имеет вес, определяющий направление движения от одного узла к другому.\",\"generated_as_correct\":false},{\"text\":\"Неориентированный граф — это структура данных, используемая исключительно для построения сетевых топологий в компьютерных сетях.\",\"generated_as_correct\":false},{\"text\":\"Неориентированный граф — это граф, где все рёбра направлены от одной вершины к другой.\",\"generated_as_correct\":false}],\"question\":\"Что такое неориентированный граф?\"},{\"answers\":[{\"text\":\"В неориентированном графе рёбра без направления, поэтому движение возможно в обоих направлениях.\",\"generated_as_correct\":true},{\"text\":\"В неориентированном графе движение по рёбрам возможно в обоих направлениях из-за наличия специальных маркеров на рёбрах, указывающих на двустороннюю проходимость.\",\"generated_as_correct\":false},{\"text\":\"В неориентированном графе движение по рёбрам возможно в обоих направлениях благодаря алгоритмам поиска кратчайшего пути, которые не учитывают направление рёбер.\",\"generated_as_correct\":false},{\"text\":\"В неориентированном графе движение по рёбрам ограничено одним направлением из-за структуры графа.\",\"generated_as_correct\":false}],\"question\":\"Почему в неориентированном графе движение по рёбрам возможно в обоих направлениях?\"},{\"answers\":[{\"text\":\"Неориентированный граф подходит для представления симметричных отношений.\",\"generated_as_correct\":true},{\"text\":\"Неориентированный граф применяется для представления иерархических отношений между объектами, где чётко определено верхнее и нижнее положение каждого элемента.\",\"generated_as_correct\":false},{\"text\":\"Неориентированный граф полезен в теории чисел для визуализации делимости одних чисел на другие.\",\"generated_as_correct\":false},{\"text\":\"Неориентированный граф используется для представления направленных отношений между объектами.\",\"generated_as_correct\":false}],\"question\":\"Для представления каких отношений между объектами подходит неориентированный граф?\"},{\"answers\":[{\"text\":\"«Петля — это ребро или дуга, начинающееся и заканчивающееся в одной вершине».\",\"generated_as_correct\":true},{\"text\":\"«Петля в графе — это цикл, проходящий через несколько вершин и возвращающийся в начальную точку».\",\"generated_as_correct\":false},{\"text\":\"«Петля в графе связана с алгоритмами поиска кратчайшего пути и используется для определения оптимального маршрута между вершинами».\",\"generated_as_correct\":false},{\"text\":\"«Петля — это соединение между двумя разными вершинами в графе».\",\"generated_as_correct\":false}],\"question\":\"Что такое петля в графе?\"},{\"answers\":[{\"text\":\"Петли позволяют представить отношения объекта с самим собой в графе.\",\"generated_as_correct\":true},{\"text\":\"Петли используются в графах исключительно для визуального разделения вершин и не несут смысловой нагрузки относительно отношений объекта с самим собой.\",\"generated_as_correct\":false},{\"text\":\"Петли применяются в теории графов для расчёта количества вершин и рёбер в графе, что помогает в анализе его структуры, но не связано с представлением отношений объекта с самим собой.\",\"generated_as_correct\":false},{\"text\":\"Петли нужны для соединения различных вершин в графе и не имеют отношения к представлению отношений объекта с самим собой.\",\"generated_as_correct\":false}],\"question\":\"Почему петли могут быть полезны при представлении отношений объекта с самим собой?\"},{\"answers\":[{\"text\":\"Петли — это рёбра/дуги, входящие и выходящие из одной вершины, обозначающие её особые свойства.\",\"generated_as_correct\":true},{\"text\":\"Петли представляют собой специальные метки, которые добавляются к вершинам графа для обозначения их уникальных характеристик, не связанных с рёбрами или дугами.\",\"generated_as_correct\":false},{\"text\":\"Петли используются в алгоритмах поиска кратчайших путей в графе и не имеют отношения к обозначению особых свойств вершин.\",\"generated_as_correct\":false},{\"text\":\"Петли служат для соединения нескольких вершин графа и не используются для обозначения особых свойств одной вершины.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать петли для обозначения особых свойств вершин в графе?\"},{\"answers\":[{\"text\":\"Смежность в графах — это связь между вершинами или рёбрами, соединёнными ребром или имеющими общую вершину.\",\"generated_as_correct\":true},{\"text\":\"Смежность в графах определяется как отношение между вершинами, при котором две вершины считаются смежными, если между ними нет рёбер.\",\"generated_as_correct\":false},{\"text\":\"Смежность в графах связана с понятием циклов, когда ребро соединяет вершину саму с собой.\",\"generated_as_correct\":false},{\"text\":\"Смежность в графах — это отношение между рёбрами, которые не имеют общих вершин.\",\"generated_as_correct\":false}],\"question\":\"Что такое смежность в контексте графов?\"},{\"answers\":[{\"text\":\"Понятие смежности важно, так как оно показывает, как вершины или рёбра соединены в графе.\",\"generated_as_correct\":true},{\"text\":\"Понятие смежности важно для анализа структуры графа, потому что оно определяет количество вершин в графе и позволяет вычислить его периметр.\",\"generated_as_correct\":false},{\"text\":\"Понятие смежности используется в теории графов для классификации графов по их типу, например, ориентированные или неориентированные, что помогает в разработке алгоритмов для работы с графами.\",\"generated_as_correct\":false},{\"text\":\"Понятие смежности важно для определения количества рёбер в графе.\",\"generated_as_correct\":false}],\"question\":\"Почему понятие смежности важно для анализа структуры графа?\"},{\"answers\":[{\"text\":\"Смежность в графе определяет отношение между вершинами или рёбрами, соединёнными ребром, что помогает анализировать структуру графа.\",\"generated_as_correct\":true},{\"text\":\"Смежность в графе определяется как отношение между вершинами, которые имеют одинаковую степень, независимо от того, соединены они ребром или нет.\",\"generated_as_correct\":false},{\"text\":\"Понятие смежности используется в теории графов для определения цветовой схемы вершин при раскраске графа, что не имеет прямого отношения к свойствам графа.\",\"generated_as_correct\":false},{\"text\":\"Смежность в графе описывает отношение между вершинами на одинаковом расстоянии, независимо от соединения ребром.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать понятие смежности для определения свойств графа?\"},{\"answers\":[{\"text\":\"Инцидентность — это связь ребра с вершиной в графе.\",\"generated_as_correct\":true},{\"text\":\"Инцидентность в теории графов определяется как количество рёбер, соединяющих две вершины.\",\"generated_as_correct\":false},{\"text\":\"Инцидентность в теории графов связана с вероятностью пересечения рёбер при случайном выборе вершин.\",\"generated_as_correct\":false},{\"text\":\"Инцидентность описывает количество вершин, соединённых одним ребром.\",\"generated_as_correct\":false}],\"question\":\"Что такое инцидентность в контексте теории графов?\"},{\"answers\":[{\"text\":\"Инцидентность важна, так как определяет связи между вершинами и рёбрами в графе.\",\"generated_as_correct\":true},{\"text\":\"Инцидентность важна для анализа графа, потому что она определяет количество вершин в графе и их координаты в пространстве.\",\"generated_as_correct\":false},{\"text\":\"Инцидентность используется в теории графов для определения циклов и путей, но не имеет отношения к топологическим свойствам графа.\",\"generated_as_correct\":false},{\"text\":\"Инцидентность важна для определения веса рёбер в графе.\",\"generated_as_correct\":false}],\"question\":\"Почему понятие инцидентности важно для анализа топологических свойств графа?\"},{\"answers\":[{\"text\":\"Инцидентность — это связь ребра с вершиной в графе, помогающая анализировать его структуру.\",\"generated_as_correct\":true},{\"text\":\"Инцидентность в графе описывает количество рёбер, входящих в вершину, и используется для определения веса вершины в сети.\",\"generated_as_correct\":false},{\"text\":\"Инцидентность используется в теории графов для классификации типов графов по их цветовой схеме и не имеет отношения к анализу связей между вершинами и рёбрами.\",\"generated_as_correct\":false},{\"text\":\"Инцидентность описывает отношение между двумя рёбрами в графе, которые пересекаются в одной вершине.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать понятие инцидентности для анализа связей между вершинами и рёбрами в графе?\"},{\"answers\":[{\"text\":\"Мультиграф — это граф с несколькими рёбрами между вершинами.\",\"generated_as_correct\":true},{\"text\":\"Мультиграф — это особый вид графа, в котором все вершины соединены друг с другом через уникальные рёбра без возможности повторения связей.\",\"generated_as_correct\":false},{\"text\":\"Мультиграф — это концепция, используемая в теории графов для описания структуры данных, которая не допускает наличия циклов.\",\"generated_as_correct\":false},{\"text\":\"Мультиграф — это граф, в котором между вершинами не может быть более одного ребра.\",\"generated_as_correct\":false}],\"question\":\"Что такое мультиграф?\"},{\"answers\":[{\"text\":\"Мультиграф допускает наличие нескольких рёбер между вершинами.\",\"generated_as_correct\":true},{\"text\":\"Мультиграф отличается от обычного графа тем, что в нём вершины могут быть соединены рёбрами только в одном направлении, образуя ориентированный граф.\",\"generated_as_correct\":false},{\"text\":\"Мультиграф используется для создания визуальных иерархий и отличается от обычного графа наличием специальных узлов, которые определяют структуру данных.\",\"generated_as_correct\":false},{\"text\":\"Мультиграф отличается от обычного графа отсутствием циклов.\",\"generated_as_correct\":false}],\"question\":\"Чем отличается мультиграф от обычного графа?\"},{\"answers\":[{\"text\":\"Мультиграф полезен для представления сетей с множеством связей между объектами.\",\"generated_as_correct\":true},{\"text\":\"Мультиграф применяется для визуализации иерархических структур, где каждая вершина имеет только одно входящее и одно исходящее ребро.\",\"generated_as_correct\":false},{\"text\":\"Мультиграф используется в теории игр для моделирования стратегий взаимодействия между игроками в условиях неопределённости.\",\"generated_as_correct\":false},{\"text\":\"Мультиграф применяется для представления сетей, где между вершинами не может быть более одного ребра.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть полезно использовать мультиграф для представления сетей?\"},{\"answers\":[{\"text\":\"Взвешенный граф — это граф с рёбрами, имеющим числовые веса.\",\"generated_as_correct\":true},{\"text\":\"Взвешенный граф — это граф, в котором вес ребра определяется случайным образом и не имеет конкретного значения, связанного с реальными характеристиками.\",\"generated_as_correct\":false},{\"text\":\"Взвешенный граф — это концепция, используемая в теории графов для анализа социальных сетей, где вес ребра указывает на степень взаимодействия между людьми.\",\"generated_as_correct\":false},{\"text\":\"Взвешенный граф — это граф, где вес вершины определяет его основные характеристики.\",\"generated_as_correct\":false}],\"question\":\"Что такое взвешенный граф?\"},{\"answers\":[{\"text\":\"Веса в взвешенных графах присваиваются рёбрам для представления таких значений, как расстояние или стоимость.\",\"generated_as_correct\":true},{\"text\":\"В взвешенных графах веса рёбер присваиваются случайным образом для создания более сложных математических моделей, не имеющих конкретного прикладного значения.\",\"generated_as_correct\":false},{\"text\":\"В взвешенных графах веса рёбер используются для определения цветовой схемы при визуализации графа, что помогает в интерпретации данных.\",\"generated_as_correct\":false},{\"text\":\"Веса в взвешенных графах присваиваются рёбрам для обозначения их приоритета в алгоритмах сортировки узлов.\",\"generated_as_correct\":false}],\"question\":\"Почему в взвешенных графах рёбрам присваиваются веса?\"},{\"answers\":[{\"text\":\"Взвешенные графы позволяют моделировать транспортные сети, представляя узлы как вершины, а связи между ними — как рёбра с весами, обозначающими расстояние или стоимость.\",\"generated_as_correct\":true},{\"text\":\"Взвешенные графы моделируют транспортные сети, присваивая весам рёбер значения, которые не имеют отношения к реальным расстояниям или стоимостям, а являются абстрактными величинами, не влияющими на выбор маршрута.\",\"generated_as_correct\":false},{\"text\":\"Взвешенные графы находят применение в теории игр для анализа стратегий и решений, что не имеет прямого отношения к моделированию транспортных сетей.\",\"generated_as_correct\":false},{\"text\":\"Взвешенные графы используются для моделирования транспортных сетей исключительно для определения количества возможных маршрутов между узлами без учёта их характеристик.\",\"generated_as_correct\":false}],\"question\":\"Как взвешенные графы могут применяться для моделирования транспортных сетей?\"},{\"answers\":[{\"text\":\"Двудольный граф — это граф, вершины которого разделены на две доли, и рёбра соединяют только вершины из разных долей.\",\"generated_as_correct\":true},{\"text\":\"Двудольный граф — это граф, в котором вершины разделены на две группы, и каждая вершина соединена хотя бы одним ребром с каждой вершиной из своей группы.\",\"generated_as_correct\":false},{\"text\":\"Двудольный граф — это особый вид графа, который используется для визуализации иерархических структур и построения деревьев.\",\"generated_as_correct\":false},{\"text\":\"Двудольный граф — это граф, в котором все вершины соединены между собой внутри своих долей.\",\"generated_as_correct\":false}],\"question\":\"Что такое двудольный граф?\"},{\"answers\":[{\"text\":\"По определению двудольного графа, вершины в одной доле не смежны.\",\"generated_as_correct\":true},{\"text\":\"В двудольном графе вершины одной доли могут быть смежными, если они имеют общий инцидентный им ребро.\",\"generated_as_correct\":false},{\"text\":\"В двудольном графе смежность вершин определяется их принадлежностью к различным подмножествам вершин, что позволяет использовать такие графы для анализа сетевых структур.\",\"generated_as_correct\":false},{\"text\":\"В двудольном графе вершины в одной доле могут быть смежными.\",\"generated_as_correct\":false}],\"question\":\"Почему в двудольном графе никакие две вершины в одной доле не могут быть смежными?\"},{\"answers\":[{\"text\":\"Двудольные графы показывают отношения между двумя различными наборами объектов, где связи возможны только между разными долями.\",\"generated_as_correct\":true},{\"text\":\"Двудольные графы представляют отношения между объектами, где каждая вершина может быть связана с любой другой вершиной независимо от доли, к которой они принадлежат.\",\"generated_as_correct\":false},{\"text\":\"Двудольные графы применяются в теории графов для определения кратчайших путей между вершинами в сложных сетях.\",\"generated_as_correct\":false},{\"text\":\"Двудольные графы отображают отношения между объектами внутри одной группы.\",\"generated_as_correct\":false}],\"question\":\"Как двудольные графы могут быть применены для представления отношений между двумя наборами объектов?\"},{\"answers\":[{\"text\":\"Полный граф — это граф со всеми возможными рёбрами между вершинами.\",\"generated_as_correct\":true},{\"text\":\"Полный граф — это граф, в котором рёбра присутствуют только между вершинами, расположенными на одной линии, образуя линейную структуру.\",\"generated_as_correct\":false},{\"text\":\"Полный граф — это концепция, используемая в теории графов для описания сетей, где важна не столько связность, сколько направление потоков данных между узлами.\",\"generated_as_correct\":false},{\"text\":\"Полный граф — это граф, где вершины соединены только с соседними вершинами.\",\"generated_as_correct\":false}],\"question\":\"Что такое полный граф?\"},{\"answers\":[{\"text\":\"Полные графы имеют максимальную связность, так как каждая вершина соединена со всеми другими.\",\"generated_as_correct\":true},{\"text\":\"Полные графы считаются примером графов с максимальной связностью из-за того, что они содержат только вершины и не имеют рёбер, что делает их максимально гибкими для различных соединений.\",\"generated_as_correct\":false},{\"text\":\"Полные графы используются в теории графов для анализа сетевых структур, но их связность не считается максимальной, так как они не учитывают веса рёбер и направления дуг.\",\"generated_as_correct\":false},{\"text\":\"Полные графы имеют минимальную связность из-за отсутствия некоторых рёбер между вершинами.\",\"generated_as_correct\":false}],\"question\":\"Почему полные графы считаются примером графов с максимальной связностью?\"},{\"answers\":[{\"text\":\"Полные графы моделируют ситуации, где все объекты связаны между собой.\",\"generated_as_correct\":true},{\"text\":\"Полные графы подходят для моделирования систем, где связи между объектами устанавливаются случайным образом и не обязательно включают все возможные соединения.\",\"generated_as_correct\":false},{\"text\":\"Полные графы могут быть использованы для анализа сетевых структур в компьютерных системах, но не учитывают динамические изменения в связях между узлами.\",\"generated_as_correct\":false},{\"text\":\"Полные графы применяются для моделирования систем с минимальной связностью между объектами.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях полные графы могут быть использованы для моделирования связей между объектами?\"},{\"answers\":[{\"text\":\"Путь в графе — это последовательность связанных рёбер между вершинами.\",\"generated_as_correct\":true},{\"text\":\"Путь в графе — это множество вершин, которые не соединены рёбрами, но рассматриваются вместе для анализа структуры графа.\",\"generated_as_correct\":false},{\"text\":\"Путь в графе связан с определением циклов и используется для расчёта хроматического числа графа.\",\"generated_as_correct\":false},{\"text\":\"Путь в графе — это произвольный набор вершин без учёта рёбер между ними.\",\"generated_as_correct\":false}],\"question\":\"Что такое путь в графе?\"},{\"answers\":[{\"text\":\"Путь в графе — это последовательность связанных рёбер, соединяющая вершины, что важно для анализа его связности.\",\"generated_as_correct\":true},{\"text\":\"Понятие пути важно для анализа связности графа, потому что оно определяет количество вершин в графе, что позволяет оценить его размер и сложность.\",\"generated_as_correct\":false},{\"text\":\"Понятие пути используется в теории графов для определения циклов и петель, что помогает в анализе структуры графа, но не связано напрямую с его связностью.\",\"generated_as_correct\":false},{\"text\":\"Путь в графе определяет количество рёбер, исходящих из вершины, что не имеет отношения к анализу связности графа.\",\"generated_as_correct\":false}],\"question\":\"Почему понятие пути важно для анализа связности графа?\"},{\"answers\":[{\"text\":\"Путь в графе — это последовательность связанных рёбер между вершинами.\",\"generated_as_correct\":true},{\"text\":\"Путь в графе определяется как количество вершин в графе, независимо от их соединения рёбрами.\",\"generated_as_correct\":false},{\"text\":\"Путь в графе используется для определения циклов и петель, что помогает в анализе структуры графа, но не связано с определением маршрутов между вершинами.\",\"generated_as_correct\":false},{\"text\":\"Путь в графе — это количество рёбер, не учитывающее их связь между вершинами.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать понятие пути для определения возможных маршрутов между вершинами в графе?\"},{\"answers\":[{\"text\":\"Цикл — это путь в графе, начинающийся и заканчивающийся в одной вершине.\",\"generated_as_correct\":true},{\"text\":\"Цикл в графе — это набор вершин, которые не соединены друг с другом и не образуют замкнутый путь.\",\"generated_as_correct\":false},{\"text\":\"Цикл в графе связан с количеством рёбер, исходящих из вершины, и используется для определения степени вершины.\",\"generated_as_correct\":false},{\"text\":\"Цикл — это путь в графе между двумя различными вершинами.\",\"generated_as_correct\":false}],\"question\":\"Что такое цикл в графе?\"},{\"answers\":[{\"text\":\"Цикл — это путь в графе, начинающийся и заканчивающийся в одной вершине, что важно для анализа циклических свойств графа.\",\"generated_as_correct\":true},{\"text\":\"Цикл в графе — это набор вершин, которые не соединены друг с другом. Это понятие важно для анализа структуры графа, поскольку позволяет выявить вершины, не участвующие в связях.\",\"generated_as_correct\":false},{\"text\":\"Цикл в графе важен для определения его планарности и для решения задач, связанных с раскраской графа.\",\"generated_as_correct\":false},{\"text\":\"Цикл — это связь между двумя вершинами в графе, что важно для определения его связности.\",\"generated_as_correct\":false}],\"question\":\"Почему понятие цикла важно для анализа структуры графа?\"},{\"answers\":[{\"text\":\"Информацию о циклах в графе используют для анализа его циклических свойств и структуры.\",\"generated_as_correct\":true},{\"text\":\"Информацию о циклах в графе можно использовать для вычисления количества рёбер в графе, так как каждый цикл добавляет определённое количество рёбер к общей сумме.\",\"generated_as_correct\":false},{\"text\":\"Информацию о циклах в графе можно использовать для расчёта его хроматического числа, которое определяет минимальное количество цветов, необходимых для раскраски графа.\",\"generated_as_correct\":false},{\"text\":\"Информацию о циклах в графе используют для определения количества вершин в нём.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать информацию о циклах в графе для определения его циклических свойств?\"},{\"answers\":[{\"text\":\"Дерево — это граф без циклов.\",\"generated_as_correct\":true},{\"text\":\"Дерево в теории графов — это направленный граф, в котором каждый узел имеет ровно одного родителя, за исключением корневого узла.\",\"generated_as_correct\":false},{\"text\":\"Дерево в теории графов тесно связано с понятием сети и используется для анализа потоков данных в коммуникационных системах.\",\"generated_as_correct\":false},{\"text\":\"Дерево — это связный граф с циклами.\",\"generated_as_correct\":false}],\"question\":\"Что такое дерево в контексте теории графов?\"},{\"answers\":[{\"text\":\"Дерево — это граф без циклов, что обеспечивает его иерархическую структуру.\",\"generated_as_correct\":true},{\"text\":\"Отсутствие циклов не является ключевым свойством дерева; на самом деле, наличие циклов делает граф более устойчивым и надёжным для представления иерархических структур.\",\"generated_as_correct\":false},{\"text\":\"Отсутствие циклов важно для деревьев, так как это свойство связано с алгоритмами поиска в ширину и глубину, которые применяются для анализа графов.\",\"generated_as_correct\":false},{\"text\":\"Дерево — это граф с циклами, что позволяет ему иметь альтернативные пути между узлами.\",\"generated_as_correct\":false}],\"question\":\"Почему отсутствие циклов является ключевым свойством дерева?\"},{\"answers\":[{\"text\":\"Деревья — это графы без циклов, используемые для представления иерархий, например, в генеалогии или файловых системах.\",\"generated_as_correct\":true},{\"text\":\"Деревья применяются для представления линейных структур данных, например, списков и очередей, что позволяет эффективно организовывать информацию в последовательностях.\",\"generated_as_correct\":false},{\"text\":\"Деревья используются в алгоритмах машинного обучения для классификации данных и построения моделей прогнозирования, что не связано напрямую с представлением иерархических структур.\",\"generated_as_correct\":false},{\"text\":\"Деревья применяются для создания циклических структур данных в программировании.\",\"generated_as_correct\":false}],\"question\":\"Как деревья используются для представления иерархических структур в реальных приложениях?\"},{\"answers\":[{\"text\":\"Связный граф — это граф, где между любыми вершинами есть путь.\",\"generated_as_correct\":true},{\"text\":\"Связный граф — это граф, в котором все вершины соединены друг с другом прямыми рёбрами без возможности альтернативных путей.\",\"generated_as_correct\":false},{\"text\":\"Связный граф — это концепция, используемая в теории графов для описания структуры данных, которая не имеет отношения к возможности соединения вершин путями.\",\"generated_as_correct\":false},{\"text\":\"Связный граф — это граф, в котором каждая вершина соединена с центральной вершиной.\",\"generated_as_correct\":false}],\"question\":\"Что такое связный граф?\"},{\"answers\":[{\"text\":\"Связный граф важен для анализа связности сети, так как показывает, можно ли добраться от одной вершины до другой.\",\"generated_as_correct\":true},{\"text\":\"Понятие связного графа важно для анализа связности сети, потому что оно определяет количество вершин в сети и позволяет вычислить общую длину всех путей в графе.\",\"generated_as_correct\":false},{\"text\":\"Понятие связного графа используется в теории графов для классификации графов по их структуре и не имеет прямого отношения к анализу связности сети.\",\"generated_as_correct\":false},{\"text\":\"Связный граф важен для анализа количества вершин в сети.\",\"generated_as_correct\":false}],\"question\":\"Почему понятие связного графа важно для анализа связности сети?\"},{\"answers\":[{\"text\":\"В связном графе любая вершина достижима из любой другой.\",\"generated_as_correct\":true},{\"text\":\"В связном графе возможность достижения одной вершины из другой определяется наличием общего ребра между ними, без учёта промежуточных вершин и путей.\",\"generated_as_correct\":false},{\"text\":\"Определение связного графа используется для анализа циклов в графе и определения его эйлеровых свойств, что не связано напрямую с достижимостью вершин.\",\"generated_as_correct\":false},{\"text\":\"В связном графе вершины соединены только прямыми рёбрами, без возможности использования промежуточных вершин.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать определение связного графа для определения возможности достижения одной вершины из другой?\"},{\"answers\":[{\"text\":\"Ориентированный граф слабо связный, если его неориентированный аналог связен.\",\"generated_as_correct\":true},{\"text\":\"Ориентированный граф считается слабо связным, если из каждой вершины можно добраться до любой другой вершины, следуя по направлениям рёбер.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный граф является слабо связным, если количество его вершин превышает количество рёбер.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный граф слабо связный, если каждая вершина имеет путь к любой другой вершине.\",\"generated_as_correct\":false}],\"question\":\"Что означает, что ориентированный граф является слабо связным?\"},{\"answers\":[{\"text\":\"Граф сильно связен, если из любой вершины достижима любая другая.\",\"generated_as_correct\":true},{\"text\":\"Ориентированный граф является сильно связным, если каждая вершина имеет одинаковое количество входящих и исходящих рёбер.\",\"generated_as_correct\":false},{\"text\":\"Для определения сильной связности ориентированного графа необходимо посчитать количество его вершин и рёбер, а затем сравнить эти значения.\",\"generated_as_correct\":false},{\"text\":\"Граф сильно связен, если он содержит цикл, проходящий через все вершины.\",\"generated_as_correct\":false}],\"question\":\"Как можно определить, является ли ориентированный граф сильно связным?\"},{\"answers\":[{\"text\":\"Сильная и слабая связность помогают анализировать возможность достижения вершин в ориентированных графах.\",\"generated_as_correct\":true},{\"text\":\"Понятия сильной и слабой связности используются для определения количества рёбер в ориентированном графе, где сильная связность указывает на максимальное количество рёбер, а слабая — на минимальное.\",\"generated_as_correct\":false},{\"text\":\"Понятия сильной и слабой связности могут быть полезны при анализе алгоритмов сортировки и поиска в ориентированных графах, так как они помогают определить оптимальный путь для обхода графа.\",\"generated_as_correct\":false},{\"text\":\"Сильная и слабая связность используются для определения количества вершин в ориентированном графе.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях понятия сильной и слабой связности могут быть полезны при анализе ориентированных графов?\"},{\"answers\":[{\"text\":\"Степень вершины — это число рёбер, связанных с этой вершиной.\",\"generated_as_correct\":true},{\"text\":\"Степень вершины в графе — это сумма весов всех рёбер, соединённых с данной вершиной.\",\"generated_as_correct\":false},{\"text\":\"Степень вершины в графе тесно связана с понятием циклов в графе и используется для определения наличия гамильтонова пути.\",\"generated_as_correct\":false},{\"text\":\"Степень вершины — это количество вершин, соединённых с данной вершиной через пути.\",\"generated_as_correct\":false}],\"question\":\"Что такое степень вершины в графе?\"},{\"answers\":[{\"text\":\"Степень вершины — это количество рёбер, связанных с ней, что показывает её связность в графе.\",\"generated_as_correct\":true},{\"text\":\"Степень вершины важна, так как она показывает максимальное количество путей, которые могут проходить через данную вершину в графе.\",\"generated_as_correct\":false},{\"text\":\"Степень вершины имеет значение в теории графов, поскольку используется для определения хроматического числа графа и его раскраски.\",\"generated_as_correct\":false},{\"text\":\"Степень вершины отражает количество циклов, проходящих через данную вершину в графе.\",\"generated_as_correct\":false}],\"question\":\"Почему степень вершины считается важным показателем в теории графов?\"},{\"answers\":[{\"text\":\"Степень вершины — это количество рёбер, связанных с вершиной.\",\"generated_as_correct\":true},{\"text\":\"Степень вершины в графе определяется как количество путей, проходящих через данную вершину, что позволяет оценить её важность в графе.\",\"generated_as_correct\":false},{\"text\":\"Степень вершины используется для определения циклов в графе и помогает выявить связные компоненты графа.\",\"generated_as_correct\":false},{\"text\":\"Степень вершины показывает, сколько вершин находится на расстоянии одного шага от данной вершины.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать понятие степени вершины для анализа связей между вершинами в графе?\"},{\"answers\":[{\"text\":\"Полустепень исхода — количество выходящих из вершины дуг, полустепень захода — количество входящих в вершину дуг.\",\"generated_as_correct\":true},{\"text\":\"Полустепень исхода и полустепень захода в ориентированном графе определяются как общее количество вершин, соединённых с данной вершиной, независимо от направления дуг.\",\"generated_as_correct\":false},{\"text\":\"Полустепень исхода и захода используются для определения циклов в неориентированном графе и не имеют отношения к количеству дуг, входящих или выходящих из вершины.\",\"generated_as_correct\":false},{\"text\":\"Полустепень исхода и полустепень захода — это общее количество дуг в ориентированном графе, не зависящее от направления.\",\"generated_as_correct\":false}],\"question\":\"Что такое полустепень исхода и полустепень захода в ориентированном графе?\"},{\"answers\":[{\"text\":\"Полустепени исхода и захода показывают количество и направление связей вершины в ориентированном графе.\",\"generated_as_correct\":true},{\"text\":\"Полустепени исхода и захода важны для анализа неориентированных графов, так как показывают общее количество рёбер, связанных с вершиной.\",\"generated_as_correct\":false},{\"text\":\"Полустепени исхода и захода используются для определения циклов в ориентированных графах и не имеют отношения к анализу связей вершин.\",\"generated_as_correct\":false},{\"text\":\"Полустепени исхода и захода определяют общее количество вершин в ориентированном графе.\",\"generated_as_correct\":false}],\"question\":\"Почему полустепени исхода и захода считаются важными показателями для анализа ориентированных графов?\"},{\"answers\":[{\"text\":\"Полустепень исхода показывает количество выходящих из вершины дуг, а полустепень захода — входящих.\",\"generated_as_correct\":true},{\"text\":\"Полустепень исхода и захода — это общее количество всех дуг в ориентированном графе, независимо от направления их связи с вершиной.\",\"generated_as_correct\":false},{\"text\":\"Полустепени исхода и захода используются для определения циклов в ориентированном графе и не имеют отношения к количеству связей вершины.\",\"generated_as_correct\":false},{\"text\":\"Полустепень исхода и захода определяют общее количество вершин в ориентированном графе.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать полустепени исхода и захода для характеристики направления и количества связей вершины в ориентированном графе?\"}],\"StoreCardId\":null,\"numberInCourse\":\"5.1\"},{\"Name\":\"algo | 5.2. Представление графа в памяти компьютера\",\"Slug\":\"predstavlenie-grafa-v-pamyati-kompyutera\",\"createdAt\":\"2024-07-03T17:33:43.763Z\",\"updatedAt\":\"2026-01-10T12:07:07.988Z\",\"publishedAt\":\"2024-07-03T17:33:44.974Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80790/problem\",\"Lead\":null,\"Content\":\"$6b\",\"Title\":\"Представление графа в памяти компьютера\",\"LikesCount\":26,\"Quiz\":[{\"answers\":[{\"text\":\"Матрица смежности — это матрица, представляющая граф, где 1 указывает на наличие ребра между вершинами, а 0 — на его отсутствие.\",\"generated_as_correct\":true},{\"text\":\"Матрица смежности — это таблица, где строки соответствуют вершинам графа, а столбцы — весу рёбер. На пересечении строки и столбца указывается вес ребра между вершинами.\",\"generated_as_correct\":false},{\"text\":\"Матрица смежности используется для описания связей между элементами в системах управления и не имеет отношения к графам.\",\"generated_as_correct\":false},{\"text\":\"Матрица смежности — это список вершин графа, где каждая вершина имеет свой номер и вес.\",\"generated_as_correct\":false}],\"question\":\"Что такое матрица смежности и как она связана с графами?\"},{\"answers\":[{\"text\":\"0 в матрице смежности означает отсутствие ребра, 1 — наличие ребра между вершинами.\",\"generated_as_correct\":true},{\"text\":\"В матрице смежности значения 0 и 1 обозначают вес ребра между вершинами: 0 — лёгкое ребро, 1 — тяжёлое ребро.\",\"generated_as_correct\":false},{\"text\":\"Значения 0 и 1 в матрице смежности используются для определения количества вершин в графе и не имеют отношения к наличию или отсутствию рёбер.\",\"generated_as_correct\":false},{\"text\":\"0 в матрице смежности указывает на наличие ребра, а 1 — на его отсутствие.\",\"generated_as_correct\":false}],\"question\":\"Как интерпретировать значения 0 и 1 в ячейках матрицы смежности?\"},{\"answers\":[{\"text\":\"Матрица смежности позволяет быстро определить наличие рёбер между вершинами графа.\",\"generated_as_correct\":true},{\"text\":\"Матрица смежности применяется для визуализации графов и помогает наглядно представить структуру графа в виде схемы или диаграммы.\",\"generated_as_correct\":false},{\"text\":\"Матрица смежности используется для расчёта кратчайших путей между вершинами графа с помощью алгоритмов поиска, таких как алгоритм Дейкстры.\",\"generated_as_correct\":false},{\"text\":\"Матрица смежности используется для подсчёта общего количества вершин в графе.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть полезно использовать матрицу смежности при алгоритмической обработке графов?\"},{\"answers\":[{\"text\":\"Матрица смежности неориентированного графа симметрична относительно главной диагонали из-за отсутствия направления у рёбер.\",\"generated_as_correct\":true},{\"text\":\"Симметричность матрицы смежности для неориентированного графа означает, что все элементы матрицы равны между собой, независимо от их положения относительно главной диагонали.\",\"generated_as_correct\":false},{\"text\":\"Симметричность матрицы смежности для неориентированного графа связана с количеством вершин в графе и не зависит от наличия или отсутствия рёбер между ними.\",\"generated_as_correct\":false},{\"text\":\"Матрица смежности неориентированного графа асимметрична относительно главной диагонали.\",\"generated_as_correct\":false}],\"question\":\"Что означает симметричность матрицы смежности для неориентированного графа?\"},{\"answers\":[{\"text\":\"Матрица смежности неориентированного графа симметрична, так как рёбра не имеют направления и представлены одинаково в позициях (i, j) и (j, i).\",\"generated_as_correct\":true},{\"text\":\"Матрица смежности для неориентированного графа симметрична относительно главной диагонали, так как количество вершин в графе всегда равно количеству рёбер, что обеспечивает зеркальное отображение значений относительно диагонали.\",\"generated_as_correct\":false},{\"text\":\"Матрица смежности для неориентированного графа симметрична относительно главной диагонали из-за свойств определителя матрицы, которые используются для вычисления количества возможных путей между вершинами.\",\"generated_as_correct\":false},{\"text\":\"Матрица смежности неориентированного графа симметрична, потому что количество вершин всегда чётное.\",\"generated_as_correct\":false}],\"question\":\"Почему матрица смежности неориентированного графа симметрична относительно главной диагонали?\"},{\"answers\":[{\"text\":\"Матрица смежности неориентированного графа симметрична относительно главной диагонали.\",\"generated_as_correct\":true},{\"text\":\"Матрица смежности симметрична для любого графа, независимо от наличия или отсутствия направления у рёбер, потому что каждая вершина соединена с каждой другой вершиной.\",\"generated_as_correct\":false},{\"text\":\"Симметричность матрицы смежности используется для определения циклов в графе, а не для определения типа графа (ориентированный или неориентированный).\",\"generated_as_correct\":false},{\"text\":\"Матрица смежности ориентированного графа симметрична относительно главной диагонали.\",\"generated_as_correct\":false}],\"question\":\"Как симметричность матрицы смежности может быть использована для определения типа графа (ориентированный или неориентированный)?\"},{\"answers\":[{\"text\":\"Матрица инцидентности — матрица, где вершины графа расположены в строках, рёбра — в столбцах, и 1 ставится, если вершина инцидентна ребру.\",\"generated_as_correct\":true},{\"text\":\"Матрица инцидентности — это таблица, где строки соответствуют рёбрам графа, а столбцы — вершинам, и на пересечении ставится значение, равное весу ребра.\",\"generated_as_correct\":false},{\"text\":\"Матрица инцидентности используется для представления сетей и помогает в анализе потоков данных между узлами в компьютерной сети.\",\"generated_as_correct\":false},{\"text\":\"Матрица инцидентности — это таблица, в которой указываются веса рёбер графа.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой матрица инцидентности?\"},{\"answers\":[{\"text\":\"В матрице инцидентности на пересечении строки вершины и столбца ребра ставится 1, если вершина является концом ребра.\",\"generated_as_correct\":true},{\"text\":\"В матрице инцидентности связь между вершинами и рёбрами графа отображается путём присвоения каждому ребру уникального номера, который записывается в соответствующую ячейку матрицы на пересечении строки и столбца, соответствующих вершинам.\",\"generated_as_correct\":false},{\"text\":\"В матрице инцидентности связь между вершинами и рёбрами графа отображается с помощью специальных символов, которые обозначают типы связей между элементами графа.\",\"generated_as_correct\":false},{\"text\":\"В матрице инцидентности связь между вершинами и рёбрами графа отображается через присвоение рёбрам весов, которые записываются в соответствующие ячейки матрицы.\",\"generated_as_correct\":false}],\"question\":\"Как в матрице инцидентности отображается связь между вершинами и рёбрами графа?\"},{\"answers\":[{\"text\":\"Матрица инцидентности помогает определить связь между вершинами и рёбрами графа.\",\"generated_as_correct\":true},{\"text\":\"Матрица инцидентности применяется для вычисления количества циклов в графе и определения его эйлеровых путей.\",\"generated_as_correct\":false},{\"text\":\"Матрица инцидентности важна для алгоритмов машинного обучения, где она используется для представления графов в виде векторов признаков.\",\"generated_as_correct\":false},{\"text\":\"Матрица инцидентности нужна для расчёта весов рёбер в графе.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть полезно использовать матрицу инцидентности при анализе графа?\"},{\"answers\":[{\"text\":\"Список смежности — это набор списков смежных вершин для каждой вершины графа.\",\"generated_as_correct\":true},{\"text\":\"Список смежности — это таблица, в которой указаны расстояния между всеми вершинами графа.\",\"generated_as_correct\":false},{\"text\":\"Список смежности используется для хранения информации о вершинах в дереве и применяется при реализации алгоритмов сортировки.\",\"generated_as_correct\":false},{\"text\":\"Список смежности — это список всех рёбер графа.\",\"generated_as_correct\":false}],\"question\":\"Что такое список смежности?\"},{\"answers\":[{\"text\":\"Список смежности эффективен для хранения графов, так как быстро позволяет определить смежные вершины.\",\"generated_as_correct\":true},{\"text\":\"Список смежности эффективен, поскольку он хранит информацию о всех возможных путях между вершинами графа, что позволяет быстро находить кратчайшие пути.\",\"generated_as_correct\":false},{\"text\":\"Список смежности используется для хранения графов, потому что он позволяет легко визуализировать структуру графа в виде таблицы.\",\"generated_as_correct\":false},{\"text\":\"Список смежности полезен для хранения графов, поскольку содержит информацию о расстоянии между вершинами.\",\"generated_as_correct\":false}],\"question\":\"Почему список смежности считается эффективным способом хранения графа?\"},{\"answers\":[{\"text\":\"Список смежности — это способ представления графа, который позволяет быстро определить смежные вершины и эффективно реализовывать алгоритмы обхода.\",\"generated_as_correct\":true},{\"text\":\"Список смежности представляет собой единый список всех вершин графа, упорядоченных по их степени смежности. Это упрощает реализацию алгоритмов обхода, так как можно быстро найти любую вершину.\",\"generated_as_correct\":false},{\"text\":\"Список смежности используется в алгоритмах сортировки вершин графа по определённым критериям, что помогает в задачах оптимизации и анализа графов.\",\"generated_as_correct\":false},{\"text\":\"Список смежности используется для хранения информации о рёбрах графа, что упрощает реализацию алгоритмов поиска кратчайших путей.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать список смежности при реализации алгоритмов обхода графа?\"},{\"answers\":[{\"text\":\"Список рёбер — это перечень всех рёбер в графе.\",\"generated_as_correct\":true},{\"text\":\"Список рёбер представляет собой графическое изображение всех рёбер графа без их перечисления.\",\"generated_as_correct\":false},{\"text\":\"Список рёбер связан с теорией графов и используется для определения количества вершин в графе.\",\"generated_as_correct\":false},{\"text\":\"Список рёбер — это список всех вершин в графе.\",\"generated_as_correct\":false}],\"question\":\"Что такое список рёбер в контексте теории графов?\"},{\"answers\":[{\"text\":\"Список рёбер удобен для анализа свойств рёбер графа, так как содержит все рёбра и их связи.\",\"generated_as_correct\":true},{\"text\":\"Список рёбер полезен при анализе свойств вершин графа, поскольку содержит информацию о всех вершинах и их связях, что позволяет быстро определить степень каждой вершины.\",\"generated_as_correct\":false},{\"text\":\"Список рёбер используется в теории графов для определения циклов и путей в графе, но не имеет отношения к анализу свойств рёбер.\",\"generated_as_correct\":false},{\"text\":\"Список рёбер применяется только для визуального представления графа и не используется для анализа его свойств.\",\"generated_as_correct\":false}],\"question\":\"Почему список рёбер может быть полезен при анализе свойств рёбер графа?\"},{\"answers\":[{\"text\":\"Список рёбер применяется в алгоритмах на графах для анализа свойств рёбер и вычислений.\",\"generated_as_correct\":true},{\"text\":\"Список рёбер применяется при реализации алгоритмов на графах только в случаях, когда граф является полным и все вершины соединены друг с другом.\",\"generated_as_correct\":false},{\"text\":\"Список рёбер может быть использован для создания матриц смежности, которые применяются в теории графов для представления связей между вершинами, но не для анализа свойств рёбер.\",\"generated_as_correct\":false},{\"text\":\"Список рёбер используется в алгоритмах на графах только для подсчёта общего количества рёбер в графе.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях список рёбер может применяться при реализации алгоритмов на графах?\"}],\"StoreCardId\":null,\"numberInCourse\":\"5.2\"},{\"Name\":\"algo | 5.3 Обходы графа\",\"Slug\":\"obhody-grafa\",\"createdAt\":\"2024-07-03T17:34:07.569Z\",\"updatedAt\":\"2026-01-10T12:07:07.525Z\",\"publishedAt\":\"2024-07-03T17:34:08.849Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80791/problem\",\"Lead\":null,\"Content\":\"$6c\",\"Title\":\"Обходы графа\",\"LikesCount\":18,\"Quiz\":[{\"answers\":[{\"text\":\"Обход графа — это систематический просмотр вершин и рёбер графа для анализа его структуры.\",\"generated_as_correct\":true},{\"text\":\"Обход графа — это метод построения графа путём добавления новых вершин и рёбер в определённом порядке.\",\"generated_as_correct\":false},{\"text\":\"Обход графа — это способ визуализации графа с помощью специальных программ, который помогает представить структуру графа в графическом виде.\",\"generated_as_correct\":false},{\"text\":\"Обход графа — это процесс удаления вершин и рёбер из графа для упрощения его структуры.\",\"generated_as_correct\":false}],\"question\":\"Что такое обход графа?\"},{\"answers\":[{\"text\":\"Обход графа — фундаментальная операция для анализа структуры графа и решения задач поиска пути и определения связности.\",\"generated_as_correct\":true},{\"text\":\"Обход графа — это второстепенная операция в теории графов, которая применяется исключительно для подсчёта количества вершин и рёбер в графе.\",\"generated_as_correct\":false},{\"text\":\"Обход графа связан с алгоритмами сортировки и используется для упорядочивания вершин по определённым критериям, что не имеет прямого отношения к его фундаментальности в теории графов.\",\"generated_as_correct\":false},{\"text\":\"Обход графа используется только для построения графа и не имеет значения для анализа его структуры.\",\"generated_as_correct\":false}],\"question\":\"Почему обход графа считается фундаментальной операцией в теории графов?\"},{\"answers\":[{\"text\":\"Обход графа помогает найти путь между вершинами путём систематического просмотра структуры графа.\",\"generated_as_correct\":true},{\"text\":\"Обход графа применяется для определения количества вершин в графе, что не связано с поиском пути.\",\"generated_as_correct\":false},{\"text\":\"Обход графа важен для вычисления хроматического числа графа, что не имеет прямого отношения к поиску пути.\",\"generated_as_correct\":false},{\"text\":\"Обход графа служит для подсчёта количества рёбер в графе, что не связано с поиском пути.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить обход графа для решения задачи поиска пути в графе?\"},{\"answers\":[{\"text\":\"Алгоритм DFS исследует граф, проходя по его веткам и полностью изучая каждую ветку перед переходом к следующей.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм поиска в глубину (DFS) работает путём случайного выбора вершин графа для посещения, без систематического подхода к исследованию его ветвей.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм поиска в глубину (DFS) используется для определения кратчайшего пути между двумя вершинами в графе и основывается на принципе динамического программирования.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм DFS работает путём одновременного исследования всех вершин графа без учёта их связи друг с другом.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается принцип работы алгоритма поиска в глубину (DFS) в графе?\"},{\"answers\":[{\"text\":\"DFS сначала исследует одну ветку графа до конца, чтобы обеспечить полный поиск в глубину.\",\"generated_as_correct\":true},{\"text\":\"При реализации DFS сначала выбирается случайная ветка для исследования, и только после её завершения алгоритм переходит к другим веткам без определённой системы.\",\"generated_as_correct\":false},{\"text\":\"При реализации DFS сначала полностью исследуется одна ветка графа, так как это позволяет оптимизировать использование памяти по сравнению с другими алгоритмами поиска, такими как поиск в ширину.\",\"generated_as_correct\":false},{\"text\":\"DFS сначала исследует все ветки графа одновременно, чтобы быстрее найти нужную вершину.\",\"generated_as_correct\":false}],\"question\":\"Почему при реализации DFS сначала полностью исследуется одна ветка графа, прежде чем перейти к другим?\"},{\"answers\":[{\"text\":\"Алгоритм DFS позволяет искать путь в графе, исследуя одну ветку до конца, затем переходя к следующей.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм DFS применяется для поиска пути в графе путём случайного выбора вершин и перемещения по рёбрам без какой-либо системы или порядка.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм DFS используется для определения количества вершин в графе и не применяется для поиска пути.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм DFS работает путём одновременного исследования всех веток графа без приоритета одной ветки перед другой.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм DFS для решения задачи поиска пути в графе?\"},{\"answers\":[{\"text\":\"Рекурсивный подход к обходу в глубину — это реализация алгоритма поиска в глубину через рекурсию, упрощающая код, но ограниченная по памяти и глубине.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный подход к обходу в глубину — это метод, который использует итерации вместо рекурсии для реализации алгоритма поиска в глубину, что позволяет избежать ограничений по памяти.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный подход к обходу в глубину — это стратегия, используемая в машинном обучении для оптимизации параметров модели, которая не связана с ограничениями по памяти или глубине рекурсии.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный подход к обходу в глубину — это способ реализации алгоритма поиска в ширину, который не имеет ограничений по памяти или глубине рекурсии.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой рекурсивный подход к обходу в глубину?\"},{\"answers\":[{\"text\":\"Рекурсивный подход ограничен по памяти и глубине, что делает его неэффективным для больших графов.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный подход неэффективен для больших графов из-за сложности написания кода и увеличения времени выполнения алгоритма по сравнению с итеративными методами.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный подход неэффективен для больших графов, потому что он не позволяет визуализировать структуру графа и затрудняет анализ связей между вершинами.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный подход неэффективен для больших графов из-за его высокой скорости выполнения и сложности реализации.\",\"generated_as_correct\":false}],\"question\":\"Почему рекурсивный подход может быть неэффективным для больших графов?\"},{\"answers\":[{\"text\":\"Рекурсивный подход упрощает код для поиска в глубину, но имеет ограничения по памяти и глубине.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный подход упрощает реализацию алгоритма поиска в глубину за счёт уменьшения потребления памяти и отсутствия ограничений по глубине рекурсии, что делает его идеальным для работы с большими графами.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный подход используется для оптимизации времени выполнения алгоритма поиска в ширину, что позволяет ускорить обработку данных в больших графах.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный подход усложняет реализацию алгоритма поиска в глубину из-за необходимости дополнительного управления памятью.\",\"generated_as_correct\":false}],\"question\":\"Как рекурсивный подход упрощает реализацию алгоритма поиска в глубину?\"},{\"answers\":[{\"text\":\"Нерекурсивный подход к обходу в глубину использует стек для реализации алгоритма поиска в глубину.\",\"generated_as_correct\":true},{\"text\":\"Нерекурсивный подход к обходу в глубину — это метод, который использует очереди для реализации алгоритма поиска в глубину, что позволяет обрабатывать большие графы.\",\"generated_as_correct\":false},{\"text\":\"Нерекурсивный подход к обходу в глубину связан с применением динамического программирования для оптимизации решений задач на графах.\",\"generated_as_correct\":false},{\"text\":\"Нерекурсивный подход к обходу в глубину использует очередь для реализации алгоритма поиска.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой нерекурсивный подход к обходу в глубину?\"},{\"answers\":[{\"text\":\"Стек в нерекурсивном подходе позволяет обрабатывать большие графы, избегая ограничений по глубине рекурсии.\",\"generated_as_correct\":true},{\"text\":\"Использование стека в нерекурсивном подходе к обходу в глубину не влияет на ограничения рекурсивного подхода, поскольку оба метода имеют одинаковые ограничения по глубине обработки графов.\",\"generated_as_correct\":false},{\"text\":\"Использование стека в нерекурсивном подходе к обходу в глубину упрощает реализацию алгоритма, но не влияет на его способность обрабатывать циклические графы.\",\"generated_as_correct\":false},{\"text\":\"Стек в нерекурсивном подходе ограничивает обработку графов из-за ограниченного размера памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему использование стека в нерекурсивном подходе к обходу в глубину позволяет избежать ограничений рекурсивного подхода?\"},{\"answers\":[{\"text\":\"Нерекурсивный подход использует стек для обхода графа в глубину, избегая ограничений рекурсии.\",\"generated_as_correct\":true},{\"text\":\"Нерекурсивный подход к обходу в глубину основывается на использовании дополнительных массивов для хранения промежуточных результатов, что позволяет избежать ограничений рекурсивного подхода при обработке больших графов.\",\"generated_as_correct\":false},{\"text\":\"Нерекурсивный подход к обходу в глубину используется для оптимизации алгоритмов машинного обучения при работе с большими объёмами данных.\",\"generated_as_correct\":false},{\"text\":\"Нерекурсивный подход применяет очередь для обхода графа в глубину.\",\"generated_as_correct\":false}],\"question\":\"Как нерекурсивный подход к обходу в глубину может быть применён для обработки больших графов?\"},{\"answers\":[{\"text\":\"Алгоритм BFS — это поиск в графе, который исследует вершины по уровням, начиная с начальной вершины.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм обхода в ширину (BFS) — это способ поиска в графе, который случайным образом выбирает вершины для исследования, не учитывая их расстояние от начальной вершины.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм обхода в ширину (BFS) используется для сортировки вершин в графе по их весу, что позволяет оптимизировать пути между ними.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм BFS — это метод поиска в графе, который сначала исследует вершины с наибольшим количеством рёбер.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм обхода в ширину (BFS)?\"},{\"answers\":[{\"text\":\"Алгоритм BFS находит кратчайший путь, исследуя вершины графа по уровням, начиная с начальной вершины.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм BFS находит кратчайший путь благодаря тому, что он случайным образом выбирает вершины для посещения, что обеспечивает быстрое нахождение кратчайшего пути за счёт исключения ненужных маршрутов.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм BFS полезен для определения связности графа и может быть использован в задачах, связанных с поиском пути, но его применение для нахождения кратчайшего пути ограничено графами с определёнными свойствами, такими как взвешенные рёбра.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм BFS находит кратчайший путь, потому что всегда выбирает вершину с наименьшим номером для дальнейшего исследования.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритм BFS позволяет найти кратчайший путь в графе?\"},{\"answers\":[{\"text\":\"BFS полезен для поиска кратчайшего пути и проверки связности графа.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм обхода в ширину используется для нахождения циклов в графе и определения его эйлеровых путей.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм обхода в ширину применяется в задачах машинного обучения для классификации данных на основе графовых структур.\",\"generated_as_correct\":false},{\"text\":\"BFS применяется для поиска всех возможных путей в графе без учёта их длины.\",\"generated_as_correct\":false}],\"question\":\"В каких задачах может быть полезен алгоритм обхода в ширину?\"},{\"answers\":[{\"text\":\"Сложность $O(V+E)$ показывает линейную зависимость времени выполнения алгоритма от числа вершин и рёбер графа.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность $O(V+E)$ указывает на то, что время выполнения алгоритма зависит от квадрата числа вершин и рёбер графа.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность $O(V+E)$ относится к анализу устойчивости алгоритмов поиска в глубину и ширину при изменении структуры данных.\",\"generated_as_correct\":false},{\"text\":\"Сложность $O(V+E)$ означает, что время выполнения алгоритма не зависит от числа вершин и рёбер графа.\",\"generated_as_correct\":false}],\"question\":\"Что означает асимптотическая сложность $O(V+E)$ для алгоритмов поиска в глубину и ширину?\"},{\"answers\":[{\"text\":\"Сложность алгоритмов поиска в глубину и ширину — $O(V+E)$, так как время выполнения линейно зависит от числа вершин и рёбер.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность алгоритмов поиска в глубину и ширину определяется только числом вершин, так как рёбра не влияют на время выполнения алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность алгоритмов поиска в глубину и ширину связана с количеством операций сравнения и не зависит от числа вершин и рёбер.\",\"generated_as_correct\":false},{\"text\":\"Сложность алгоритмов поиска в глубину и ширину — $O(VE)$, так как время выполнения зависит от произведения числа вершин и рёбер.\",\"generated_as_correct\":false}],\"question\":\"Почему асимптотическая сложность алгоритмов поиска в глубину и ширину выражается через сумму числа вершин и рёбер?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность $O(V+E)$ показывает линейную зависимость времени выполнения алгоритма от числа вершин и рёбер, помогая выбрать подходящий алгоритм.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность $O(V+E)$ указывает на то, что время выполнения алгоритма будет оставаться постоянным независимо от количества вершин и рёбер в графе, что делает выбор алгоритма независимым от размера графа.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность $O(V+E)$ используется для анализа стабильности алгоритма при изменении структуры графа, но не влияет на выбор конкретного алгоритма поиска.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность $O(V+E)$ означает, что время выполнения алгоритма не зависит от количества вершин и рёбер в графе.\",\"generated_as_correct\":false}],\"question\":\"Как знание асимптотической сложности $O(V+E)$ может помочь при выборе алгоритма поиска для графа с определённым количеством вершин и рёбер?\"}],\"StoreCardId\":null,\"numberInCourse\":\"5.3\"},{\"Name\":\"algo | 5.4. Алгоритм нахождения компонент связности в графе\",\"Slug\":\"algoritm-nahozhdeniya-komponent-svyaznosti-v-grafe\",\"createdAt\":\"2024-07-03T17:35:15.737Z\",\"updatedAt\":\"2026-01-10T12:07:06.985Z\",\"publishedAt\":\"2024-07-03T17:35:16.917Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80792/problem\",\"Lead\":null,\"Content\":\"$6d\",\"Title\":\"Алгоритм нахождения компонент связности в графе\",\"LikesCount\":17,\"Quiz\":[{\"answers\":[{\"text\":\"Алгоритмы поиска в глубину и ширину — методы обхода графа для поиска путей между вершинами.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы поиска в глубину и ширину используются для вычисления кратчайших путей между всеми парами вершин в графе, минуя необходимость обхода самого графа.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы поиска в глубину и ширину тесно связаны с методами шифрования и применяются для защиты данных в криптографических системах.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы поиска в глубину и ширину используются для построения графов на основе заданных данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритмы поиска в глубину и ширину?\"},{\"answers\":[{\"text\":\"Алгоритмы поиска в глубину и ширину помогают исследовать структуру графа, находить пути и компоненты связности.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы поиска в глубину и ширину используются исключительно для подсчёта количества вершин в графе и не имеют отношения к исследованию его структуры.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы поиска в глубину и ширину применяются для сортировки вершин графа по определённым критериям, что помогает в анализе его структуры, но не напрямую связано с исследованием путей или связности.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы поиска в глубину и ширину предназначены для вычисления веса рёбер в графе.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритмы поиска в глубину и ширину полезны для исследования структуры графа?\"},{\"answers\":[{\"text\":\"Алгоритмы поиска в глубину и ширину используются для поиска путей и определения компонент связности в графах.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы поиска в глубину и ширину применяются только для визуализации графов и не используются для поиска путей или определения связности.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы поиска в глубину и ширину находят применение в задачах машинного обучения для классификации данных, не связанных с графами.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы поиска в глубину и ширину применяются для расчёта веса рёбер в графах.\",\"generated_as_correct\":false}],\"question\":\"В каких задачах, связанных с графами, могут применяться алгоритмы поиска в глубину и ширину?\"},{\"answers\":[{\"text\":\"Компонента связности — это связный подграф, где каждая вершина достижима из любой другой.\",\"generated_as_correct\":true},{\"text\":\"Компонента связности в графе — это набор вершин, выбранных случайным образом, вместе с некоторыми рёбрами графа, которые могут их соединять или не соединять.\",\"generated_as_correct\":false},{\"text\":\"Компонента связности в графе связана с количеством рёбер в графе и используется для определения его плотности и степени связанности.\",\"generated_as_correct\":false},{\"text\":\"Компонента связности — это произвольный набор вершин графа без учёта их связности.\",\"generated_as_correct\":false}],\"question\":\"Что такое компонента связности в графе?\"},{\"answers\":[{\"text\":\"Компоненты связности помогают разделить граф на связные подграфы, что важно для анализа его структуры.\",\"generated_as_correct\":true},{\"text\":\"Компоненты связности важны для анализа графа, потому что они показывают количество рёбер в графе и помогают определить его плотность.\",\"generated_as_correct\":false},{\"text\":\"Компоненты связности используются для определения циклов в графе и не имеют отношения к анализу его структуры.\",\"generated_as_correct\":false},{\"text\":\"Компоненты связности определяют количество вершин в графе, что важно для его анализа.\",\"generated_as_correct\":false}],\"question\":\"Почему компоненты связности важны для анализа структуры графа?\"},{\"answers\":[{\"text\":\"Компоненты связности разделяют граф на связные подграфы.\",\"generated_as_correct\":true},{\"text\":\"Компоненты связности помогают разделить граф на части по количеству вершин, не учитывая их связность или достижимость.\",\"generated_as_correct\":false},{\"text\":\"Компоненты связности применяются для определения циклов в графе и не используются для разделения графа на отдельные части.\",\"generated_as_correct\":false},{\"text\":\"Компоненты связности делят граф на равные по размеру части без учёта связности вершин.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать компоненты связности для разделения графа на отдельные части?\"},{\"answers\":[{\"text\":\"Поиск компонент связности — это алгоритм обхода графа из каждой непосещённой вершины для разделения его на связные подграфы.\",\"generated_as_correct\":true},{\"text\":\"Процесс поиска компонент связности в графе подразумевает использование специального математического уравнения для вычисления количества связных подграфов без необходимости обхода вершин.\",\"generated_as_correct\":false},{\"text\":\"Процесс поиска компонент связности в графе связан с определением циклов в графе и вычислением их количества для анализа структуры графа.\",\"generated_as_correct\":false},{\"text\":\"Поиск компонент связности заключается в определении количества рёбер в графе.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой процесс поиска компонент связности в графе?\"},{\"answers\":[{\"text\":\"Запуск алгоритма обхода из каждой не посещённой вершины необходим для обнаружения всех компонент связности в графе.\",\"generated_as_correct\":true},{\"text\":\"Для поиска компонент связности нужно запускать алгоритм обхода только из вершин, которые имеют наибольшее количество рёбер, так как они являются ключевыми для определения структуры графа.\",\"generated_as_correct\":false},{\"text\":\"Для поиска компонент связности важно использовать алгоритмы сортировки, которые позволяют упорядочить вершины по определённым критериям, что помогает в анализе структуры графа.\",\"generated_as_correct\":false},{\"text\":\"Запуск алгоритма обхода требуется только из начальной вершины, чтобы найти все компоненты связности.\",\"generated_as_correct\":false}],\"question\":\"Почему для поиска компонент связности необходимо запускать алгоритм обхода из каждой не посещённой вершины?\"},{\"answers\":[{\"text\":\"Результаты поиска компонент связности помогают разделить граф на подграфы для анализа их свойств.\",\"generated_as_correct\":true},{\"text\":\"Результаты поиска компонент связности применяются для определения количества рёбер в графе, что помогает анализировать его плотность и связность.\",\"generated_as_correct\":false},{\"text\":\"Результаты поиска компонент связности могут быть использованы для определения циклов в графе и анализа его планарности.\",\"generated_as_correct\":false},{\"text\":\"Результаты поиска компонент связности используются для определения общего количества вершин в графе.\",\"generated_as_correct\":false}],\"question\":\"Как результаты поиска компонент связности могут быть использованы для анализа свойств графа?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность — это оценка времени выполнения алгоритма в терминах большого О (O) в зависимости от размера входных данных.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность алгоритма — это мера сложности алгоритма, которая определяется максимальным количеством памяти, необходимым для выполнения алгоритма, и выражается в терминах большого О (O).\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность алгоритма связана с анализом стабильности алгоритма при изменении входных параметров и выражается через коэффициенты корреляции.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность алгоритма — это количество операций, выполняемых алгоритмом, независимо от размера входных данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое асимптотическая сложность алгоритма и как она выражается?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность O(V+E) эффективна, так как время выполнения алгоритма линейно зависит от числа вершин и рёбер в графе.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность O(V+E) считается эффективной для алгоритмов поиска компонент связности в графе, поскольку она показывает, что время выполнения алгоритма не зависит от размера графа, а определяется только количеством операций.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность O(V+E) используется для оценки сложности алгоритмов сортировки и не имеет отношения к поиску компонент связности в графе.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность O(V+E) неэффективна, так как время выполнения алгоритма квадратично зависит от числа вершин и рёбер в графе.\",\"generated_as_correct\":false}],\"question\":\"Почему асимптотическая сложность O(V+E) считается эффективной для алгоритмов поиска компонент связности в графе?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность позволяет оценить, как время выполнения алгоритма зависит от размера графа.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность показывает, сколько памяти потребуется алгоритму для работы с графом, и не имеет отношения к времени выполнения.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность используется для анализа устойчивости алгоритма к изменениям в структуре графа, но не влияет на выбор алгоритма для работы с большими графами.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность определяет максимальное количество операций, которое алгоритм может выполнить на любом графе.\",\"generated_as_correct\":false}],\"question\":\"Как знание асимптотической сложности может помочь при выборе алгоритма для работы с большими графами?\"}],\"StoreCardId\":null,\"numberInCourse\":\"5.4\"},{\"Name\":\"algo | 5.5. Задача поиска кратчайшего пути в графе\",\"Slug\":\"zadacha-poiska-kratchajshego-puti-v-grafe\",\"createdAt\":\"2024-07-03T17:35:48.647Z\",\"updatedAt\":\"2026-01-10T12:07:08.992Z\",\"publishedAt\":\"2024-07-03T17:35:49.911Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80793/problem\",\"Lead\":null,\"Content\":\"$6e\",\"Title\":\"Задача поиска кратчайшего пути в графе\",\"LikesCount\":17,\"Quiz\":[{\"answers\":[{\"text\":\"Алгоритм Дейкстры находит кратчайшие пути от одной вершины до всех остальных в графе без отрицательных весов рёбер.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Дейкстры предназначен для определения максимального пути между вершинами в графе с любыми весами рёбер.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры применяется для сортировки вершин в графе по их весу, что используется в задачах оптимизации сетевых потоков.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры определяет кратчайшие пути в графах с рёбрами любого веса.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм Дейкстры?\"},{\"answers\":[{\"text\":\"Алгоритм Дейкстры не работает с графами, содержащими рёбра отрицательного веса, так как его принцип основан на неотрицательных весах.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Дейкстры неприменим для графов с рёбрами отрицательного веса, поскольку он предназначен исключительно для нахождения кратчайших путей в ориентированных графах и не может обрабатывать неориентированные графы с отрицательными весами.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры неприменим для графов с рёбрами отрицательного веса, потому что его основная цель — оптимизация сетевых потоков, а не работа с отрицательными значениями весов рёбер.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры неприменим для графов с рёбрами отрицательного веса, потому что он предназначен для поиска путей максимальной длины.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритм Дейкстры неприменим для графов с рёбрами отрицательного веса?\"},{\"answers\":[{\"text\":\"Алгоритм Дейкстры находит кратчайшие пути от одной вершины до всех остальных в графе без отрицательных рёбер.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Дейкстры позволяет найти кратчайшие пути между всеми парами вершин в графе, независимо от наличия рёбер с отрицательным весом.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры используется для определения циклов в графах и не применяется для решения задачи о кратчайших путях.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры предназначен для нахождения кратчайших путей в графах с рёбрами любого веса.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать алгоритм Дейкстры для решения задачи о кратчайших путях в графах?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность — это описание того, как вычислительная сложность алгоритма изменяется с ростом размера входных данных.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность алгоритма — это мера, которая показывает, насколько быстро алгоритм может обрабатывать данные независимо от их объёма.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность алгоритма связана с анализом устойчивости алгоритма к изменениям в структуре данных и не зависит от размера входных данных.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность алгоритма — это фиксированное число операций, необходимое для выполнения алгоритма независимо от размера входных данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое асимптотическая сложность алгоритма?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность позволяет оценить, как растёт время выполнения алгоритма с увеличением размера входных данных.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность важна, потому что она определяет точное количество операций, которое алгоритм выполнит для любого заданного набора данных, независимо от их размера.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность используется для классификации алгоритмов по их пространственной сложности и не имеет отношения к времени выполнения.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность определяет максимальное количество памяти, необходимое алгоритму для выполнения задачи.\",\"generated_as_correct\":false}],\"question\":\"Почему асимптотическая сложность важна для анализа эффективности алгоритмов?\"},{\"answers\":[{\"text\":\"Асимптотическая сложность описывает, как растёт время выполнения алгоритма с увеличением размера входных данных, например, для алгоритма Дейкстры — $O(V^2 + E)$.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность показывает количество операций, которые алгоритм выполняет на каждом шаге. Для алгоритма Дейкстры сложность $O(V^2 + E)$ означает, что на каждом шаге алгоритма выполняется $V^2 + E$ операций.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность применяется для анализа стабильности алгоритмов при изменении параметров графа, таких как вес рёбер или связность компонентов.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность определяет максимальное количество операций, которое алгоритм может выполнить за фиксированное время, независимо от размера входных данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать асимптотическую сложность для сравнения алгоритмов при работе с графами разного размера?\"},{\"answers\":[{\"text\":\"Компоненты связности — это подмножества вершин графа, где каждая вершина связана с другими внутри подмножества и изолирована от вершин вне его.\",\"generated_as_correct\":true},{\"text\":\"Компоненты связности в графе — это группы вершин, которые не имеют связей между собой и изолированы от остальных вершин графа.\",\"generated_as_correct\":false},{\"text\":\"Компоненты связности в графе связаны с алгоритмами сортировки и используются для определения порядка вершин в графе.\",\"generated_as_correct\":false},{\"text\":\"Компоненты связности в графе — это пути, соединяющие все вершины графа между собой.\",\"generated_as_correct\":false}],\"question\":\"Что такое компоненты связности в графе?\"},{\"answers\":[{\"text\":\"Сложность O(V + E) возникает из-за необходимости обойти все вершины и рёбра графа.\",\"generated_as_correct\":true},{\"text\":\"Асимптотическая сложность нахождения компонент связности в графе выражается как O(V + E), так как для каждой вершины нужно выполнить операции, зависящие от количества рёбер, что приводит к квадратичной сложности.\",\"generated_as_correct\":false},{\"text\":\"Асимптотическая сложность нахождения компонент связности в графе связана с количеством операций, необходимых для раскраски графа, что выражается как O(V).\",\"generated_as_correct\":false},{\"text\":\"Сложность O(V + E) обусловлена необходимостью умножить количество вершин на количество рёбер.\",\"generated_as_correct\":false}],\"question\":\"Почему асимптотическая сложность нахождения компонент связности в графе выражается как O(V + E)?\"},{\"answers\":[{\"text\":\"Компоненты связности позволяют выявить связанные подмножества вершин в графе, анализируя его структуру.\",\"generated_as_correct\":true},{\"text\":\"Компоненты связности помогают определить количество рёбер в графе и их распределение, что позволяет анализировать структуру графа и его связность.\",\"generated_as_correct\":false},{\"text\":\"Компоненты связности используются для определения циклов в графе и расчёта его хроматического числа, что важно для задач раскраски графов.\",\"generated_as_correct\":false},{\"text\":\"Компоненты связности определяют количество изолированных вершин в графе, что помогает анализировать его структуру.\",\"generated_as_correct\":false}],\"question\":\"Как знание о компонентах связности может быть применено для анализа структуры графа?\"},{\"answers\":[{\"text\":\"Рёбра отрицательного веса — это рёбра в графе с весом меньше нуля.\",\"generated_as_correct\":true},{\"text\":\"Рёбра отрицательного веса в графе — это рёбра, которые соединяют вершины с отрицательными значениями координат. Алгоритм Дейкстры адаптирован для работы с такими графами.\",\"generated_as_correct\":false},{\"text\":\"Рёбра отрицательного веса в графе связаны с концепцией ориентированных графов и используются для определения циклов в графе.\",\"generated_as_correct\":false},{\"text\":\"Рёбра отрицательного веса — это рёбра в графе, которые увеличивают общий вес пути при их прохождении.\",\"generated_as_correct\":false}],\"question\":\"Что такое рёбра отрицательного веса в графе?\"},{\"answers\":[{\"text\":\"Алгоритм Дейкстры не работает с рёбрами отрицательного веса из-за возможности бесконечного уменьшения веса пути.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Дейкстры неприменим к графам с рёбрами отрицательного веса, поскольку он использует метод случайного выбора рёбер, что приводит к некорректным результатам при наличии отрицательных весов.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры неэффективен для графов с отрицательными весами рёбер, потому что его основная цель — оптимизация количества итераций, а не учёт знаков весов.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры не применяется к графам с отрицательными весами, так как он не способен обрабатывать графы с циклами.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритм Дейкстры не подходит для работы с графами, содержащими рёбра отрицательного веса?\"},{\"answers\":[{\"text\":\"Алгоритм Дейкстры может дать некорректные результаты на графах с рёбрами отрицательного веса.\",\"generated_as_correct\":true},{\"text\":\"Рёбра отрицательного веса улучшают точность алгоритма Дейкстры, позволяя находить более короткие пути по сравнению с графами, где все рёбра имеют положительный вес.\",\"generated_as_correct\":false},{\"text\":\"Рёбра отрицательного веса влияют на сложность вычисления максимального потока в сети, но не оказывают существенного влияния на алгоритм поиска кратчайшего пути.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры эффективно работает с рёбрами отрицательного веса, обеспечивая точные результаты.\",\"generated_as_correct\":false}],\"question\":\"Как наличие рёбер отрицательного веса может повлиять на результаты алгоритма поиска кратчайшего пути?\"},{\"answers\":[{\"text\":\"Алгоритм Дейкстры находит кратчайший путь, обновляя веса вершин от начальной до конечной.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Дейкстры определяет кратчайшие пути путём случайного выбора вершин и их соединения, не учитывая веса рёбер между ними.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры используется для сортировки вершин в графе по их весу, что позволяет построить дерево минимальной стоимости.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры ищет кратчайшие пути, выбирая вершины с наибольшими весами.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой принцип работы алгоритма Дейкстры?\"},{\"answers\":[{\"text\":\"Последовательное обновление весов вершин позволяет алгоритму Дейкстры находить кратчайший путь от начальной вершины до остальных.\",\"generated_as_correct\":true},{\"text\":\"Последовательное обновление весов вершин в алгоритме Дейкстры нужно для того, чтобы случайно выбрать одну из вершин и обновить её вес, не учитывая веса соседних вершин, что позволяет найти кратчайший путь.\",\"generated_as_correct\":false},{\"text\":\"Последовательное обновление весов вершин важно для корректной работы алгоритмов машинного обучения, которые используют графы для классификации данных.\",\"generated_as_correct\":false},{\"text\":\"Последовательное обновление весов вершин необходимо для определения максимального пути в алгоритме Дейкстры.\",\"generated_as_correct\":false}],\"question\":\"Почему в алгоритме Дейкстры важно последовательно обновлять веса вершин?\"},{\"answers\":[{\"text\":\"Алгоритм Дейкстры находит кратчайший путь в графе через последовательное обновление весов вершин от начальной до конечной.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Дейкстры находит кратчайший путь в графе, выбирая вершины с наибольшими весами и соединяя их последовательно от начальной до конечной вершины.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры связан с теорией графов и может быть использован для анализа связности графа, но не для нахождения кратчайших путей.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Дейкстры определяет кратчайший путь в графе путём выбора вершин с минимальными весами без учёта их связности.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм Дейкстры для нахождения кратчайшего пути в графе?\"}],\"StoreCardId\":null,\"numberInCourse\":\"5.5\"},{\"Name\":\"algo | 5.6. Чему вы научились\",\"Slug\":\"chemu-vi-nauchilis-five\",\"createdAt\":\"2024-07-03T17:35:48.647Z\",\"updatedAt\":\"2025-09-11T20:12:31.625Z\",\"publishedAt\":\"2025-09-08T14:21:32.368Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$6f\",\"Title\":\"Чему вы научились\",\"LikesCount\":40,\"Quiz\":null,\"StoreCardId\":null,\"numberInCourse\":\"5.6\"}]},{\"id\":31,\"Name\":\"6. Техники проектирования алгоритмов\",\"Articles\":[{\"Name\":\"algo | 6.1. Полный перебор и оптимизация перебора\",\"Slug\":\"polnyj-perebor-i-optimizaciya-perebora\",\"createdAt\":\"2024-07-03T08:28:16.199Z\",\"updatedAt\":\"2026-01-10T12:07:07.855Z\",\"publishedAt\":\"2024-07-03T08:28:17.377Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/79921/problem\",\"Lead\":\"Метод полного перебора позволяет проанализировать все возможные исходы поставленной задачи и\u0026nbsp;выбрать самый оптимальный. Перечисление возможных вариантов само по\u0026nbsp;себе может оказаться нетривиальным и\u0026nbsp;увлекательным.\",\"Content\":\"$70\",\"Title\":\"Полный перебор и оптимизация перебора\",\"LikesCount\":25,\"Quiz\":[{\"answers\":[{\"text\":\"Метод полного перебора — это алгоритм, рассматривающий все возможные варианты для решения задачи.\",\"generated_as_correct\":true},{\"text\":\"Метод полного перебора — это эвристический алгоритм, который использует определённые правила для исключения неподходящих вариантов и быстрого нахождения решения задачи.\",\"generated_as_correct\":false},{\"text\":\"Метод полного перебора используется в теории графов для определения кратчайшего пути между двумя вершинами без перебора всех возможных путей.\",\"generated_as_correct\":false},{\"text\":\"Метод полного перебора — это метод, который находит решение задачи, выбирая наиболее вероятные варианты без полного перебора.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой метод полного перебора?\"},{\"answers\":[{\"text\":\"Метод полного перебора требует перебора всех вариантов, что занимает много времени при большом их количестве.\",\"generated_as_correct\":true},{\"text\":\"Метод полного перебора неэффективен, потому что он не учитывает закономерности и связи между вариантами, что делает его непригодным для сложных задач.\",\"generated_as_correct\":false},{\"text\":\"Метод полного перебора может быть неэффективным из-за ограничений памяти и сложности реализации алгоритма, но это не связано напрямую с количеством вариантов.\",\"generated_as_correct\":false},{\"text\":\"Метод полного перебора неэффективен, так как не гарантирует нахождения решения задачи.\",\"generated_as_correct\":false}],\"question\":\"Почему метод полного перебора может быть неэффективным для задач с большим количеством вариантов?\"},{\"answers\":[{\"text\":\"Метод полного перебора находит решение, если оно есть, путём проверки всех вариантов.\",\"generated_as_correct\":true},{\"text\":\"Метод полного перебора гарантирует нахождение решения задачи, даже если некоторые возможные варианты не будут рассмотрены.\",\"generated_as_correct\":false},{\"text\":\"Метод полного перебора используется для оптимизации сложных систем и не связан с гарантией нахождения решения задачи.\",\"generated_as_correct\":false},{\"text\":\"Метод полного перебора находит решение задачи только при наличии ограниченного числа вариантов.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях метод полного перебора гарантирует нахождение решения задачи?\"},{\"answers\":[{\"text\":\"Метод ветвей и границ сокращает время поиска решения путём исключения неподходящих вариантов перебора.\",\"generated_as_correct\":true},{\"text\":\"Метод ветвей и границ — это метод, который используется для полного перебора всех возможных вариантов без исключения каких-либо из них.\",\"generated_as_correct\":false},{\"text\":\"Метод ветвей и границ — это подход, который применяется в теории графов для определения кратчайшего пути между двумя узлами.\",\"generated_as_correct\":false},{\"text\":\"Метод ветвей и границ увеличивает время поиска решения за счёт добавления дополнительных критериев перебора.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой метод ветвей и границ?\"},{\"answers\":[{\"text\":\"Метод ветвей и границ сокращает время поиска решения за счёт исключения неподходящих вариантов перебора.\",\"generated_as_correct\":true},{\"text\":\"Метод ветвей и границ предполагает случайный отбор вариантов для перебора, что может иногда сократить время поиска решения, но не гарантирует улучшения эффективности алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Метод ветвей и границ используется для визуализации процесса перебора вариантов и не влияет на скорость поиска решения, но помогает лучше понять структуру задачи.\",\"generated_as_correct\":false},{\"text\":\"Метод ветвей и границ замедляет поиск решения, так как добавляет дополнительные шаги проверки для каждого варианта перебора.\",\"generated_as_correct\":false}],\"question\":\"Каким образом метод ветвей и границ способствует повышению эффективности алгоритмов, основанных на полном переборе?\"},{\"answers\":[{\"text\":\"Метод ветвей и границ сокращает время поиска решения путём исключения неподходящих вариантов в алгоритмах полного перебора.\",\"generated_as_correct\":true},{\"text\":\"Метод ветвей и границ используется исключительно для теоретических исследований и не применим для сокращения времени поиска решения в практических задачах.\",\"generated_as_correct\":false},{\"text\":\"Метод ветвей и границ тесно связан с теорией графов и применяется для анализа сетевых структур, не влияя на сокращение времени поиска решения.\",\"generated_as_correct\":false},{\"text\":\"Метод ветвей и границ увеличивает время поиска решения за счёт добавления дополнительных условий в алгоритмы.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях применение метода ветвей и границ может быть особенно полезным для сокращения времени поиска решения?\"},{\"answers\":[{\"text\":\"«Стресс-тестирование алгоритмов — это проверка их устойчивости к высоким нагрузкам и большим объёмам данных».\",\"generated_as_correct\":true},{\"text\":\"«Стресс-тестирование алгоритмов — это метод оптимизации алгоритмов путём их многократного запуска с различными входными данными для определения среднего времени выполнения».\",\"generated_as_correct\":false},{\"text\":\"«Стресс-тестирование алгоритмов связано с анализом их сложности и определением класса вычислимости, к которому они принадлежат».\",\"generated_as_correct\":false},{\"text\":\"«Стресс-тестирование алгоритмов — это процесс их обучения на больших объёмах данных для улучшения точности».\",\"generated_as_correct\":false}],\"question\":\"Что такое стресс-тестирование алгоритмов?\"},{\"answers\":[{\"text\":\"Стресс-тестирование помогает выявить слабые места алгоритмов при высокой нагрузке, улучшая их надёжность и эффективность.\",\"generated_as_correct\":true},{\"text\":\"Стресс-тестирование важно для алгоритмов, так как оно помогает определить максимальную скорость работы алгоритма при оптимальных условиях, что напрямую влияет на его эффективность.\",\"generated_as_correct\":false},{\"text\":\"Стресс-тестирование используется для оценки психологической устойчивости разработчиков алгоритмов, а не для проверки самих алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Стресс-тестирование необходимо для демонстрации оптимальной работы алгоритмов в стандартных условиях.\",\"generated_as_correct\":false}],\"question\":\"Почему стресс-тестирование важно для повышения надёжности и эффективности алгоритмов?\"},{\"answers\":[{\"text\":\"Алгоритмы полного перебора помогают проверить устойчивость алгоритмов к большим объёмам данных в условиях стресс-тестирования.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы полного перебора используются в стресс-тестировании для генерации случайных данных, которые затем анализируются на предмет соответствия ожидаемым результатам.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы полного перебора применяются в стресс-тестировании для оптимизации маршрутов в задачах логистики и планирования.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы полного перебора используются для ускорения работы алгоритмов в условиях стандартного тестирования.\",\"generated_as_correct\":false}],\"question\":\"Как алгоритмы полного перебора могут быть использованы в стресс-тестировании?\"}],\"StoreCardId\":null,\"numberInCourse\":\"6.1\"},{\"Name\":\"algo | 6.2. Жадные алгоритмы\",\"Slug\":\"zhadnye-algoritmy\",\"createdAt\":\"2024-07-03T08:29:01.295Z\",\"updatedAt\":\"2026-01-10T12:07:09.798Z\",\"publishedAt\":\"2024-07-03T08:29:02.490Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/79922/problem\",\"Lead\":\"В этом параграфе мы рассмотрим пример задачи, решение которой итеративным методом с выбором самого привлекательного шага не всегда является корректным, но в то же время обоснованный подход приводит к элегантному эффективному алгоритму.\",\"Content\":\"$71\",\"Title\":\"Жадные алгоритмы\",\"LikesCount\":22,\"Quiz\":[{\"answers\":[{\"text\":\"Итерационные процедуры — это алгоритмы, повторяющие шаги для приближения к результату.\",\"generated_as_correct\":true},{\"text\":\"Итерационные процедуры — это методы, которые используют однократное вычисление для получения окончательного результата, без необходимости повторных шагов.\",\"generated_as_correct\":false},{\"text\":\"Итерационные процедуры — это способы организации данных в структурах, таких как деревья и графы, не связанные с алгоритмами выбора.\",\"generated_as_correct\":false},{\"text\":\"Итерационные процедуры — это единичные операции, не предполагающие повторений.\",\"generated_as_correct\":false}],\"question\":\"Что такое итерационные процедуры?\"},{\"answers\":[{\"text\":\"Итерационные процедуры позволяют алгоритму постепенно приближаться к цели за счёт последовательного анализа и выбора на каждом шаге.\",\"generated_as_correct\":true},{\"text\":\"Итерационные процедуры представляют собой единичные действия, после выполнения которых алгоритм сразу достигает желаемого результата без необходимости повторений.\",\"generated_as_correct\":false},{\"text\":\"Итерационные процедуры используются для создания начальных условий в алгоритмах машинного обучения, но не влияют на процесс приближения к желаемому результату.\",\"generated_as_correct\":false},{\"text\":\"Итерационные процедуры не влияют на результат алгоритма, так как они просто повторяют одни и те же действия без изменений.\",\"generated_as_correct\":false}],\"question\":\"Как итерационные процедуры позволяют алгоритму приближаться к желаемому результату?\"},{\"answers\":[{\"text\":\"Итерационные процедуры полезны для последовательной обработки данных и приближения к желаемому результату.\",\"generated_as_correct\":true},{\"text\":\"Итерационные процедуры применяются исключительно для решения задач, связанных с графическим представлением данных, и не используются для обработки числовых значений.\",\"generated_as_correct\":false},{\"text\":\"Итерационные процедуры находят применение в области криптографии для создания сложных алгоритмов шифрования, не связанных с последовательной обработкой данных.\",\"generated_as_correct\":false},{\"text\":\"Итерационные процедуры применяются для однократной обработки всех данных без учёта промежуточных результатов.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях могут быть полезны итерационные процедуры?\"},{\"answers\":[{\"text\":\"Жадный алгоритм выбирает на каждом шаге наилучший вариант, стремясь к оптимальному решению, но может «застрять» в локальном оптимуме.\",\"generated_as_correct\":true},{\"text\":\"Жадный алгоритм — это алгоритм, который изначально рассчитывает все возможные варианты решения задачи и только после этого выбирает наилучший путь к глобальному оптимуму.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм — это метод, используемый в теории графов для определения количества вершин и рёбер в графе.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм всегда находит глобальное оптимальное решение задачи, независимо от начальных условий.\",\"generated_as_correct\":false}],\"question\":\"Что такое жадный алгоритм?\"},{\"answers\":[{\"text\":\"Жадные алгоритмы могут «застревать» в локальном оптимуме и не находить глобальный.\",\"generated_as_correct\":true},{\"text\":\"Жадные алгоритмы не находят глобальный оптимум из-за своей сложности и вычислительных ограничений, которые не позволяют им обрабатывать большие объёмы данных.\",\"generated_as_correct\":false},{\"text\":\"Жадные алгоритмы не гарантируют нахождение глобального оптимума из-за ограничений, связанных с архитектурой вычислительных систем, на которых они выполняются.\",\"generated_as_correct\":false},{\"text\":\"Жадные алгоритмы не находят глобальный оптимум из-за недостатка данных для анализа.\",\"generated_as_correct\":false}],\"question\":\"Почему жадные алгоритмы не всегда гарантируют нахождение глобального оптимума?\"},{\"answers\":[{\"text\":\"Жадные алгоритмы применяются в задачах оптимизации, где выбирается наилучший локальный вариант на каждом шаге.\",\"generated_as_correct\":true},{\"text\":\"Жадные алгоритмы используются для решения задач, где требуется найти все возможные решения, а не только оптимальное, например, в задачах на перебор и комбинаторику.\",\"generated_as_correct\":false},{\"text\":\"Жадные алгоритмы находят применение в задачах машинного обучения для классификации данных, где они помогают определить наиболее значимые признаки для модели.\",\"generated_as_correct\":false},{\"text\":\"Жадные алгоритмы используются в задачах оптимизации, где необходимо найти все возможные решения.\",\"generated_as_correct\":false}],\"question\":\"В каких типах задач оптимизации часто применяются жадные алгоритмы?\"},{\"answers\":[{\"text\":\"Задача «Размен» — это выдача сдачи минимальным количеством монет с использованием жадного алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Задача «Размен» — это задача по подсчёту общего количества монет, необходимых для оплаты товара, без учёта их номиналов.\",\"generated_as_correct\":false},{\"text\":\"Задача «Размен» связана с определением оптимального способа упаковки монет в банкноты для удобства хранения.\",\"generated_as_correct\":false},{\"text\":\"Задача «Размен» заключается в выдаче сдачи максимальным количеством монет.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой задача «Размен»?\"},{\"answers\":[{\"text\":\"Жадный алгоритм используется в задаче «Размен», чтобы выдать сдачу минимальным количеством монет, выбирая на каждом шаге монету наибольшего номинала.\",\"generated_as_correct\":true},{\"text\":\"В задаче «Размен» используется жадный алгоритм, который случайным образом выбирает монеты различных номиналов до тех пор, пока не будет достигнута необходимая сумма сдачи.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм в задаче «Размен» связан с определением оптимального количества бумажных купюр для выдачи сдачи, а не монет.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм в задаче «Размен» выбирает монеты наименьшего номинала на каждом шаге для выдачи сдачи.\",\"generated_as_correct\":false}],\"question\":\"Почему в задаче «Размен» используется жадный алгоритм и как он работает?\"},{\"answers\":[{\"text\":\"Жадный алгоритм из задачи «Размен» минимизирует количество монет в сдаче, выбирая на каждом шаге монету наибольшего номинала.\",\"generated_as_correct\":true},{\"text\":\"Для оптимизации количества монет при выдаче сдачи следует использовать случайный выбор монет, так как это обеспечивает равномерное распределение различных номиналов в кошельке покупателя.\",\"generated_as_correct\":false},{\"text\":\"Принцип задачи «Размен» используется для определения оптимального количества товаров в упаковке, чтобы минимизировать количество упаковочных материалов.\",\"generated_as_correct\":false},{\"text\":\"Для минимизации количества монет в сдаче нужно выбирать монеты среднего номинала на каждом шаге.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить принцип задачи «Размен» в реальной жизни для оптимизации количества монет при выдаче сдачи?\"},{\"answers\":[{\"text\":\"Задача «Бронирование переговорки» — выбор максимального числа непересекающихся временных отрезков.\",\"generated_as_correct\":true},{\"text\":\"Задача «Бронирование переговорки» состоит в том, чтобы определить, сколько раз одна и та же компания может забронировать переговорную комнату в течение дня, не учитывая других пользователей.\",\"generated_as_correct\":false},{\"text\":\"Задача «Бронирование переговорки» связана с разработкой алгоритма для автоматического уведомления участников о начале встречи в переговорной комнате.\",\"generated_as_correct\":false},{\"text\":\"Задача «Бронирование переговорки» — распределение времени использования комнаты по принципу «кто первый пришёл, того и место».\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой задача «Бронирование переговорки» с точки зрения определения?\"},{\"answers\":[{\"text\":\"Задача «Бронирование переговорки» позволяет оптимально распределить время использования переговорной комнаты между компаниями.\",\"generated_as_correct\":true},{\"text\":\"Задача «Бронирование переговорки» важна, потому что она помогает определить, сколько раз одна и та же компания может использовать переговорную комнату в течение дня, что способствует более равномерному распределению ресурсов между сотрудниками.\",\"generated_as_correct\":false},{\"text\":\"Задача «Бронирование переговорки» связана с разработкой алгоритмов для оптимизации работы серверов и не имеет прямого отношения к эффективному использованию ресурсов в офисе.\",\"generated_as_correct\":false},{\"text\":\"Задача «Бронирование переговорки» нужна для того, чтобы определить, какая компания получит право на использование комнаты в определённое время, без учёта эффективности использования ресурсов.\",\"generated_as_correct\":false}],\"question\":\"Почему важно решать задачу «Бронирование переговорки» для эффективного использования ресурсов?\"},{\"answers\":[{\"text\":\"Задача «Бронирование переговорки» помогает выбрать максимальное количество непересекающихся бронирований переговорной комнаты.\",\"generated_as_correct\":true},{\"text\":\"Задача «Бронирование переговорки» заключается в равномерном распределении времени использования переговорной комнаты между всеми желающими, независимо от количества запросов на бронирование.\",\"generated_as_correct\":false},{\"text\":\"Задача «Бронирование переговорки» связана с определением оптимальной площади переговорной комнаты для размещения определённого количества людей и не касается распределения времени её использования.\",\"generated_as_correct\":false},{\"text\":\"Задача «Бронирование переговорки» предназначена для определения общего времени, которое необходимо выделить для использования переговорной комнаты всеми желающими.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить задачу «Бронирование переговорки» в реальной ситуации распределения времени использования переговорной комнаты?\"},{\"answers\":[{\"text\":\"«Чемпионский» отрезок — отрезок с минимально возможной правой границей.\",\"generated_as_correct\":true},{\"text\":\"«Чемпионский» отрезок — это отрезок с максимальной длиной, который выбирается на каждом шаге алгоритма для задачи «Бронирование переговорки».\",\"generated_as_correct\":false},{\"text\":\"«Чемпионский» отрезок — это термин, используемый в теории графов для описания пути с минимальным количеством рёбер между двумя вершинами.\",\"generated_as_correct\":false},{\"text\":\"«Чемпионский» отрезок — отрезок с максимально возможной левой границей.\",\"generated_as_correct\":false}],\"question\":\"Что такое «чемпионский» отрезок?\"},{\"answers\":[{\"text\":\"Выбор «чемпионского» отрезка на каждом шаге позволяет максимизировать количество непересекающихся бронирований переговорки.\",\"generated_as_correct\":true},{\"text\":\"«Чемпионский» отрезок важен в жадном алгоритме, поскольку он соответствует отрезку с наибольшим количеством пересечений с другими отрезками, что позволяет оптимизировать процесс бронирования.\",\"generated_as_correct\":false},{\"text\":\"«Чемпионский» отрезок используется в жадном алгоритме как инструмент для определения начальной точки каждого бронирования, независимо от его длины или пересечения с другими отрезками.\",\"generated_as_correct\":false},{\"text\":\"Выбор «чемпионского» отрезка важен, так как он имеет наибольшее значение левой границы среди всех отрезков.\",\"generated_as_correct\":false}],\"question\":\"Почему в контексте жадного алгоритма для задачи «Бронирование переговорки» важно выбирать «чемпионский» отрезок на каждом шаге?\"},{\"answers\":[{\"text\":\"«Выбор „чемпионского“ отрезка с минимальной правой границей на каждом шаге позволяет максимизировать количество непересекающихся отрезков».\",\"generated_as_correct\":true},{\"text\":\"«„Чемпионский“ отрезок — это отрезок с наименьшей длиной, и его использование позволяет максимизировать количество непересекающихся отрезков за счёт минимизации общей длины выбранных отрезков».\",\"generated_as_correct\":false},{\"text\":\"«„Чемпионский“ отрезок используется в теории графов для определения кратчайшего пути между двумя точками и не имеет отношения к максимизации количества непересекающихся отрезков».\",\"generated_as_correct\":false},{\"text\":\"«Использование „чемпионского“ отрезка заключается в выборе отрезка с максимальной левой границей, что позволяет увеличить количество непересекающихся отрезков».\",\"generated_as_correct\":false}],\"question\":\"Как использование «чемпионского» отрезка помогает максимизировать количество непересекающихся отрезков?\"},{\"answers\":[{\"text\":\"Оптимальная «жадная» стратегия — выбор «чемпионского» отрезка для максимизации непересекающихся отрезков.\",\"generated_as_correct\":true},{\"text\":\"Оптимальная «жадная» стратегия в задаче «Бронирование переговорки» состоит в выборе отрезка с наибольшим количеством пересечений на каждом шаге.\",\"generated_as_correct\":false},{\"text\":\"Оптимальная «жадная» стратегия относится к методам машинного обучения и не имеет отношения к задаче «Бронирование переговорки».\",\"generated_as_correct\":false},{\"text\":\"Оптимальная «жадная» стратегия — это выбор отрезка с наименьшей продолжительностью на каждом шаге.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой оптимальная «жадная» стратегия в контексте задачи «Бронирование переговорки»?\"},{\"answers\":[{\"text\":\"Выбор «чемпионского» отрезка максимизирует количество непересекающихся отрезков.\",\"generated_as_correct\":true},{\"text\":\"Выбор «чемпионского» отрезка на каждом этапе не влияет на количество непересекающихся отрезков и является случайным процессом без определённой стратегии.\",\"generated_as_correct\":false},{\"text\":\"Выбор «чемпионского» отрезка связан с теорией игр и используется для определения наилучшего хода в стратегических играх.\",\"generated_as_correct\":false},{\"text\":\"Выбор «чемпионского» отрезка минимизирует количество доступных отрезков для бронирования.\",\"generated_as_correct\":false}],\"question\":\"Почему выбор «чемпионского» отрезка на каждом этапе считается оптимальным решением задачи?\"},{\"answers\":[{\"text\":\"Оптимальная «жадная» стратегия выбирает «чемпионский» отрезок на каждом шаге для максимизации непересекающихся бронирований.\",\"generated_as_correct\":true},{\"text\":\"Оптимальная «жадная» стратегия для задачи «Бронирование переговорки» состоит в том, чтобы выбирать отрезок с наибольшим количеством пересечений на каждом шаге, чтобы увеличить общее количество возможных бронирований.\",\"generated_as_correct\":false},{\"text\":\"Оптимальная «жадная» стратегия используется для определения наилучшего пути в графах и не применима к задаче «Бронирование переговорки».\",\"generated_as_correct\":false},{\"text\":\"Оптимальная «жадная» стратегия заключается в выборе самого длинного отрезка на каждом шаге без учёта пересечений.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить оптимальную «жадную» стратегию для решения задачи «Бронирование переговорки» на практике?\"}],\"StoreCardId\":null,\"numberInCourse\":\"6.2\"},{\"Name\":\"algo | 6.3. Динамическое программирование\",\"Slug\":\"dinamicheskoe-programmirovanie\",\"createdAt\":\"2024-07-03T08:30:11.650Z\",\"updatedAt\":\"2026-01-10T12:07:07.188Z\",\"publishedAt\":\"2024-07-03T08:30:12.939Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/79927/problem\",\"Lead\":\"Здесь мы\u0026nbsp;найдём оптимальную стратегию действий в\u0026nbsp;игре «Камни». Решив большее количество меньших экземпляров задачи, мы\u0026nbsp;сможем гарантированно определить, какой из\u0026nbsp;игроков непременно победит.\",\"Content\":\"$72\",\"Title\":\"Динамическое программирование\",\"LikesCount\":15,\"Quiz\":[{\"answers\":[{\"text\":\"Динамическое программирование — метод оптимизации вычислений путём сохранения результатов подзадач.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование — это подход к программированию, который фокусируется на создании максимально сложного и запутанного кода для повышения его защищённости от взлома.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование — это техника, используемая в теории игр для определения оптимальных стратегий в условиях неопределённости.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование — это способ ускорения программ путём увеличения количества вычислений.\",\"generated_as_correct\":false}],\"question\":\"Что такое динамическое программирование?\"},{\"answers\":[{\"text\":\"Динамическое программирование ускоряет алгоритмы, исключая повторные вычисления и сохраняя результаты.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование ускоряет выполнение алгоритмов путём параллельного вычисления всех возможных значений, что позволяет мгновенно получать результаты без необходимости сохранения промежуточных данных.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование используется для улучшения читаемости кода и упрощения его структуры, что косвенно может привести к ускорению выполнения алгоритмов за счёт более эффективной отладки.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование ускоряет алгоритмы за счёт уменьшения объёма памяти, используемой для хранения данных.\",\"generated_as_correct\":false}],\"question\":\"Почему динамическое программирование позволяет ускорить выполнение алгоритмов?\"},{\"answers\":[{\"text\":\"Динамическое программирование эффективно для задач с повторяющимися вычислениями, где можно сохранить результаты подзадач.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование наиболее полезно для задач, где требуется однократное вычисление каждого значения без возможности повторного использования результатов, что делает его идеальным для задач с линейной структурой данных.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование применяется для анализа и оптимизации сетевых структур, где основной задачей является поиск кратчайшего пути между узлами в графе.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование полезно для решения задач, где все вычисления уникальны и не повторяются.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение динамического программирования будет наиболее эффективным?\"},{\"answers\":[{\"text\":\"Игрок может взять один камень из набора или по одному из двух наборов.\",\"generated_as_correct\":true},{\"text\":\"Игрок в игре «Камни» на каждом ходу может взять любое количество камней из одного набора.\",\"generated_as_correct\":false},{\"text\":\"В игре «Камни» игроки могут использовать камни для построения определённых комбинаций, которые приносят им очки.\",\"generated_as_correct\":false},{\"text\":\"Игрок может взять три камня из любого набора на каждом ходу.\",\"generated_as_correct\":false}],\"question\":\"Какие действия может совершать игрок в игре «Камни» на каждом ходу?\"},{\"answers\":[{\"text\":\"Игра «Камни» подходит для решения с помощью динамического программирования из-за возможности анализа стратегий и исходов.\",\"generated_as_correct\":true},{\"text\":\"Игра «Камни» решается с помощью динамического программирования, потому что количество камней в каждом наборе постоянно изменяется, что создаёт бесконечное количество возможных состояний.\",\"generated_as_correct\":false},{\"text\":\"Игра «Камни» связана с динамическим программированием, поскольку для победы необходимо учитывать математические последовательности и применять теорию игр.\",\"generated_as_correct\":false},{\"text\":\"Игра «Камни» решается с помощью динамического программирования, потому что игроки могут выбирать любое количество камней за ход.\",\"generated_as_correct\":false}],\"question\":\"Почему игра «Камни» может быть решена с помощью динамического программирования?\"},{\"answers\":[{\"text\":\"Анализ стратегий в игре «Камни» с помощью динамического программирования позволяет предсказать победителя на основе начальных условий.\",\"generated_as_correct\":true},{\"text\":\"В игре «Камни» анализ стратегий не имеет значения, так как исход определяется случайным выбором ходов игроками.\",\"generated_as_correct\":false},{\"text\":\"Анализ стратегий и исходов в игре «Камни» помогает понять принципы комбинаторной математики, но не определяет победителя, так как результат зависит от внешних факторов, не учитываемых в модели.\",\"generated_as_correct\":false},{\"text\":\"В игре «Камни» победитель определяется случайным образом, независимо от анализа стратегий и возможных исходов.\",\"generated_as_correct\":false}],\"question\":\"Как анализ стратегий и возможных исходов помогает определить победителя в игре «Камни»?\"},{\"answers\":[{\"text\":\"Таблица R используется в игре «Камни» для анализа стратегий и определения исходов при разных начальных условиях.\",\"generated_as_correct\":true},{\"text\":\"Таблица R — это таблица, которая содержит случайные исходы игры «Камни» и не зависит от количества камней в наборах.\",\"generated_as_correct\":false},{\"text\":\"Таблица R — это инструмент для визуализации данных о камнях, который используется в геологии для классификации минералов.\",\"generated_as_correct\":false},{\"text\":\"Таблица R содержит информацию о количестве ходов, необходимых для победы в игре «Камни».\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой таблица R в контексте игры «Камни»?\"},{\"answers\":[{\"text\":\"Таблица R систематизирует исходы игры «Камни» при разных начальных условиях, помогая определить выигрышные и проигрышные позиции.\",\"generated_as_correct\":true},{\"text\":\"Таблица R в игре «Камни» используется для подсчёта общего количества камней на поле и не имеет отношения к анализу стратегий или определению выигрышных позиций.\",\"generated_as_correct\":false},{\"text\":\"Таблица R связана с теорией вероятностей и используется для расчёта шансов на победу в играх, не обязательно в «Камни».\",\"generated_as_correct\":false},{\"text\":\"Таблица R содержит информацию о количестве камней, необходимых для выигрыша в игре «Камни».\",\"generated_as_correct\":false}],\"question\":\"Как таблица R помогает анализировать стратегии в игре «Камни»?\"},{\"answers\":[{\"text\":\"Таблица R помогает анализировать стратегии в игре «Камни» и определять выигрышные и проигрышные позиции по значениям $R(n, m)$.\",\"generated_as_correct\":true},{\"text\":\"Таблица R содержит информацию о случайных ходах в игре «Камни», и значения $R(n, m)$ не связаны с анализом стратегий или определением выигрышных позиций.\",\"generated_as_correct\":false},{\"text\":\"Таблица R используется для хранения исторических данных о результатах игр «Камни», но не для анализа стратегий или определения выигрышных и проигрышных позиций.\",\"generated_as_correct\":false},{\"text\":\"Таблица R служит для записи количества ходов в игре «Камни» и не используется для определения выигрышных или проигрышных позиций.\",\"generated_as_correct\":false}],\"question\":\"Каким образом таблица R может быть использована для определения выигрышных и проигрышных позиций в игре?\"},{\"answers\":[{\"text\":\"Алгоритм Rocks определяет исход игры «Камни» с помощью динамического программирования.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Rocks — это алгоритм машинного обучения, который предсказывает исход игры «Камни» на основе исторических данных о предыдущих партиях.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Rocks связан с анализом сетевых структур и используется для оптимизации маршрутов в графах.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Rocks используется для генерации случайных чисел в игре «Камни».\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм Rocks и для чего он используется?\"},{\"answers\":[{\"text\":\"Метод динамического программирования в алгоритме Rocks позволяет анализировать игру «Камни» благодаря использованию таблицы промежуточных результатов.\",\"generated_as_correct\":true},{\"text\":\"Метод динамического программирования в алгоритме Rocks применяется для анализа игры «Камни», так как он позволяет случайным образом генерировать возможные исходы игры, что увеличивает вероятность нахождения выигрышной стратегии.\",\"generated_as_correct\":false},{\"text\":\"Метод динамического программирования важен в алгоритме Rocks, поскольку он используется для оптимизации алгоритмов машинного обучения, применяемых для прогнозирования исходов игры «Камни».\",\"generated_as_correct\":false},{\"text\":\"Метод динамического программирования в алгоритме Rocks используется для анализа игры «Камни», потому что он обеспечивает быстрый поиск всех возможных комбинаций ходов.\",\"generated_as_correct\":false}],\"question\":\"Почему для анализа игры «Камни» в алгоритме Rocks применяется метод динамического программирования?\"},{\"answers\":[{\"text\":\"Алгоритм Rocks определяет исход игры «Камни» при заданных начальных условиях с помощью динамического программирования.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Rocks используется для случайного определения исхода игры «Камни», без учёта начальных условий n и m и без применения методов динамического программирования.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Rocks связан с анализом последовательностей и используется для оптимизации стратегий в играх, не связанных с игрой «Камни».\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Rocks служит для подсчёта количества возможных ходов в игре «Камни», не определяя исход игры.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм Rocks для определения исхода игры «Камни» при заданных начальных условиях?\"},{\"answers\":[{\"text\":\"Алгоритм FastRocks основан на проверке чётности чисел \\\\( n \\\\) и \\\\( m \\\\).\",\"generated_as_correct\":true},{\"text\":\"Алгоритм FastRocks для решения игры «Камни» использует метод случайного выбора чисел \\\\( n \\\\) и \\\\( m \\\\) для определения исхода игры.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм FastRocks использует сложные математические модели для прогнозирования исходов в играх с неполной информацией.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм FastRocks основан на подсчёте суммы чисел \\\\( n \\\\) и \\\\( m \\\\).\",\"generated_as_correct\":false}],\"question\":\"На чём основан алгоритм FastRocks для решения игры «Камни»?\"},{\"answers\":[{\"text\":\"Ограниченность алгоритма FastRocks в сложных вариантах игры обусловлена его основами на чётности чисел и простыми закономерностями.\",\"generated_as_correct\":true},{\"text\":\"Применение алгоритма FastRocks ограничено из-за его зависимости от случайного выбора чисел n и m, что делает его неэффективным в сложных игровых условиях.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм FastRocks может быть ограничен в применении из-за сложностей, связанных с визуализацией игровых данных и пользовательским интерфейсом в более сложных версиях игры.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм FastRocks неэффективен в сложных играх из-за необходимости вручную задавать параметры n и m перед каждым ходом.\",\"generated_as_correct\":false}],\"question\":\"Почему применение алгоритма FastRocks может быть ограничено в более сложных вариантах игры?\"},{\"answers\":[{\"text\":\"FastRocks определяет исход игры, проверяя чётность чисел n и m в таблице R.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм FastRocks определяет исход игры «Камни» путём случайного выбора исхода на основе данных из таблицы R.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм FastRocks используется для анализа статистических данных и не имеет отношения к определению исхода игры «Камни».\",\"generated_as_correct\":false},{\"text\":\"FastRocks определяет исход игры путём подсчёта суммы чисел n и m.\",\"generated_as_correct\":false}],\"question\":\"Как алгоритм FastRocks использует закономерность в таблице R для определения исхода игры?\"}],\"StoreCardId\":null,\"numberInCourse\":\"6.3\"},{\"Name\":\"algo | 6.4 Рекурсивные алгоритмы\",\"Slug\":\"rekursivnye-algoritmy\",\"createdAt\":\"2024-07-03T08:30:38.742Z\",\"updatedAt\":\"2026-01-10T12:07:08.325Z\",\"publishedAt\":\"2024-07-03T08:30:39.878Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/79930/problem\",\"Lead\":\"Насколько эффективно алгоритму вызывать самого себя? Зависит от реализации и задачи. На примере головоломки «Ханойские башни» составим короткий и элегантный рекурсивный алгоритм.\",\"Content\":\"$73\",\"Title\":\"Рекурсивные алгоритмы\",\"LikesCount\":23,\"Quiz\":[{\"answers\":[{\"text\":\"Рекурсия — это когда алгоритм вызывает сам себя для решения подзадач.\",\"generated_as_correct\":true},{\"text\":\"Рекурсия — это метод последовательного выполнения операций в алгоритме, при котором каждая следующая операция зависит от результата предыдущей, но алгоритм при этом не вызывает сам себя.\",\"generated_as_correct\":false},{\"text\":\"Рекурсия — это концепция, используемая в теории графов для описания связей между узлами, которая не имеет отношения к алгоритмам.\",\"generated_as_correct\":false},{\"text\":\"Рекурсия — это процесс последовательного выполнения инструкций в алгоритме без самовызова.\",\"generated_as_correct\":false}],\"question\":\"Что такое рекурсия в контексте алгоритмики?\"},{\"answers\":[{\"text\":\"Рекурсия разбивает сложные задачи на простые подзадачи с аналогичной структурой, решая их путём повторного вызова алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Рекурсия полезна для решения задач с иерархической структурой, потому что она позволяет хранить промежуточные результаты в памяти и использовать их для решения последующих задач, не обращаясь к исходному алгоритму.\",\"generated_as_correct\":false},{\"text\":\"Рекурсия используется в программировании для создания циклов, которые выполняются определённое количество раз, что делает её полезной для задач, требующих многократного выполнения одного и того же действия.\",\"generated_as_correct\":false},{\"text\":\"Рекурсия усложняет решение задач с повторяющейся структурой из-за необходимости хранить множество промежуточных результатов в памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему рекурсия эффективна для решения задач с иерархической или повторяющейся структурой?\"},{\"answers\":[{\"text\":\"Рекурсия разбивает сложную задачу на аналогичные простые подзадачи через повторный вызов алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Рекурсия — это метод, при котором алгоритм вызывает себя для решения подзадач путём последовательного увеличения сложности каждой последующей подзадачи.\",\"generated_as_correct\":false},{\"text\":\"Рекурсия применяется в теории графов для определения связности компонентов графа и не имеет отношения к разбиению задач на подзадачи.\",\"generated_as_correct\":false},{\"text\":\"Рекурсия объединяет простые задачи в одну сложную путём многократного вызова алгоритма.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекурсию для разбиения сложной задачи на более простые подзадачи?\"},{\"answers\":[{\"text\":\"Головоломка «Ханойские башни» состоит из трёх стержней и стопки дисков.\",\"generated_as_correct\":true},{\"text\":\"Головоломка «Ханойские башни» состоит из двух стержней и стопки дисков без отверстий, расположенных на одном из стержней.\",\"generated_as_correct\":false},{\"text\":\"Головоломка «Ханойские башни» включает в себя набор карточек с числами и правила для их упорядочивания на столе.\",\"generated_as_correct\":false},{\"text\":\"Головоломка «Ханойские башни» состоит из пяти стержней и набора кубиков.\",\"generated_as_correct\":false}],\"question\":\"Из каких основных элементов состоит головоломка «Ханойские башни»?\"},{\"answers\":[{\"text\":\"Головоломка «Ханойские башни» — пример задачи, решаемой рекурсивно, так как её решение состоит из повторяющихся шагов.\",\"generated_as_correct\":true},{\"text\":\"Головоломка «Ханойские башни» является классическим примером задачи, решаемой с помощью линейного алгоритма, поскольку для её решения требуется выполнить действия в строго определённом порядке без возврата к предыдущим шагам.\",\"generated_as_correct\":false},{\"text\":\"Головоломка «Ханойские башни» связана с теорией графов и используется для иллюстрации принципов комбинаторики, что делает её полезной в образовательных целях.\",\"generated_as_correct\":false},{\"text\":\"Головоломка «Ханойские башни» — пример задачи, решаемой итеративно, так как её решение требует последовательного выполнения действий без возврата к предыдущим шагам.\",\"generated_as_correct\":false}],\"question\":\"Почему головоломку «Ханойские башни» считают классическим примером задачи, решаемой с помощью рекурсивного алгоритма?\"},{\"answers\":[{\"text\":\"Принцип решения «Ханойских башен» — это использование рекурсивного подхода для разбиения сложной задачи на повторяющиеся простые шаги.\",\"generated_as_correct\":true},{\"text\":\"Принцип решения головоломки «Ханойские башни» можно применить для разбиения сложных задач на более простые шаги путём случайного перебора возможных решений. Этот метод эффективен в областях, где нет чёткой структуры или алгоритма для решения задачи.\",\"generated_as_correct\":false},{\"text\":\"Принцип решения головоломки «Ханойские башни» связан с теорией графов и может быть использован для анализа сетевых структур и оптимизации путей в графах, что применимо в логистике и сетевых технологиях.\",\"generated_as_correct\":false},{\"text\":\"Принцип решения «Ханойских башен» заключается в применении линейного алгоритма для последовательного выполнения действий без разбиения задачи на подзадачи.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить принцип решения головоломки «Ханойские башни» для разбиения сложных задач на более простые шаги в других областях?\"},{\"answers\":[{\"text\":\"Рекурсивный алгоритм для «Ханойских башен» перемещает n дисков с одного стержня на другой, используя третий стержень, через рекурсивное перемещение n-1 дисков.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный алгоритм для «Ханойских башен» предполагает перемещение дисков с одного стержня на другой путём случайного выбора дисков и их перемещения без какой-либо стратегии или порядка.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм для «Ханойских башен» связан с методом динамического программирования, который используется для оптимизации решений в задачах с множеством переменных.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм для «Ханойских башен» заключается в последовательном перемещении дисков с одного стержня на другой без использования промежуточного стержня.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается суть рекурсивного алгоритма для решения головоломки «Ханойские башни»?\"},{\"answers\":[{\"text\":\"Рекурсивный подход позволяет решать задачу «Ханойские башни» путём разбиения её на подзадачи с перемещением n-1 дисков и последующим переносом самого большого диска.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный подход используется для решения задачи «Ханойские башни» из-за того, что он обеспечивает возможность перемещения дисков в произвольном порядке, что позволяет быстрее достичь решения.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный подход важен для решения задачи «Ханойские башни», поскольку он связан с теорией графов и позволяет анализировать возможные пути перемещения дисков как вершины и рёбра графа.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный подход используется для решения задачи «Ханойские башни», потому что он позволяет перемещать все диски одновременно.\",\"generated_as_correct\":false}],\"question\":\"Почему для решения задачи «Ханойские башни» используется именно рекурсивный подход?\"},{\"answers\":[{\"text\":\"Рекурсивный алгоритм для «Ханойских башен» перемещает n-1 дисков на временный стержень, затем самый большой диск на целевой и снова n-1 дисков на целевой.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный алгоритм для «Ханойских башен» заключается в последовательном перемещении дисков с одного стержня на другой без учёта их размера, что приводит к невозможности решения задачи.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм используется для оптимизации маршрутов в логистических задачах, что не имеет отношения к «Ханойским башням».\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм для «Ханойских башен» позволяет переместить все диски за один шаг, минуя использование временного стержня.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекурсивный алгоритм для решения задачи с переносом n дисков в игре «Ханойские башни»?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма «Ханойские башни» для n дисков задаётся рекуррентно: T(n) = 2 * T(n - 1) + 1.\",\"generated_as_correct\":true},{\"text\":\"Время выполнения алгоритма «Ханойские башни» для n дисков определяется формулой T(n) = n^2, что означает квадратичный рост времени выполнения с увеличением количества дисков.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма «Ханойские башни» зависит от сложности рекурсивных вызовов и может быть оптимизировано с помощью методов динамического программирования.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма «Ханойские башни» для n дисков вычисляется по формуле T(n) = n + 1.\",\"generated_as_correct\":false}],\"question\":\"Как выражается время выполнения алгоритма «Ханойские башни» для n дисков?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма «Ханойские башни» растёт экспоненциально с увеличением количества дисков из-за рекуррентного соотношения T(n) = 2 * T(n - 1) + 1.\",\"generated_as_correct\":true},{\"text\":\"Увеличение количества дисков в алгоритме «Ханойские башни» не влияет на время выполнения, так как алгоритм оптимизирован для работы с любым количеством дисков и выполняет операции за постоянное время.\",\"generated_as_correct\":false},{\"text\":\"Увеличение количества дисков в алгоритме «Ханойские башни» влияет на сложность задачи, но это связано с увеличением количества возможных комбинаций, а не с экспоненциальным ростом времени выполнения.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма «Ханойские башни» растёт линейно с увеличением количества дисков.\",\"generated_as_correct\":false}],\"question\":\"Почему увеличение количества дисков в алгоритме «Ханойские башни» приводит к значительному росту времени выполнения?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение T(n) = 2 * T(n - 1) + 1 позволяет предсказать экспоненциальный рост времени выполнения алгоритма «Ханойские башни» с увеличением количества дисков.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение T(n) = 2 * T(n - 1) + 1 можно использовать для расчёта времени выполнения алгоритма «Ханойские башни», однако оно предполагает линейное увеличение времени с ростом количества дисков.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение T(n) = 2 * T(n - 1) + 1 связано с анализом сложности алгоритмов, но оно не применимо для прогнозирования времени выполнения алгоритма «Ханойские башни».\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение T(n) = 2 * T(n - 1) + 1 показывает, что время выполнения алгоритма «Ханойские башни» увеличивается линейно с ростом количества дисков.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать рекуррентное соотношение T(n) = 2 * T(n - 1) + 1 для прогнозирования времени выполнения алгоритма при различном количестве дисков?\"}],\"StoreCardId\":null,\"numberInCourse\":\"6.4\"},{\"Name\":\"algo | 6.5. Алгоритмы «Разделяй и властвуй»\",\"Slug\":\"razdelyaj-i-vlastvuj\",\"createdAt\":\"2024-07-03T08:31:34.733Z\",\"updatedAt\":\"2026-01-10T12:07:08.258Z\",\"publishedAt\":\"2024-07-03T08:31:35.866Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/79935/problem\",\"Lead\":\"Одна большая задача может казаться трудной. Но если разделить её на две задачи в два раза меньше, она станет намного проще. Для таких случаев хорошо подходят алгоритмы «разделяй и властвуй».\",\"Content\":\"$74\",\"Title\":\"Алгоритмы «Разделяй и властвуй»\",\"LikesCount\":27,\"Quiz\":[{\"answers\":[{\"text\":\"Алгоритмы «разделяй и властвуй» разбивают задачу на подзадачи, решают их и объединяют решения.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы «разделяй и властвуй» — это способы решения задач путём случайного выбора подзадач и их последовательного решения без учёта связи между ними.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы «разделяй и властвуй» используются для классификации данных и не предполагают разбиения задачи на подзадачи.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы «разделяй и властвуй» решают задачи путём их усложнения и объединения с другими задачами.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритмы «разделяй и властвуй»?\"},{\"answers\":[{\"text\":\"Алгоритмы «разделяй и властвуй» упрощают решение сложных задач путём их разбиения на более мелкие подзадачи.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы «разделяй и властвуй» эффективны, потому что они позволяют решать задачи параллельно на разных устройствах, что ускоряет процесс решения в несколько раз.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы «разделяй и властвуй» используются для оптимизации работы сетевых протоколов и обеспечивают более быстрое соединение между устройствами в сети.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы «разделяй и властвуй» ускоряют решение сложных задач за счёт увеличения количества операций.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритмы «разделяй и властвуй» эффективны для решения сложных задач?\"},{\"answers\":[{\"text\":\"Алгоритмы «разделяй и властвуй» разбивают сложную задачу на более мелкие, решают их и объединяют решения для получения ответа на исходную задачу.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы «разделяй и властвуй» упрощают решение задачи путём случайного выбора подзадач и их решения без какой-либо системы или порядка, что приводит к непредсказуемым результатам.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы «разделяй и властвуй» используются для анализа данных и прогнозирования тенденций на основе исторических данных, что помогает в принятии решений в условиях неопределённости.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы «разделяй и властвуй» объединяют несколько задач в одну большую, что упрощает их решение.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритмы «разделяй и властвуй» для упрощения процесса решения задачи?\"},{\"answers\":[{\"text\":\"Сортировка — это упорядочивание данных по определённому критерию.\",\"generated_as_correct\":true},{\"text\":\"Сортировка в информатике — это метод шифрования данных, при котором элементы перемешиваются в случайном порядке для обеспечения безопасности информации.\",\"generated_as_correct\":false},{\"text\":\"Сортировка в информатике связана с процессом создания резервных копий данных и их хранения в специальных архивах для последующего восстановления.\",\"generated_as_correct\":false},{\"text\":\"Сортировка — это процесс удаления повторяющихся данных из списка.\",\"generated_as_correct\":false}],\"question\":\"Что такое сортировка в контексте информатики?\"},{\"answers\":[{\"text\":\"Сортировка — фундаментальная операция в информатике, упорядочивающая данные для эффективной обработки.\",\"generated_as_correct\":true},{\"text\":\"Сортировка является фундаментальной операцией в информатике, потому что она позволяет случайным образом распределять данные, что упрощает их анализ и обработку.\",\"generated_as_correct\":false},{\"text\":\"Сортировка важна в информатике, поскольку она тесно связана с теорией графов и используется для построения сложных математических моделей.\",\"generated_as_correct\":false},{\"text\":\"Сортировка считается фундаментальной операцией в информатике, потому что она используется для шифрования данных.\",\"generated_as_correct\":false}],\"question\":\"Почему сортировка считается фундаментальной операцией в информатике?\"},{\"answers\":[{\"text\":\"Сортировка упорядочивает данные, улучшая их обработку в алгоритмах.\",\"generated_as_correct\":true},{\"text\":\"Сортировка заключается в изменении значений данных для их приведения к определённому формату, что помогает улучшить обработку информации в алгоритмах и приложениях.\",\"generated_as_correct\":false},{\"text\":\"Сортировка используется в графических интерфейсах для визуального представления данных и не оказывает значительного влияния на алгоритмы обработки данных.\",\"generated_as_correct\":false},{\"text\":\"Сортировка изменяет структуру данных, не влияя на их порядок, что улучшает обработку информации.\",\"generated_as_correct\":false}],\"question\":\"Как сортировка может быть применена для улучшения обработки данных в алгоритмах и приложениях?\"},{\"answers\":[{\"text\":\"SelectionSort — это алгоритм сортировки, который пошагово находит минимальный элемент и перемещает его на нужное место.\",\"generated_as_correct\":true},{\"text\":\"SelectionSort — это метод сортировки, который случайным образом выбирает элементы из массива и меняет их местами до тех пор, пока массив не будет отсортирован.\",\"generated_as_correct\":false},{\"text\":\"SelectionSort используется для поиска элементов в массиве и основан на принципе бинарного поиска.\",\"generated_as_correct\":false},{\"text\":\"SelectionSort — это алгоритм сортировки, который делит массив на части и объединяет их в отсортированном порядке.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм SelectionSort?\"},{\"answers\":[{\"text\":\"Эффективность SelectionSort ограничена для больших данных из-за квадратичного времени выполнения O(n^2).\",\"generated_as_correct\":true},{\"text\":\"Эффективность алгоритма SelectionSort ограничена для больших объёмов данных из-за его высокой сложности по памяти, которая растёт экспоненциально с увеличением размера данных.\",\"generated_as_correct\":false},{\"text\":\"Эффективность алгоритма SelectionSort ограничена из-за его зависимости от начальной упорядоченности данных, что делает его менее предсказуемым для больших наборов данных.\",\"generated_as_correct\":false},{\"text\":\"Эффективность SelectionSort ограничена для больших данных из-за его высокой сложности по памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему эффективность алгоритма SelectionSort ограничена для больших объёмов данных?\"},{\"answers\":[{\"text\":\"SelectionSort подходит для небольших наборов данных и образовательных целей из-за простоты реализации.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм SelectionSort наиболее эффективен при работе с уже частично отсортированными данными, что делает его предпочтительным выбором для определённых специализированных задач.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм SelectionSort часто используется в системах реального времени из-за его предсказуемого времени выполнения, что важно для задач с жёсткими временными ограничениями.\",\"generated_as_correct\":false},{\"text\":\"SelectionSort эффективен для сортировки больших массивов данных благодаря своей высокой скорости выполнения.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение алгоритма SelectionSort может быть целесообразным, несмотря на его ограниченную эффективность?\"},{\"answers\":[{\"text\":\"Алгоритм MergeSort основан на принципе «разделяй и властвуй» — разделение массива, рекурсивная сортировка и объединение частей.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм MergeSort основан на принципе последовательного сравнения элементов массива и их перестановки в нужном порядке, что позволяет сортировать массив за один проход.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм MergeSort использует метод прямого обмена элементов массива для достижения отсортированного порядка, что делает его похожим на алгоритм BubbleSort.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм MergeSort основан на принципе последовательного сравнения и перестановки элементов массива.\",\"generated_as_correct\":false}],\"question\":\"На каком принципе основан алгоритм MergeSort?\"},{\"answers\":[{\"text\":\"MergeSort эффективнее SelectionSort из-за времени выполнения $O(n \\\\log n)$.\",\"generated_as_correct\":true},{\"text\":\"MergeSort более эффективен, чем SelectionSort, поскольку он выполняет сортировку за один проход по массиву, в то время как SelectionSort требует многократного прохода.\",\"generated_as_correct\":false},{\"text\":\"MergeSort и SelectionSort оба являются алгоритмами сортировки, но MergeSort лучше подходит для параллельной обработки данных, что не имеет отношения к его эффективности по сравнению с SelectionSort.\",\"generated_as_correct\":false},{\"text\":\"MergeSort медленнее SelectionSort, так как требует больше памяти для работы с данными.\",\"generated_as_correct\":false}],\"question\":\"Почему MergeSort считается более эффективным алгоритмом сортировки по сравнению с SelectionSort?\"},{\"answers\":[{\"text\":\"Алгоритм MergeSort эффективен для сортировки больших объёмов данных благодаря принципу «разделяй и властвуй» и времени выполнения $O(n \\\\log n)$.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм MergeSort используется для обработки больших объёмов данных путём случайного выбора элементов и их перемещения в отсортированный массив, что обеспечивает быструю работу с данными.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм MergeSort может быть использован для анализа данных, но его основное применение — в области машинного обучения для классификации данных.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм MergeSort неэффективен для обработки больших объёмов данных из-за линейного времени выполнения.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм MergeSort для обработки больших объёмов данных?\"},{\"answers\":[{\"text\":\"Слияние — это объединение двух отсортированных списков в один.\",\"generated_as_correct\":true},{\"text\":\"Слияние представляет собой процесс случайного объединения элементов из двух списков без учёта их порядка, что применяется в алгоритмах сортировки для увеличения энтропии данных.\",\"generated_as_correct\":false},{\"text\":\"Слияние относится к методу комбинирования данных из разных источников в базах данных, что не связано напрямую с алгоритмами сортировки.\",\"generated_as_correct\":false},{\"text\":\"Слияние — это разделение одного списка на несколько частей.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой процесс слияния (Merge)?\"},{\"answers\":[{\"text\":\"Слияние в MergeSort важно для объединения двух отсортированных подмассивов в один упорядоченный массив.\",\"generated_as_correct\":true},{\"text\":\"Слияние в алгоритме MergeSort используется для случайного перемешивания элементов двух массивов, что помогает достичь равномерного распределения значений в итоговом массиве.\",\"generated_as_correct\":false},{\"text\":\"Слияние в алгоритме MergeSort связано с процессом сравнения элементов массива по определённым критериям, что позволяет определить их порядок без фактического объединения массивов.\",\"generated_as_correct\":false},{\"text\":\"Слияние в алгоритме MergeSort нужно для разделения массива на более мелкие части.\",\"generated_as_correct\":false}],\"question\":\"Почему слияние является важным этапом в алгоритме MergeSort?\"},{\"answers\":[{\"text\":\"Слияние объединяет несколько отсортированных списков в один отсортированный.\",\"generated_as_correct\":true},{\"text\":\"Процесс слияния заключается в простом добавлении элементов из нескольких списков друг к другу без учёта их порядка, что приводит к созданию одного большого, но не отсортированного списка.\",\"generated_as_correct\":false},{\"text\":\"Процесс слияния применяется для объединения данных из разных источников в базы данных, что позволяет создавать более полные и точные отчёты.\",\"generated_as_correct\":false},{\"text\":\"Слияние разделяет один большой список на несколько маленьких неупорядоченных списков.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить процесс слияния для объединения нескольких отсортированных списков?\"}],\"StoreCardId\":null,\"numberInCourse\":\"6.5\"},{\"Name\":\"algo | 6.6. Рандомизированные алгоритмы\",\"Slug\":\"randomizirovannye-algoritmy\",\"createdAt\":\"2024-07-03T08:32:10.809Z\",\"updatedAt\":\"2026-01-10T12:07:08.193Z\",\"publishedAt\":\"2024-07-03T08:32:12.138Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/79936/problem\",\"Lead\":\"Случайность в действиях алгоритма может приводить к неопределённости в точности результатов или времени работы. В этом параграфе спроектируем и оценим трудоёмкость рандомизированного алгоритма для задачи сортировки.\",\"Content\":\"$75\",\"Title\":\"Рандомизированные алгоритмы\",\"LikesCount\":15,\"Quiz\":[{\"answers\":[{\"text\":\"Вероятностный алгоритм использует случайность и может давать разные результаты при одинаковых входных данных.\",\"generated_as_correct\":true},{\"text\":\"Вероятностный алгоритм — это алгоритм, который использует фиксированные правила для обработки данных и не допускает случайных изменений в процессе выполнения, что гарантирует одинаковые результаты при каждом запуске.\",\"generated_as_correct\":false},{\"text\":\"Вероятностный алгоритм — это метод, используемый в теории игр для определения оптимальных стратегий, который не учитывает элементы случайности и основывается исключительно на математических моделях.\",\"generated_as_correct\":false},{\"text\":\"Вероятностный алгоритм всегда даёт одинаковые результаты, независимо от использования случайности в процессе выполнения.\",\"generated_as_correct\":false}],\"question\":\"Что такое вероятностный алгоритм?\"},{\"answers\":[{\"text\":\"Вероятностные алгоритмы быстрее за счёт использования случайности в процессе выполнения.\",\"generated_as_correct\":true},{\"text\":\"Вероятностные алгоритмы более эффективны по времени выполнения, потому что они исключают возможность ошибок, связанных со случайностью, и обеспечивают стабильное время работы.\",\"generated_as_correct\":false},{\"text\":\"Вероятностные алгоритмы используются для повышения точности вычислений в задачах машинного обучения и не имеют прямого отношения к времени выполнения по сравнению с детерминированными алгоритмами.\",\"generated_as_correct\":false},{\"text\":\"Вероятностные алгоритмы медленнее, так как требуют дополнительных вычислений для обеспечения стабильности результатов.\",\"generated_as_correct\":false}],\"question\":\"Почему вероятностные алгоритмы могут быть более эффективными по времени выполнения по сравнению с детерминированными алгоритмами?\"},{\"answers\":[{\"text\":\"Вероятностные алгоритмы эффективны для задач, где важна скорость выполнения, и допустимы варьирующиеся результаты.\",\"generated_as_correct\":true},{\"text\":\"Вероятностные алгоритмы наиболее эффективны в задачах, где требуется точное повторение результатов при каждом запуске, и их использование оправдано в условиях строгих требований к точности данных.\",\"generated_as_correct\":false},{\"text\":\"Вероятностные алгоритмы применяются в криптографии для создания случайных ключей, что обеспечивает высокий уровень безопасности, но их эффективность не связана с вариативностью результатов.\",\"generated_as_correct\":false},{\"text\":\"Вероятностные алгоритмы целесообразно использовать, когда требуется получить одинаковые результаты при каждом запуске алгоритма.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях использование вероятностных алгоритмов может быть целесообразным, несмотря на вариативность их результатов?\"},{\"answers\":[{\"text\":\"Детерминированный алгоритм всегда выдаёт один и тот же результат при одинаковых входных данных.\",\"generated_as_correct\":true},{\"text\":\"Детерминированный алгоритм — это алгоритм, который использует случайные числа для генерации результатов, что делает его непредсказуемым при одинаковых входных данных.\",\"generated_as_correct\":false},{\"text\":\"Детерминированный алгоритм — это концепция, связанная с теорией вероятностей и статистическим анализом данных.\",\"generated_as_correct\":false},{\"text\":\"Детерминированный алгоритм может давать разные результаты при одинаковых входных данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое детерминированный алгоритм?\"},{\"answers\":[{\"text\":\"Детерминированные алгоритмы важны, так как обеспечивают одинаковые результаты при одинаковых данных.\",\"generated_as_correct\":true},{\"text\":\"Детерминированные алгоритмы обеспечивают точность и надёжность за счёт использования случайных чисел, что делает результаты непредсказуемыми, но уникальными для каждого запуска.\",\"generated_as_correct\":false},{\"text\":\"Детерминированные алгоритмы используются в криптографии для создания уникальных ключей, что не связано напрямую с их точностью и надёжностью в других приложениях.\",\"generated_as_correct\":false},{\"text\":\"Детерминированные алгоритмы важны, потому что они позволяют получать разные результаты при одинаковых входных данных.\",\"generated_as_correct\":false}],\"question\":\"Почему детерминированные алгоритмы важны для приложений, требующих точности и надёжности?\"},{\"answers\":[{\"text\":\"Детерминированный алгоритм гарантирует одинаковые результаты при одних и тех же входных данных.\",\"generated_as_correct\":true},{\"text\":\"Детерминированный алгоритм использует случайные входные данные для обеспечения уникальности результатов при каждом запуске, что позволяет получать разнообразные исходы в задачах с высокой степенью неопределённости.\",\"generated_as_correct\":false},{\"text\":\"Детерминированный алгоритм применяется в криптографии для создания ключей, которые могут меняться в зависимости от внешних условий, обеспечивая высокий уровень безопасности.\",\"generated_as_correct\":false},{\"text\":\"Детерминированный алгоритм позволяет получать разные результаты при одних и тех же входных данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать детерминированный алгоритм для обеспечения предсказуемости результатов в определённой задаче?\"},{\"answers\":[{\"text\":\"QuickSort — алгоритм сортировки, использующий стратегию «разделяй и властвуй» с выбором опорного элемента.\",\"generated_as_correct\":true},{\"text\":\"QuickSort — это алгоритм сортировки, который работает по принципу циклического перебора элементов массива и их последовательного перемещения в нужное место без использования опорного элемента.\",\"generated_as_correct\":false},{\"text\":\"QuickSort — это метод оптимизации запросов в базах данных, который использует стратегию индексации для ускорения доступа к данным.\",\"generated_as_correct\":false},{\"text\":\"QuickSort — алгоритм сортировки, который использует метод полного перебора для упорядочивания элементов массива.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм QuickSort и какую стратегию он использует?\"},{\"answers\":[{\"text\":\"Выбор опорного элемента важен для эффективности разделения массива в QuickSort.\",\"generated_as_correct\":true},{\"text\":\"Выбор опорного элемента важен для QuickSort, потому что от него зависит количество итераций, необходимых для полного упорядочивания массива, причём наилучший результат достигается при выборе среднего элемента по значению.\",\"generated_as_correct\":false},{\"text\":\"Выбор опорного элемента влияет на стабильность алгоритма QuickSort, определяя, сохранит ли он относительный порядок равных элементов в массиве.\",\"generated_as_correct\":false},{\"text\":\"Выбор опорного элемента не влияет на производительность QuickSort, так как алгоритм адаптируется к любому выбранному элементу.\",\"generated_as_correct\":false}],\"question\":\"Почему выбор опорного элемента важен для производительности QuickSort?\"},{\"answers\":[{\"text\":\"QuickSort эффективен для больших объёмов данных при оптимальном выборе опорного элемента.\",\"generated_as_correct\":true},{\"text\":\"QuickSort показывает наилучшие результаты при сортировке данных, когда опорный элемент выбирается случайным образом, независимо от содержимого массива.\",\"generated_as_correct\":false},{\"text\":\"QuickSort часто используется в ситуациях, когда требуется обеспечить высокую безопасность данных, благодаря своей способности эффективно шифровать информацию при сортировке.\",\"generated_as_correct\":false},{\"text\":\"QuickSort лучше всего работает с уже отсортированными данными, так как это минимизирует количество операций разделения.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение алгоритма QuickSort будет наиболее эффективным?\"},{\"answers\":[{\"text\":\"RandomizedQuickSort — модификация QuickSort со случайным выбором опорного элемента.\",\"generated_as_correct\":true},{\"text\":\"RandomizedQuickSort — это алгоритм сортировки, который использует фиксированный опорный элемент и случайные перестановки элементов для ускорения работы, что делает его более эффективным по сравнению с обычным QuickSort.\",\"generated_as_correct\":false},{\"text\":\"RandomizedQuickSort — это метод, связанный с теорией вероятностей, который используется для анализа статистических данных и не имеет отношения к алгоритмам сортировки.\",\"generated_as_correct\":false},{\"text\":\"RandomizedQuickSort — версия QuickSort с заранее определённым опорным элементом.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм RandomizedQuickSort?\"},{\"answers\":[{\"text\":\"Случайный выбор опорного элемента в RandomizedQuickSort снижает вероятность наихудшего случая и улучшает время выполнения.\",\"generated_as_correct\":true},{\"text\":\"В RandomizedQuickSort опорный элемент выбирается случайным образом для того, чтобы усложнить анализ алгоритма и сделать его более трудным для понимания.\",\"generated_as_correct\":false},{\"text\":\"В RandomizedQuickSort случайный выбор опорного элемента используется для обеспечения равномерного распределения данных в памяти, что способствует более эффективному использованию кэша процессора.\",\"generated_as_correct\":false},{\"text\":\"Случайный выбор опорного элемента в RandomizedQuickSort нужен для того, чтобы сделать алгоритм более сложным и непредсказуемым.\",\"generated_as_correct\":false}],\"question\":\"Почему в RandomizedQuickSort опорный элемент выбирается случайным образом?\"},{\"answers\":[{\"text\":\"Случайный выбор опорного элемента улучшает эффективность RandomizedQuickSort, снижая вероятность наихудшего случая.\",\"generated_as_correct\":true},{\"text\":\"Случайный выбор опорного элемента не влияет на эффективность алгоритма RandomizedQuickSort, так как время выполнения зависит только от количества элементов в массиве.\",\"generated_as_correct\":false},{\"text\":\"Случайный выбор опорного элемента влияет на стабильность алгоритма RandomizedQuickSort, что может быть полезно при работе с данными, содержащими повторяющиеся значения.\",\"generated_as_correct\":false},{\"text\":\"Случайный выбор опорного элемента делает алгоритм RandomizedQuickSort менее предсказуемым, но не влияет на его эффективность.\",\"generated_as_correct\":false}],\"question\":\"Как случайный выбор опорного элемента влияет на эффективность алгоритма RandomizedQuickSort?\"},{\"answers\":[{\"text\":\"Ожидаемое время выполнения — среднее время работы вероятностного алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Ожидаемое время выполнения вероятностного алгоритма — это фиксированное время, которое требуется алгоритму для завершения работы при любых условиях.\",\"generated_as_correct\":false},{\"text\":\"Ожидаемое время выполнения вероятностного алгоритма связано с количеством операций, необходимых для его реализации, и не учитывает вероятности различных исходов.\",\"generated_as_correct\":false},{\"text\":\"Ожидаемое время выполнения — это минимальное время, за которое вероятностный алгоритм может завершить работу.\",\"generated_as_correct\":false}],\"question\":\"Что такое ожидаемое время выполнения вероятностного алгоритма?\"},{\"answers\":[{\"text\":\"Ожидаемое время выполнения позволяет оценить среднюю производительность вероятностных алгоритмов.\",\"generated_as_correct\":true},{\"text\":\"Ожидаемое время выполнения — это фиксированное время, за которое вероятностный алгоритм гарантированно выполнит задачу. Этот показатель важен, потому что он даёт точное представление о времени работы алгоритма в любых условиях.\",\"generated_as_correct\":false},{\"text\":\"Ожидаемое время выполнения связано с определением сложности алгоритма и используется для классификации алгоритмов по их временной сложности в рамках теории вычислений.\",\"generated_as_correct\":false},{\"text\":\"Ожидаемое время выполнения показывает максимальное время работы алгоритма в оптимальных условиях.\",\"generated_as_correct\":false}],\"question\":\"Почему ожидаемое время выполнения считается важным показателем эффективности вероятностных алгоритмов?\"},{\"answers\":[{\"text\":\"Ожидаемое время выполнения позволяет оценить среднюю производительность вероятностного алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Ожидаемое время выполнения — это фиксированное время, необходимое для завершения работы вероятностного алгоритма при любых условиях. Оно не зависит от вероятностей различных исходов и всегда одинаково.\",\"generated_as_correct\":false},{\"text\":\"Ожидаемое время выполнения используется для определения сложности алгоритма в терминах Big O notation и не связано с оценкой производительности в реальных условиях.\",\"generated_as_correct\":false},{\"text\":\"Ожидаемое время выполнения показывает максимальное время работы вероятностного алгоритма.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать ожидаемое время выполнения для оценки производительности вероятностных алгоритмов в реальных условиях?\"},{\"answers\":[{\"text\":\"Алгоритмы класса Лас-Вегас всегда дают правильный результат, но время их выполнения варьируется.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы класса Лас-Вегас — это вероятностные алгоритмы, которые иногда выдают неправильный результат, но всегда выполняются за фиксированное время.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы класса Лас-Вегас используются для генерации случайных чисел и не имеют отношения к времени выполнения или правильности результата.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы класса Лас-Вегас могут давать неправильный результат, но выполняются за фиксированное время.\",\"generated_as_correct\":false}],\"question\":\"Что характеризует алгоритмы класса Лас-Вегас с точки зрения их результата и времени выполнения?\"},{\"answers\":[{\"text\":\"Алгоритмы Лас-Вегас вероятностные, так как их время выполнения варьируется, но результат всегда правильный.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы класса Лас-Вегас считаются вероятностными из-за того, что они используют случайные числа для генерации решений, но их время выполнения фиксировано.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы класса Лас-Вегас связаны с теорией игр и стратегиями принятия решений в условиях неопределённости, что делает их вероятностными.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы Лас-Вегас вероятностные, потому что они могут давать неправильные ответы.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритмы класса Лас-Вегас считаются вероятностными?\"},{\"answers\":[{\"text\":\"Алгоритмы класса Лас-Вегас полезны, когда нужно получить точное решение, даже если время выполнения не определено.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы класса Лас-Вегас применяются в случаях, когда необходимо получить приблизительное решение задачи с фиксированным временем выполнения.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы класса Лас-Вегас используются для оптимизации сетевых протоколов и обеспечения безопасности данных в криптографических системах.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы класса Лас-Вегас подходят для задач, где требуется быстрое, но не обязательно точное решение.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях может быть полезно применение алгоритмов класса Лас-Вегас, несмотря на вариативность времени их выполнения?\"},{\"answers\":[{\"text\":\"Алгоритмы класса Монте-Карло — это вероятностные алгоритмы, дающие приближённые решения быстро и просто.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы класса Монте-Карло — это алгоритмы, которые используют строго определённые математические формулы для вычисления точных значений и не допускают никаких отклонений от этих формул.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы класса Монте-Карло применяются в теории графов для поиска кратчайших путей и оптимизации сетевых потоков.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы класса Монте-Карло — это методы, гарантирующие точное решение сложных задач.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритмы класса Монте-Карло?\"},{\"answers\":[{\"text\":\"Алгоритмы Монте-Карло быстрее и проще в реализации, хотя могут быть менее точными.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы класса Монте-Карло считаются более предпочтительными, так как они обеспечивают точное решение для задач, где другие алгоритмы не могут найти решение в принципе.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы класса Монте-Карло используются для генерации случайных чисел и не сравнимы с алгоритмами, гарантирующими точное решение, в контексте их применения в криптографии.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы Монте-Карло всегда дают точные решения и поэтому предпочтительнее других алгоритмов.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритмы класса Монте-Карло могут быть предпочтительнее алгоритмов, гарантирующих точное решение?\"},{\"answers\":[{\"text\":\"Алгоритмы Монте-Карло применяют, когда нужно быстрое и простое решение, пусть и приближённое.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы класса Монте-Карло применяются только в теоретических исследованиях и не используются в практических задачах из-за их низкой надёжности.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы класса Монте-Карло находят применение в криптографии для генерации случайных чисел, что обеспечивает высокий уровень безопасности шифров.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы Монте-Карло используют только для решения задач с гарантированной точностью результата.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях можно применить алгоритмы класса Монте-Карло, учитывая их особенности?\"}],\"StoreCardId\":null,\"numberInCourse\":\"6.6\"},{\"Name\":\"algo | 6.7. Чему вы научились\",\"Slug\":\"chemu-vi-nauchilis-six\",\"createdAt\":\"2024-07-03T08:32:10.809Z\",\"updatedAt\":\"2025-09-11T18:34:56.890Z\",\"publishedAt\":\"2025-09-09T09:27:28.329Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$76\",\"Title\":\"Чему вы научились\",\"LikesCount\":15,\"Quiz\":null,\"StoreCardId\":null,\"numberInCourse\":\"6.7\"}]},{\"id\":33,\"Name\":\"7. Жадные алгоритмы\",\"Articles\":[{\"Name\":\"algo | 7.1. Задача «Размен»\",\"Slug\":\"zadacha-razmen\",\"createdAt\":\"2024-07-03T08:36:55.694Z\",\"updatedAt\":\"2026-01-10T12:07:09.253Z\",\"publishedAt\":\"2024-07-03T08:36:56.900Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80765/problem\",\"Lead\":null,\"Content\":\"$77\",\"Title\":\"Задача «Размен»\",\"LikesCount\":20,\"Quiz\":[{\"answers\":[{\"text\":\"Жадный алгоритм — это метод решения задач оптимизации, который на каждом шаге выбирает локально наилучшее решение.\",\"generated_as_correct\":true},{\"text\":\"Жадный алгоритм — это алгоритм, который случайным образом выбирает решения на каждом шаге, не заботясь о том, чтобы конечное решение было оптимальным.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм — это метод, используемый в теории графов для определения кратчайшего пути между двумя вершинами в графе.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм — это метод, который всегда гарантирует нахождение глобального оптимального решения задачи.\",\"generated_as_correct\":false}],\"question\":\"Что такое жадный алгоритм?\"},{\"answers\":[{\"text\":\"Жадные алгоритмы могут не давать оптимального решения, поэтому их корректность нужно доказывать.\",\"generated_as_correct\":true},{\"text\":\"Жадные алгоритмы не всегда находят оптимальное решение из-за сложности реализации, а не из-за особенностей самого подхода.\",\"generated_as_correct\":false},{\"text\":\"Жадные алгоритмы просты в реализации и всегда эффективны для решения задач сортировки, поэтому их корректность не требует доказательства.\",\"generated_as_correct\":false},{\"text\":\"Жадные алгоритмы всегда дают оптимальное решение, поэтому их корректность очевидна.\",\"generated_as_correct\":false}],\"question\":\"Почему корректность жадных алгоритмов не всегда очевидна и требует доказательства?\"},{\"answers\":[{\"text\":\"Жадные алгоритмы применяются в задачах оптимизации для поиска наилучшего решения на основе локальных выборов.\",\"generated_as_correct\":true},{\"text\":\"Жадные алгоритмы применяются в задачах, где требуется выполнить большое количество итераций для достижения результата, например, в машинном обучении и нейронных сетях.\",\"generated_as_correct\":false},{\"text\":\"Жадные алгоритмы используются в криптографии для генерации ключей и в теории игр для определения стратегий.\",\"generated_as_correct\":false},{\"text\":\"Жадные алгоритмы используются для решения сложных комбинаторных задач, где глобальная оптимизация невозможна.\",\"generated_as_correct\":false}],\"question\":\"В каких типах задач часто применяются жадные алгоритмы и почему?\"},{\"answers\":[{\"text\":\"Алгоритм Change определяет минимальное количество монет для выдачи сдачи, выбирая монеты с наибольшим номиналом.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Change — это алгоритм, который используется для подсчёта общего количества монет, необходимых для накопления определённой суммы, путём сложения всех доступных номиналов монет без учёта их количества.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Change связан с методами шифрования данных и используется для изменения ключей в криптографических системах.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Change используется для определения максимального количества монет, необходимых для накопления определённой суммы.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм Change?\"},{\"answers\":[{\"text\":\"Алгоритм Change выбирает монету с наибольшим номиналом, не превышающим оставшуюся сумму.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Change выбирает монету с наименьшим номиналом, чтобы минимизировать количество используемых монет.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Change использует сложные математические формулы для определения оптимального распределения монет по номиналам без учёта текущей суммы сдачи.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Change выбирает монеты по порядку их номинала от меньшего к большему.\",\"generated_as_correct\":false}],\"question\":\"Каким образом алгоритм Change определяет, какую монету выбрать следующей?\"},{\"answers\":[{\"text\":\"Алгоритм Change определяет минимальное количество монет для выдачи сдачи, выбирая монеты с наибольшим номиналом, не превышающим оставшуюся сумму.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм Change позволяет определить количество монет каждого номинала, которое нужно выдать в качестве сдачи, путём случайного выбора монет до достижения необходимой суммы.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Change может быть использован для сортировки монет по номиналу перед их выдачей, что ускоряет процесс подсчёта суммы.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм Change выдаёт сдачу, выбирая монеты случайным образом до достижения необходимой суммы.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм Change для решения задачи выдачи сдачи определённой суммы денег?\"},{\"answers\":[{\"text\":\"Оптимальное решение — это решение, которое оптимизирует целевую функцию при заданных ограничениях.\",\"generated_as_correct\":true},{\"text\":\"Оптимальное решение — это любое решение задачи, удовлетворяющее ограничениям, независимо от значения целевой функции.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение связано с выбором наилучшего алгоритма для сортировки данных в условиях ограниченного времени выполнения.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение — это первое найденное решение задачи, не обязательно учитывающее целевую функцию и ограничения.\",\"generated_as_correct\":false}],\"question\":\"Что такое оптимальное решение в контексте задачи с целевой функцией и ограничениями?\"},{\"answers\":[{\"text\":\"В алгоритме Change оптимальное решение — это минимальное количество монет для выдачи нужной суммы сдачи.\",\"generated_as_correct\":true},{\"text\":\"В алгоритме Change оптимальное решение определяется как среднее количество монет, которое приблизительно соответствует необходимой сумме сдачи, чтобы упростить расчёты и ускорить процесс выдачи.\",\"generated_as_correct\":false},{\"text\":\"В алгоритме Change оптимальное решение связано с определением наиболее удобных номиналов монет для пользователей, что не всегда соответствует минимальному количеству монет.\",\"generated_as_correct\":false},{\"text\":\"В алгоритме Change оптимальное решение определяется как максимально возможное количество монет для выдачи суммы сдачи.\",\"generated_as_correct\":false}],\"question\":\"Почему в алгоритме Change оптимальное решение определяется как минимальное количество монет?\"},{\"answers\":[{\"text\":\"Оптимальное решение для задачи выдачи сдачи — это минимальное количество монет для заданной суммы.\",\"generated_as_correct\":true},{\"text\":\"Концепция оптимального решения для задачи выдачи сдачи состоит в том, чтобы выдать сдачу, используя равное количество монет каждого номинала, независимо от суммы сдачи.\",\"generated_as_correct\":false},{\"text\":\"Концепция оптимального решения для задачи выдачи сдачи связана с разработкой алгоритмов для сортировки монет по номиналу перед выдачей сдачи.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение для задачи выдачи сдачи — это использование наибольшего количества монет крупного номинала.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить концепцию оптимального решения для задачи выдачи сдачи?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма зависит от размера входных данных, например, для алгоритма Change оно оценивается как O(money).\",\"generated_as_correct\":true},{\"text\":\"Время выполнения алгоритма определяется исключительно количеством строк кода в его реализации, а не размером входных данных.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма связано с количеством операций ввода-вывода, которые алгоритм выполняет, и не зависит от размера входных данных.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма не зависит от размера входных данных и определяется только сложностью самого алгоритма.\",\"generated_as_correct\":false}],\"question\":\"Что такое время выполнения алгоритма и как оно связано с размером входных данных?\"},{\"answers\":[{\"text\":\"Однострочная версия алгоритма Change быстрее, так как требует меньше операций.\",\"generated_as_correct\":true},{\"text\":\"Однострочная версия алгоритма Change более эффективна по времени выполнения, поскольку она использует более сложные математические формулы, которые ускоряют процесс вычислений.\",\"generated_as_correct\":false},{\"text\":\"Однострочная версия алгоритма Change более эффективна, потому что она использует меньше памяти для хранения промежуточных результатов.\",\"generated_as_correct\":false},{\"text\":\"Однострочная версия алгоритма Change эффективнее, потому что работает с меньшими входными данными.\",\"generated_as_correct\":false}],\"question\":\"Почему однострочная версия алгоритма Change считается более эффективной по времени выполнения?\"},{\"answers\":[{\"text\":\"Оценка времени выполнения алгоритма O(money) помогает понять, что однострочная версия алгоритма более эффективна для работы с разными суммами сдачи.\",\"generated_as_correct\":true},{\"text\":\"Оценка времени выполнения алгоритма O(money) означает, что время выполнения алгоритма зависит от количества монет, используемых для сдачи, а не от суммы. Для оптимизации работы нужно минимизировать количество различных типов монет.\",\"generated_as_correct\":false},{\"text\":\"Оценка времени выполнения алгоритма O(money) используется для определения сложности алгоритма в контексте обработки финансовых транзакций, но не связана напрямую с оптимизацией работы с разными суммами сдачи.\",\"generated_as_correct\":false},{\"text\":\"Оценка времени выполнения алгоритма O(money) показывает, что более сложные версии алгоритма предпочтительнее для работы с небольшими суммами сдачи.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать оценку времени выполнения алгоритма O(money) для оптимизации работы с разными суммами сдачи?\"}],\"StoreCardId\":null,\"numberInCourse\":\"7.1\"},{\"Name\":\"algo | 7.2 Задача «Специи»\",\"Slug\":\"zadacha-specii\",\"createdAt\":\"2024-07-03T08:38:36.699Z\",\"updatedAt\":\"2026-01-10T12:07:09.524Z\",\"publishedAt\":\"2024-07-03T08:38:38.079Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80766/problem\",\"Lead\":null,\"Content\":\"$78\",\"Title\":\"Задача «Специи»\",\"LikesCount\":26,\"Quiz\":[{\"answers\":[{\"text\":\"Задача о рюкзаке — выбор предметов с максимальной ценностью при ограниченном весе.\",\"generated_as_correct\":true},{\"text\":\"Задача о рюкзаке — это поиск такого набора предметов, при котором их общий вес и ценность будут равны заданным значениям без каких-либо ограничений.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке связана с определением оптимального маршрута для доставки предметов, учитывая их вес и ценность, что применяется в теории графов.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке — равномерное распределение предметов по весу и ценности без учёта ограничений.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается суть задачи о рюкзаке?\"},{\"answers\":[{\"text\":\"Задача о рюкзаке — это проблема оптимизации, где нужно максимизировать ценность предметов при ограничении по весу.\",\"generated_as_correct\":true},{\"text\":\"Задача о рюкзаке считается проблемой оптимизации, поскольку она требует минимизировать общий вес предметов, не учитывая их ценность.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке связана с теорией графов и используется для определения кратчайшего пути между двумя точками.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке — это задача на вычисление общего веса предметов без учёта их ценности.\",\"generated_as_correct\":false}],\"question\":\"Почему задача о рюкзаке считается проблемой оптимизации?\"},{\"answers\":[{\"text\":\"Задача о рюкзаке помогает выбрать оптимальный набор предметов с максимальным общим значением при ограничении по весу, что применяется в логистике для эффективного распределения грузов.\",\"generated_as_correct\":true},{\"text\":\"Задача о рюкзаке — это метод распределения ресурсов, который учитывает только вес предметов, игнорируя их ценность. В логистике она применяется для определения максимального количества товаров, которые можно поместить в транспортное средство, не учитывая их стоимость или полезность.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке используется в криптографии для создания сложных алгоритмов шифрования, что имеет косвенное отношение к логистике и управлению ресурсами, так как обеспечивает безопасность данных при транспортировке.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке используется для минимизации веса груза при максимальной загрузке транспортного средства, без учёта ценности предметов.\",\"generated_as_correct\":false}],\"question\":\"Как задача о рюкзаке может быть применена в логистике и управлении ресурсами?\"},{\"answers\":[{\"text\":\"Стоимость специи — это отношение её цены к весу ($\\\\frac{c_i}{w_i}$).\",\"generated_as_correct\":true},{\"text\":\"Стоимость специи определяется как разница между её ценой и весом ($c_i - w_i$), что показывает, насколько цена превышает вес специи.\",\"generated_as_correct\":false},{\"text\":\"Стоимость специи зависит от её редкости, сложности добычи и спроса на рынке, что влияет на конечную цену продукта.\",\"generated_as_correct\":false},{\"text\":\"Стоимость специи рассчитывается как сумма её цены и веса ($c_i + w_i$).\",\"generated_as_correct\":false}],\"question\":\"Как определяется стоимость специи согласно данному утверждению?\"},{\"answers\":[{\"text\":\"Сравнение стоимости специй за единицу веса помогает определить их ценность и сделать рациональный выбор.\",\"generated_as_correct\":true},{\"text\":\"Сравнение специй по их стоимости за единицу веса важно, потому что более дорогие специи всегда обладают лучшим качеством и вкусом.\",\"generated_as_correct\":false},{\"text\":\"Сравнение стоимости специй за единицу веса помогает понять их химический состав и влияние на здоровье, что важно для правильного выбора при приготовлении пищи.\",\"generated_as_correct\":false},{\"text\":\"Сравнение стоимости специй за единицу веса не имеет значения, так как качество специи определяется её происхождением, а не ценой.\",\"generated_as_correct\":false}],\"question\":\"Почему сравнение специй по их стоимости за единицу веса может быть важным при принятии решения о выборе специй?\"},{\"answers\":[{\"text\":\"Стоимость специи — это отношение цены к весу ($\\\\frac{c_i}{w_i}$), что позволяет сравнивать их ценность за единицу веса при закупке.\",\"generated_as_correct\":true},{\"text\":\"Стоимость специи рассчитывается как разница между ценой и весом ($c_i - w_i$). Это помогает определить, какие специи наиболее доступны по цене при закупке для ресторана.\",\"generated_as_correct\":false},{\"text\":\"Стоимость специи можно использовать для расчёта оптимального количества специй, необходимых для приготовления определённого блюда в ресторане.\",\"generated_as_correct\":false},{\"text\":\"Стоимость специи определяется как сумма её цены и веса ($c_i + w_i$), что помогает оценить общую стоимость при закупке.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать показатель стоимости специи в практической ситуации, например, при закупке товаров для ресторана?\"},{\"answers\":[{\"text\":\"Жадный алгоритм делает локально оптимальные выборы на каждом шаге, стремясь к глобальному оптимуму.\",\"generated_as_correct\":true},{\"text\":\"Жадный алгоритм — это метод решения задач, который всегда гарантирует нахождение наилучшего решения за счёт тщательного анализа всех возможных вариантов.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм используется для сортировки данных в базах данных и основан на принципе сравнения соседних элементов.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм всегда находит точное решение задачи путём полного перебора всех возможных вариантов.\",\"generated_as_correct\":false}],\"question\":\"Что такое жадный алгоритм?\"},{\"answers\":[{\"text\":\"Жадный алгоритм может привести к неоптимальному решению, так как он фокусируется на локальных максимумах, не учитывая общую картину.\",\"generated_as_correct\":true},{\"text\":\"Жадный алгоритм не находит оптимальное решение, потому что его основная цель — минимизировать количество шагов, а не максимизировать общую выгоду от решения задачи.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм не гарантирует оптимального решения из-за ограничений вычислительной сложности, которые не позволяют ему обрабатывать большие объёмы данных.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм не находит оптимальное решение из-за своей линейной структуры, которая не позволяет ему анализировать все возможные варианты.\",\"generated_as_correct\":false}],\"question\":\"Почему жадный алгоритм не всегда гарантирует нахождение оптимального решения задачи?\"},{\"answers\":[{\"text\":\"Жадный алгоритм выбирает самую дорогую специю, пока рюкзак не заполнен.\",\"generated_as_correct\":true},{\"text\":\"Жадный алгоритм для задачи о рюкзаке состоит в случайном выборе специй, пока рюкзак не будет заполнен, без учёта их стоимости.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм используется для определения оптимального маршрута в графе, где вершины представляют различные специи, а рёбра — их стоимость.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм выбирает специи случайным образом, не учитывая их стоимость.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить жадный алгоритм для решения задачи о рюкзаке?\"},{\"answers\":[{\"text\":\"Оптимальное решение — это выбор предметов максимальной ценности при соблюдении ограничений на вес.\",\"generated_as_correct\":true},{\"text\":\"Оптимальное решение в контексте задачи с ограничениями на вес — это выбор предметов с наибольшим весом, независимо от их ценности, чтобы максимально использовать допустимый лимит веса.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение в контексте задачи с ограничениями на вес связано с определением минимального количества предметов, необходимых для достижения определённой цели, без учёта их веса или ценности.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение — это выбор предметов максимального веса, независимо от их ценности.\",\"generated_as_correct\":false}],\"question\":\"Что такое оптимальное решение в контексте задачи с ограничениями на вес?\"},{\"answers\":[{\"text\":\"«Разные методы используются для поиска оптимального решения, так как они подходят для разных типов задач и ограничений».\",\"generated_as_correct\":true},{\"text\":\"«Разные методы используются для поиска оптимального решения, так как каждый из них обеспечивает уникальное решение, отличное от других методов, даже при одинаковых начальных условиях задачи».\",\"generated_as_correct\":false},{\"text\":\"«Разные методы, такие как жадные алгоритмы и динамическое программирование, применяются для анализа данных и прогнозирования, что позволяет предсказывать оптимальные решения на основе исторических данных».\",\"generated_as_correct\":false},{\"text\":\"«Разные методы применяются для поиска оптимального решения, потому что каждый из них находит решение быстрее других методов».\",\"generated_as_correct\":false}],\"question\":\"Почему для поиска оптимального решения могут использоваться разные методы, такие как жадные алгоритмы и динамическое программирование?\"},{\"answers\":[{\"text\":\"Оптимальное решение задачи с ограничениями на вес помогает максимизировать ценность предметов при соблюдении весовых лимитов, например, в логистике или производстве.\",\"generated_as_correct\":true},{\"text\":\"Оптимальное решение для задачи с ограничениями на вес заключается в выборе предметов с наибольшим весом, независимо от их ценности, что применяется в строительстве для расчёта нагрузки на конструкции.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение для задачи с ограничениями на вес связано с разработкой алгоритмов для прогнозирования погодных условий, где вес данных влияет на точность прогноза.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение задачи с ограничениями на вес заключается в выборе предметов с наименьшим весом, независимо от их ценности.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить оптимальное решение для задачи с ограничениями на вес в реальной жизни?\"},{\"answers\":[{\"text\":\"$$O(n^2)$ показывает, что время выполнения алгоритма растёт квадратично с увеличением числа предметов.\",\"generated_as_correct\":true},{\"text\":\"Запись $O(n^2)$ указывает на то, что время выполнения алгоритма линейно зависит от количества предметов $n$.\",\"generated_as_correct\":false},{\"text\":\"Запись $O(n^2)$ относится к сложности алгоритма в контексте пространства памяти, а не времени выполнения.\",\"generated_as_correct\":false},{\"text\":\"$$O(n^2)$ означает, что время выполнения алгоритма остаётся постоянным независимо от количества предметов.\",\"generated_as_correct\":false}],\"question\":\"Что означает запись $O(n^2)$ в контексте времени выполнения жадного алгоритма для задачи о рюкзаке?\"},{\"answers\":[{\"text\":\"Время выполнения жадного алгоритма для задачи о рюкзаке растёт квадратично ($O(n^2)$) с увеличением количества предметов.\",\"generated_as_correct\":true},{\"text\":\"Время выполнения жадного алгоритма для задачи о рюкзаке уменьшается при увеличении количества предметов, так как алгоритм оптимизирован для работы с большими объёмами данных.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения жадного алгоритма зависит от сложности задачи и может быть оптимизировано путём изменения порядка добавления предметов в рюкзак.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения жадного алгоритма для задачи о рюкзаке растёт линейно ($O(n)$) с увеличением количества предметов.\",\"generated_as_correct\":false}],\"question\":\"Как изменяется время выполнения жадного алгоритма для задачи о рюкзаке при увеличении количества предметов?\"},{\"answers\":[{\"text\":\"Алгоритм с временем выполнения $O(n^2)$ может значительно замедлить обработку при больших объёмах данных из-за квадратичного роста времени выполнения.\",\"generated_as_correct\":true},{\"text\":\"Время выполнения алгоритма $O(n^2)$ критично только для малых объёмов данных, так как при больших объёмах оно стабилизируется и перестаёт существенно влиять на производительность системы.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма $O(n^2)$ связано с вычислительной сложностью задачи и может быть оптимизировано путём использования параллельных вычислений, что не всегда применимо к большим объёмам данных.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм с временем выполнения $O(n^2)$ оптимально подходит для обработки больших объёмов данных, так как его время выполнения растёт линейно.\",\"generated_as_correct\":false}],\"question\":\"Почему важно учитывать время выполнения алгоритма $O(n^2)$, если предстоит работа с большими объёмами данных?\"}],\"StoreCardId\":null,\"numberInCourse\":\"7.2\"},{\"Name\":\"algo | 7.3. Задача «Рекламная кампания»\",\"Slug\":\"zadacha-reklamnaya-kampaniya\",\"createdAt\":\"2024-07-03T08:39:24.072Z\",\"updatedAt\":\"2026-01-10T12:07:09.388Z\",\"publishedAt\":\"2024-07-03T08:39:25.240Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80767/problem\",\"Lead\":null,\"Content\":\"$79\",\"Title\":\"Задача «Рекламная кампания»\",\"LikesCount\":19,\"Quiz\":[{\"answers\":[{\"text\":\"Задача о максимизации прибыли от рекламы — найти оптимальное распределение рекламных мест между рекламодателями для максимизации общей прибыли от кликов.\",\"generated_as_correct\":true},{\"text\":\"Задача о максимизации прибыли от рекламы заключается в равномерном распределении всех рекламных мест между всеми рекламодателями, независимо от ожидаемого количества кликов и цены за клик, чтобы обеспечить каждому рекламодателю равные условия.\",\"generated_as_correct\":false},{\"text\":\"Задача о максимизации прибыли от рекламы связана с анализом эффективности рекламных кампаний и определением оптимального бюджета для каждого рекламного канала.\",\"generated_as_correct\":false},{\"text\":\"Задача о максимизации прибыли от рекламы — распределить рекламные места случайным образом между рекламодателями, чтобы максимизировать общую прибыль от кликов.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается задача о максимизации прибыли от рекламы?\"},{\"answers\":[{\"text\":\"Учитывать количество кликов и цену за клик важно для максимизации прибыли от рекламы.\",\"generated_as_correct\":true},{\"text\":\"Учитывать ожидаемое количество кликов и цену за клик важно, потому что рекламодатели всегда готовы платить больше за места с большим количеством кликов, что автоматически увеличивает общую прибыль.\",\"generated_as_correct\":false},{\"text\":\"Учитывать количество кликов и цену за клик важно для анализа поведения пользователей на сайте, что помогает оптимизировать контент и улучшить пользовательский опыт.\",\"generated_as_correct\":false},{\"text\":\"Учитывать только цену за клик достаточно для эффективного распределения рекламных мест.\",\"generated_as_correct\":false}],\"question\":\"Почему важно учитывать как ожидаемое количество кликов, так и цену за клик при распределении рекламных мест?\"},{\"answers\":[{\"text\":\"Оптимизация распределения рекламных мест по цене за клик и ожидаемому количеству кликов увеличивает общую прибыль.\",\"generated_as_correct\":true},{\"text\":\"Решение задачи о максимизации прибыли от рекламы предполагает выбор рекламодателей на основе их известности и репутации, а не на основе цены за клик или ожидаемого количества кликов.\",\"generated_as_correct\":false},{\"text\":\"Решение задачи о максимизации прибыли от рекламы связано с анализом психологических факторов влияния рекламы на потребителей и разработкой креативных рекламных материалов.\",\"generated_as_correct\":false},{\"text\":\"Увеличение количества рекламных мест без учёта цен за клик и ожидаемых кликов максимизирует прибыль от рекламы.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить решение задачи о максимизации прибыли от рекламы на практике для повышения эффективности рекламных кампаний?\"},{\"answers\":[{\"text\":\"Жадный алгоритм делает локально оптимальные выборы на каждом шаге в надежде на глобальную оптимальность.\",\"generated_as_correct\":true},{\"text\":\"Жадный алгоритм — это алгоритм, который сразу ищет глобально оптимальное решение, анализируя все возможные варианты и выбирая наилучший.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм — это метод, используемый в теории игр для определения стратегии, которая максимизирует выигрыш в краткосрочной перспективе.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм выбирает решения случайным образом, надеясь на лучший итоговый результат.\",\"generated_as_correct\":false}],\"question\":\"Что такое жадный алгоритм?\"},{\"answers\":[{\"text\":\"Жадный алгоритм может упускать глобально оптимальные решения, выбирая локально оптимальные варианты на каждом шаге.\",\"generated_as_correct\":true},{\"text\":\"Жадный алгоритм не гарантирует глобально оптимальное решение из-за своей сложности и непредсказуемости в вычислениях, что делает его неэффективным для большинства задач.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм не всегда гарантирует глобально оптимальное решение из-за ограничений вычислительной мощности и времени выполнения, которые могут быть недостаточными для обработки больших объёмов данных.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм гарантирует глобально оптимальные решения благодаря последовательному выбору наилучших вариантов.\",\"generated_as_correct\":false}],\"question\":\"Почему жадный алгоритм не всегда гарантирует глобально оптимальное решение, несмотря на то что на каждом шаге выбирается локально оптимальный вариант?\"},{\"answers\":[{\"text\":\"Жадный алгоритм распределяет самые популярные рекламные места тем, кто предлагает наибольшую цену за клик, максимизируя прибыль.\",\"generated_as_correct\":true},{\"text\":\"Жадный алгоритм в контексте распределения рекламных мест подразумевает случайный выбор мест для размещения рекламы, основываясь на предположении, что это приведёт к максимальной прибыли.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм используется для оптимизации маршрутов доставки рекламных материалов, минимизируя время и затраты на транспортировку.\",\"generated_as_correct\":false},{\"text\":\"Жадный алгоритм предполагает распределение рекламных мест среди всех рекламодателей поровну для обеспечения равных условий.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить жадный алгоритм для решения задачи о распределении рекламных мест?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма — это количество операций, зависящее от размера входных данных.\",\"generated_as_correct\":true},{\"text\":\"Время выполнения алгоритма — это фиксированное количество времени, которое требуется алгоритму для выполнения, независимо от размера входных данных или сложности операций.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма связано с количеством памяти, которое алгоритм использует для хранения промежуточных результатов в процессе работы.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма определяется исключительно количеством входных данных, без учёта количества операций.\",\"generated_as_correct\":false}],\"question\":\"Что такое время выполнения алгоритма?\"},{\"answers\":[{\"text\":\"$$O(n^2)$ требует линейного сканирования на каждой итерации, а $O(n \\\\log n)$ ускоряет поиск за счёт предварительной сортировки.\",\"generated_as_correct\":true},{\"text\":\"Подход $O(n^2)$ применяется для алгоритмов, работающих с постоянными данными, а $O(n \\\\log n)$ используется для алгоритмов, зависящих от размера входных данных, но не требует сортировки.\",\"generated_as_correct\":false},{\"text\":\"Подход $O(n^2)$ используется для анализа сложности памяти алгоритма, а $O(n \\\\log n)$ — для оценки сложности времени выполнения параллельных алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"$$O(n^2)$ ускоряет поиск через предварительную сортировку, а $O(n \\\\log n)$ требует линейного сканирования на каждой итерации.\",\"generated_as_correct\":false}],\"question\":\"Чем отличаются подходы к оценке времени выполнения алгоритма $O(n^2)$ и $O(n \\\\log n)$?\"},{\"answers\":[{\"text\":\"Знание времени выполнения алгоритма помогает выбрать более эффективный метод сортировки данных, например, $O(n \\\\log n)$ вместо $O(n^2)$.\",\"generated_as_correct\":true},{\"text\":\"Знание о времени выполнения алгоритма важно только для теоретических исследований и не имеет практического значения при выборе метода сортировки данных.\",\"generated_as_correct\":false},{\"text\":\"Знание о времени выполнения алгоритма полезно для определения сложности вычислений, но не связано с выбором метода сортировки данных, так как выбор зависит исключительно от типа данных и их структуры.\",\"generated_as_correct\":false},{\"text\":\"Знание времени выполнения алгоритма не важно при выборе метода сортировки, так как все методы одинаково эффективны.\",\"generated_as_correct\":false}],\"question\":\"Как знание о времени выполнения алгоритма может помочь при выборе метода сортировки данных?\"},{\"answers\":[{\"text\":\"Оптимизация прибыли — это распределение рекламных мест для максимизации общей прибыли на основе анализа кликов и цен за клик.\",\"generated_as_correct\":true},{\"text\":\"Оптимизация прибыли при распределении рекламных мест предполагает равномерное распределение мест между всеми рекламодателями независимо от количества кликов и цен за клик, чтобы обеспечить равные условия для всех.\",\"generated_as_correct\":false},{\"text\":\"Оптимизация прибыли в контексте распределения рекламных мест связана с анализом эффективности рекламных кампаний и разработкой стратегий для повышения узнаваемости бренда.\",\"generated_as_correct\":false},{\"text\":\"Оптимизация прибыли заключается в минимизации затрат на рекламу путём снижения цен за клик без учёта количества кликов.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой оптимизация прибыли в контексте распределения рекламных мест?\"},{\"answers\":[{\"text\":\"Учитываются количество кликов и цены за клик для каждого рекламного места.\",\"generated_as_correct\":true},{\"text\":\"При оптимизации прибыли для максимизации общей прибыли от рекламных мест учитываются исключительно цены, которые рекламодатели готовы платить за клик, без учёта количества кликов для каждого рекламного места.\",\"generated_as_correct\":false},{\"text\":\"При оптимизации прибыли для максимизации общей прибыли от рекламных мест анализируется эффективность рекламных креативов и их соответствие целевой аудитории.\",\"generated_as_correct\":false},{\"text\":\"Учитывается только общее количество рекламных мест без учёта количества кликов и цен за клик.\",\"generated_as_correct\":false}],\"question\":\"Какие факторы учитываются при оптимизации прибыли для максимизации общей прибыли от рекламных мест?\"},{\"answers\":[{\"text\":\"Оптимизация прибыли помогает найти лучшее распределение рекламных мест для максимизации общей прибыли.\",\"generated_as_correct\":true},{\"text\":\"Метод оптимизации прибыли используется для минимизации затрат на рекламные кампании путём снижения цен за клик без анализа эффективности рекламных мест.\",\"generated_as_correct\":false},{\"text\":\"Метод оптимизации прибыли применяется для улучшения качества рекламных материалов и повышения их привлекательности для аудитории.\",\"generated_as_correct\":false},{\"text\":\"Оптимизация прибыли заключается в увеличении количества рекламных мест без учёта их эффективности.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить метод оптимизации прибыли для повышения эффективности рекламных кампаний?\"}],\"StoreCardId\":null,\"numberInCourse\":\"7.3\"},{\"Name\":\"algo | 7.4. Задача «Сбор подписей»\",\"Slug\":\"zadacha-sbor-podpisej\",\"createdAt\":\"2024-07-03T08:39:56.649Z\",\"updatedAt\":\"2026-01-10T12:07:09.457Z\",\"publishedAt\":\"2024-07-03T08:40:03.184Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80768/problem\",\"Lead\":null,\"Content\":\"$7a\",\"Title\":\"Задача «Сбор подписей»\",\"LikesCount\":23,\"Quiz\":[{\"answers\":[{\"text\":\"Сегмент — это время нахождения жильца в доме.\",\"generated_as_correct\":true},{\"text\":\"Сегмент представляет собой фиксированный промежуток времени, который не зависит от присутствия жильца в доме, а определяется расписанием коммунальных услуг.\",\"generated_as_correct\":false},{\"text\":\"Сегмент — это часть жилого пространства, выделенная для определённых целей, например, для отдыха или работы.\",\"generated_as_correct\":false},{\"text\":\"Сегмент — это период отсутствия жильца в доме.\",\"generated_as_correct\":false}],\"question\":\"Что такое сегмент в контексте присутствия жильцов в доме?\"},{\"answers\":[{\"text\":\"«Каждый сегмент соответствует одному жильцу и отражает время его нахождения в доме».\",\"generated_as_correct\":true},{\"text\":\"«Количество сегментов соответствует количеству жильцов, поскольку каждый сегмент обозначает площадь, которую занимает жилец в доме».\",\"generated_as_correct\":false},{\"text\":\"«Количество сегментов связано с количеством жильцов, так как сегменты используются для определения структуры здания и планирования ремонтных работ».\",\"generated_as_correct\":false},{\"text\":\"«Количество сегментов равно количеству жильцов, потому что каждый сегмент определяет количество вещей, принадлежащих жильцу».\",\"generated_as_correct\":false}],\"question\":\"Почему количество сегментов соответствует количеству жильцов?\"},{\"answers\":[{\"text\":\"сегменты показывают интервалы времени присутствия каждого жильца в доме, помогая анализировать их распорядок дня.\",\"generated_as_correct\":true},{\"text\":\"информацию о сегментах можно использовать для определения точного времени, когда все жильцы одновременно находятся в доме, что позволяет оптимизировать расписание домашних мероприятий.\",\"generated_as_correct\":false},{\"text\":\"информацию о сегментах можно использовать для анализа частоты использования различных комнат в доме, выявляя наиболее популярные пространства среди жильцов.\",\"generated_as_correct\":false},{\"text\":\"сегменты используются для определения общего времени отсутствия всех жильцов в доме.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать информацию о сегментах для анализа распределения времени присутствия жильцов в доме?\"},{\"answers\":[{\"text\":\"минимальное количество точек — это наименьшее число точек для покрытия всех сегментов.\",\"generated_as_correct\":true},{\"text\":\"минимальное количество точек — это общее количество точек, которые находятся на границах сегментов.\",\"generated_as_correct\":false},{\"text\":\"минимальное количество точек связано с количеством жильцов в доме и не зависит от временных интервалов их присутствия.\",\"generated_as_correct\":false},{\"text\":\"минимальное количество точек — это среднее количество точек на каждом сегменте.\",\"generated_as_correct\":false}],\"question\":\"Что такое минимальное количество точек в контексте покрытия всех сегментов?\"},{\"answers\":[{\"text\":\"Определение минимального количества точек позволяет оптимизировать визиты для сбора подписей.\",\"generated_as_correct\":true},{\"text\":\"Определение минимального количества точек важно, так как это помогает определить максимальное количество жильцов, которые могут присутствовать в доме одновременно.\",\"generated_as_correct\":false},{\"text\":\"Определение минимального количества точек связано с анализом геометрических фигур и используется в задачах по планиметрии.\",\"generated_as_correct\":false},{\"text\":\"Определение минимального количества точек необходимо для расчёта общего количества жильцов в доме.\",\"generated_as_correct\":false}],\"question\":\"Почему важно определять минимальное количество точек для покрытия всех сегментов?\"},{\"answers\":[{\"text\":\"Минимальное количество точек помогает определить, сколько раз нужно зайти в дом для сбора подписей у всех жильцов.\",\"generated_as_correct\":true},{\"text\":\"Концепцию минимального количества точек применяют для расчёта общего времени, которое потребуется для сбора подписей у всех жильцов, без учёта оптимального маршрута посещения.\",\"generated_as_correct\":false},{\"text\":\"Концепцию минимального количества точек используют в геометрии для определения наименьшего числа точек, необходимых для построения многоугольника.\",\"generated_as_correct\":false},{\"text\":\"Минимальное количество точек определяет максимальное число жильцов, у которых можно собрать подписи за один визит в дом.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить концепцию минимального количества точек для оптимизации сбора подписей у жильцов?\"},{\"answers\":[{\"text\":\"Алгоритм SegmentsCover находит минимальное количество точек для покрытия всех сегментов.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм SegmentsCover используется для нахождения максимального количества точек внутри сегментов путём анализа их центральных координат.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм SegmentsCover связан с методами сортировки и используется для упорядочивания сегментов по их длине.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм SegmentsCover определяет максимальное количество сегментов, которые могут быть покрыты одной точкой.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм SegmentsCover?\"},{\"answers\":[{\"text\":\"алгоритм SegmentsCover последовательно выбирает минимальное значение правой границы сегмента, покрывая и отбрасывая соответствующие сегменты.\",\"generated_as_correct\":true},{\"text\":\"алгоритм SegmentsCover определяет покрываемые сегменты путём случайного выбора точек и проверки, покрывают ли они сегменты, до тех пор пока не будут найдены все необходимые точки.\",\"generated_as_correct\":false},{\"text\":\"алгоритм SegmentsCover используется для определения оптимального пути между сегментами на плоскости, минимизируя общее расстояние между точками.\",\"generated_as_correct\":false},{\"text\":\"алгоритм SegmentsCover выбирает сегменты на основе максимального значения их левой границы.\",\"generated_as_correct\":false}],\"question\":\"Каким образом алгоритм SegmentsCover определяет, какие сегменты покрываются выбранной точкой?\"},{\"answers\":[{\"text\":\"Алгоритм SegmentsCover находит минимальное количество точек для покрытия всех сегментов путём последовательного выбора минимальных правых границ.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм SegmentsCover позволяет найти минимальное количество сегментов, которые покрывают заданный набор точек, путём последовательного выбора сегментов с наибольшими интервалами.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм SegmentsCover связан с методами оптимизации и может быть использован для решения задач, связанных с маршрутизацией и логистикой.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм SegmentsCover определяет максимальное количество точек, необходимых для покрытия сегментов, выбирая максимальные левые границы.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм SegmentsCover для решения задачи по покрытию сегментов минимальным количеством точек?\"},{\"answers\":[{\"text\":\"Оценка сложности алгоритма по времени выполнения показывает, как время работы алгоритма зависит от размера входных данных, например, для SegmentsCover можно оптимизировать с $O(n^2)$ до $O(n \\\\log n)$.\",\"generated_as_correct\":true},{\"text\":\"Оценка сложности алгоритма по времени выполнения — это метод определения максимального времени, которое алгоритм может затратить на обработку данных. Для алгоритма SegmentsCover сложность всегда остаётся $O(n^2)$ независимо от предварительной обработки данных.\",\"generated_as_correct\":false},{\"text\":\"Оценка сложности алгоритма по времени выполнения — это способ определения эффективности алгоритма через количество используемых переменных и структур данных. Для алгоритма SegmentsCover важно количество операций сравнения, а не сложность по времени.\",\"generated_as_correct\":false},{\"text\":\"Оценка сложности алгоритма по времени выполнения — это подсчёт общего количества операций в алгоритме, который не зависит от входных данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое оценка сложности алгоритма по времени выполнения?\"},{\"answers\":[{\"text\":\"Оптимизация SegmentsCover до $O(n \\\\log n)$ достигается сортировкой сегментов по правым границам.\",\"generated_as_correct\":true},{\"text\":\"Временная сложность алгоритма SegmentsCover уменьшается с $O(n^2)$ до $O(n \\\\log n)$ за счёт уменьшения количества сегментов в процессе выполнения алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Оптимизация временной сложности алгоритма SegmentsCover достигается путём изменения структуры данных, на которых он работает, например, использования деревьев вместо массивов.\",\"generated_as_correct\":false},{\"text\":\"Временная сложность SegmentsCover уменьшается за счёт увеличения количества итераций.\",\"generated_as_correct\":false}],\"question\":\"Почему оптимизация алгоритма SegmentsCover позволяет уменьшить его временную сложность с $O(n^2)$ до $O(n \\\\log n)$?\"},{\"answers\":[{\"text\":\"сортировка сегментов по правой границе уменьшает время выполнения SegmentsCover до $O(n \\\\log n)$.\",\"generated_as_correct\":true},{\"text\":\"предварительная сортировка сегментов по значениям правой границы увеличивает время выполнения алгоритма SegmentsCover до $O(n^3)$.\",\"generated_as_correct\":false},{\"text\":\"предварительная сортировка сегментов влияет на распределение памяти при выполнении алгоритма SegmentsCover.\",\"generated_as_correct\":false},{\"text\":\"сортировка сегментов по правой границе не влияет на время выполнения SegmentsCover.\",\"generated_as_correct\":false}],\"question\":\"Как предварительная сортировка сегментов по значениям правой границы влияет на время выполнения алгоритма SegmentsCover?\"},{\"answers\":[{\"text\":\"Оптимальное решение — это минимальное количество точек, покрывающих все сегменты.\",\"generated_as_correct\":true},{\"text\":\"Оптимальное решение в контексте покрытия сегментов точками — это выбор произвольных точек, которые покрывают сегменты, без учёта минимизации общего количества точек.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение в контексте покрытия сегментов точками связано с определением наиболее эффективных маршрутов для доставки товаров, не учитывая количество точек покрытия.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение — это максимальное количество точек, покрывающих сегменты.\",\"generated_as_correct\":false}],\"question\":\"Что такое оптимальное решение в контексте покрытия сегментов точками?\"},{\"answers\":[{\"text\":\"Минимизация точек важна для оптимального покрытия сегментов с минимальными визитами.\",\"generated_as_correct\":true},{\"text\":\"Минимизация количества точек важна, потому что это помогает увеличить количество визитов в каждый дом, что улучшает качество обслуживания.\",\"generated_as_correct\":false},{\"text\":\"Минимизация количества точек при покрытии сегментов связана с уменьшением времени на планирование маршрута, что косвенно влияет на эффективность работы.\",\"generated_as_correct\":false},{\"text\":\"Минимизация точек не важна, так как она не влияет на покрытие сегментов и эффективность работы.\",\"generated_as_correct\":false}],\"question\":\"Почему важно минимизировать количество точек при покрытии сегментов?\"},{\"answers\":[{\"text\":\"Оптимальное решение для планирования визитов в дом — это выбор минимального количества точек для покрытия всех сегментов.\",\"generated_as_correct\":true},{\"text\":\"Концепция оптимального решения для планирования визитов в дом состоит в том, чтобы равномерно распределить визиты по всем сегментам дома без учёта их количества или расположения.\",\"generated_as_correct\":false},{\"text\":\"Концепция оптимального решения используется для определения наилучшего маршрута доставки товаров, не учитывая специфику планирования визитов в дом.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное решение для планирования визитов в дом — это посещение каждого сегмента дома отдельно, без учёта их расположения.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить концепцию оптимального решения для планирования визитов в дом?\"},{\"answers\":[{\"text\":\"покрытие сегментов — выбор точек времени, соответствующих интервалам присутствия жильцов.\",\"generated_as_correct\":true},{\"text\":\"процесс покрытия сегментов — это способ определения времени, когда все жильцы гарантированно отсутствуют дома, чтобы избежать ненужных визитов.\",\"generated_as_correct\":false},{\"text\":\"процесс покрытия сегментов связан с алгоритмами машинного обучения для прогнозирования временных интервалов активности в различных системах.\",\"generated_as_correct\":false},{\"text\":\"покрытие сегментов — выбор случайных точек времени для визитов, независимо от присутствия жильцов.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой процесс покрытия сегментов?\"},{\"answers\":[{\"text\":\"Покрытие сегментов гарантирует, что визиты проводятся в те моменты, когда жильцы присутствуют дома.\",\"generated_as_correct\":true},{\"text\":\"Покрытие сегментов — это метод, при котором выбираются случайные точки времени для визитов, независимо от присутствия жильцов, чтобы охватить максимальное количество времени.\",\"generated_as_correct\":false},{\"text\":\"Покрытие сегментов связано с анализом временных рядов и используется для прогнозирования поведения жильцов на основе исторических данных.\",\"generated_as_correct\":false},{\"text\":\"Покрытие сегментов подразумевает выбор времени визитов, когда жильцов точно нет дома.\",\"generated_as_correct\":false}],\"question\":\"Почему важно, чтобы каждая выбранная точка времени визита соответствовала интервалу присутствия хотя бы одного жильца?\"},{\"answers\":[{\"text\":\"Метод покрытия сегментов помогает выбрать время визитов, чтобы охватить все интервалы присутствия жильцов и собрать подписи.\",\"generated_as_correct\":true},{\"text\":\"Метод покрытия сегментов предполагает случайный выбор временных интервалов для визитов, что не гарантирует сбор подписей всех жильцов, но упрощает планирование.\",\"generated_as_correct\":false},{\"text\":\"Метод покрытия сегментов используется для анализа структуры здания и определения оптимальных маршрутов передвижения внутри дома, не связанных со сбором подписей.\",\"generated_as_correct\":false},{\"text\":\"Метод покрытия сегментов подразумевает выбор одного оптимального времени визита, которое подходит всем жильцам для сбора подписей.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить метод покрытия сегментов для оптимизации сбора подписей жильцов?\"}],\"StoreCardId\":null,\"numberInCourse\":\"7.4\"},{\"Name\":\"algo | 7.5. Задача «Количество призов»\",\"Slug\":\"zadacha-kolichestvo-prizov\",\"createdAt\":\"2024-07-03T08:42:22.867Z\",\"updatedAt\":\"2026-01-10T12:07:08.588Z\",\"publishedAt\":\"2024-07-03T08:42:23.962Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80770/problem\",\"Lead\":null,\"Content\":\"$7b\",\"Title\":\"Задача «Количество призов»\",\"LikesCount\":25,\"Quiz\":[{\"answers\":[{\"text\":\"Задача — распределить $n$ конфет так, чтобы за более высокое место давали больше конфет.\",\"generated_as_correct\":true},{\"text\":\"Основная задача заключается в распределении конфет таким образом, чтобы участники, занявшие последние места, получили больше конфет, чем те, кто занял первые места.\",\"generated_as_correct\":false},{\"text\":\"Основная задача при распределении конфет — это разработка алгоритма для случайного распределения конфет между всеми участниками без учёта занятых мест.\",\"generated_as_correct\":false},{\"text\":\"Задача — распределить $n$ конфет поровну между всеми участниками.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается основная задача при распределении $n$ конфет между участниками, занявшими первые $k$ мест?\"},{\"answers\":[{\"text\":\"Чтобы обеспечить мотивацию участников и оптимально распределить конфеты, за более высокое место должно быть больше конфет.\",\"generated_as_correct\":true},{\"text\":\"В задаче распределения конфет не имеет значения, сколько конфет получает участник за место, главное — чтобы общее количество конфет было распределено поровну между всеми участниками.\",\"generated_as_correct\":false},{\"text\":\"В задаче распределения конфет важно учитывать вкусовые предпочтения участников, чтобы каждый получил конфеты, которые ему нравятся.\",\"generated_as_correct\":false},{\"text\":\"Чтобы сделать распределение более справедливым, за более высокое место должно быть меньше конфет.\",\"generated_as_correct\":false}],\"question\":\"Почему в задаче распределения конфет важно, чтобы за более высокое место всегда выходило больше конфет?\"},{\"answers\":[{\"text\":\"Распределение конфет между $k$ участниками так, чтобы за более высокое место было больше конфет, позволяет найти максимальное количество участников.\",\"generated_as_correct\":true},{\"text\":\"Принцип распределения конфет заключается в равномерном распределении $n$ конфет между всеми участниками, независимо от занятого места. Задача заключается в определении общего количества конфет, необходимых для такого распределения.\",\"generated_as_correct\":false},{\"text\":\"Принцип распределения конфет связан с теорией вероятностей и может быть использован для определения вероятности получения определённого количества конфет каждым участником.\",\"generated_as_correct\":false},{\"text\":\"Распределение конфет между участниками происходит таким образом, что за каждое место даётся одинаковое количество конфет.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить принцип распределения конфет для определения максимального количества участников, которые могут получить призы?\"},{\"answers\":[{\"text\":\"Найти $k$ пар уникальных положительных чисел, сумма которых равна $n$.\",\"generated_as_correct\":true},{\"text\":\"Нужно представить число $n$ как сумму $k$ отдельных чисел (не пар), где каждое число уникально и положительно.\",\"generated_as_correct\":false},{\"text\":\"Для представления числа $n$ в виде суммы $k$ пар чисел необходимо использовать теорему о сумме арифметической прогрессии.\",\"generated_as_correct\":false},{\"text\":\"Представить $n$ как сумму $k$ одинаковых пар положительных чисел.\",\"generated_as_correct\":false}],\"question\":\"Что требуется сделать для представления числа \\\\( n \\\\) в виде суммы \\\\( k \\\\) пар неповторяющихся положительных целых чисел?\"},{\"answers\":[{\"text\":\"Уникальность чисел в парах необходима для правильного распределения призов, чтобы избежать повторений.\",\"generated_as_correct\":true},{\"text\":\"Уникальность чисел в парах важна, потому что это позволяет упростить подсчёт общего количества призов, так как каждое число вносит уникальный вклад в сумму \\\\( n \\\\).\",\"generated_as_correct\":false},{\"text\":\"Уникальность чисел в парах важна для обеспечения уникальности идентификаторов в системах управления данными, что не связано напрямую с представлением числа \\\\( n \\\\) в виде суммы пар.\",\"generated_as_correct\":false},{\"text\":\"Уникальность чисел в парах не важна, так как главное — достичь суммы \\\\( n \\\\), а повторения чисел не влияют на результат.\",\"generated_as_correct\":false}],\"question\":\"Почему важно, чтобы все числа в парах были уникальными при представлении числа \\\\( n \\\\)?\"},{\"answers\":[{\"text\":\"Задача представления числа \\\\( n \\\\) в виде суммы \\\\( k \\\\) пар уникальных чисел применяется для распределения призов, где каждая пара определяет количество конфет за место.\",\"generated_as_correct\":true},{\"text\":\"Задача представления числа \\\\( n \\\\) в виде суммы \\\\( k \\\\) пар чисел может быть использована для распределения призов, где количество конфет, выданных за каждое место, определяется случайным образом без учёта уникальности чисел в парах.\",\"generated_as_correct\":false},{\"text\":\"Задача представления числа \\\\( n \\\\) в виде суммы пар чисел связана с теорией чисел и может быть использована для анализа статистических данных о распределении призов, но не для непосредственного распределения.\",\"generated_as_correct\":false},{\"text\":\"Задача представления числа \\\\( n \\\\) в виде суммы \\\\( k \\\\) пар чисел используется для распределения призов, где пары могут содержать повторяющиеся числа.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить задачу представления числа \\\\( n \\\\) в виде суммы пар для распределения призов?\"},{\"answers\":[{\"text\":\"Формула $\\\\frac{k(k+1)}{2} \\\\le n$ определяет максимальное $k$ для количества пар чисел с суммой, не превышающей $n$.\",\"generated_as_correct\":true},{\"text\":\"Формула $\\\\frac{k(k+1)}{2} \\\\le n$ применяется для вычисления суммы всех чисел от 1 до $n$, не учитывая при этом максимальное значение $k$.\",\"generated_as_correct\":false},{\"text\":\"Формула $\\\\frac{k(k+1)}{2} \\\\le n$ связана с вычислением площади под кривой и используется в интегральном исчислении.\",\"generated_as_correct\":false},{\"text\":\"Формула $\\\\frac{k(k+1)}{2} \\\\le n$ служит для нахождения минимального $k$, при котором сумма чисел равна $n$.\",\"generated_as_correct\":false}],\"question\":\"Что позволяет определить формула $\\\\frac{k(k+1)}{2} \\\\le n$?\"},{\"answers\":[{\"text\":\"Формула для определения максимального $k$ основана на сумме арифметической прогрессии.\",\"generated_as_correct\":true},{\"text\":\"Формула для определения максимального $k$ базируется на принципе комбинаторики, который используется для вычисления количества возможных комбинаций чисел без учёта их суммы.\",\"generated_as_correct\":false},{\"text\":\"Формула для определения максимального $k$ связана с теорией вероятностей и используется для расчёта вероятности выпадения определённых чисел в случайном эксперименте.\",\"generated_as_correct\":false},{\"text\":\"Формула для определения максимального $k$ основана на принципе факторизации чисел.\",\"generated_as_correct\":false}],\"question\":\"На каком математическом принципе основана данная формула?\"},{\"answers\":[{\"text\":\"Формула для определения максимального $k$ полезна для нахождения оптимального количества пар чисел с суммой, не превышающей $n$.\",\"generated_as_correct\":true},{\"text\":\"Формула для определения максимального $k$ используется для расчёта количества комбинаций, при которых сумма случайных чисел равна $n$, без учёта порядка их следования.\",\"generated_as_correct\":false},{\"text\":\"Формула для определения максимального $k$ может быть использована для анализа последовательностей в теории чисел и для определения свойств арифметических прогрессий.\",\"generated_as_correct\":false},{\"text\":\"Формула для определения максимального $k$ используется для вычисления минимального количества чисел, сумма которых равна $n$.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях может быть полезно применение этой формулы для определения максимального $k$?\"},{\"answers\":[{\"text\":\"Алгоритм нахождения максимального $k$ определяет наибольшее $k$, для которого $\\\\frac{k(k+1)}{2} \\\\le n$.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм нахождения максимального $k$ предполагает поиск такого значения $k$, что $k^2 \\\\le n$, где $n$ — общее количество конфет. Это значение используется для определения максимального количества участников, которые могут получить призы.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм нахождения максимального $k$ связан с методами оптимизации и используется для распределения ресурсов в условиях ограниченного бюджета.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм нахождения максимального $k$ ищет такое $k$, что $k \\\\le n$.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм нахождения максимального $k$?\"},{\"answers\":[{\"text\":\"Неравенство $\\\\frac{k(k+1)}{2} \\\\le n$ используется для нахождения максимального количества участников, получающих призы, при заданном количестве конфет $n$.\",\"generated_as_correct\":true},{\"text\":\"В алгоритме нахождения максимального $k$ используется неравенство $\\\\frac{k(k+1)}{2} \\\\le n$, чтобы найти минимальное количество конфет, необходимых для распределения среди участников.\",\"generated_as_correct\":false},{\"text\":\"В алгоритме нахождения максимального $k$ используется неравенство $\\\\frac{k(k+1)}{2} \\\\le n$ для определения оптимального количества раундов в соревновании, не связанного с распределением призов.\",\"generated_as_correct\":false},{\"text\":\"Неравенство $\\\\frac{k(k+1)}{2} \\\\le n$ применяется для вычисления общего количества конфет, необходимых для всех участников соревнования.\",\"generated_as_correct\":false}],\"question\":\"Почему в алгоритме нахождения максимального $k$ используется неравенство $\\\\frac{k(k+1)}{2} \\\\le n$?\"},{\"answers\":[{\"text\":\"Алгоритм нахождения максимального $k$ определяет максимальное количество участников, получающих призы, по формуле $\\\\frac{k(k+1)}{2} \\\\le n$.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм нахождения максимального $k$ применяется для расчёта общего количества призов, которые нужно подготовить для участников соревнований, исходя из количества участников $n$.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм нахождения максимального $k$ связан с определением количества раундов в соревновании, где каждый раунд требует определённое количество конфет для проведения.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм нахождения максимального $k$ помогает определить минимальное количество призов, необходимых для награждения участников соревнований.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм нахождения максимального $k$ для организации соревнований с призами?\"},{\"answers\":[{\"text\":\"Запись $O(k)$ или $O(\\\\sqrt{n})$ показывает сложность алгоритма и его эффективность в зависимости от $n$.\",\"generated_as_correct\":true},{\"text\":\"Запись времени выполнения алгоритма в виде $O(k)$ или $O(\\\\sqrt{n})$ указывает на то, что время выполнения алгоритма прямо пропорционально квадрату значения $n$ и не зависит от $k$.\",\"generated_as_correct\":false},{\"text\":\"Запись времени выполнения алгоритма в виде $O(k)$ или $O(\\\\sqrt{n})$ относится к методам сортировки данных и не имеет отношения к оценке эффективности алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Запись $O(k)$ или $O(\\\\sqrt{n})$ определяет точное время выполнения алгоритма независимо от значения $n$.\",\"generated_as_correct\":false}],\"question\":\"Что означает запись времени выполнения алгоритма в виде $O(k)$ или $O(\\\\sqrt{n})$?\"},{\"answers\":[{\"text\":\"Оценка времени выполнения алгоритма важна для понимания, как быстро он работает при разных \\\\( n \\\\).\",\"generated_as_correct\":true},{\"text\":\"Оценка времени выполнения алгоритма важна, потому что она определяет количество памяти, необходимое для хранения данных при различных значениях \\\\( n \\\\), что влияет на его эффективность.\",\"generated_as_correct\":false},{\"text\":\"Оценка времени выполнения алгоритма важна для определения его сложности в терминах вычислительной геометрии и анализа графов.\",\"generated_as_correct\":false},{\"text\":\"Оценка времени выполнения алгоритма важна для определения объёма памяти, который потребуется для его выполнения.\",\"generated_as_correct\":false}],\"question\":\"Почему оценка времени выполнения алгоритма важна для понимания его эффективности?\"},{\"answers\":[{\"text\":\"Оценка $O(k)$ или $O(\\\\sqrt{n})$ помогает оценить, насколько быстро алгоритм найдёт максимальное значение $k$ для заданного $n$.\",\"generated_as_correct\":true},{\"text\":\"Оценка времени выполнения $O(k)$ или $O(\\\\sqrt{n})$ определяет, сколько памяти потребуется алгоритму для решения задачи с заданным $n$, а не его скорость выполнения.\",\"generated_as_correct\":false},{\"text\":\"Оценка времени выполнения $O(k)$ или $O(\\\\sqrt{n})$ используется для определения сложности алгоритма в терминах вычислительной геометрии и не связана напрямую с выбором алгоритма для решения задачи.\",\"generated_as_correct\":false},{\"text\":\"Оценка $O(k)$ или $O(\\\\sqrt{n})$ указывает на количество памяти, необходимое алгоритму для работы с заданным $n$.\",\"generated_as_correct\":false}],\"question\":\"Как оценка времени выполнения $O(k)$ или $O(\\\\sqrt{n})$ может помочь при выборе алгоритма для решения задачи с определённым значением $n$?\"}],\"StoreCardId\":null,\"numberInCourse\":\"7.5\"},{\"Name\":\"algo | 7.6. Задача «Максимальный оклад»\",\"Slug\":\"zadacha-maksimalnyj-oklad\",\"createdAt\":\"2024-07-03T08:42:59.714Z\",\"updatedAt\":\"2026-01-10T12:07:08.795Z\",\"publishedAt\":\"2024-07-03T08:43:00.797Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80771/problem\",\"Lead\":null,\"Content\":\"$7c\",\"Title\":\"Задача «Максимальный оклад»\",\"LikesCount\":26,\"Quiz\":[{\"answers\":[{\"text\":\"Алгоритм LargestConcatenate объединяет числа из набора в наибольшее возможное число, но может давать неточные результаты при работе с числами разной длины.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм LargestConcatenate работает путём случайного выбора чисел из набора и их последовательного объединения, что гарантирует получение наибольшего возможного числа.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм LargestConcatenate используется для сортировки чисел в порядке убывания и не предполагает их объединение в одно число.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм LargestConcatenate всегда точно составляет наибольшее число из набора чисел любой длины.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм LargestConcatenate?\"},{\"answers\":[{\"text\":\"Алгоритм LargestConcatenate может давать некорректный результат при работе с числами разной длины из-за неправильного порядка их объединения.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм LargestConcatenate не работает с числами разной длины из-за ограничений в его алгоритмической структуре, которая не позволяет корректно обрабатывать числа разной разрядности.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм LargestConcatenate неэффективен из-за высокой сложности вычислений при обработке больших объёмов данных, что не позволяет ему корректно работать с числами разной длины.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм LargestConcatenate всегда даёт правильный результат при работе с числами разной длины, так как выбирает наибольшее число на каждом шаге.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритм LargestConcatenate может не всегда приводить к правильному результату при работе с числами разной длины?\"},{\"answers\":[{\"text\":\"Алгоритм LargestConcatenate объединяет числа из набора, выбирая на каждом шаге наибольшее, но может давать некорректные результаты при числах разной длины.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм LargestConcatenate позволяет составить наибольшее число из набора чисел путём их случайного объединения, не требуя выбора наибольшего числа на каждом шаге.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм LargestConcatenate связан с сортировкой чисел по возрастанию и не применяется для составления наибольшего числа из набора чисел.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм LargestConcatenate всегда правильно составляет наибольшее число из набора путём простого сложения всех чисел.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм LargestConcatenate для составления наибольшего числа из набора чисел?\"},{\"answers\":[{\"text\":\"Функция IsBetter определяет порядок двух чисел для формирования наибольшего числа.\",\"generated_as_correct\":true},{\"text\":\"Функция IsBetter используется для определения, какое из двух чисел больше по модулю, независимо от их порядка и количества цифр.\",\"generated_as_correct\":false},{\"text\":\"Функция IsBetter применяется для сортировки строк в алфавитном порядке, не имеет отношения к числовым значениям.\",\"generated_as_correct\":false},{\"text\":\"Функция IsBetter определяет, какое число меньше, для составления наименьшего числа.\",\"generated_as_correct\":false}],\"question\":\"Что определяет функция IsBetter?\"},{\"answers\":[{\"text\":\"Функция IsBetter определяет порядок чисел для создания наибольшего числа, учитывая их цифры и количество.\",\"generated_as_correct\":true},{\"text\":\"Функция IsBetter нужна для подсчёта суммы цифр в числах, что помогает определить, какое число больше, независимо от их порядка и количества цифр.\",\"generated_as_correct\":false},{\"text\":\"Функция IsBetter используется для сортировки чисел в алфавитном порядке, что может быть полезно в некоторых текстовых алгоритмах.\",\"generated_as_correct\":false},{\"text\":\"Функция IsBetter служит для определения количества цифр в числе, что не влияет на составление наибольшего числа.\",\"generated_as_correct\":false}],\"question\":\"Почему важно, чтобы функция IsBetter учитывала порядок цифр и их количество?\"},{\"answers\":[{\"text\":\"Функция IsBetter определяет порядок двух чисел для создания наибольшего числа в алгоритме LargestConcatenate.\",\"generated_as_correct\":true},{\"text\":\"Функция IsBetter используется для определения, какое из двух чисел больше по величине, без учёта их порядка при объединении в наибольшее число.\",\"generated_as_correct\":false},{\"text\":\"Функция IsBetter помогает оптимизировать работу алгоритма LargestConcatenate путём сокращения времени выполнения за счёт уменьшения количества операций сложения.\",\"generated_as_correct\":false},{\"text\":\"Функция IsBetter служит для проверки корректности работы алгоритма LargestConcatenate.\",\"generated_as_correct\":false}],\"question\":\"Как функция IsBetter может быть использована для улучшения алгоритма LargestConcatenate?\"},{\"answers\":[{\"text\":\"Из набора чисел нужно составить максимально большое число, объединяя их определённым образом.\",\"generated_as_correct\":true},{\"text\":\"Задача состоит в том, чтобы сложить все числа из заданного набора и получить максимально возможную сумму.\",\"generated_as_correct\":false},{\"text\":\"Задача заключается в анализе комбинаций чисел для выявления закономерностей в их последовательности, не обязательно приводящих к формированию наибольшего числа.\",\"generated_as_correct\":false},{\"text\":\"Нужно просто расположить числа из набора в порядке убывания, чтобы получить наибольшее число.\",\"generated_as_correct\":false}],\"question\":\"В чём состоит задача составления наибольшего числа из заданного набора чисел?\"},{\"answers\":[{\"text\":\"Итоговое число зависит от сочетания цифр, а не только от их величины.\",\"generated_as_correct\":true},{\"text\":\"Простое объединение чисел в порядке убывания всегда приводит к оптимальному результату, поскольку чем больше число, тем больше вклад в общую сумму.\",\"generated_as_correct\":false},{\"text\":\"Простое объединение чисел в порядке убывания может быть неэффективным из-за ограничений, связанных с разрядностью чисел в компьютерных системах.\",\"generated_as_correct\":false},{\"text\":\"Простое объединение чисел в порядке убывания всегда даёт максимальный результат.\",\"generated_as_correct\":false}],\"question\":\"Почему простое объединение чисел в порядке убывания не всегда приводит к оптимальному результату?\"},{\"answers\":[{\"text\":\"Понимание влияния порядка цифр помогает правильно расположить числа для получения максимального значения при их объединении.\",\"generated_as_correct\":true},{\"text\":\"Понимание влияния порядка цифр на итоговое число заключается в том, что наибольшего числа можно достичь, если сложить все цифры из набора и использовать результат как первую цифру в итоговом числе.\",\"generated_as_correct\":false},{\"text\":\"Понимание влияния порядка цифр на итоговое число связано с теорией вероятностей и помогает определить шансы на выпадение определённых комбинаций при случайном выборе чисел.\",\"generated_as_correct\":false},{\"text\":\"Чтобы составить наибольшее число, достаточно просто расположить все цифры в порядке убывания без дополнительного анализа.\",\"generated_as_correct\":false}],\"question\":\"Как понимание влияния порядка цифр на итоговое число может помочь в решении задачи составления наибольшего числа?\"},{\"answers\":[{\"text\":\"Пример с числами 23 и 3 показывает ошибку алгоритма LargestConcatenate, требующую доработки с помощью функции IsBetter.\",\"generated_as_correct\":true},{\"text\":\"Пример с числами 23 и 3 иллюстрирует, что алгоритм LargestConcatenate может быть улучшен путём простого изменения порядка чисел без использования дополнительных функций.\",\"generated_as_correct\":false},{\"text\":\"Пример с числами 23 и 3 демонстрирует важность правильной сортировки чисел в алгоритмах машинного обучения для улучшения точности предсказаний.\",\"generated_as_correct\":false},{\"text\":\"Пример с числами 23 и 3 подтверждает корректную работу алгоритма LargestConcatenate без необходимости дополнительных изменений.\",\"generated_as_correct\":false}],\"question\":\"Что демонстрирует пример с числами 23 и 3 в контексте работы алгоритма LargestConcatenate?\"},{\"answers\":[{\"text\":\"Алгоритм LargestConcatenate даёт неправильный результат, так как 233 меньше, чем 323, что требует доработки алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Результат алгоритма LargestConcatenate считается неправильным, потому что алгоритм неправильно сортирует числа по возрастанию перед их объединением.\",\"generated_as_correct\":false},{\"text\":\"Результат алгоритма LargestConcatenate считается неправильным из-за ошибки в функции сортировки, которая не учитывает отрицательные числа.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм LargestConcatenate даёт правильный результат, потому что 233 — это наибольшее число, которое можно получить из данных чисел.\",\"generated_as_correct\":false}],\"question\":\"Почему результат алгоритма LargestConcatenate в данном примере считается неправильным?\"},{\"answers\":[{\"text\":\"Функция IsBetter улучшает алгоритм LargestConcatenate, правильно определяя порядок конкатенации чисел.\",\"generated_as_correct\":true},{\"text\":\"Функция IsBetter помогает алгоритму LargestConcatenate путём сложения чисел вместо их конкатенации, что приводит к более точным результатам.\",\"generated_as_correct\":false},{\"text\":\"Функция IsBetter используется для проверки корректности входных данных в алгоритме LargestConcatenate, но не влияет на процесс конкатенации чисел.\",\"generated_as_correct\":false},{\"text\":\"Функция IsBetter не нужна для улучшения алгоритма LargestConcatenate, так как он и так работает корректно.\",\"generated_as_correct\":false}],\"question\":\"Как функция IsBetter может помочь улучшить работу алгоритма LargestConcatenate?\"},{\"answers\":[{\"text\":\"Ограничения задачи — это условия по количеству чисел в наборе (от 1 до 100) и диапазону их значений (от 1 до $10^3$).\",\"generated_as_correct\":true},{\"text\":\"Ограничения задачи — это произвольные условия, которые не влияют на процесс составления наибольшего числа и могут быть проигнорированы при разработке алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Ограничения задачи связаны с ограничениями памяти и времени выполнения алгоритма, но не учитывают количество чисел в наборе или диапазон их значений.\",\"generated_as_correct\":false},{\"text\":\"Ограничения задачи не включают количество чисел в наборе и диапазон их значений, а касаются только сложности алгоритма.\",\"generated_as_correct\":false}],\"question\":\"Что такое ограничения задачи при составлении наибольшего числа?\"},{\"answers\":[{\"text\":\"Учёт количества чисел и диапазона их значений важен для выбора эффективного алгоритма.\",\"generated_as_correct\":true},{\"text\":\"При разработке алгоритма количество чисел в наборе и диапазон их значений не имеют значения, поскольку алгоритм будет работать одинаково эффективно независимо от этих параметров.\",\"generated_as_correct\":false},{\"text\":\"При разработке алгоритма важно учитывать тип данных, с которыми предстоит работать, например, целые числа или вещественные, а также возможные операции над этими данными.\",\"generated_as_correct\":false},{\"text\":\"Учёт количества чисел и диапазона их значений не важен при разработке алгоритма.\",\"generated_as_correct\":false}],\"question\":\"Почему важно учитывать количество чисел в наборе и диапазон их значений при разработке алгоритма?\"},{\"answers\":[{\"text\":\"Ограничения на количество и диапазон чисел важны для выбора эффективной стратегии составления наибольшего числа.\",\"generated_as_correct\":true},{\"text\":\"Ограничения на количество чисел в наборе и диапазон их значений никак не связаны с выбором стратегии для составления наибольшего числа, так как стратегия определяется исключительно количеством операций, которые можно выполнить.\",\"generated_as_correct\":false},{\"text\":\"Ограничения на количество чисел и диапазон их значений важны для определения сложности алгоритма сортировки, но не влияют на стратегию составления наибольшего числа.\",\"generated_as_correct\":false},{\"text\":\"Ограничения на количество и диапазон чисел не влияют на стратегию составления наибольшего числа.\",\"generated_as_correct\":false}],\"question\":\"Как ограничения на количество чисел в наборе и диапазон их значений могут повлиять на выбор стратегии для составления наибольшего числа?\"}],\"StoreCardId\":null,\"numberInCourse\":\"7.6\"},{\"Name\":\"algo | 7.7. Чему вы научились\",\"Slug\":\"chemu-vi-nauchilis-seven\",\"createdAt\":\"2024-07-03T08:42:59.714Z\",\"updatedAt\":\"2025-09-11T20:10:36.480Z\",\"publishedAt\":\"2025-09-09T09:29:51.690Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$7d\",\"Title\":\"Чему вы научились\",\"LikesCount\":37,\"Quiz\":null,\"StoreCardId\":null,\"numberInCourse\":\"7.7\"}]},{\"id\":35,\"Name\":\"8. Динамическое программирование\",\"Articles\":[{\"Name\":\"algo | 8.1. Принципы построения алгоритмов\",\"Slug\":\"principy-postroeniya-algoritmov\",\"createdAt\":\"2024-07-03T17:22:30.720Z\",\"updatedAt\":\"2026-01-10T12:07:08.057Z\",\"publishedAt\":\"2024-07-03T17:22:31.977Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$7e\",\"Title\":\"Принципы построения алгоритмов\",\"LikesCount\":23,\"Quiz\":[{\"answers\":[{\"text\":\"Динамическое программирование — метод решения сложных задач через разбиение на подзадачи с использованием их решений для общего ответа.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование — это подход к решению задач, который основывается на последовательном усложнении начальных условий задачи до тех пор, пока не будет найдено решение.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование — это техника программирования, используемая для создания динамических веб-приложений, которая позволяет коду адаптироваться к различным условиям выполнения.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование — способ решения задач путём случайного выбора и тестирования возможных решений до нахождения правильного.\",\"generated_as_correct\":false}],\"question\":\"Что такое динамическое программирование?\"},{\"answers\":[{\"text\":\"Динамическое программирование эффективно при наличии перекрывающихся подзадач и оптимального подструктурного свойства.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование наиболее эффективно для решения задач, которые можно представить в виде графа без циклов, где каждая вершина представляет собой уникальную подзадачу без повторений.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование используется для оптимизации алгоритмов сортировки и поиска, так как позволяет значительно сократить количество сравнений при обработке данных.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование эффективно для решения любых сложных задач без учёта их структуры и свойств.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение динамического программирования наиболее эффективно и почему?\"},{\"answers\":[{\"text\":\"Динамическое программирование разбивает сложную задачу на простые подзадачи, сохраняет их решения и использует их для построения решения исходной задачи.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование применяется для решения задач с перекрывающимися подзадачами путём случайного выбора подзадач и их решения независимо друг от друга, что не гарантирует нахождения оптимального решения исходной задачи.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование — это метод, который используется для анализа и оптимизации алгоритмов, но он не связан с решением задач, имеющих перекрывающиеся подзадачи.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование решает задачи с перекрывающимися подзадачами путём последовательного решения каждой подзадачи без учёта их взаимосвязи.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать динамическое программирование для решения задачи с перекрывающимися подзадачами?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение — это формула, выражающая решение задачи через решения подзадач.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение — это алгоритм, который используется для прямого вычисления решения задачи без учёта предыдущих шагов или подзадач.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение — это способ организации данных в виде рекурсивной структуры, такой как дерево или список.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение — это метод решения задач, который не учитывает предыдущие результаты и работает только с конечными условиями.\",\"generated_as_correct\":false}],\"question\":\"Что такое рекуррентное соотношение?\"},{\"answers\":[{\"text\":\"Рекуррентные соотношения позволяют вычислять решения задач на основе решений подзадач в динамическом программировании.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентные соотношения важны для динамического программирования, потому что они позволяют мгновенно получить решение задачи без необходимости вычисления решений подзадач.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения важны в теории графов, где они используются для определения кратчайших путей между узлами, что не имеет прямого отношения к динамическому программированию.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения используются в динамическом программировании для случайного выбора решений подзадач без учёта предыдущих результатов.\",\"generated_as_correct\":false}],\"question\":\"Почему рекуррентные соотношения важны для динамического программирования?\"},{\"answers\":[{\"text\":\"Рекуррентные соотношения выражают решение задачи через решения подзадач, позволяя использовать динамическое программирование.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентные соотношения представляют собой набор случайных уравнений, которые не связаны между собой и не позволяют вычислить решение задачи на основе решений подзадач.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения применяются в теории графов для определения кратчайших путей между узлами, не имея отношения к разбиению задачи на подзадачи.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения предназначены для непосредственного вычисления окончательного ответа без учёта решений подзадач.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентные соотношения для решения задачи, разбивая её на подзадачи?\"},{\"answers\":[{\"text\":\"ОАГ — это направленный граф без циклов.\",\"generated_as_correct\":true},{\"text\":\"Ориентированный ациклический граф (ОАГ) — это граф, в котором рёбра не имеют направления, но отсутствуют циклы.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный ациклический граф (ОАГ) — это структура данных, используемая в теории графов для анализа социальных сетей и определения связей между узлами.\",\"generated_as_correct\":false},{\"text\":\"ОАГ — это граф с циклами, где рёбра имеют направление.\",\"generated_as_correct\":false}],\"question\":\"Что такое ориентированный ациклический граф (ОАГ)?\"},{\"answers\":[{\"text\":\"Отсутствие циклов в ОАГ позволяет эффективно решать подзадачи в алгоритмах динамического программирования без повторений.\",\"generated_as_correct\":true},{\"text\":\"Отсутствие циклов в ОАГ не имеет значения для алгоритмов динамического программирования; главное, чтобы граф был ориентированным, что позволяет определить направление решения подзадач.\",\"generated_as_correct\":false},{\"text\":\"Отсутствие циклов в ОАГ важно для алгоритмов поиска кратчайшего пути, так как оно предотвращает зацикливание и позволяет алгоритму корректно находить оптимальные маршруты.\",\"generated_as_correct\":false},{\"text\":\"Циклы в ОАГ необходимы для алгоритмов динамического программирования, чтобы обеспечить многократное решение подзадач.\",\"generated_as_correct\":false}],\"question\":\"Почему отсутствие циклов в ОАГ важно для алгоритмов динамического программирования?\"},{\"answers\":[{\"text\":\"ОАГ помогает представить структуру задачи и порядок решения подзадач в динамическом программировании.\",\"generated_as_correct\":true},{\"text\":\"ОАГ используется для визуализации иерархической структуры данных, но не играет роли в определении порядка решения подзадач в алгоритмах.\",\"generated_as_correct\":false},{\"text\":\"ОАГ применяется для моделирования сетевых структур и анализа связности компонентов в графах, что не связано напрямую с представлением структуры задачи в алгоритмах.\",\"generated_as_correct\":false},{\"text\":\"ОАГ используется для создания циклических структур в алгоритмах, что способствует повторному использованию подзадач.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать ОАГ для представления структуры задачи и порядка решения подзадач в алгоритмах?\"},{\"answers\":[{\"text\":\"Базовый случай — это известное решение простейшей подзадачи, служащее отправной точкой для динамического программирования.\",\"generated_as_correct\":true},{\"text\":\"Базовый случай — это дополнительный шаг в алгоритме динамического программирования, который используется для проверки корректности решений сложных подзадач, но не влияет на процесс их вычисления.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай относится к начальным настройкам параметров алгоритма машинного обучения, которые определяют его поведение на начальных этапах обучения.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай — это условие остановки алгоритма динамического программирования после решения всех подзадач.\",\"generated_as_correct\":false}],\"question\":\"Что такое базовый случай в контексте разработки алгоритма динамического программирования?\"},{\"answers\":[{\"text\":\"Базовый случай — это известное решение простейшей подзадачи, которое служит отправной точкой для решения более сложных задач в динамическом программировании.\",\"generated_as_correct\":true},{\"text\":\"Базовый случай в динамическом программировании — это случай, когда задача не имеет решения. Определение базового случая важно, чтобы алгоритм мог определить, что дальнейшая работа нецелесообразна.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай важен в теории графов для определения кратчайшего пути между узлами. В динамическом программировании он не играет существенной роли.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай — это условие, которое проверяется в конце алгоритма динамического программирования для его завершения.\",\"generated_as_correct\":false}],\"question\":\"Почему определение базового случая важно для решения подзадач в динамическом программировании?\"},{\"answers\":[{\"text\":\"Базовый случай — это известное решение простейшей подзадачи, служащее основой для решения более сложных задач.\",\"generated_as_correct\":true},{\"text\":\"Базовый случай — это дополнительное условие, которое может быть использовано для проверки правильности решения сложных подзадач, но не является необходимым для их решения.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай используется в теории графов для определения кратчайшего пути между двумя вершинами и не имеет отношения к решению подзадач.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай — это условие, которое проверяется в конце алгоритма для определения правильности решения сложной задачи.\",\"generated_as_correct\":false}],\"question\":\"Как использование базового случая помогает в построении решения более сложных подзадач?\"},{\"answers\":[{\"text\":\"Бэктрекинг — метод поиска оптимального решения через обратное отслеживание и корректировку путей при обнаружении неоптимальности.\",\"generated_as_correct\":true},{\"text\":\"Бэктрекинг — это алгоритм, который предсказывает оптимальные решения на основе случайных предположений, не учитывая предыдущие шаги и результаты вычислений.\",\"generated_as_correct\":false},{\"text\":\"Бэктрекинг — это техника, применяемая в теории графов для визуализации связей между элементами, не связанная с поиском оптимальных решений в динамическом программировании.\",\"generated_as_correct\":false},{\"text\":\"Бэктрекинг — это способ подтверждения уже найденных решений без возможности их изменения в динамическом программировании.\",\"generated_as_correct\":false}],\"question\":\"Что такое бэктрекинг и для чего он используется в динамическом программировании?\"},{\"answers\":[{\"text\":\"Бэктрекинг находит оптимальное решение за счёт обратного отслеживания и корректировки неоптимальных путей.\",\"generated_as_correct\":true},{\"text\":\"Метод бэктрекинга основывается на случайном выборе решений и не предусматривает отслеживание ранее принятых решений, что делает его неэффективным для поиска оптимального решения.\",\"generated_as_correct\":false},{\"text\":\"Метод бэктрекинга используется для анализа исторических данных и прогнозирования будущих тенденций, что позволяет делать выводы о возможных оптимальных решениях на основе прошлых событий.\",\"generated_as_correct\":false},{\"text\":\"Бэктрекинг всегда выбирает первый доступный путь без отслеживания и корректировки решений, что приводит к нахождению оптимального решения.\",\"generated_as_correct\":false}],\"question\":\"Почему метод бэктрекинга позволяет находить оптимальное решение, отслеживая принятые решения?\"},{\"answers\":[{\"text\":\"Бэктрекинг находит оптимальное решение путём обратного отслеживания и выбора альтернативных путей при обнаружении неоптимальности.\",\"generated_as_correct\":true},{\"text\":\"Метод бэктрекинга заключается в случайном выборе путей и их последующем анализе без обратного отслеживания, что обеспечивает нахождение оптимального решения.\",\"generated_as_correct\":false},{\"text\":\"Метод бэктрекинга применяется в теории графов для определения количества возможных путей между двумя точками без учёта их оптимальности.\",\"generated_as_correct\":false},{\"text\":\"Бэктрекинг используется для прямого перебора всех возможных путей без возможности возврата к предыдущим решениям.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить метод бэктрекинга для решения задачи, где требуется найти наилучший путь к цели?\"},{\"answers\":[{\"text\":\"Мемоизация — это сохранение результатов вычислений для их повторного использования.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация — это процесс автоматического упрощения алгоритмов путём исключения сложных вычислений на основе предварительных данных.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это концепция в области искусственного интеллекта, которая используется для улучшения взаимодействия с пользователем путём запоминания его предпочтений.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это метод шифрования данных, при котором информация преобразуется и сохраняется в зашифрованном виде.\",\"generated_as_correct\":false}],\"question\":\"Что такое мемоизация?\"},{\"answers\":[{\"text\":\"Мемоизация экономит время, сохраняя результаты вычислений для повторного использования.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация сокращает время выполнения алгоритмов путём упрощения алгоритмов и уменьшения количества операций, необходимых для решения задачи.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация используется для улучшения читаемости кода и его структуры, что косвенно может повлиять на время выполнения алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация ускоряет алгоритмы за счёт уменьшения объёма памяти, используемой при вычислениях.\",\"generated_as_correct\":false}],\"question\":\"Почему мемоизация позволяет сократить время выполнения алгоритмов?\"},{\"answers\":[{\"text\":\"мемоизация полезна для алгоритмов с повторяющимися вычислениями подзадач.\",\"generated_as_correct\":true},{\"text\":\"мемоизация применяется для ускорения работы алгоритмов путём сохранения исходных данных, а не результатов вычислений.\",\"generated_as_correct\":false},{\"text\":\"мемоизация используется для оптимизации хранения данных в базах данных, что позволяет ускорить доступ к информации.\",\"generated_as_correct\":false},{\"text\":\"мемоизация эффективна для оптимизации алгоритмов, которые не имеют повторяющихся подзадач.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение мемоизации может быть особенно полезным?\"}],\"StoreCardId\":null,\"numberInCourse\":\"8.1\"},{\"Name\":\"algo | 8.2 Задача «Размен 2»\",\"Slug\":\"zadacha-razmen-2\",\"createdAt\":\"2024-07-03T17:23:08.090Z\",\"updatedAt\":\"2026-01-10T12:07:09.319Z\",\"publishedAt\":\"2024-07-03T17:23:09.435Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80777/problem\",\"Lead\":null,\"Content\":\"$7f\",\"Title\":\"Задача «Размен 2»\",\"LikesCount\":18,\"Quiz\":[{\"answers\":[{\"text\":\"Задача «Сдача» — найти минимальное количество монет для выдачи определённой суммы сдачи.\",\"generated_as_correct\":true},{\"text\":\"Задача «Сдача» заключается в простом перечислении всех возможных комбинаций монет, которые в сумме дают нужную сдачу, без поиска минимального количества монет.\",\"generated_as_correct\":false},{\"text\":\"Задача «Сдача» связана с разработкой алгоритма для подсчёта общего количества монет в кассе, не учитывая их номиналы и необходимость выдачи сдачи.\",\"generated_as_correct\":false},{\"text\":\"Задача «Сдача» — выбрать любое количество монет, чтобы сумма сдачи была равна заданной.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается суть задачи «Сдача»?\"},{\"answers\":[{\"text\":\"Динамическое программирование лучше «жадного» алгоритма для задачи «Сдача», так как находит оптимальное количество монет.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование не подходит для задачи «Сдача», так как оно требует предварительного знания всех возможных комбинаций монет, что делает его неприменимым на практике.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование и «жадный» алгоритм оба используются для решения задачи «Сдача», но выбор между ними зависит от скорости выполнения алгоритма на конкретном оборудовании.\",\"generated_as_correct\":false},{\"text\":\"«Жадный» алгоритм предпочтительнее динамического программирования для задачи «Сдача», потому что он быстрее находит решение.\",\"generated_as_correct\":false}],\"question\":\"Почему для решения задачи «Сдача» динамическое программирование предпочтительнее «жадного» алгоритма?\"},{\"answers\":[{\"text\":\"Решение задачи «Сдача» позволяет кассовым аппаратам выдавать сдачу минимальным количеством монет.\",\"generated_as_correct\":true},{\"text\":\"Решение задачи «Сдача» помогает кассовым аппаратам определить максимальное количество монет, которое можно выдать клиенту в качестве сдачи, независимо от их номиналов.\",\"generated_as_correct\":false},{\"text\":\"Решение задачи «Сдача» используется для настройки алгоритмов шифрования в кассовых системах, чтобы обеспечить безопасность транзакций.\",\"generated_as_correct\":false},{\"text\":\"Решение задачи «Сдача» помогает кассовым аппаратам выбирать монеты для сдачи случайным образом.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить решение задачи «Сдача» в реальных ситуациях, например, в кассовых аппаратах?\"},{\"answers\":[{\"text\":\"Метод динамического программирования разбивает сложные задачи на простые подзадачи и использует их решения для построения общего ответа.\",\"generated_as_correct\":true},{\"text\":\"Метод динамического программирования представляет собой технику решения сложных задач путём случайного выбора и решения подзадач без учёта их взаимосвязи, что позволяет быстро найти решение исходной задачи.\",\"generated_as_correct\":false},{\"text\":\"Метод динамического программирования используется для оптимизации алгоритмов машинного обучения и не связан с разбиением задач на подзадачи.\",\"generated_as_correct\":false},{\"text\":\"Метод динамического программирования предполагает решение сложных задач путём исключения всех возможных подзадач без их повторного использования.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой метод динамического программирования?\"},{\"answers\":[{\"text\":\"Динамическое программирование эффективно, так как позволяет избежать повторного вычисления подзадач.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование эффективно для решения задач с перекрывающимися подзадачами, потому что оно позволяет решать каждую подзадачу независимо от других, что ускоряет процесс нахождения общего решения.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование используется для оптимизации алгоритмов машинного обучения и не имеет прямого отношения к решению задач с перекрывающимися подзадачами.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование эффективно, потому что позволяет решать задачи параллельно.\",\"generated_as_correct\":false}],\"question\":\"Почему динамическое программирование эффективно для решения задач с перекрывающимися подзадачами?\"},{\"answers\":[{\"text\":\"Динамическое программирование решает сложные задачи через разбиение на подзадачи и использование их решений для построения общего ответа.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование заключается в последовательном решении подзадач без учёта их взаимосвязи, что позволяет получить решение исходной задачи путём простого сложения решений подзадач.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование — это метод, который используется для оптимизации алгоритмов путём изменения порядка выполнения операций, что позволяет ускорить выполнение программы.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование предполагает решение сложной задачи путём случайного выбора и решения подзадач без учёта их взаимосвязи.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить динамическое программирование для решения сложной задачи?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение для задачи «Сдача» определяет минимальное количество монет для сдачи суммы `money` через меньшие суммы.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для задачи «Сдача» представляет собой сумму всех возможных комбинаций монет, которые могут быть использованы для сдачи суммы `money`, без учёта их количества.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для задачи «Сдача» связано с теорией графов и используется для определения кратчайшего пути в графе, где вершины представляют собой суммы денег, а рёбра — монеты.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для задачи «Сдача» определяет общее количество монет, которое можно использовать для сдачи суммы `money`.\",\"generated_as_correct\":false}],\"question\":\"Что выражает рекуррентное соотношение для задачи «Сдача»?\"},{\"answers\":[{\"text\":\"Значения $\\\\{1, 3, 4\\\\}$ в рекуррентном соотношении задачи «Сдача» представляют номиналы монет для вычисления минимальной сдачи.\",\"generated_as_correct\":true},{\"text\":\"В рекуррентном соотношении для задачи «Сдача» используются значения $\\\\{1, 3, 4\\\\}$, так как это единственные номиналы монет, доступные в данной валютной системе.\",\"generated_as_correct\":false},{\"text\":\"В рекуррентном соотношении для задачи «Сдача» используются значения $\\\\{1, 3, 4\\\\}$, поскольку они связаны с количеством возможных комбинаций монет для каждой суммы.\",\"generated_as_correct\":false},{\"text\":\"Значения $\\\\{1, 3, 4\\\\}$ выбраны в рекуррентном соотношении задачи «Сдача» как наиболее часто встречающиеся номиналы монет в мире.\",\"generated_as_correct\":false}],\"question\":\"Почему в рекуррентном соотношении для задачи «Сдача» используются именно значения $\\\\{1, 3, 4\\\\}$?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение позволяет найти минимальное количество монет для заданной суммы, уменьшая сумму на доступные номиналы и выбирая минимальное количество монет для каждой промежуточной суммы.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение применяется для нахождения минимального количества монет путём сложения всех возможных комбинаций монет без учёта их номиналов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение используется для определения количества возможных перестановок монет при заданной сумме, не учитывая их минимальное количество.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение определяет максимальное количество монет, необходимых для сдачи определённой суммы, без учёта их номиналов.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентное соотношение для решения задачи о нахождении минимального количества монет для определённой суммы?\"},{\"answers\":[{\"text\":\"Мемоизация — это оптимизация рекурсивных алгоритмов через сохранение результатов вычислений.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация — это способ упрощения кода рекурсивных функций путём замены сложных вычислений на заранее заданные константы.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это концепция в области машинного обучения, которая используется для улучшения точности моделей путём запоминания входных данных.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это процесс удаления результатов вычислений для освобождения памяти в рекурсивных алгоритмах.\",\"generated_as_correct\":false}],\"question\":\"Что такое мемоизация?\"},{\"answers\":[{\"text\":\"Мемоизация ускоряет рекурсивные алгоритмы за счёт сохранения результатов вычислений.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация помогает оптимизировать рекурсивные алгоритмы путём изменения порядка выполнения операций, что позволяет сократить количество итераций.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация используется для улучшения читаемости кода и его структуры, что косвенно влияет на производительность рекурсивных алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация замедляет рекурсивные алгоритмы, сохраняя все промежуточные вычисления.\",\"generated_as_correct\":false}],\"question\":\"Как мемоизация помогает оптимизировать рекурсивные алгоритмы?\"},{\"answers\":[{\"text\":\"Мемоизация ускоряет алгоритмы за счёт сохранения результатов вычислений и их повторного использования при повторных вызовах.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация эффективна для ускорения алгоритмов, которые выполняют операции с большими объёмами данных в реальном времени, но не сохраняют результаты вычислений для повторного использования.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация используется для улучшения визуального представления данных в графиках и диаграммах, что не влияет на скорость работы алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация ускоряет алгоритм путём уменьшения количества входных данных для обработки.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение мемоизации может значительно ускорить работу алгоритма?\"},{\"answers\":[{\"text\":\"Ориентированный ациклический граф (DAG) — это направленный граф без циклов.\",\"generated_as_correct\":true},{\"text\":\"Ориентированный ациклический граф (DAG) — это граф, в котором рёбра не имеют направления, но при этом отсутствуют циклы.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный ациклический граф (DAG) используется для определения цветовой схемы в графах и связан с теорией графов, но не имеет отношения к циклам или направлению рёбер.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный ациклический граф (DAG) — это граф с циклами, но без направленных рёбер.\",\"generated_as_correct\":false}],\"question\":\"Что такое ориентированный ациклический граф (DAG)?\"},{\"answers\":[{\"text\":\"В ориентированном ациклическом графе нет циклов, так как все рёбра направлены.\",\"generated_as_correct\":true},{\"text\":\"В ориентированном ациклическом графе циклы отсутствуют, потому что все вершины графа соединены только ненаправленными рёбрами.\",\"generated_as_correct\":false},{\"text\":\"В ориентированном ациклическом графе не может быть циклов, потому что он используется для визуализации процесса нахождения кратчайшего пути в задачах оптимизации.\",\"generated_as_correct\":false},{\"text\":\"В ориентированном ациклическом графе нет циклов, потому что граф не содержит направленных рёбер.\",\"generated_as_correct\":false}],\"question\":\"Почему в ориентированном ациклическом графе не может быть циклов?\"},{\"answers\":[{\"text\":\"Ориентированный ациклический граф (DAG) помогает визуализировать процесс нахождения кратчайшего пути в задаче «Сдача», представляя возможные комбинации сдачи без циклов.\",\"generated_as_correct\":true},{\"text\":\"Ориентированный ациклический граф (DAG) используется для визуализации процесса нахождения кратчайшего пути в задаче «Сдача» путём построения графа с циклами, где рёбра указывают на произвольные узлы без определённой направленности.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный ациклический граф (DAG) может быть использован для анализа структуры данных в алгоритмах сортировки, что не имеет прямого отношения к задаче «Сдача».\",\"generated_as_correct\":false},{\"text\":\"Ориентированный ациклический граф (DAG) используется для визуализации процесса нахождения кратчайшего пути в задаче «Сдача» путём создания графа с циклическими связями между узлами.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать ориентированный ациклический граф для визуализации процесса нахождения кратчайшего пути в задаче «Сдача»?\"}],\"StoreCardId\":null,\"numberInCourse\":\"8.2\"},{\"Name\":\"algo | 8.3. Задача «Простой калькулятор»\",\"Slug\":\"zadacha-prostoj-kalkulyator\",\"createdAt\":\"2024-07-03T17:24:12.808Z\",\"updatedAt\":\"2026-01-10T12:07:09.057Z\",\"publishedAt\":\"2024-07-03T17:24:14.303Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80778/problem\",\"Lead\":null,\"Content\":\"$80\",\"Title\":\"Задача «Простой калькулятор»\",\"LikesCount\":19,\"Quiz\":[{\"answers\":[{\"text\":\"Жадная стратегия — выбор наилучшего локального решения на каждом шаге в надежде на глобальную оптимальность.\",\"generated_as_correct\":true},{\"text\":\"Жадная стратегия — это алгоритм, который всегда находит оптимальное решение для любой задачи, независимо от её сложности, путём последовательного выбора лучших вариантов на каждом шаге.\",\"generated_as_correct\":false},{\"text\":\"Жадная стратегия — это концепция в теории игр, где игроки выбирают действия, основываясь на максимизации своего текущего выигрыша без учёта долгосрочных последствий.\",\"generated_as_correct\":false},{\"text\":\"Жадная стратегия гарантирует нахождение оптимального решения для любой задачи.\",\"generated_as_correct\":false}],\"question\":\"Что такое жадная стратегия в контексте решения задач?\"},{\"answers\":[{\"text\":\"Жадная стратегия может не привести к оптимальному решению, так как локально лучшие выборы не всегда обеспечивают глобально лучший результат.\",\"generated_as_correct\":true},{\"text\":\"Жадная стратегия не приводит к оптимальному решению из-за того, что она учитывает только предыдущие шаги и не анализирует возможные будущие варианты, что делает её неэффективной по сравнению с другими стратегиями.\",\"generated_as_correct\":false},{\"text\":\"Жадная стратегия неэффективна, потому что она требует слишком много вычислительных ресурсов и времени для анализа всех возможных вариантов на каждом шаге.\",\"generated_as_correct\":false},{\"text\":\"Жадная стратегия не приводит к оптимальному решению, потому что она не учитывает начальные условия задачи.\",\"generated_as_correct\":false}],\"question\":\"Почему жадная стратегия не всегда приводит к оптимальному решению?\"},{\"answers\":[{\"text\":\"Жадная стратегия — выбор на каждом шаге наилучшей операции для минимизации количества действий при достижении целевого числа на калькуляторе.\",\"generated_as_correct\":true},{\"text\":\"Жадная стратегия для задачи с калькулятором состоит в том, чтобы всегда выбирать операцию умножения на 3, так как это самый быстрый способ достичь целевого числа n и минимизировать количество операций.\",\"generated_as_correct\":false},{\"text\":\"Жадная стратегия используется для определения порядка выполнения арифметических операций в выражении, чтобы максимизировать результат, не учитывая минимизацию количества операций.\",\"generated_as_correct\":false},{\"text\":\"Жадная стратегия всегда обеспечивает оптимальное решение при использовании калькулятора для достижения целевого числа.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить жадную стратегию для решения задачи с калькулятором, где нужно минимизировать количество операций?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение связывает значение функции с её предыдущими значениями.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение — это формула, которая определяет значение функции в каждой точке независимо от её предыдущих значений.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение используется в теории вероятностей для определения вероятности наступления событий на основе их предыдущих исходов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение определяет значение функции через её будущие значения.\",\"generated_as_correct\":false}],\"question\":\"Что такое рекуррентное соотношение?\"},{\"answers\":[{\"text\":\"Предыдущие значения функции важны, так как они позволяют вычислить текущее значение через рекуррентное соотношение.\",\"generated_as_correct\":true},{\"text\":\"Предыдущие значения функции в рекуррентном соотношении важны только для определения начального условия, но не влияют на последующие вычисления.\",\"generated_as_correct\":false},{\"text\":\"Предыдущие значения функции важны для построения графика функции и анализа её поведения на различных интервалах.\",\"generated_as_correct\":false},{\"text\":\"Предыдущие значения функции не важны, так как каждое значение вычисляется независимо от других.\",\"generated_as_correct\":false}],\"question\":\"Почему в рекуррентном соотношении важно учитывать предыдущие значения функции?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение помогает найти минимальное количество операций для получения числа n из 1, используя значения calculator(n-1), calculator(n/2) и calculator(n/3).\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение определяет количество операций calculator(n) как сумму всех предыдущих значений calculator(k) для k от 1 до n-1.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение применяется для анализа последовательности чисел и выявления закономерностей в их изменении, но не связано с определением количества операций.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение определяет максимальное количество операций для преобразования числа 1 в число n, используя значения calculator(n+1).\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентное соотношение для определения минимального количества операций, необходимых для получения числа n из числа 1?\"},{\"answers\":[{\"text\":\"Оптимальная последовательность операций — это минимальный набор шагов для преобразования числа 1 в число n.\",\"generated_as_correct\":true},{\"text\":\"Оптимальная последовательность операций — это набор случайных операций, которые в итоге приведут к преобразованию начального числа 1 в целевое число n.\",\"generated_as_correct\":false},{\"text\":\"Оптимальная последовательность операций относится к методам сортировки данных в компьютерных алгоритмах, где важен порядок обработки элементов.\",\"generated_as_correct\":false},{\"text\":\"Оптимальная последовательность операций — это любой способ преобразования числа 1 в число n без учёта количества шагов.\",\"generated_as_correct\":false}],\"question\":\"Что такое оптимальная последовательность операций?\"},{\"answers\":[{\"text\":\"Порядок выполнения операций важен, так как он влияет на количество шагов для достижения цели.\",\"generated_as_correct\":true},{\"text\":\"При поиске оптимальной последовательности операций важно учитывать только тип операций, а порядок их выполнения не влияет на результат.\",\"generated_as_correct\":false},{\"text\":\"При поиске оптимальной последовательности операций важно учитывать временные интервалы между операциями, чтобы оптимизировать процесс по времени выполнения каждой операции.\",\"generated_as_correct\":false},{\"text\":\"Порядок выполнения операций не важен, главное — их общее количество.\",\"generated_as_correct\":false}],\"question\":\"Почему при поиске оптимальной последовательности операций важно учитывать порядок их выполнения?\"},{\"answers\":[{\"text\":\"Оптимальная последовательность операций позволяет получить целевое число из начального с минимальным количеством шагов, учитывая порядок операций.\",\"generated_as_correct\":true},{\"text\":\"Концепция оптимальной последовательности операций предполагает использование случайного набора арифметических действий для достижения целевого числа из начального, без учёта количества шагов.\",\"generated_as_correct\":false},{\"text\":\"Концепция оптимальной последовательности операций применяется в теории графов для определения кратчайших путей в сетях и не имеет отношения к получению целевого числа из начального.\",\"generated_as_correct\":false},{\"text\":\"Оптимальная последовательность операций — это набор случайных арифметических действий, которые могут привести к целевому числу из начального.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить концепцию оптимальной последовательности операций для решения задачи по получению целевого числа из начального?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм — это алгоритм, который пошагово обновляет результаты для решения задачи.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм — это алгоритм, который использует рекурсию для решения задачи, вызывая сам себя с уменьшенными параметрами до достижения базового случая.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм — это метод, который применяется в теории графов для поиска кратчайшего пути между двумя вершинами.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм — это алгоритм, который выполняет операции одновременно, не сохраняя промежуточные результаты.\",\"generated_as_correct\":false}],\"question\":\"Что такое итерационный алгоритм?\"},{\"answers\":[{\"text\":\"Сохранение и обновление промежуточных результатов в итерационном алгоритме позволяет эффективно вычислять последующие значения.\",\"generated_as_correct\":true},{\"text\":\"В итерационном алгоритме сохранение и обновление промежуточных результатов на каждом шаге необходимо для того, чтобы обеспечить случайный выбор значений при вычислении окончательного результата.\",\"generated_as_correct\":false},{\"text\":\"В итерационном алгоритме сохранение промежуточных результатов важно для анализа сходимости алгоритма, но не влияет на процесс обновления значений в таблице.\",\"generated_as_correct\":false},{\"text\":\"Промежуточные результаты в итерационном алгоритме сохраняются для визуального отслеживания процесса вычислений, но не влияют на конечный результат.\",\"generated_as_correct\":false}],\"question\":\"Почему в итерационном алгоритме важно сохранять и обновлять промежуточные результаты на каждом шаге?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм вычисляет минимальное количество операций для чисел от 1 до n, обновляя результаты на каждом шаге.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм позволяет вычислить минимальное количество операций для каждого числа от 1 до n путём случайного выбора операций и их выполнения без сохранения промежуточных результатов.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм может быть использован для сортировки чисел от 1 до n, где на каждом шаге происходит сравнение и перестановка элементов.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм определяет максимальное количество операций для чисел от 1 до n без сохранения промежуточных результатов.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить итерационный алгоритм для вычисления минимального количества операций для каждого числа от 1 до n?\"},{\"answers\":[{\"text\":\"Оценка O(n) показывает линейную зависимость времени выполнения алгоритма от размера входных данных.\",\"generated_as_correct\":true},{\"text\":\"Оценка времени выполнения алгоритма O(n) означает, что время выполнения алгоритма не зависит от размера входных данных и остаётся постоянным независимо от их величины.\",\"generated_as_correct\":false},{\"text\":\"Оценка времени выполнения алгоритма O(n) используется для определения сложности алгоритма по количеству операций, необходимых для сортировки данных.\",\"generated_as_correct\":false},{\"text\":\"Оценка O(n) указывает на то, что время выполнения алгоритма уменьшается с увеличением размера входных данных.\",\"generated_as_correct\":false}],\"question\":\"Что означает оценка времени выполнения алгоритма O(n)?\"},{\"answers\":[{\"text\":\"В случае O(n) время выполнения алгоритма растёт линейно с увеличением размера входных данных.\",\"generated_as_correct\":true},{\"text\":\"В случае O(n) время выполнения алгоритма увеличивается экспоненциально по отношению к росту размера входных данных, поскольку каждый новый элемент требует дополнительных вычислений, которые значительно увеличивают общее время обработки.\",\"generated_as_correct\":false},{\"text\":\"В случае O(n) время выполнения алгоритма связано с количеством операций, необходимых для сортировки данных, что не всегда прямо пропорционально размеру входных данных, но может зависеть от их начального порядка.\",\"generated_as_correct\":false},{\"text\":\"В случае O(n) время выполнения алгоритма остаётся постоянным независимо от размера входных данных.\",\"generated_as_correct\":false}],\"question\":\"Почему в случае O(n) время выполнения алгоритма увеличивается пропорционально росту размера входных данных?\"},{\"answers\":[{\"text\":\"Оценка O(n) помогает предсказать рост времени выполнения алгоритма с увеличением объёма данных, что важно для выбора эффективного алгоритма.\",\"generated_as_correct\":true},{\"text\":\"Оценка O(n) показывает максимальное время выполнения алгоритма при любом размере входных данных, что позволяет выбрать алгоритм с наименьшим временем выполнения для больших объёмов данных.\",\"generated_as_correct\":false},{\"text\":\"Оценка O(n) используется для определения сложности алгоритма по памяти, что может быть полезно при выборе алгоритма для систем с ограниченными ресурсами памяти.\",\"generated_as_correct\":false},{\"text\":\"Оценка O(n) показывает, сколько памяти потребуется алгоритму для обработки данных, что помогает выбрать алгоритм с наименьшими требованиями к памяти.\",\"generated_as_correct\":false}],\"question\":\"Как знание оценки O(n) может помочь при выборе алгоритма для обработки больших объёмов данных?\"}],\"StoreCardId\":null,\"numberInCourse\":\"8.3\"},{\"Name\":\"algo | 8.4 Задача «Расстояние редактирования»\",\"Slug\":\"zadacha-rasstoyanie-redaktirovaniya\",\"createdAt\":\"2024-07-03T17:24:54.604Z\",\"updatedAt\":\"2026-01-10T12:07:09.188Z\",\"publishedAt\":\"2024-07-03T17:24:56.219Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80779/problem\",\"Lead\":null,\"Content\":\"$81\",\"Title\":\"Задача «Расстояние редактирования»\",\"LikesCount\":30,\"Quiz\":[{\"answers\":[{\"text\":\"Расстояние редактирования — это минимальное число операций для преобразования одной строки в другую.\",\"generated_as_correct\":true},{\"text\":\"Расстояние редактирования — это количество символов, которые отличаются в двух строках при их сравнении.\",\"generated_as_correct\":false},{\"text\":\"Расстояние редактирования используется для определения схожести двух изображений путём подсчёта количества пикселей, которые необходимо изменить.\",\"generated_as_correct\":false},{\"text\":\"Расстояние редактирования — это общее количество символов в двух строках.\",\"generated_as_correct\":false}],\"question\":\"Что такое расстояние редактирования?\"},{\"answers\":[{\"text\":\"Расстояние редактирования используется в обработке текстов, проверке правописания и биологии для анализа мутаций.\",\"generated_as_correct\":true},{\"text\":\"Расстояние редактирования применяется в физике для измерения расстояний между объектами и в химии для анализа молекулярных структур.\",\"generated_as_correct\":false},{\"text\":\"Расстояние редактирования связано с теорией графов и используется для анализа сетевых структур в компьютерных науках.\",\"generated_as_correct\":false},{\"text\":\"Расстояние редактирования применяется в астрономии для измерения расстояний между звёздами.\",\"generated_as_correct\":false}],\"question\":\"В каких областях применяется понятие расстояния редактирования и почему оно там полезно?\"},{\"answers\":[{\"text\":\"Расстояние редактирования помогает выявить мутации, подсчитывая минимальные изменения между двумя генетическими последовательностями.\",\"generated_as_correct\":true},{\"text\":\"Расстояние редактирования применяется для подсчёта общего количества символов в двух генетических последовательностях, что позволяет определить наличие мутаций на основе разницы в длине последовательностей.\",\"generated_as_correct\":false},{\"text\":\"Расстояние редактирования используется в биоинформатике для классификации биологических видов на основе их генетического сходства, независимо от конкретных мутаций.\",\"generated_as_correct\":false},{\"text\":\"Расстояние редактирования определяет максимальное количество символов, которые можно изменить в генетической последовательности, не влияя на её функцию.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать расстояние редактирования для выявления мутаций в биологии?\"},{\"answers\":[{\"text\":\"Выравнивание строк — это сопоставление строк путём вставки пробелов для анализа различий.\",\"generated_as_correct\":true},{\"text\":\"Выравнивание строк — это метод шифрования, при котором символы строк перемешиваются для создания зашифрованного сообщения.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание строк — это техника форматирования текста в графических редакторах, которая используется для выравнивания абзацев по левому или правому краю.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание строк — это удаление пробелов из строк для их объединения.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой процесс выравнивания строк?\"},{\"answers\":[{\"text\":\"Выравнивание строк нужно для сопоставления строк и анализа их различий.\",\"generated_as_correct\":true},{\"text\":\"Выравнивание строк используется исключительно для эстетического оформления текста, чтобы строки были одинаковой длины и выглядели симметрично на странице.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание строк связано с настройкой отступов и табуляции в текстовых редакторах для улучшения читаемости кода.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание строк необходимо для подсчёта количества символов в тексте.\",\"generated_as_correct\":false}],\"question\":\"Для чего используется выравнивание строк при работе с текстовыми данными?\"},{\"answers\":[{\"text\":\"Выравнивание строк помогает сопоставить символы двух строк и найти оптимальный способ их преобразования с минимальным числом операций.\",\"generated_as_correct\":true},{\"text\":\"Выравнивание строк заключается в том, чтобы изменить порядок символов в строках так, чтобы они стали идентичными, без использования пробелов или других операций.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание строк используется для форматирования текста в документах и не имеет отношения к преобразованию одной строки в другую.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание строк позволяет определить количество символов в строках и их типы, но не помогает в нахождении оптимального способа преобразования.\",\"generated_as_correct\":false}],\"question\":\"Как выравнивание строк может помочь в нахождении оптимального способа преобразования одной строки в другую?\"},{\"answers\":[{\"text\":\"оптимальное выравнивание строк — это минимизация различий между двумя строками.\",\"generated_as_correct\":true},{\"text\":\"оптимальное выравнивание строк — это метод сортировки символов в двух строках для достижения их полного совпадения без учёта операций удаления или вставки.\",\"generated_as_correct\":false},{\"text\":\"оптимальное выравнивание строк связано с алгоритмами сжатия данных и используется для уменьшения размера текстовых файлов.\",\"generated_as_correct\":false},{\"text\":\"оптимальное выравнивание строк — это способ максимального увеличения различий между двумя строками.\",\"generated_as_correct\":false}],\"question\":\"Что такое оптимальное выравнивание строк?\"},{\"answers\":[{\"text\":\"Минимизация несоответствий, удалений и вставок позволяет найти наилучший способ преобразования одной строки в другую.\",\"generated_as_correct\":true},{\"text\":\"Минимизация несоответствий, удалений и вставок важна при оптимальном выравнивании, потому что это увеличивает количество возможных вариантов преобразования одной строки в другую.\",\"generated_as_correct\":false},{\"text\":\"Минимизация несоответствий, удалений и вставок важна для улучшения читаемости кода при работе с текстовыми данными, но не имеет прямого отношения к оптимальному выравниванию.\",\"generated_as_correct\":false},{\"text\":\"Минимизация несоответствий, удалений и вставок важна, так как она увеличивает длину строк при оптимальном выравнивании.\",\"generated_as_correct\":false}],\"question\":\"Почему минимизация несоответствий, удалений и вставок важна при оптимальном выравнивании?\"},{\"answers\":[{\"text\":\"Оптимальное выравнивание строк используется в задачах расстояния редактирования для минимизации несоответствий при преобразовании одной строки в другую.\",\"generated_as_correct\":true},{\"text\":\"Оптимальное выравнивание строк применяется для нахождения точного совпадения между двумя строками без учёта возможных несоответствий, удалений или вставок.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное выравнивание строк связано с алгоритмами сортировки и используется для упорядочивания строк в алфавитном порядке.\",\"generated_as_correct\":false},{\"text\":\"Оптимальное выравнивание строк применяется для нахождения максимального количества различий между двумя строками.\",\"generated_as_correct\":false}],\"question\":\"В каких задачах применяется оптимальное выравнивание строк и как оно помогает решать эти задачи?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение для редакционного расстояния — это формула вычисления расстояния между префиксами строк на основе предыдущих значений.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для редакционного расстояния — это метод, который позволяет определить количество символов, необходимых для полного преобразования одной строки в другую без учёта предыдущих значений.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для редакционного расстояния связано с теорией графов и используется для определения кратчайшего пути между двумя узлами в графе.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для редакционного расстояния — это способ вычисления количества общих подстрок в двух строках.\",\"generated_as_correct\":false}],\"question\":\"Что такое рекуррентное соотношение для редакционного расстояния?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение позволяет вычислить редакционное расстояние между префиксами строк, используя предыдущие значения.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение используется для вычисления редакционного расстояния между строками, потому что оно определяет точное количество символов, которые необходимо изменить в одной строке, чтобы получить другую строку, без учёта предыдущих значений.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение важно для вычисления редакционного расстояния между строками, так как оно связано с теорией графов и помогает определить кратчайшие пути между вершинами, представляющими строки.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение определяет максимальное количество изменений, необходимых для преобразования одной строки в другую, без учёта предыдущих вычислений.\",\"generated_as_correct\":false}],\"question\":\"Почему рекуррентное соотношение важно для вычисления редакционного расстояния между строками?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение вычисляет редакционное расстояние между префиксами строк.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение позволяет вычислить количество общих подстрок между двумя строками, что используется в алгоритмах сравнения текстов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение применяется в теории графов для определения кратчайшего пути между вершинами, что не связано с обработкой строк.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение определяет максимальное количество символов, которые совпадают в двух строках.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентное соотношение для нахождения редакционного расстояния в алгоритмах обработки строк?\"},{\"answers\":[{\"text\":\"Мемоизация — это сохранение промежуточных результатов вычислений для оптимизации рекурсивных алгоритмов.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация — это процесс удаления промежуточных результатов вычислений из памяти для освобождения ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это концепция в области искусственного интеллекта, связанная с улучшением способности моделей запоминать большие объёмы данных.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это метод увеличения времени выполнения рекурсивных алгоритмов за счёт дополнительных вычислений.\",\"generated_as_correct\":false}],\"question\":\"Что такое мемоизация?\"},{\"answers\":[{\"text\":\"Мемоизация экономит время за счёт сохранения результатов промежуточных вычислений в рекурсивных алгоритмах.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация ускоряет работу рекурсивных алгоритмов за счёт использования дополнительных математических формул для предсказания результатов вычислений, вместо сохранения уже вычисленных значений.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация используется для улучшения читаемости кода рекурсивных алгоритмов путём упрощения структуры функций и уменьшения количества вложенных вызовов.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация замедляет работу рекурсивных алгоритмов из-за необходимости дополнительного хранения всех входных данных.\",\"generated_as_correct\":false}],\"question\":\"Почему мемоизация эффективна для оптимизации рекурсивных алгоритмов?\"},{\"answers\":[{\"text\":\"Мемоизация ускоряет вычисление редакционного расстояния через сохранение промежуточных результатов.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация ускоряет вычисление редакционного расстояния за счёт использования дополнительных математических формул, которые упрощают вычисления без сохранения промежуточных результатов.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это метод, который используется в теории графов для оптимизации путей, он не имеет отношения к вычислению редакционного расстояния.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация замедляет вычисление редакционного расстояния из-за необходимости дополнительного хранения данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить мемоизацию для ускорения вычисления редакционного расстояния?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм вычисляет редакционное расстояние, заполняя таблицу значениями для префиксов строк.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм для вычисления редакционного расстояния — это способ, который сравнивает две строки посимвольно, подсчитывая количество несовпадений, и не использует таблицы или рекурсию.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм для вычисления редакционного расстояния связан с методами сортировки и используется для упорядочивания элементов в массиве.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм вычисляет редакционное расстояние с помощью рекурсивных вызовов для сравнения суффиксов строк.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой итерационный алгоритм для вычисления редакционного расстояния?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм эффективнее рекурсивного, так как не требует повторных вычислений и экономит память.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм более эффективен, потому что он использует меньше математических операций по сравнению с рекурсивным алгоритмом, что ускоряет процесс вычисления редакционного расстояния.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм эффективнее, так как он лучше подходит для параллельных вычислений и может быть легко адаптирован для работы на многоядерных процессорах.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм эффективнее из-за меньшего количества сравнений строк в процессе вычисления.\",\"generated_as_correct\":false}],\"question\":\"Почему использование итерационного алгоритма может быть более эффективным по сравнению с рекурсивным подходом при вычислении редакционного расстояния?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм позволяет эффективно вычислять редакционное расстояние между строками, заполняя двумерную таблицу без использования рекурсии.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм вычисляет редакционное расстояние путём сравнения первых символов строк и игнорирования остальных, что делает его непригодным для практических задач обработки текста.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм применяется для вычисления редакционного расстояния в задачах машинного обучения, где он используется для определения сходства между векторами признаков.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм используется для прямого сравнения строк без учёта промежуточных изменений, что делает его неприменимым для вычисления редакционного расстояния.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить итерационный алгоритм для вычисления редакционного расстояния в практических задачах обработки текста?\"},{\"answers\":[{\"text\":\"ОАГ в контексте редакционного расстояния — граф, показывающий все пути преобразования одной строки в другую через операции вставки, удаления и замены.\",\"generated_as_correct\":true},{\"text\":\"Ориентированный ациклический граф (ОАГ) в контексте редакционного расстояния — это структура данных, которая используется для хранения строк и их прямого сравнения без учёта каких-либо преобразований.\",\"generated_as_correct\":false},{\"text\":\"Ориентированный ациклический граф (ОАГ) — это инструмент, используемый в теории графов для анализа сетевых структур и определения путей между узлами, не связанный с вычислением редакционного расстояния.\",\"generated_as_correct\":false},{\"text\":\"ОАГ в контексте редакционного расстояния — это метод прямого сравнения строк без учёта возможных преобразований.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой ориентированный ациклический граф (ОАГ) в контексте редакционного расстояния?\"},{\"answers\":[{\"text\":\"при построении ОАГ учитываются операции вставки, удаления, замены.\",\"generated_as_correct\":true},{\"text\":\"при построении ОАГ для преобразования одной строки в другую учитываются операции копирования, дублирования и сортировки символов.\",\"generated_as_correct\":false},{\"text\":\"при построении ОАГ для преобразования одной строки в другую учитываются алгоритмы поиска и сопоставления строк, а также методы хеширования.\",\"generated_as_correct\":false},{\"text\":\"при построении ОАГ учитываются операции транспозиции и фильтрации символов.\",\"generated_as_correct\":false}],\"question\":\"Какие операции учитываются при построении ОАГ для преобразования одной строки в другую?\"},{\"answers\":[{\"text\":\"ОАГ визуализирует все возможные пути преобразования одной строки в другую через операции вставки, удаления и замены для анализа редакционного расстояния.\",\"generated_as_correct\":true},{\"text\":\"ОАГ служит для определения максимального количества операций, которые можно применить к строке, чтобы преобразовать её в другую строку, не учитывая при этом возможные пути преобразования.\",\"generated_as_correct\":false},{\"text\":\"ОАГ используется в алгоритмах машинного обучения для классификации строк на основе их структурного сходства, не связанного с вычислением редакционного расстояния.\",\"generated_as_correct\":false},{\"text\":\"ОАГ определяет минимальное количество символов, которое нужно изменить в одной строке, чтобы она стала идентична другой строке.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать ОАГ для анализа процесса вычисления редакционного расстояния между двумя строками?\"}],\"StoreCardId\":null,\"numberInCourse\":\"8.4\"},{\"Name\":\"algo | 8.5 Задача LCS\",\"Slug\":\"zadacha-lcs\",\"createdAt\":\"2024-07-03T17:25:30.229Z\",\"updatedAt\":\"2026-01-10T12:07:08.656Z\",\"publishedAt\":\"2024-07-03T17:25:31.323Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80780/problem\",\"Lead\":null,\"Content\":\"$82\",\"Title\":\"Задача LCS\",\"LikesCount\":21,\"Quiz\":[{\"answers\":[{\"text\":\"Наибольшая общая подпоследовательность — это самая длинная подпоследовательность, общая для двух или более последовательностей.\",\"generated_as_correct\":true},{\"text\":\"Наибольшая общая подпоследовательность — это набор элементов, которые встречаются в двух или более последовательностях, независимо от их порядка.\",\"generated_as_correct\":false},{\"text\":\"Наибольшая общая подпоследовательность используется в теории графов для определения кратчайших путей между узлами.\",\"generated_as_correct\":false},{\"text\":\"Наибольшая общая подпоследовательность — это любая подпоследовательность, которая встречается в двух последовательностях, независимо от её длины.\",\"generated_as_correct\":false}],\"question\":\"Что такое наибольшая общая подпоследовательность (НОП)?\"},{\"answers\":[{\"text\":\"НОП помогает сравнивать данные, выявляя общие элементы и их порядок в нескольких последовательностях.\",\"generated_as_correct\":true},{\"text\":\"НОП полезен для сравнения данных, так как он находит наиболее часто встречающиеся элементы в одной последовательности, игнорируя их наличие в других последовательностях.\",\"generated_as_correct\":false},{\"text\":\"НОП применяется в теории чисел для определения делимости последовательностей и не имеет отношения к сравнению данных.\",\"generated_as_correct\":false},{\"text\":\"НОП используется для нахождения уникальных элементов в одной последовательности без учёта их присутствия в других.\",\"generated_as_correct\":false}],\"question\":\"Почему НОП считается полезным инструментом для сравнения данных?\"},{\"answers\":[{\"text\":\"НОП применима для проверки орфографии и сравнения данных.\",\"generated_as_correct\":true},{\"text\":\"НОП применяется для задач машинного обучения, таких как классификация изображений, и не используется для сравнения данных или проверки орфографии.\",\"generated_as_correct\":false},{\"text\":\"НОП используется в криптографии для создания сложных алгоритмов шифрования и не имеет отношения к сравнению генов или другим перечисленным задачам.\",\"generated_as_correct\":false},{\"text\":\"НОП используется только в задачах биоинформатики для анализа геномных данных.\",\"generated_as_correct\":false}],\"question\":\"В каких задачах, помимо сравнения генов, может быть применена НОП?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение для НОП позволяет вычислить длину наибольшей общей подпоследовательности двух последовательностей с помощью динамического программирования, учитывая три случая: пропуск элемента из первой последовательности, пропуск элемента из второй или совпадение элементов.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для НОП представляет собой формулу $LCS(i,j) = LCS(i-1,j-1) + 2$, если элементы $A[i]$ и $B[j]$ совпадают, и $LCS(i,j) = 0$ в противном случае.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для НОП связано с методом поиска в глубину и используется для определения оптимального пути в графе.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для НОП используется для нахождения наименьшей общей подпоследовательности двух последовательностей.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой рекуррентное соотношение для НОП (наибольшей общей подпоследовательности)?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение для НОП учитывает пропуск элемента из $A$, пропуск элемента из $B$ или совпадение элементов, увеличивая длину подпоследовательности.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для НОП учитывает три возможных случая: умножение длины подпоследовательности на коэффициент, зависящий от элементов $A[i]$ и $B[j]$, деление длины подпоследовательности на коэффициент, зависящий от элементов $A[i]$ и $B[j]$, или сохранение текущей длины подпоследовательности без изменений.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для НОП учитывает три возможных случая, которые связаны с различными способами сортировки элементов в последовательностях $A$ и $B$.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для НОП учитывает три случая: сложение элементов из $A$ и $B$, вычитание элементов из $A$ и $B$ или их умножение для вычисления длины подпоследовательности.\",\"generated_as_correct\":false}],\"question\":\"Почему в рекуррентном соотношении для НОП учитываются три возможных случая?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение позволяет вычислить длину наибольшей общей подпоследовательности двух последовательностей с помощью динамического программирования.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для вычисления длины наибольшей общей подпоследовательности учитывает только количество совпавших элементов в двух последовательностях, без учёта их порядка.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение применяется для анализа временных рядов и прогнозирования будущих значений на основе предыдущих данных.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение используется для подсчёта количества элементов в двух последовательностях.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентное соотношение для вычисления длины наибольшей общей подпоследовательности двух последовательностей?\"},{\"answers\":[{\"text\":\"$$O(nm)$ — время выполнения алгоритма НОП, где $n$ и $m$ — длины последовательностей.\",\"generated_as_correct\":true},{\"text\":\"Запись $O(nm)$ указывает на то, что время выполнения алгоритма для нахождения НОП двух последовательностей зависит от суммы длин этих последовательностей $n$ и $m$.\",\"generated_as_correct\":false},{\"text\":\"Запись $O(nm)$ относится к пространственной сложности алгоритма, а не ко времени его выполнения.\",\"generated_as_correct\":false},{\"text\":\"$$O(nm)$ — это константное время выполнения алгоритма независимо от длин последовательностей $n$ и $m$.\",\"generated_as_correct\":false}],\"question\":\"Что означает запись $O(nm)$ в контексте времени выполнения алгоритма для нахождения НОП двух последовательностей?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма для нахождения НОП двух последовательностей составляет $O(nm)$ из-за использования двумерного массива и итераций по всем элементам.\",\"generated_as_correct\":true},{\"text\":\"Время выполнения алгоритма для нахождения НОП двух последовательностей имеет линейную сложность, потому что алгоритм осуществляет последовательный проход по элементам одной из последовательностей, не требуя вложенных циклов.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма для нахождения НОП зависит от сложности структуры данных, используемой для хранения последовательностей, и от эффективности используемых методов сравнения элементов.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма для нахождения НОП двух последовательностей составляет $O(\\\\max(n, m))$, так как алгоритм выполняет итерации только по более длинной последовательности.\",\"generated_as_correct\":false}],\"question\":\"Почему время выполнения алгоритма для нахождения НОП двух последовательностей имеет квадратичную сложность?\"},{\"answers\":[{\"text\":\"Знание $O(nm)$ помогает планировать ресурсы и выбирать стратегии обработки больших данных.\",\"generated_as_correct\":true},{\"text\":\"Знание о времени выполнения алгоритма $O(nm)$ можно использовать для определения максимального размера данных, которые могут быть обработаны за заданное время, без учёта возможных оптимизаций или ограничений ресурсов системы.\",\"generated_as_correct\":false},{\"text\":\"Знание о времени выполнения алгоритма $O(nm)$ может быть использовано для анализа сложности алгоритмов сортировки и выбора наиболее подходящего алгоритма в зависимости от характеристик данных.\",\"generated_as_correct\":false},{\"text\":\"Знание $O(nm)$ не влияет на оптимизацию работы с большими данными, так как зависит только от длины последовательностей.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать знание о времени выполнения алгоритма $O(nm)$ для оптимизации работы с большими объёмами данных?\"},{\"answers\":[{\"text\":\"Задача нахождения НОП для трёх последовательностей — это поиск максимальной длины общей подпоследовательности в трёх последовательностях.\",\"generated_as_correct\":true},{\"text\":\"Задача нахождения НОП для трёх последовательностей заключается в определении суммарной длины всех возможных подпоследовательностей, которые можно извлечь из каждой из трёх последовательностей.\",\"generated_as_correct\":false},{\"text\":\"Задача нахождения НОП для трёх последовательностей связана с анализом генетических данных и используется для сравнения последовательностей ДНК.\",\"generated_as_correct\":false},{\"text\":\"Задача нахождения НОП для трёх последовательностей заключается в нахождении минимальной длины подпоследовательности в каждой из трёх последовательностей.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой задача нахождения НОП для трёх последовательностей?\"},{\"answers\":[{\"text\":\"Задача нахождения НОП для трёх последовательностей сложнее из-за необходимости учёта трёх измерений.\",\"generated_as_correct\":true},{\"text\":\"Задача нахождения НОП для трёх последовательностей считается более сложной из-за необходимости учитывать больше переменных, однако сложность не увеличивается по сравнению с задачей для двух последовательностей, так как алгоритмы для её решения остаются теми же.\",\"generated_as_correct\":false},{\"text\":\"Задача нахождения НОП для трёх последовательностей требует применения методов динамического программирования, которые отличаются от методов, используемых для анализа статистических данных.\",\"generated_as_correct\":false},{\"text\":\"Задача нахождения НОП для трёх последовательностей не сложнее, чем для двух, так как количество вычислений остаётся прежним.\",\"generated_as_correct\":false}],\"question\":\"Почему задача нахождения НОП для трёх последовательностей считается более сложной по сравнению с задачей для двух последовательностей?\"},{\"answers\":[{\"text\":\"Решение задачи нахождения НОП для трёх последовательностей используется для сравнения и анализа данных в биоинформатике и обработке текстов.\",\"generated_as_correct\":true},{\"text\":\"Решение задачи нахождения НОП для трёх последовательностей применяется для определения количества уникальных элементов в каждой из трёх последовательностей, что используется в задачах классификации данных.\",\"generated_as_correct\":false},{\"text\":\"Решение задачи нахождения НОП для трёх последовательностей связано с разработкой алгоритмов машинного обучения для прогнозирования временных рядов.\",\"generated_as_correct\":false},{\"text\":\"Решение задачи нахождения НОП для трёх последовательностей применяется для нахождения кратчайшего пути между тремя точками в графе.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить решение задачи нахождения НОП для трёх последовательностей в практических целях?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение для НОП трёх последовательностей вычисляется по формуле $LCS(i,j,k) = \\\\max$ из четырёх случаев: пропуск элемента или совпадение элементов, увеличивающее длину на 1 при равенстве элементов.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для НОП трёх последовательностей определяется как $LCS(i,j,k) = LCS(i-1,j-1,k-1)$, что позволяет вычислить длину НОП только при условии полного совпадения элементов всех трёх последовательностей на каждом шаге.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для НОП трёх последовательностей используется для определения максимального количества общих элементов между последовательностями и не учитывает порядок их следования.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для НОП трёх последовательностей определяется как сумма длин всех подпоследовательностей, независимо от их совпадений.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой рекуррентное соотношение для НОП трёх последовательностей?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение для НОП учитывает пропуск элемента из каждой последовательности и совпадение элементов во всех трёх, что увеличивает длину подпоследовательности.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для НОП учитывает четыре возможных случая, так как предполагается, что каждая последовательность может быть либо полностью включена, либо исключена из рассмотрения, независимо от других последовательностей.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для НОП учитывает четыре возможных случая из-за необходимости применения различных алгоритмов сортировки к каждой из последовательностей перед сравнением их элементов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для НОП учитывает четыре случая, потому что каждая последовательность может быть добавлена или удалена независимо от других.\",\"generated_as_correct\":false}],\"question\":\"Почему в рекуррентном соотношении для НОП учитываются четыре возможных случая?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение позволяет вычислить длину НОП трёх последовательностей, учитывая пропуск элементов или их совпадение, что увеличивает длину подпоследовательности на 1.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для вычисления длины НОП трёх последовательностей основывается на формуле $LCS(i,j,k) = LCS(i-1,j-1,k-1) + 2$, если элементы в соответствующих позициях равны, и $LCS(i,j,k) = 0$ в противном случае.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение применяется для решения задач комбинаторики и теории графов, но не связано с вычислением длины НОП трёх последовательностей.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение используется для вычисления суммы элементов трёх последовательностей при условии их равенства.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентное соотношение для вычисления длины НОП трёх последовательностей с помощью динамического программирования?\"},{\"answers\":[{\"text\":\"$$O(nmk)$ означает кубическую временную сложность алгоритма НОП для трёх последовательностей длиной $n$, $m$ и $k$.\",\"generated_as_correct\":true},{\"text\":\"Запись $O(nmk)$ указывает на то, что время выполнения алгоритма для нахождения НОП трёх последовательностей зависит от суммы длин этих последовательностей, а не от их произведения.\",\"generated_as_correct\":false},{\"text\":\"Запись $O(nmk)$ относится к пространственной сложности алгоритма, которая определяет количество памяти, необходимое для хранения данных, а не к времени выполнения алгоритма.\",\"generated_as_correct\":false},{\"text\":\"$$O(nmk)$ показывает, что алгоритм НОП для трёх последовательностей имеет линейную временную сложность относительно суммы длин последовательностей.\",\"generated_as_correct\":false}],\"question\":\"Что означает запись $O(nmk)$ в контексте времени выполнения алгоритма для нахождения НОП трёх последовательностей?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма для нахождения НОП трёх последовательностей имеет кубическую сложность \\\\(O(nmk)\\\\) из-за использования трёхмерного массива.\",\"generated_as_correct\":true},{\"text\":\"Время выполнения алгоритма для нахождения НОП трёх последовательностей составляет \\\\(O(n^2)\\\\), так как алгоритм использует двумерный массив для хранения промежуточных результатов и выполняет итерации по двум из трёх последовательностей.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма для нахождения НОП трёх последовательностей зависит от сложности используемых математических операций и количества сравнений, производимых на каждом шаге итерации.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма для нахождения НОП трёх последовательностей имеет линейную сложность \\\\(O(n + m + k)\\\\).\",\"generated_as_correct\":false}],\"question\":\"Почему время выполнения алгоритма для нахождения НОП трёх последовательностей имеет кубическую сложность?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма $O(nmk)$ позволяет оценить, как увеличение длин последовательностей $n$, $m$ и $k$ влияет на время нахождения НОП.\",\"generated_as_correct\":true},{\"text\":\"Информацию о времени выполнения алгоритма $O(nmk)$ можно использовать для оценки эффективности, считая, что время выполнения алгоритма линейно зависит от длины самой длинной последовательности, независимо от длин других последовательностей.\",\"generated_as_correct\":false},{\"text\":\"Информацию о времени выполнения алгоритма $O(nmk)$ можно использовать для анализа сложности хранения данных в трёхмерном массиве, не учитывая при этом влияние длины последовательностей на время выполнения.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма $O(nmk)$ не зависит от длин последовательностей $n$, $m$ и $k$.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать информацию о времени выполнения алгоритма $O(nmk)$ для оценки эффективности алгоритма при работе с последовательностями разной длины?\"}],\"StoreCardId\":null,\"numberInCourse\":\"8.5\"},{\"Name\":\"algo | 8.6. Задача о рюкзаке\",\"Slug\":\"zadacha-o-ryukzake\",\"createdAt\":\"2024-07-03T17:26:19.969Z\",\"updatedAt\":\"2026-01-10T12:07:08.861Z\",\"publishedAt\":\"2024-07-03T17:26:21.882Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80781/problem\",\"Lead\":null,\"Content\":\"$83\",\"Title\":\"Задача о рюкзаке\",\"LikesCount\":18,\"Quiz\":[{\"answers\":[{\"text\":\"Задача о рюкзаке — выбрать поднабор предметов с максимальным весом, не превышающим вместимость рюкзака.\",\"generated_as_correct\":true},{\"text\":\"Суть задачи о рюкзаке заключается в том, чтобы равномерно распределить предметы по рюкзаку, чтобы достичь идеального баланса между весом и объёмом.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке связана с определением оптимального маршрута для доставки предметов, учитывая их вес и объём.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке — распределить предметы по рюкзаку так, чтобы их общий вес был равен его вместимости.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается суть задачи о рюкзаке?\"},{\"answers\":[{\"text\":\"Задача о рюкзаке — это выбор поднабора предметов с максимальным весом в пределах вместимости рюкзака, что делает её классической задачей оптимизации.\",\"generated_as_correct\":true},{\"text\":\"Задача о рюкзаке считается классической задачей оптимизации, потому что она требует найти максимальный вес, который можно поместить в рюкзак, не учитывая его вместимость.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке связана с теорией графов и используется для анализа сетевых структур.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке заключается в поиске минимального веса предметов, которые можно поместить в рюкзак.\",\"generated_as_correct\":false}],\"question\":\"Почему задачу о рюкзаке считают классической задачей оптимизации?\"},{\"answers\":[{\"text\":\"Задача о рюкзаке помогает оптимизировать загрузку и распределение ресурсов в логистике, выбирая предметы с максимальным весом в пределах заданной вместимости.\",\"generated_as_correct\":true},{\"text\":\"Задача о рюкзаке используется для расчёта оптимального количества предметов, которые можно разместить в рюкзаке без учёта их веса. В логистике она применяется для определения количества упаковок, которые можно поместить на склад.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке связана с разработкой алгоритмов для поиска кратчайшего пути между двумя точками на карте, что может быть полезно в навигации и планировании маршрутов в логистике.\",\"generated_as_correct\":false},{\"text\":\"Задача о рюкзаке используется в логистике для определения максимального количества предметов, которые можно поместить в транспортное средство без учёта их веса.\",\"generated_as_correct\":false}],\"question\":\"Как задача о рюкзаке может быть применена в логистике и управлении ресурсами?\"},{\"answers\":[{\"text\":\"«Жадный» алгоритм выбирает на каждом шаге наилучшее доступное решение без учёта будущих последствий.\",\"generated_as_correct\":true},{\"text\":\"«Жадный» алгоритм — это метод, который учитывает все возможные комбинации решений и выбирает наилучший вариант с учётом всех будущих шагов.\",\"generated_as_correct\":false},{\"text\":\"«Жадный» алгоритм используется для сортировки данных в массиве, выбирая на каждом шаге наименьший элемент и перемещая его в начало массива.\",\"generated_as_correct\":false},{\"text\":\"«Жадный» алгоритм учитывает все будущие шаги и выбирает оптимальное решение на основе глобального анализа.\",\"generated_as_correct\":false}],\"question\":\"Что такое «жадный» алгоритм?\"},{\"answers\":[{\"text\":\"«Жадный» алгоритм может не дать оптимального решения, так как не учитывает последствия выбора на будущих шагах.\",\"generated_as_correct\":true},{\"text\":\"«Жадный» алгоритм не приводит к оптимальному решению, потому что он случайно выбирает решения на каждом шаге, не учитывая текущие условия задачи, что делает его неэффективным для большинства задач оптимизации.\",\"generated_as_correct\":false},{\"text\":\"«Жадный» алгоритм неэффективен, потому что его сложно реализовать программно из-за высокой вычислительной сложности на каждом шаге решения задачи.\",\"generated_as_correct\":false},{\"text\":\"«Жадный» алгоритм всегда находит оптимальное решение, так как выбирает наилучший вариант на каждом шаге.\",\"generated_as_correct\":false}],\"question\":\"Почему «жадный» алгоритм не всегда приводит к оптимальному решению задачи?\"},{\"answers\":[{\"text\":\"«Жадный» алгоритм для задачи о рюкзаке выбирает слитки с наибольшим весом, которые помещаются в рюкзак, но не всегда находит оптимальное решение.\",\"generated_as_correct\":true},{\"text\":\"«Жадный» алгоритм для задачи о рюкзаке состоит в случайном выборе слитков и их помещении в рюкзак до тех пор, пока рюкзак не будет заполнен, что обеспечивает оптимальное использование пространства.\",\"generated_as_correct\":false},{\"text\":\"«Жадный» алгоритм используется для сортировки элементов в порядке убывания их веса, что позволяет эффективно решать задачи оптимизации, не связанные с задачей о рюкзаке.\",\"generated_as_correct\":false},{\"text\":\"«Жадный» алгоритм для задачи о рюкзаке всегда находит оптимальное решение, выбирая слитки с наименьшим весом.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить «жадный» алгоритм для решения задачи о рюкзаке?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение связывает значение функции с её предыдущими значениями.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение — это формула, которая позволяет вычислить значение функции для любого аргумента, не зависящее от её предыдущих значений.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение — это метод решения дифференциальных уравнений, который используется в физике для описания движения объектов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение определяет значение функции через её будущие значения.\",\"generated_as_correct\":false}],\"question\":\"Что такое рекуррентное соотношение?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение помогает определить, как заполнить рюкзак с учётом его вместимости.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение помогает вычислить общий вес всех слитков, которые нужно поместить в рюкзак, без учёта его вместимости.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение применяется для анализа структуры данных в алгоритмах сортировки, что не имеет прямого отношения к задаче о рюкзаке.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение позволяет вычислить общий объём слитков для рюкзака без учёта его вместимости.\",\"generated_as_correct\":false}],\"question\":\"Почему рекуррентное соотношение полезно при решении задачи о рюкзаке?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение связывает возможность размещения текущего слитка с результатами для предыдущих, помогая определить, можно ли заполнить рюкзак.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение помогает определить, сколько слитков можно поместить в рюкзак, исходя из их общего веса, без учёта объёма рюкзака.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение применяется для расчёта оптимального распределения веса в рюкзаке с целью минимизации нагрузки на определённые части тела.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение определяет максимальный вес слитков в рюкзаке, не учитывая их количество и объём.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентное соотношение для определения возможности заполнения рюкзака определённым количеством слитков?\"},{\"answers\":[{\"text\":\"Динамическое программирование разбивает задачу на подзадачи и использует их решения для построения общего ответа.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование — это метод, который позволяет решать задачи путём случайного выбора подзадач и их решения без учёта общей структуры задачи.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование используется для создания алгоритмов машинного обучения, которые могут адаптироваться к новым данным без переобучения.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование заключается в решении задачи путём исключения подзадач без учёта их взаимосвязей.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается суть метода динамического программирования?\"},{\"answers\":[{\"text\":\"Динамическое программирование эффективно, так как сохраняет решения подзадач и повторно использует их.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование эффективно для задач с перекрывающимися подзадачами, потому что оно упрощает исходную задачу до набора независимых подзадач, которые можно решать параллельно без учёта их взаимосвязи.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование используется для оптимизации алгоритмов машинного обучения и не имеет отношения к решению задач с перекрывающимися подзадачами.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование неэффективно, потому что требует полного перебора всех возможных решений подзадач.\",\"generated_as_correct\":false}],\"question\":\"Почему динамическое программирование эффективно для задач с перекрывающимися подзадачами?\"},{\"answers\":[{\"text\":\"Динамическое программирование разбивает задачу о рюкзаке на подзадачи, решая их и используя решения для построения оптимального решения исходной задачи.\",\"generated_as_correct\":true},{\"text\":\"Динамическое программирование в задаче о рюкзаке заключается в случайном выборе предметов до тех пор, пока не будет достигнуто ограничение по весу, после чего оценивается общая ценность выбранных предметов.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование позволяет оптимизировать алгоритмы сортировки, что может быть использовано для предварительной обработки данных перед решением задачи о рюкзаке, хотя это не является прямым применением метода к самой задаче.\",\"generated_as_correct\":false},{\"text\":\"Динамическое программирование решает задачу о рюкзаке путём последовательного добавления предметов в рюкзак без учёта их ценности и веса.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить динамическое программирование для решения задачи о рюкзаке?\"},{\"answers\":[{\"text\":\"Мемоизация — это сохранение результатов вычислений в рекурсивных алгоритмах для их повторного использования.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация — это процесс упрощения кода рекурсивных функций путём удаления повторяющихся участков кода.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это концепция в области машинного обучения, которая используется для улучшения качества моделей путём запоминания всех входных данных.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация — это метод увеличения времени выполнения рекурсивных алгоритмов за счёт сохранения всех промежуточных результатов.\",\"generated_as_correct\":false}],\"question\":\"Что такое мемоизация?\"},{\"answers\":[{\"text\":\"Мемоизация ускоряет рекурсивные алгоритмы, сохраняя результаты вычислений для повторного использования.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация ускоряет работу рекурсивных алгоритмов за счёт уменьшения объёма памяти, необходимого для их выполнения, сохраняя промежуточные результаты в специальном буфере.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация используется для улучшения читаемости кода и упрощения структуры рекурсивных алгоритмов, хотя и не всегда приводит к ускорению их выполнения.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация замедляет рекурсивные алгоритмы из-за необходимости сохранять все промежуточные результаты вычислений.\",\"generated_as_correct\":false}],\"question\":\"Почему мемоизация эффективна для оптимизации рекурсивных алгоритмов?\"},{\"answers\":[{\"text\":\"Мемоизация ускоряет решение задачи о рюкзаке за счёт сохранения и повторного использования результатов вычислений.\",\"generated_as_correct\":true},{\"text\":\"Мемоизация используется для решения задачи о рюкзаке путём случайного выбора и сохранения некоторых результатов вычислений, что может иногда ускорить алгоритм, но не гарантирует значительного улучшения производительности.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация помогает оптимизировать алгоритмы сортировки, сохраняя промежуточные результаты и используя их для последующих операций сравнения.\",\"generated_as_correct\":false},{\"text\":\"Мемоизация усложняет решение задачи о рюкзаке из-за необходимости дополнительного хранения всех возможных комбинаций предметов.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить мемоизацию для ускорения решения задачи о рюкзаке?\"}],\"StoreCardId\":null,\"numberInCourse\":\"8.6\"},{\"Name\":\"algo | 8.7. Задача «Сувениры»\",\"Slug\":\"zadacha-suveniry\",\"createdAt\":\"2024-07-03T17:27:08.130Z\",\"updatedAt\":\"2026-01-10T12:07:09.664Z\",\"publishedAt\":\"2024-07-03T17:27:09.819Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80782/problem\",\"Lead\":null,\"Content\":\"$84\",\"Title\":\"Задача «Сувениры»\",\"LikesCount\":16,\"Quiz\":[{\"answers\":[{\"text\":\"Задача о разделении добычи пиратов — это определение возможности разделить \\\\( n \\\\) предметов на три поднабора с одинаковой суммой ценностей.\",\"generated_as_correct\":true},{\"text\":\"Задача о разделении добычи пиратов заключается в поиске оптимального способа распределения предметов между пиратами, чтобы максимизировать общую ценность для каждого из них.\",\"generated_as_correct\":false},{\"text\":\"Задача о разделении добычи пиратов связана с анализом стратегий поведения в условиях неопределённости и риска, когда пираты должны принять решение о распределении ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Задача о разделении добычи пиратов заключается в равномерном распределении одинакового количества предметов между тремя пиратами.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается задача о разделении добычи пиратов?\"},{\"answers\":[{\"text\":\"Общая сумма ценностей предметов должна быть кратна трём, и возможно распределение предметов на три поднабора с равной суммой.\",\"generated_as_correct\":true},{\"text\":\"Чтобы предметы можно было разделить на три поднабора с одинаковыми суммами, достаточно, чтобы количество предметов было кратно трём, независимо от их ценности.\",\"generated_as_correct\":false},{\"text\":\"Чтобы предметы можно было разделить на три поднабора с одинаковыми суммами, нужно использовать метод полного перебора всех возможных комбинаций предметов, что является одним из подходов в теории графов.\",\"generated_as_correct\":false},{\"text\":\"Сумма ценностей предметов должна быть чётной, чтобы их можно было разделить на три поднабора с одинаковыми суммами.\",\"generated_as_correct\":false}],\"question\":\"Какие условия должны быть выполнены, чтобы предметы можно было разделить на три поднабора с одинаковыми суммами?\"},{\"answers\":[{\"text\":\"Задача о разделении добычи пиратов помогает определить, можно ли разделить предметы разной ценности на три равные по сумме поднабора, что применимо для справедливого распределения ресурсов.\",\"generated_as_correct\":true},{\"text\":\"Задача о разделении добычи пиратов предполагает, что предметы разделяются между пиратами случайным образом, без учёта их ценности, что приводит к неравномерному распределению ресурсов между участниками.\",\"generated_as_correct\":false},{\"text\":\"Задача о разделении добычи пиратов используется для разработки алгоритмов шифрования и защиты данных, что не имеет прямого отношения к распределению ресурсов в практических задачах.\",\"generated_as_correct\":false},{\"text\":\"Задача о разделении добычи пиратов позволяет определить, как объединить все предметы в одну общую кучу для последующего случайного распределения между участниками.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить задачу о разделении добычи пиратов для решения практических задач по распределению ресурсов?\"},{\"answers\":[{\"text\":\"$$\\\\operatorname{sum}(i)$ — это сумма ценностей первых $i$ предметов.\",\"generated_as_correct\":true},{\"text\":\"Функция $\\\\operatorname{sum}(i)$ обозначает количество предметов в наборе, где $i$ — это индекс последнего предмета.\",\"generated_as_correct\":false},{\"text\":\"Функция $\\\\operatorname{sum}(i)$ используется для определения максимального значения среди первых $i$ элементов массива.\",\"generated_as_correct\":false},{\"text\":\"$$\\\\operatorname{sum}(i)$ — это среднее значение первых $i$ предметов.\",\"generated_as_correct\":false}],\"question\":\"Что обозначает функция \\\\( \\\\operatorname{sum}(i) \\\\)?\"},{\"answers\":[{\"text\":\"Функция \\\\( \\\\operatorname{sum}(i) \\\\) вычисляет сумму ценностей первых \\\\( i \\\\) предметов для проверки делимости на три при разделении добычи.\",\"generated_as_correct\":true},{\"text\":\"Функция \\\\( \\\\operatorname{sum}(i) \\\\) служит для определения максимальной ценности среди первых \\\\( i \\\\) предметов в наборе, что используется для проверки возможности разделения добычи на три равные части.\",\"generated_as_correct\":false},{\"text\":\"Функция \\\\( \\\\operatorname{sum}(i) \\\\) используется в алгоритмах сортировки для определения порядка предметов по их ценности.\",\"generated_as_correct\":false},{\"text\":\"Функция \\\\( \\\\operatorname{sum}(i) \\\\) определяет количество предметов в наборе для разделения добычи.\",\"generated_as_correct\":false}],\"question\":\"Для чего используется функция \\\\( \\\\operatorname{sum}(i) \\\\) в контексте разделения добычи?\"},{\"answers\":[{\"text\":\"Функция $\\\\operatorname{sum}(i)$ помогает вычислить общую ценность предметов и проверить, делится ли она на три.\",\"generated_as_correct\":true},{\"text\":\"Функция $\\\\operatorname{sum}(i)$ позволяет вычислить общую сумму ценностей всех предметов, и если эта сумма чётная, то добычу можно разделить на три равные части.\",\"generated_as_correct\":false},{\"text\":\"Функция $\\\\operatorname{sum}(i)$ используется для подсчёта количества предметов в наборе и не имеет отношения к разделению добычи на равные части.\",\"generated_as_correct\":false},{\"text\":\"Функция $\\\\operatorname{sum}(i)$ нужна для вычисления суммы квадратов ценностей предметов, чтобы проверить возможность их разделения на три равные части.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить функцию \\\\( \\\\operatorname{sum}(i) \\\\) для проверки возможности разделения добычи на три равные части?\"},{\"answers\":[{\"text\":\"Общая ценность предметов должна делиться на три без остатка.\",\"generated_as_correct\":true},{\"text\":\"Чтобы разделить набор из \\\\( n \\\\) предметов на три части с одинаковыми суммами, достаточно, чтобы количество предметов \\\\( n \\\\) было кратно трём.\",\"generated_as_correct\":false},{\"text\":\"Чтобы разделить набор из \\\\( n \\\\) предметов на три части, нужно убедиться, что каждый предмет имеет одинаковую ценность, независимо от общей суммы.\",\"generated_as_correct\":false},{\"text\":\"Количество предметов \\\\( n \\\\) должно быть кратно трём.\",\"generated_as_correct\":false}],\"question\":\"Какое условие должно выполняться, чтобы можно было разделить набор из \\\\( n \\\\) предметов на три части с одинаковыми суммами?\"},{\"answers\":[{\"text\":\"Разделить предметы на три поднабора с одинаковыми суммами нельзя, если их общая ценность не делится на три.\",\"generated_as_correct\":true},{\"text\":\"Разделить набор предметов на три поднабора с одинаковыми суммами невозможно из-за того, что количество предметов в наборе не кратно трём, независимо от их общей ценности.\",\"generated_as_correct\":false},{\"text\":\"Разделить набор предметов на три поднабора невозможно из-за ограничений, связанных с их физическими размерами или формой, а не из-за общей ценности предметов.\",\"generated_as_correct\":false},{\"text\":\"Разделить предметы на три поднабора с одинаковыми суммами нельзя, если количество предметов не кратно трём.\",\"generated_as_correct\":false}],\"question\":\"Почему разделение предметов на три поднабора с одинаковыми суммами невозможно, если общая ценность предметов не делится на три?\"},{\"answers\":[{\"text\":\"Проверить, делится ли общая ценность предметов на три без остатка.\",\"generated_as_correct\":true},{\"text\":\"Чтобы разделить набор предметов на три равные части, достаточно, чтобы количество предметов в наборе было кратно трём, независимо от их общей ценности.\",\"generated_as_correct\":false},{\"text\":\"Для разделения набора предметов на три части можно использовать метод сортировки по возрастанию или убыванию их ценности, что позволит визуально оценить возможность равномерного распределения.\",\"generated_as_correct\":false},{\"text\":\"Убедиться, что количество предметов кратно трём.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать данное условие для определения возможности разделения набора предметов на три равные части в практических задачах?\"},{\"answers\":[{\"text\":\"\\\\( split(i, s_1, s_2) \\\\) проверяет, можно ли разделить первые \\\\( i \\\\) предметов на две части с суммами \\\\( s_1 \\\\) и \\\\( s_2 \\\\).\",\"generated_as_correct\":true},{\"text\":\"Функция \\\\( split(i, s_1, s_2) \\\\) — это функция, которая определяет, можно ли разделить предметы на три части с суммами \\\\( s_1 \\\\), \\\\( s_2 \\\\) и \\\\( s_3 \\\\), где \\\\( s_3 \\\\) — оставшаяся сумма.\",\"generated_as_correct\":false},{\"text\":\"Функция \\\\( split(i, s_1, s_2) \\\\) используется для сортировки элементов массива по возрастанию и убыванию, где \\\\( i \\\\) — количество элементов, \\\\( s_1 \\\\) и \\\\( s_2 \\\\) — индексы для разделения массива.\",\"generated_as_correct\":false},{\"text\":\"\\\\( split(i, s_1, s_2) \\\\) определяет, можно ли объединить первые \\\\( i \\\\) предметов в одну группу с общей суммой \\\\( s_1 \\\\times s_2 \\\\).\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой функция \\\\( split(i, s_1, s_2) \\\\)?\"},{\"answers\":[{\"text\":\"Функция \\\\( split(i, s_1, s_2) \\\\) проверяет, можно ли разделить первые \\\\( i \\\\) предметов на две части с заданными суммами \\\\( s_1 \\\\) и \\\\( s_2 \\\\).\",\"generated_as_correct\":true},{\"text\":\"Функция \\\\( split(i, s_1, s_2) \\\\) используется для определения общего количества предметов, которые можно разделить между двумя участниками, не учитывая их суммарную стоимость.\",\"generated_as_correct\":false},{\"text\":\"Функция \\\\( split(i, s_1, s_2) \\\\) применяется для сортировки предметов по их стоимости перед разделением добычи, что помогает упростить процесс распределения.\",\"generated_as_correct\":false},{\"text\":\"Функция \\\\( split(i, s_1, s_2) \\\\) определяет, сколько предметов можно разделить между двумя участниками без учёта их стоимости.\",\"generated_as_correct\":false}],\"question\":\"Каким образом функция \\\\( split(i, s_1, s_2) \\\\) помогает в решении задачи о разделении добычи?\"},{\"answers\":[{\"text\":\"\\\\( split(i, s_1, s_2) \\\\) равна true, если первые \\\\( i \\\\) предметов делятся на части с суммами \\\\( s_1 \\\\) и \\\\( s_2 \\\\).\",\"generated_as_correct\":true},{\"text\":\"Функция \\\\( split(i, s_1, s_2) \\\\) принимает значение true, если сумма всех \\\\( i \\\\) предметов равна \\\\( s_1 + s_2 \\\\), независимо от их распределения по частям.\",\"generated_as_correct\":false},{\"text\":\"Функция \\\\( split(i, s_1, s_2) \\\\) используется для определения количества предметов, которые можно разделить между двумя участниками, не учитывая их суммарную стоимость.\",\"generated_as_correct\":false},{\"text\":\"\\\\( split(i, s_1, s_2) \\\\) равна true, если сумма всех предметов равна \\\\( i \\\\).\",\"generated_as_correct\":false}],\"question\":\"В каком случае функция \\\\( split(i, s_1, s_2) \\\\) принимает значение true?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение для \\\\( split(i, s_1, s_2) \\\\) использует предыдущие значения \\\\( split(i-1, \\\\cdot, \\\\cdot) \\\\) для вычисления текущего.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для функции \\\\( split(i, s_1, s_2) \\\\) основывается на вычислении среднего арифметического значений \\\\( s_1 \\\\) и \\\\( s_2 \\\\) для всех предыдущих шагов \\\\( i \\\\).\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для функции \\\\( split(i, s_1, s_2) \\\\) связано с определением максимального значения среди всех возможных комбинаций \\\\( s_1 \\\\) и \\\\( s_2 \\\\) без учёта предыдущих шагов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для \\\\( split(i, s_1, s_2) \\\\) вычисляется через сумму \\\\( s_1 \\\\) и \\\\( s_2 \\\\) на текущем шаге \\\\( i \\\\).\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой рекуррентное соотношение для функции \\\\( split(i, s_1, s_2) \\\\)?\"},{\"answers\":[{\"text\":\"Вычисление \\\\( split(i, s_1, s_2) \\\\) требует рассмотрения предыдущих значений \\\\( split(i-1, s_1-v_i, s_2) \\\\), \\\\( split(i-1, s_1, s_2-v_i) \\\\), \\\\( split(i-1, s_1, s_2) \\\\) для применения рекуррентного соотношения.\",\"generated_as_correct\":true},{\"text\":\"Для вычисления \\\\( split(i, s_1, s_2) \\\\) достаточно рассмотреть значение \\\\( split(i-1, s_1, s_2) \\\\), так как остальные комбинации не влияют на результат функции.\",\"generated_as_correct\":false},{\"text\":\"Для вычисления \\\\( split(i, s_1, s_2) \\\\) важно учитывать начальные условия задачи и применять методы динамического программирования, но конкретные предыдущие значения функции не имеют значения.\",\"generated_as_correct\":false},{\"text\":\"Вычисление \\\\( split(i, s_1, s_2) \\\\) основывается на значениях \\\\( split(i, s_1-v_i, s_2) \\\\), \\\\( split(i, s_1, s_2-v_i) \\\\), \\\\( split(i, s_1, s_2) \\\\).\",\"generated_as_correct\":false}],\"question\":\"Почему для вычисления \\\\( split(i, s_1, s_2) \\\\) необходимо рассматривать значения \\\\( split(i-1, s_1-v_i, s_2) \\\\), \\\\( split(i-1, s_1, s_2-v_i) \\\\) и \\\\( split(i-1, s_1, s_2) \\\\)?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение для \\\\( split \\\\) позволяет вычислять текущие значения функции на основе предыдущих.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение для функции \\\\( split \\\\) используется для определения максимального значения среди всех возможных комбинаций параметров \\\\( s_1 \\\\) и \\\\( s_2 \\\\) без учёта предыдущих шагов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение применяется для анализа временных рядов и прогнозирования будущих значений на основе исторических данных, что не имеет отношения к функции \\\\( split \\\\).\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение для \\\\( split \\\\) вычисляется путём сложения всех возможных значений параметров \\\\( s_1 \\\\) и \\\\( s_2 \\\\).\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентное соотношение для решения задачи с использованием функции \\\\( split \\\\)?\"},{\"answers\":[{\"text\":\"Базовый случай для рекуррентного соотношения устанавливает, что при \\\\( i = 0 \\\\) разделение возможно только если \\\\( s_1 = 0 \\\\) и \\\\( s_2 = 0 \\\\).\",\"generated_as_correct\":true},{\"text\":\"Базовый случай для рекуррентного соотношения определяет, что при отсутствии предметов (\\\\( i = 0 \\\\)) разделение возможно в любом случае, независимо от значений сумм \\\\( s_1 \\\\) и \\\\( s_2 \\\\).\",\"generated_as_correct\":false},{\"text\":\"Базовый случай для рекуррентного соотношения связан с определением начальных условий для алгоритмов сортировки и не имеет отношения к разделению предметов.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай для рекуррентного соотношения утверждает, что при \\\\( i = 0 \\\\) разделение возможно независимо от значений \\\\( s_1 \\\\) и \\\\( s_2 \\\\).\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой базовый случай для рекуррентного соотношения в контексте разделения предметов?\"},{\"answers\":[{\"text\":\"Базовый случай определяет, что при отсутствии предметов разделение возможно только если все суммы равны нулю.\",\"generated_as_correct\":true},{\"text\":\"Базовый случай для рекуррентного соотношения определяет, что при отсутствии предметов разделение возможно в любом случае, независимо от значений сумм.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай для рекуррентного соотношения связан с определением начальных условий для итеративного процесса, который не зависит от значений сумм при отсутствии предметов.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай утверждает, что при отсутствии предметов разделение возможно независимо от значений сумм.\",\"generated_as_correct\":false}],\"question\":\"Почему базовый случай определяет, что при отсутствии предметов разделение возможно только в случае, если все суммы равны нулю?\"},{\"answers\":[{\"text\":\"Базовый случай устанавливает, что при i = 0 разделение возможно только если все суммы равны нулю.\",\"generated_as_correct\":true},{\"text\":\"Базовый случай для рекуррентного соотношения задаёт начальные условия, согласно которым при отсутствии предметов (i = 0) разделение возможно в любом случае, независимо от значений сумм s_1 и s_2.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай для рекуррентного соотношения используется для определения условий выхода из рекурсии и не влияет на начальные условия алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Базовый случай определяет, что при i = 0 разделение возможно независимо от значений сумм.\",\"generated_as_correct\":false}],\"question\":\"Как базовый случай для рекуррентного соотношения может быть применён для определения начальных условий в рекурсивном алгоритме?\"}],\"StoreCardId\":null,\"numberInCourse\":\"8.7\"},{\"Name\":\"algo | 8.8. Задача «Расставить скобки»\",\"Slug\":\"zadacha-rasstavit-skobki\",\"createdAt\":\"2024-07-03T17:28:01.937Z\",\"updatedAt\":\"2026-01-10T12:07:09.122Z\",\"publishedAt\":\"2024-07-03T17:28:03.545Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80783/problem\",\"Lead\":null,\"Content\":\"$85\",\"Title\":\"Задача «Расставить скобки»\",\"LikesCount\":24,\"Quiz\":[{\"answers\":[{\"text\":\"Порядок выполнения операций: сначала умножение и деление, потом сложение и вычитание; скобки меняют порядок.\",\"generated_as_correct\":true},{\"text\":\"Порядок выполнения арифметических операций зависит от количества чисел в выражении: чем больше чисел, тем раньше выполняются операции сложения и вычитания.\",\"generated_as_correct\":false},{\"text\":\"Порядок выполнения арифметических операций связан с теорией чисел и определяет свойства чисел в выражении.\",\"generated_as_correct\":false},{\"text\":\"Порядок выполнения операций определяется слева направо, независимо от типа операции.\",\"generated_as_correct\":false}],\"question\":\"Что определяет порядок выполнения арифметических операций в математическом выражении?\"},{\"answers\":[{\"text\":\"Порядок выполнения операций влияет на результат математических выражений.\",\"generated_as_correct\":true},{\"text\":\"Порядок выполнения операций важен только для сложных выражений с большим количеством переменных, в простых случаях он не влияет на результат.\",\"generated_as_correct\":false},{\"text\":\"Порядок выполнения операций важен для программирования, так как он определяет последовательность выполнения команд в алгоритмах.\",\"generated_as_correct\":false},{\"text\":\"Порядок выполнения операций не важен, результат выражения всегда будет одинаковым.\",\"generated_as_correct\":false}],\"question\":\"Почему важно учитывать порядок выполнения операций при вычислении математических выражений?\"},{\"answers\":[{\"text\":\"Скобки меняют порядок выполнения операций в арифметическом выражении, влияя на результат.\",\"generated_as_correct\":true},{\"text\":\"Скобки в арифметическом выражении используются исключительно для визуального разделения частей выражения и не влияют на порядок выполнения операций или конечный результат.\",\"generated_as_correct\":false},{\"text\":\"Скобки в арифметических выражениях играют важную роль в теории множеств, помогая определить границы между различными элементами множества.\",\"generated_as_correct\":false},{\"text\":\"Скобки не влияют на порядок выполнения операций, но изменяют приоритет сложения и вычитания.\",\"generated_as_correct\":false}],\"question\":\"Как использование скобок может изменить результат арифметического выражения?\"},{\"answers\":[{\"text\":\"Подвыражение — это вычислимая часть арифметического выражения с минимальным и максимальным значением.\",\"generated_as_correct\":true},{\"text\":\"Подвыражение — это любая группа символов в арифметическом выражении, которая включает хотя бы один оператор и может быть интерпретирована как отдельное выражение, независимо от возможности её вычисления.\",\"generated_as_correct\":false},{\"text\":\"Подвыражение — это термин, используемый в программировании для обозначения частей кода, которые могут быть оптимизированы для повышения производительности.\",\"generated_as_correct\":false},{\"text\":\"Подвыражение — это произвольная часть арифметического выражения без возможности отдельного вычисления.\",\"generated_as_correct\":false}],\"question\":\"Что такое подвыражение в контексте арифметических выражений?\"},{\"answers\":[{\"text\":\"Анализ подвыражений позволяет определить их минимальное и максимальное значения, что помогает оптимизировать вычисления.\",\"generated_as_correct\":true},{\"text\":\"Анализ подвыражений важен для определения их средних значений, что помогает упростить вычисление всего выражения, но не влияет на расстановку скобок.\",\"generated_as_correct\":false},{\"text\":\"Анализ подвыражений важен для понимания структуры выражения, что может быть полезно при разработке алгоритмов машинного обучения.\",\"generated_as_correct\":false},{\"text\":\"Анализ подвыражений необходим для определения их количества в арифметическом выражении.\",\"generated_as_correct\":false}],\"question\":\"Почему важно анализировать подвыражения при вычислении арифметического выражения?\"},{\"answers\":[{\"text\":\"Знание границ значений подвыражений помогает определить оптимальную расстановку скобок.\",\"generated_as_correct\":true},{\"text\":\"Знание минимального и максимального значения подвыражения помогает только в определении порядка выполнения операций, но не влияет на расстановку скобок.\",\"generated_as_correct\":false},{\"text\":\"Знание минимального и максимального значения подвыражения используется для определения приоритета операций в выражении, что не связано с расстановкой скобок.\",\"generated_as_correct\":false},{\"text\":\"Минимальное и максимальное значения подвыражений не влияют на расстановку скобок в выражении.\",\"generated_as_correct\":false}],\"question\":\"Как знание минимального и максимального значения подвыражения может помочь в определении оптимальных способов расстановки скобок?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение определяет значение функции через её предыдущие значения.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение — это формула, которая определяет значение функции через случайные значения, выбранные из заданного диапазона.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение используется в теории вероятностей для определения вероятности наступления событий на основе предыдущих исходов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение определяет значение функции через её производную.\",\"generated_as_correct\":false}],\"question\":\"Что такое рекуррентное соотношение?\"},{\"answers\":[{\"text\":\"Рекуррентные соотношения позволяют вычислять минимумы и максимумы подвыражений через предыдущие значения функции.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентные соотношения помогают вычислять минимальные и максимальные значения подвыражений за счёт использования сложных интегральных преобразований, которые учитывают все возможные вариации значений.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения важны для анализа динамических систем и прогнозирования поведения функций в различных условиях, но не имеют прямого отношения к вычислению минимальных и максимальных значений подвыражений.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения используются для вычисления средних значений подвыражений, а не минимальных и максимальных.\",\"generated_as_correct\":false}],\"question\":\"Почему рекуррентные соотношения полезны для вычисления минимальных и максимальных значений подвыражений?\"},{\"answers\":[{\"text\":\"Рекуррентные соотношения помогают вычислять оптимальные значения через предыдущие результаты.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентные соотношения применяются для прямого вычисления всех возможных значений функции без учёта предыдущих результатов, что помогает в поиске оптимальных решений.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения тесно связаны с теорией вероятностей и используются для анализа статистических данных, что может быть полезно при оценке оптимальных решений задачи.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения используются для нахождения средних значений функции, что помогает определить оптимальные решения задачи.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентные соотношения для нахождения оптимальных решений задачи?\"},{\"answers\":[{\"text\":\"Рекурсивный алгоритм — это алгоритм, который решает подзадачи путём вызова самого себя.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивный алгоритм — это алгоритм, который выполняет операции в случайном порядке, не вызывая себя, и применяется исключительно для сортировки данных.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм — это метод, используемый в теории графов для поиска кратчайшего пути между двумя вершинами.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивный алгоритм — это алгоритм, который требует внешнего ввода данных для решения каждой подзадачи.\",\"generated_as_correct\":false}],\"question\":\"Что такое рекурсивный алгоритм?\"},{\"answers\":[{\"text\":\"Рекурсивные алгоритмы подходят для вычисления значений функций, определённых рекуррентными соотношениями, так как могут вызывать себя для решения подзадач.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивные алгоритмы подходят для вычисления значений функций, определённых рекуррентными соотношениями, поскольку они используют итеративный подход, который позволяет им вычислять значения без вызова самих себя.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивные алгоритмы применяются в теории графов для поиска путей и не имеют отношения к вычислению значений функций, определённых рекуррентными соотношениями.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивные алгоритмы не подходят для вычисления значений функций, определённых рекуррентными соотношениями, так как требуют большого объёма памяти для хранения промежуточных результатов.\",\"generated_as_correct\":false}],\"question\":\"Почему рекурсивные алгоритмы подходят для вычисления значений функций, определённых рекуррентными соотношениями?\"},{\"answers\":[{\"text\":\"Преобразование рекурсивного алгоритма в итерационный повышает эффективность за счёт сокращения вызовов функций и оптимизации использования памяти.\",\"generated_as_correct\":true},{\"text\":\"Преобразование рекурсивного алгоритма в итерационный не влияет на эффективность, так как оба типа алгоритмов используют одинаковое количество ресурсов и имеют одинаковую скорость выполнения.\",\"generated_as_correct\":false},{\"text\":\"Преобразование рекурсивного алгоритма в итерационный используется для улучшения читаемости кода и упрощения его структуры, что облегчает процесс отладки и внесения изменений.\",\"generated_as_correct\":false},{\"text\":\"Преобразование рекурсивного алгоритма в итерационный снижает эффективность из-за усложнения структуры кода и увеличения времени выполнения.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать преобразование рекурсивного алгоритма в итерационный для повышения его эффективности?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм — это алгоритм, выполняющий вычисления путём повторения определённых действий.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм — это алгоритм, который использует случайные значения для выполнения вычислений и не требует повторения действий для достижения результата.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм — это метод, который применяется в теории графов для определения кратчайших путей между узлами в сети.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм — это алгоритм, который выполняет вычисления только один раз и не использует повторения.\",\"generated_as_correct\":false}],\"question\":\"Что такое итерационный алгоритм?\"},{\"answers\":[{\"text\":\"Итерационные алгоритмы эффективнее рекурсивных при больших объёмах данных из-за меньшего количества вызовов функций.\",\"generated_as_correct\":true},{\"text\":\"Итерационные алгоритмы более эффективны, потому что они используют меньше переменных и проще в реализации, что делает их идеальными для работы с данными любого объёма, независимо от сложности вычислений.\",\"generated_as_correct\":false},{\"text\":\"Итерационные алгоритмы могут быть более эффективными, поскольку они лучше подходят для параллельных вычислений и распределённых систем, что не имеет прямого отношения к объёму данных.\",\"generated_as_correct\":false},{\"text\":\"Итерационные алгоритмы более эффективны из-за их способности обрабатывать данные в случайном порядке, что ускоряет доступ к информации.\",\"generated_as_correct\":false}],\"question\":\"Почему итерационные алгоритмы могут быть более эффективными, чем рекурсивные, при работе с большими объёмами данных?\"},{\"answers\":[{\"text\":\"Итерационный алгоритм применяется для вычисления значений функций при необходимости повторных вычислений, особенно эффективен с большими объёмами данных.\",\"generated_as_correct\":true},{\"text\":\"Итерационный алгоритм используется для вычисления значений функций только в случаях, когда данные имеют строго определённую структуру и небольшое количество элементов.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм применяется в ситуациях, когда требуется провести анализ данных с использованием методов машинного обучения, не связанных с вычислением значений функций.\",\"generated_as_correct\":false},{\"text\":\"Итерационный алгоритм применим для вычисления значений функций только при наличии рекурсивной структуры данных.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях можно применить итерационный алгоритм для вычисления значений функций?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма — это время, нужное алгоритму для завершения вычислений.\",\"generated_as_correct\":true},{\"text\":\"Время выполнения алгоритма — это общее время, затраченное на разработку алгоритма, включая время на его проектирование, кодирование и тестирование.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма связано с количеством памяти, которое алгоритм использует во время своей работы, и не имеет прямого отношения ко времени.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма — это время, за которое программист пишет код алгоритма.\",\"generated_as_correct\":false}],\"question\":\"Что такое время выполнения алгоритма?\"},{\"answers\":[{\"text\":\"Оценка времени выполнения алгоритма позволяет определить его эффективность и применимость в реальных задачах.\",\"generated_as_correct\":true},{\"text\":\"Оценка времени выполнения алгоритма важна только для теоретических исследований и не имеет практического значения при реализации программных решений.\",\"generated_as_correct\":false},{\"text\":\"Оценка времени выполнения алгоритма важна для понимания его сложности в контексте теории графов и анализа сетевых структур.\",\"generated_as_correct\":false},{\"text\":\"Оценка времени выполнения алгоритма важна только для сравнения его с другими алгоритмами, но не влияет на его практическое применение.\",\"generated_as_correct\":false}],\"question\":\"Почему оценка времени выполнения алгоритма важна для его практического применения?\"},{\"answers\":[{\"text\":\"Кубическая сложность $O(n^3)$ приводит к значительному увеличению времени выполнения алгоритма при росте размера входных данных.\",\"generated_as_correct\":true},{\"text\":\"Кубическая сложность алгоритма $O(n^3)$ указывает на то, что время выполнения алгоритма увеличивается линейно с ростом размера входных данных, что не оказывает значительного влияния на его эффективность.\",\"generated_as_correct\":false},{\"text\":\"Кубическая сложность алгоритма $O(n^3)$ связана с количеством операций, необходимых для сортировки данных, и не влияет на время выполнения алгоритма при увеличении размера входных данных.\",\"generated_as_correct\":false},{\"text\":\"Кубическая сложность $O(n^3)$ не оказывает существенного влияния на время выполнения алгоритма при увеличении размера входных данных.\",\"generated_as_correct\":false}],\"question\":\"Как кубическая сложность алгоритма $O(n^3)$ влияет на его эффективность при увеличении размера входных данных?\"}],\"StoreCardId\":null,\"numberInCourse\":\"8.8\"},{\"Name\":\"algo | 8.9 Чему вы научились\",\"Slug\":\"chemu-vi-nauchilis-eight\",\"createdAt\":\"2024-07-03T17:28:01.937Z\",\"updatedAt\":\"2025-09-11T20:11:26.532Z\",\"publishedAt\":\"2025-09-09T09:36:35.133Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"В этой главе вы познакомились с основами динамического программирования — одного из самых мощных приёмов в алгоритмике. Вы поняли, как разбивать сложные задачи на подзадачи, хранить уже найденные решения и использовать их повторно. А главное — научились видеть в задачах структуру, подходящую под динамику.\\n\\nТеперь вы умеете:\\n\\n* замечать подзадачи и формулировать рекуррентные соотношения;\\n* строить таблицы значений (в одну или несколько строк или столбцов) и переходов между ними;\\n* оптимизировать память и избегать повторных вычислений;\\n* решать задачи разными способами: с мемоизацией, итерацией, через восстановление ответа;\\n* применять динамическое программирование в практических задачах — от редактирования строк и поиска LCS до рюкзака и оптимального размещения скобок.\\n\\nВ следующей главе вы познакомитесь с другой идеей — «Разделяй и властвуй». Эта стратегия открывает путь к более эффективным алгоритмам для сортировки, поиска и анализа данных.\",\"Title\":\"Чему вы научились\",\"LikesCount\":38,\"Quiz\":null,\"StoreCardId\":null,\"numberInCourse\":\"8.9\"}]},{\"id\":34,\"Name\":\"9. Разделяй и властвуй\",\"Articles\":[{\"Name\":\"algo | 9.1. Двоичный поиск\",\"Slug\":\"dvoichnyj-poisk\",\"createdAt\":\"2024-07-03T08:47:11.225Z\",\"updatedAt\":\"2026-01-10T12:07:07.254Z\",\"publishedAt\":\"2024-07-03T08:47:12.468Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80772/problem\",\"Lead\":null,\"Content\":\"$86\",\"Title\":\"Двоичный поиск\",\"LikesCount\":22,\"Quiz\":[{\"answers\":[{\"text\":\"Стратегия «разделяй и властвуй» — это метод разделения задачи на подзадачи, их рекурсивного решения и объединения результатов.\",\"generated_as_correct\":true},{\"text\":\"Стратегия «разделяй и властвуй» заключается в последовательном решении задачи шаг за шагом, без разделения на подзадачи, что позволяет упростить процесс и ускорить его выполнение.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» используется в теории игр для анализа стратегий игроков и прогнозирования их действий на основе разделения возможных сценариев на более простые случаи.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» — это подход, при котором задача решается путём случайного выбора подзадач и их последовательного решения без объединения результатов.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой стратегия «разделяй и властвуй»?\"},{\"answers\":[{\"text\":\"Стратегия «разделяй и властвуй» эффективна, так как разбивает сложные задачи на более простые подзадачи, ускоряя их решение.\",\"generated_as_correct\":true},{\"text\":\"Стратегия «разделяй и властвуй» эффективна, потому что она позволяет сразу найти оптимальное решение для всей задачи без необходимости разбиения её на подзадачи.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» используется в основном в военных и политических целях для ослабления противника, а её эффективность в решении сложных задач не доказана.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» эффективна, потому что позволяет решать задачи путём простого перебора всех возможных вариантов.\",\"generated_as_correct\":false}],\"question\":\"Почему стратегия «разделяй и властвуй» считается эффективным подходом к решению сложных задач?\"},{\"answers\":[{\"text\":\"Стратегия «разделяй и властвуй» — это метод решения сложных задач путём их разделения на более простые подзадачи и последующего объединения решений.\",\"generated_as_correct\":true},{\"text\":\"Стратегия «разделяй и властвуй» подразумевает разделение задачи на несколько независимых частей, которые решаются параллельно, но их решения не объединяются в единое целое, а рассматриваются отдельно.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» используется в основном в военных и политических целях для ослабления противника путём разделения его на части и изолирования их друг от друга.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» заключается в том, чтобы игнорировать часть условий задачи и сосредоточиться на её наиболее простых аспектах.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить стратегию «разделяй и властвуй» для решения задачи, которая кажется сложной и запутанной?\"},{\"answers\":[{\"text\":\"Бинарный поиск — метод поиска в отсортированном массиве путём деления области поиска пополам.\",\"generated_as_correct\":true},{\"text\":\"Бинарный поиск — это алгоритм, который используется для сортировки элементов в массиве путём их последовательного сравнения и перестановки.\",\"generated_as_correct\":false},{\"text\":\"Бинарный поиск — это техника, используемая в криптографии для шифрования данных, основанная на принципе деления информации на биты.\",\"generated_as_correct\":false},{\"text\":\"Бинарный поиск — метод поиска, который эффективен только для небольших и не отсортированных массивов данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое бинарный (двоичный) поиск?\"},{\"answers\":[{\"text\":\"Бинарный поиск эффективнее линейного для больших отсортированных наборов данных из-за его временной сложности O(log n).\",\"generated_as_correct\":true},{\"text\":\"Бинарный поиск более эффективен, чем линейный, потому что он проходит по всем элементам массива, проверяя каждый из них, что позволяет быстрее найти нужный элемент в больших наборах данных.\",\"generated_as_correct\":false},{\"text\":\"Бинарный поиск эффективен для больших наборов данных, поскольку он минимизирует количество операций записи в память, что особенно важно для систем с ограниченной пропускной способностью памяти.\",\"generated_as_correct\":false},{\"text\":\"Бинарный поиск эффективнее линейного, потому что он всегда находит элемент с первой попытки.\",\"generated_as_correct\":false}],\"question\":\"Почему бинарный поиск считается более эффективным, чем линейный поиск, для больших отсортированных наборов данных?\"},{\"answers\":[{\"text\":\"Бинарный поиск делит отсортированный массив пополам, исключая половину элементов на каждом шаге, и имеет сложность O(log n).\",\"generated_as_correct\":true},{\"text\":\"Бинарный поиск ускоряет поиск элемента в отсортированном массиве за счёт последовательного сравнения искомого элемента с каждым элементом массива, начиная с середины.\",\"generated_as_correct\":false},{\"text\":\"Бинарный поиск — это метод, который используется для сортировки массивов путём сравнения элементов и их перестановки в определённом порядке.\",\"generated_as_correct\":false},{\"text\":\"Бинарный поиск применяется для поиска элемента в любом массиве, независимо от его сортировки, и работает за линейное время.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить бинарный поиск для ускорения поиска элемента в отсортированном массиве?\"},{\"answers\":[{\"text\":\"Линейный поиск проверяет каждый элемент последовательности по очереди.\",\"generated_as_correct\":true},{\"text\":\"Линейный поиск — это метод поиска, который использует двоичное деление последовательности для быстрого нахождения искомого элемента.\",\"generated_as_correct\":false},{\"text\":\"Линейный поиск — это алгоритм, используемый для сортировки элементов в последовательности по возрастанию или убыванию.\",\"generated_as_correct\":false},{\"text\":\"Линейный поиск делит последовательность пополам для поиска элемента.\",\"generated_as_correct\":false}],\"question\":\"Что такое линейный поиск?\"},{\"answers\":[{\"text\":\"Линейный поиск имеет сложность O(n) и проверяет каждый элемент, что делает его менее эффективным для больших данных по сравнению с бинарным поиском.\",\"generated_as_correct\":true},{\"text\":\"Линейный поиск менее эффективен, потому что он требует предварительной сортировки данных, что занимает дополнительное время, в то время как бинарный поиск не требует сортировки.\",\"generated_as_correct\":false},{\"text\":\"Линейный поиск менее эффективен из-за ограничений, связанных с объёмом оперативной памяти, в то время как бинарный поиск оптимизирован для работы с большими объёмами данных на жёстком диске.\",\"generated_as_correct\":false},{\"text\":\"Линейный поиск более эффективен для больших наборов данных, так как не требует сортировки данных перед поиском.\",\"generated_as_correct\":false}],\"question\":\"Почему линейный поиск считается менее эффективным для больших наборов данных по сравнению с бинарным поиском?\"},{\"answers\":[{\"text\":\"Линейный поиск подходит для небольших наборов данных или когда данные не отсортированы.\",\"generated_as_correct\":true},{\"text\":\"Линейный поиск наиболее эффективен для работы с данными, которые организованы в виде сложных структур, таких как деревья или графы, благодаря своей способности быстро анализировать связи между элементами.\",\"generated_as_correct\":false},{\"text\":\"Линейный поиск используется для определения временной сложности алгоритмов и сравнения их эффективности с другими методами поиска, такими как бинарный поиск.\",\"generated_as_correct\":false},{\"text\":\"Линейный поиск эффективен для больших отсортированных наборов данных.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть целесообразно использовать линейный поиск?\"},{\"answers\":[{\"text\":\"Сортировка — это упорядочивание элементов по определённому критерию.\",\"generated_as_correct\":true},{\"text\":\"Сортировка в информатике — это метод шифрования данных, при котором элементы перемешиваются для обеспечения конфиденциальности информации.\",\"generated_as_correct\":false},{\"text\":\"Сортировка в информатике связана с созданием структур данных и не влияет на скорость поиска и обработки информации.\",\"generated_as_correct\":false},{\"text\":\"Сортировка — это процесс объединения данных без какого-либо порядка.\",\"generated_as_correct\":false}],\"question\":\"Что такое сортировка в информатике?\"},{\"answers\":[{\"text\":\"Сортировка ускоряет поиск и обработку данных за счёт упорядочивания элементов.\",\"generated_as_correct\":true},{\"text\":\"Сортировка ускоряет процессы поиска и обработки данных, поскольку при перемешивании элементов увеличивается вероятность быстрого нахождения нужных данных.\",\"generated_as_correct\":false},{\"text\":\"Сортировка важна для обеспечения безопасности данных, так как упорядоченные данные сложнее взломать или исказить.\",\"generated_as_correct\":false},{\"text\":\"Сортировка замедляет поиск и обработку данных из-за необходимости дополнительного времени на упорядочивание.\",\"generated_as_correct\":false}],\"question\":\"Почему сортировка может ускорить процессы поиска и обработки данных?\"},{\"answers\":[{\"text\":\"Стратегия «разделяй и властвуй» разделяет массив на части, сортирует их и объединяет.\",\"generated_as_correct\":true},{\"text\":\"Стратегия «разделяй и властвуй» в алгоритмах сортировки используется для случайного перемешивания элементов массива, что якобы приводит к их естественному упорядочиванию.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» применяется в алгоритмах сортировки для определения оптимального количества итераций, необходимых для полного упорядочивания массива.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» заключается в последовательной сортировке каждого элемента массива по отдельности.\",\"generated_as_correct\":false}],\"question\":\"Как стратегия «разделяй и властвуй» применяется в алгоритмах сортировки?\"},{\"answers\":[{\"text\":\"Временная сложность алгоритма — это время выполнения алгоритма в зависимости от размера данных, выраженное в нотации O.\",\"generated_as_correct\":true},{\"text\":\"Временная сложность алгоритма — это фиксированное время, которое требуется алгоритму для обработки данных любого размера, и она выражается в секундах.\",\"generated_as_correct\":false},{\"text\":\"Временная сложность алгоритма связана с количеством операций, которые алгоритм выполняет для сортировки данных, и выражается в количестве сравнений.\",\"generated_as_correct\":false},{\"text\":\"Временная сложность алгоритма — это количество памяти, необходимое для выполнения алгоритма, выраженное в нотации O.\",\"generated_as_correct\":false}],\"question\":\"Что такое временная сложность алгоритма и как она обычно выражается?\"},{\"answers\":[{\"text\":\"Оценка временной сложности позволяет оценить, как быстро алгоритм работает в зависимости от размера данных.\",\"generated_as_correct\":true},{\"text\":\"Оценка временной сложности важна только для теоретических исследований и не имеет практического применения в реальных системах, так как не учитывает влияние аппаратного обеспечения на скорость выполнения алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Оценка временной сложности важна для определения сложности алгоритма с точки зрения количества операций, но не учитывает сложность алгоритма с точки зрения объёма используемой памяти.\",\"generated_as_correct\":false},{\"text\":\"Оценка временной сложности нужна только для сравнения алгоритмов по количеству операций, не учитывая размер входных данных.\",\"generated_as_correct\":false}],\"question\":\"Почему оценка временной сложности важна для анализа эффективности алгоритмов?\"},{\"answers\":[{\"text\":\"Бинарный поиск эффективнее линейного для больших объёмов данных, так как его временная сложность O(log n) лучше, чем O(n) у линейного поиска.\",\"generated_as_correct\":true},{\"text\":\"Временная сложность бинарного поиска и линейного поиска одинакова и составляет O(n), поэтому их эффективность при работе с большими объёмами данных не отличается.\",\"generated_as_correct\":false},{\"text\":\"Временная сложность алгоритмов важна для определения их эффективности, но она не влияет на выбор между бинарным и линейным поиском при работе с большими объёмами данных, так как важнее учитывать структуру данных и их упорядоченность.\",\"generated_as_correct\":false},{\"text\":\"Линейный поиск эффективнее бинарного для больших объёмов данных, так как его временная сложность O(n) лучше, чем O(log n) у бинарного поиска.\",\"generated_as_correct\":false}],\"question\":\"Как разница во временной сложности между бинарным поиском и линейным поиском влияет на их применение при работе с большими объёмами данных?\"}],\"StoreCardId\":null,\"numberInCourse\":\"9.1\"},{\"Name\":\"algo | 9.2. Поиск доминирующего элемента\",\"Slug\":\"poisk-dominiruyushego-elementa\",\"createdAt\":\"2024-07-03T08:55:27.876Z\",\"updatedAt\":\"2026-01-10T12:07:07.789Z\",\"publishedAt\":\"2024-07-03T08:55:29.011Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80773/problem\",\"Lead\":null,\"Content\":\"$87\",\"Title\":\"Поиск доминирующего элемента\",\"LikesCount\":19,\"Quiz\":[{\"answers\":[{\"text\":\"Доминирующий элемент — это элемент, встречающийся более чем в половине случаев в последовательности.\",\"generated_as_correct\":true},{\"text\":\"Доминирующий элемент — это элемент, который встречается в последовательности хотя бы один раз и имеет наибольшее значение среди всех элементов.\",\"generated_as_correct\":false},{\"text\":\"Доминирующий элемент — это понятие, связанное с анализом частотности элементов в графах и их вершин.\",\"generated_as_correct\":false},{\"text\":\"Доминирующий элемент — это наиболее часто встречающийся элемент в последовательности, независимо от его количества.\",\"generated_as_correct\":false}],\"question\":\"Что такое доминирующий элемент в последовательности?\"},{\"answers\":[{\"text\":\"Доминирующий элемент встречается более чем $n/2$ раз и является наиболее часто встречающимся значением в последовательности.\",\"generated_as_correct\":true},{\"text\":\"Доминирующий элемент — это элемент, который встречается ровно $n/2$ раз в последовательности. Это позволяет сделать вывод о равномерном распределении значений в наборе данных.\",\"generated_as_correct\":false},{\"text\":\"Для определения доминирующего элемента важно учитывать не только количество его вхождений, но и его значение по сравнению с другими элементами в последовательности. Например, если элемент имеет наибольшее значение, он может считаться доминирующим независимо от его количества.\",\"generated_as_correct\":false},{\"text\":\"Доминирующий элемент — это элемент, который встречается ровно $n/3$ раз в последовательности.\",\"generated_as_correct\":false}],\"question\":\"Почему для определения доминирующего элемента важно, чтобы его количество превышало $n/2$, где $n$ — общее количество элементов в последовательности?\"},{\"answers\":[{\"text\":\"Доминирующий элемент — это элемент, встречающийся более чем $n/2$ раз в последовательности из $n$ элементов.\",\"generated_as_correct\":true},{\"text\":\"Доминирующий элемент — это значение, которое встречается в последовательности чаще других, но не обязательно более чем $n/2$ раз.\",\"generated_as_correct\":false},{\"text\":\"Доминирующий элемент используется для определения среднего значения в наборе данных и помогает выявить центральную тенденцию.\",\"generated_as_correct\":false},{\"text\":\"Доминирующий элемент — это наиболее часто встречающееся значение в наборе данных, независимо от его количества.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать понятие доминирующего элемента для анализа набора данных?\"},{\"answers\":[{\"text\":\"Алгоритм поиска доминирующего элемента проверяет, есть ли в последовательности элемент, который встречается более чем $n/2$ раз.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм поиска доминирующего элемента — это метод, который ищет в последовательности элемент, встречающийся хотя бы один раз, используя только примитивный алгоритм с линейным временем выполнения.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм поиска доминирующего элемента связан с алгоритмами сортировки и используется для упорядочивания элементов в последовательности по частоте их встречаемости.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм поиска доминирующего элемента находит в последовательности элемент, который встречается ровно один раз.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритм поиска доминирующего элемента?\"},{\"answers\":[{\"text\":\"Поиск доминирующего элемента требует разных подходов из-за необходимости оптимизации времени выполнения, например, примитивный алгоритм или методы с ассоциативными массивами.\",\"generated_as_correct\":true},{\"text\":\"Поиск доминирующего элемента осуществляется исключительно с помощью примитивного алгоритма, так как более сложные методы не обеспечивают достаточной точности результатов.\",\"generated_as_correct\":false},{\"text\":\"Различные подходы к поиску доминирующего элемента используются для анализа частоты встречаемости элементов в графах и сетях, что помогает в определении ключевых узлов и связей.\",\"generated_as_correct\":false},{\"text\":\"Для поиска доминирующего элемента всегда используется один и тот же алгоритм, независимо от размера данных.\",\"generated_as_correct\":false}],\"question\":\"Почему для поиска доминирующего элемента могут использоваться различные подходы, включая примитивный алгоритм и более эффективные методы?\"},{\"answers\":[{\"text\":\"Алгоритм поиска доминирующего элемента выявляет элемент, встречающийся более чем $n/2$ раз в наборе данных.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм поиска доминирующего элемента помогает найти все элементы, которые встречаются в последовательности более одного раза, что используется для выявления дубликатов в данных.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм поиска доминирующего элемента применяется в криптографии для генерации ключей на основе частотности символов в тексте.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм поиска доминирующего элемента определяет, какой элемент встречается в последовательности реже всего.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм поиска доминирующего элемента в практических задачах обработки данных?\"},{\"answers\":[{\"text\":\"Ассоциативный массив — структура данных для хранения пар «ключ-значение», обеспечивающая быстрый доступ по ключу.\",\"generated_as_correct\":true},{\"text\":\"Ассоциативный массив — это линейная структура данных, которая позволяет хранить только числовые значения и используется для сортировки элементов.\",\"generated_as_correct\":false},{\"text\":\"Ассоциативный массив связан с концепцией массивов в программировании и используется для хранения данных в виде списка, где доступ к элементам осуществляется по индексу.\",\"generated_as_correct\":false},{\"text\":\"Ассоциативный массив — это структура данных для последовательного хранения значений без использования ключей.\",\"generated_as_correct\":false}],\"question\":\"Что такое ассоциативный массив и для чего он используется?\"},{\"answers\":[{\"text\":\"Быстрый доступ к значениям в ассоциативных массивах обеспечивается за счёт использования ключей.\",\"generated_as_correct\":true},{\"text\":\"Ассоциативные массивы обеспечивают быстрый доступ к значениям за счёт того, что все значения хранятся в отсортированном порядке, что позволяет использовать бинарный поиск.\",\"generated_as_correct\":false},{\"text\":\"Ассоциативные массивы используются для хранения данных в виде иерархической структуры, что позволяет эффективно организовывать данные, но не влияет на скорость доступа к ним.\",\"generated_as_correct\":false},{\"text\":\"Быстрый доступ к значениям в ассоциативных массивах достигается за счёт их последовательного хранения.\",\"generated_as_correct\":false}],\"question\":\"Почему ассоциативные массивы обеспечивают быстрый доступ к значениям?\"},{\"answers\":[{\"text\":\"Ассоциативные массивы ускоряют алгоритмы за счёт быстрого доступа к значениям по ключу.\",\"generated_as_correct\":true},{\"text\":\"Ассоциативные массивы используются для хранения данных в виде списка, где каждый элемент имеет свой порядковый номер. Это позволяет оптимизировать время выполнения алгоритмов за счёт быстрого доступа к элементам по индексу.\",\"generated_as_correct\":false},{\"text\":\"Ассоциативные массивы применяются для сортировки данных в алфавитном порядке, что может быть полезно при работе с текстовой информацией, но не влияет на время выполнения алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Ассоциативные массивы замедляют алгоритмы из-за необходимости последовательного поиска элементов.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать ассоциативные массивы для оптимизации времени выполнения алгоритмов?\"},{\"answers\":[{\"text\":\"Стратегия «разделяй и властвуй» — это метод решения задачи путём её разделения на подзадачи и последующего объединения их решений.\",\"generated_as_correct\":true},{\"text\":\"Стратегия «разделяй и властвуй» основана на многократном повторении одной и той же операции над разными частями данных до достижения желаемого результата.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» используется для классификации данных и определения их принадлежности к определённым категориям.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» подразумевает последовательное решение задачи без разделения на подзадачи.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается суть стратегии «разделяй и властвуй» при разработке алгоритмов?\"},{\"answers\":[{\"text\":\"Стратегия «разделяй и властвуй» сокращает время выполнения за счёт разбиения задачи на меньшие подзадачи и их рекурсивного решения.\",\"generated_as_correct\":true},{\"text\":\"Стратегия «разделяй и властвуй» обеспечивает логарифмическое время выполнения за счёт линейного увеличения количества подзадач на каждом шаге рекурсии.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» используется для оптимизации алгоритмов, но её эффективность зависит от сложности операций объединения результатов, а не от логарифмического времени выполнения.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» приводит к линейному времени выполнения из-за необходимости объединения результатов подзадач.\",\"generated_as_correct\":false}],\"question\":\"Почему стратегия «разделяй и властвуй» позволяет создавать эффективные алгоритмы с логарифмическим временем выполнения?\"},{\"answers\":[{\"text\":\"Стратегия «разделяй и властвуй» позволяет разбить последовательность на части, рекурсивно найти доминирующий элемент в каждой части и объединить результаты.\",\"generated_as_correct\":true},{\"text\":\"Стратегия «разделяй и властвуй» для поиска доминирующего элемента в последовательности предполагает случайный выбор элементов из последовательности и их сравнение между собой для определения доминирующего элемента без разделения последовательности на части.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» используется для оптимизации алгоритмов сортировки, где последовательность делится на меньшие подмножества, сортируется и затем объединяется в отсортированный массив.\",\"generated_as_correct\":false},{\"text\":\"Стратегия «разделяй и властвуй» заключается в последовательном сравнении всех элементов между собой для нахождения доминирующего элемента.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить стратегию «разделяй и властвуй» для поиска доминирующего элемента в последовательности?\"},{\"answers\":[{\"text\":\"Время выполнения алгоритма — это время, зависящее от размера входных данных, выражаемое через большую O-нотацию.\",\"generated_as_correct\":true},{\"text\":\"Время выполнения алгоритма определяется исключительно количеством строк кода в его реализации и не зависит от размера входных данных.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма связано с количеством операций ввода-вывода, которые алгоритм выполняет во время своей работы.\",\"generated_as_correct\":false},{\"text\":\"Время выполнения алгоритма не зависит от размера входных данных и является константой для всех случаев.\",\"generated_as_correct\":false}],\"question\":\"Что такое время выполнения алгоритма?\"},{\"answers\":[{\"text\":\"Большая O-нотация описывает, как время выполнения алгоритма зависит от размера входных данных.\",\"generated_as_correct\":true},{\"text\":\"Большая O-нотация определяет минимальное время, необходимое для выполнения алгоритма, и используется для нахождения самого быстрого алгоритма среди предложенных.\",\"generated_as_correct\":false},{\"text\":\"Большая O-нотация используется в теории графов для определения оптимального пути в графе и не имеет отношения к анализу времени выполнения алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Большая O-нотация показывает точное время выполнения алгоритма независимо от размера входных данных.\",\"generated_as_correct\":false}],\"question\":\"Как большая O-нотация помогает анализировать время выполнения алгоритма?\"},{\"answers\":[{\"text\":\"Знание времени выполнения алгоритма помогает выбрать наиболее эффективный алгоритм, анализируя его сложность с помощью большой O-нотации.\",\"generated_as_correct\":true},{\"text\":\"Знание времени выполнения алгоритма используется для определения максимального времени, которое алгоритм может затратить на выполнение задачи при любых условиях, независимо от размера входных данных.\",\"generated_as_correct\":false},{\"text\":\"Знание времени выполнения алгоритма помогает в настройке параметров аппаратного обеспечения, таких как частота процессора или объём оперативной памяти, для улучшения производительности системы в целом.\",\"generated_as_correct\":false},{\"text\":\"Знание времени выполнения алгоритма позволяет точно предсказать время выполнения задачи на любом компьютере независимо от характеристик оборудования.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать знание времени выполнения алгоритма для оптимизации решения задачи?\"}],\"StoreCardId\":null,\"numberInCourse\":\"9.2\"},{\"Name\":\"algo | 9.3. Модификация быстрой сортировки\",\"Slug\":\"modifikaciya-bystroj-sortirovki\",\"createdAt\":\"2024-07-03T08:56:01.104Z\",\"updatedAt\":\"2026-01-10T12:07:07.460Z\",\"publishedAt\":\"2024-07-03T08:56:02.239Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80774/problem\",\"Lead\":null,\"Content\":\"$88\",\"Title\":\"Модификация быстрой сортировки\",\"LikesCount\":28,\"Quiz\":[{\"answers\":[{\"text\":\"RandomizedQuickSort — алгоритм сортировки с временной сложностью $O(n \\\\log n)$, использующий случайный выбор опорного элемента.\",\"generated_as_correct\":true},{\"text\":\"RandomizedQuickSort — это алгоритм сортировки, который выбирает опорный элемент детерминированно и использует метод вставки для упорядочивания массива, что делает его менее эффективным по сравнению с другими алгоритмами сортировки.\",\"generated_as_correct\":false},{\"text\":\"RandomizedQuickSort — это метод, который используется для анализа данных и определения их распределения в массиве, не связанный напрямую с сортировкой элементов.\",\"generated_as_correct\":false},{\"text\":\"RandomizedQuickSort — алгоритм сортировки, использующий последовательный выбор опорного элемента и имеющий временную сложность $O(n^2)$.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой алгоритм RandomizedQuickSort?\"},{\"answers\":[{\"text\":\"Случайный выбор опорного элемента в RandomizedQuickSort предотвращает худший случай и обеспечивает среднюю сложность $O(n \\\\log n)$.\",\"generated_as_correct\":true},{\"text\":\"Случайный выбор опорного элемента в RandomizedQuickSort эффективен, потому что он гарантирует сортировку массива за линейное время $O(n)$.\",\"generated_as_correct\":false},{\"text\":\"Случайный выбор опорного элемента в RandomizedQuickSort важен для обеспечения равномерного распределения данных по массиву, что способствует более быстрой работе алгоритма при поиске определённых элементов.\",\"generated_as_correct\":false},{\"text\":\"Случайный выбор опорного элемента в RandomizedQuickSort замедляет работу алгоритма и ухудшает его среднюю временную сложность.\",\"generated_as_correct\":false}],\"question\":\"Почему использование случайного выбора опорного элемента в RandomizedQuickSort считается эффективным?\"},{\"answers\":[{\"text\":\"RandomizedQuickSort эффективен для сортировки массивов благодаря случайному выбору опорного элемента и имеет среднюю временную сложность $O(n \\\\log n)$.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм RandomizedQuickSort используется для сортировки данных, но его основная особенность заключается в том, что он всегда выбирает первый элемент массива в качестве опорного, что делает его менее эффективным по сравнению с другими алгоритмами.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм RandomizedQuickSort связан с методами машинного обучения и используется для предварительной обработки данных перед тренировкой моделей.\",\"generated_as_correct\":false},{\"text\":\"RandomizedQuickSort применяется для сортировки данных, но его сложность всегда составляет $O(n^2)$, что делает его малоэффективным.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях можно применять алгоритм RandomizedQuickSort и почему?\"},{\"answers\":[{\"text\":\"Временная сложность алгоритма — это оценка количества операций в зависимости от размера входных данных.\",\"generated_as_correct\":true},{\"text\":\"Временная сложность алгоритма — это фиксированное время, необходимое для выполнения алгоритма независимо от размера входных данных.\",\"generated_as_correct\":false},{\"text\":\"Временная сложность алгоритма связана с количеством итераций, которые алгоритм совершает для сортировки массива, и не зависит от размера входных данных.\",\"generated_as_correct\":false},{\"text\":\"Временная сложность алгоритма — это максимальное количество памяти, которое алгоритм может использовать.\",\"generated_as_correct\":false}],\"question\":\"Что такое временная сложность алгоритма?\"},{\"answers\":[{\"text\":\"Временная сложность RandomizedQuickSort ухудшается до $O(n^2)$ из-за несбалансированного разделения массива при множестве повторяющихся элементов.\",\"generated_as_correct\":true},{\"text\":\"В контексте RandomizedQuickSort временная сложность ухудшается до $O(n^2)$ из-за увеличения времени на выбор опорного элемента при большом количестве уникальных элементов в массиве.\",\"generated_as_correct\":false},{\"text\":\"В контексте RandomizedQuickSort временная сложность может измениться из-за влияния внешних факторов, таких как скорость работы процессора или объём оперативной памяти.\",\"generated_as_correct\":false},{\"text\":\"Временная сложность RandomizedQuickSort ухудшается до $O(n^2)$ из-за увеличения количества итераций при малом количестве повторяющихся элементов.\",\"generated_as_correct\":false}],\"question\":\"Почему в контексте RandomizedQuickSort временная сложность может ухудшиться до $O(n^2)$ при наличии большого количества повторяющихся элементов?\"},{\"answers\":[{\"text\":\"Знание временной сложности помогает выбрать подходящий алгоритм, учитывая размер данных, и избежать неэффективных решений.\",\"generated_as_correct\":true},{\"text\":\"Знание о временной сложности алгоритма используется для определения максимального размера данных, которые алгоритм способен обработать за фиксированное время, что позволяет заранее установить ограничения на объём входных данных.\",\"generated_as_correct\":false},{\"text\":\"Знание о временной сложности алгоритма помогает в анализе стабильности алгоритма при различных условиях выполнения, что важно для систем, требующих высокой надёжности и предсказуемости поведения.\",\"generated_as_correct\":false},{\"text\":\"Знание временной сложности позволяет определить, сколько памяти потребуется алгоритму для обработки данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать знание о временной сложности алгоритма для оптимизации работы с данными?\"},{\"answers\":[{\"text\":\"Модификация RandomizedQuickSort разделяет массив на три части: меньше, равны и больше опорного элемента, сохраняя время выполнения $O(n \\\\log n)$.\",\"generated_as_correct\":true},{\"text\":\"Модификация алгоритма RandomizedQuickSort для работы с повторяющимися элементами подразумевает удаление всех повторяющихся элементов из массива перед сортировкой, чтобы упростить процесс сортировки и ускорить его выполнение.\",\"generated_as_correct\":false},{\"text\":\"Модификация алгоритма RandomizedQuickSort для работы с повторяющимися элементами включает в себя использование дополнительных структур данных, таких как хеш-таблицы, для учёта количества повторений каждого элемента.\",\"generated_as_correct\":false},{\"text\":\"Модификация RandomizedQuickSort заключается в сортировке массива по частоте встречаемости элементов, что ускоряет процесс при наличии повторов.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой модификация алгоритма RandomizedQuickSort для работы с повторяющимися элементами?\"},{\"answers\":[{\"text\":\"Разделение массива на три подмассива помогает сохранить эффективность алгоритма при наличии повторяющихся элементов.\",\"generated_as_correct\":true},{\"text\":\"Разделение массива на три подмассива улучшает работу алгоритма, потому что упрощает процесс сортировки уникальных элементов, что сокращает время выполнения до \\\\(O(n)\\\\).\",\"generated_as_correct\":false},{\"text\":\"Разделение массива на подмассивы улучшает работу алгоритма за счёт уменьшения количества итераций при поиске минимального элемента в массиве.\",\"generated_as_correct\":false},{\"text\":\"Разделение массива на три подмассива ухудшает работу алгоритма из-за увеличения сложности при обработке повторяющихся элементов.\",\"generated_as_correct\":false}],\"question\":\"Почему разделение массива на три подмассива (меньше опорного, равные ему и больше) улучшает работу алгоритма при наличии повторяющихся элементов?\"},{\"answers\":[{\"text\":\"Модификация RandomizedQuickSort разделяет массив на три части по отношению к опорному элементу, сохраняя время выполнения \\\\(O(n \\\\log n)\\\\).\",\"generated_as_correct\":true},{\"text\":\"Модификация алгоритма заключается в сортировке повторяющихся элементов отдельным методом, что не влияет на общее время выполнения алгоритма \\\\(O(n \\\\log n)\\\\).\",\"generated_as_correct\":false},{\"text\":\"Модификация алгоритма включает использование дополнительного массива для хранения уникальных элементов, что помогает улучшить производительность при работе с повторяющимися значениями.\",\"generated_as_correct\":false},{\"text\":\"Модификация алгоритма состоит в удалении повторяющихся элементов для сохранения времени выполнения \\\\(O(n \\\\log n)\\\\).\",\"generated_as_correct\":false}],\"question\":\"Как модификация алгоритма позволяет сохранить ожидаемое время выполнения \\\\(O(n \\\\log n)\\\\) при наличии множества повторяющихся значений?\"},{\"answers\":[{\"text\":\"Разделение массива на три части — это деление массива на подмассивы по сравнению с опорным значением в алгоритме RandomizedQuickSort.\",\"generated_as_correct\":true},{\"text\":\"Процесс разделения массива на три части подразумевает деление массива на три равные части независимо от значений элементов, что используется в некоторых алгоритмах сортировки для ускорения обработки данных.\",\"generated_as_correct\":false},{\"text\":\"Процесс разделения массива на три части связан с методами распределения данных по трём различным структурам для последующего анализа и обработки, что может быть полезно в задачах машинного обучения.\",\"generated_as_correct\":false},{\"text\":\"Разделение массива на три части — это равномерное деление массива на три равных подмассива без учёта значений элементов.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой процесс разделения массива на три части?\"},{\"answers\":[{\"text\":\"Разделение массива на три части в RandomizedQuickSort позволяет эффективно обрабатывать повторяющиеся элементы и сохранить оптимальную временную сложность.\",\"generated_as_correct\":true},{\"text\":\"Разделение массива на три части в алгоритме RandomizedQuickSort используется для упрощения процесса сортировки, но не влияет на временную сложность алгоритма при наличии повторяющихся элементов.\",\"generated_as_correct\":false},{\"text\":\"Разделение массива на три части важно для обеспечения равномерного распределения данных между различными уровнями памяти в процессе выполнения алгоритма RandomizedQuickSort.\",\"generated_as_correct\":false},{\"text\":\"Разделение массива на три части в RandomizedQuickSort нужно для улучшения работы алгоритма при отсутствии повторяющихся элементов.\",\"generated_as_correct\":false}],\"question\":\"Почему разделение массива на три части важно для модифицированного алгоритма RandomizedQuickSort?\"},{\"answers\":[{\"text\":\"Разделение массива на три части в RandomizedQuickSort предотвращает ухудшение временной сложности при наличии множества одинаковых элементов.\",\"generated_as_correct\":true},{\"text\":\"Разделение массива на три части помогает улучшить временную сложность алгоритма за счёт уменьшения количества сравнений между элементами, что особенно эффективно при работе с массивами, содержащими уникальные элементы.\",\"generated_as_correct\":false},{\"text\":\"Разделение массива на три части используется для оптимизации памяти при обработке больших объёмов данных, что не влияет на временную сложность алгоритма.\",\"generated_as_correct\":false},{\"text\":\"Разделение массива на три части увеличивает временную сложность алгоритма при наличии множества одинаковых элементов.\",\"generated_as_correct\":false}],\"question\":\"Как разделение массива на три части помогает избежать ухудшения временной сложности алгоритма при наличии множества одинаковых элементов?\"}],\"StoreCardId\":null,\"numberInCourse\":\"9.3\"},{\"Name\":\"algo | 9.4. Подсчёт инверсий\",\"Slug\":\"podschet-inversij\",\"createdAt\":\"2024-07-03T08:56:29.166Z\",\"updatedAt\":\"2026-01-10T12:07:07.722Z\",\"publishedAt\":\"2024-07-03T08:56:30.294Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80775/problem\",\"Lead\":null,\"Content\":\"$89\",\"Title\":\"Подсчёт инверсий\",\"LikesCount\":16,\"Quiz\":[{\"answers\":[{\"text\":\"Инверсия — это пара элементов в последовательности, где меньший индекс имеет большее значение.\",\"generated_as_correct\":true},{\"text\":\"Инверсия в последовательности — это ситуация, когда каждый следующий элемент строго меньше предыдущего.\",\"generated_as_correct\":false},{\"text\":\"Инверсия в последовательности — это метод сортировки элементов в обратном порядке.\",\"generated_as_correct\":false},{\"text\":\"Инверсия — это когда все элементы последовательности расположены в порядке возрастания.\",\"generated_as_correct\":false}],\"question\":\"Что такое инверсия в последовательности?\"},{\"answers\":[{\"text\":\"Инверсия — это пара элементов, где меньший индекс имеет большее значение. Чем больше инверсий, тем менее упорядочена последовательность.\",\"generated_as_correct\":true},{\"text\":\"Инверсии в последовательности показывают, насколько часто элементы следуют друг за другом в порядке возрастания. Чем больше инверсий, тем более упорядоченной является последовательность.\",\"generated_as_correct\":false},{\"text\":\"Инверсии используются для определения количества элементов в последовательности и не имеют отношения к её упорядоченности.\",\"generated_as_correct\":false},{\"text\":\"Инверсия показывает, насколько часто элементы последовательности расположены в порядке возрастания их индексов.\",\"generated_as_correct\":false}],\"question\":\"Как инверсии помогают определить степень упорядоченности последовательности?\"},{\"answers\":[{\"text\":\"Инверсия — это пара элементов в последовательности, где меньший индекс имеет большее значение. Чем больше инверсий, тем менее упорядочена последовательность.\",\"generated_as_correct\":true},{\"text\":\"Инверсия в последовательности — это ситуация, когда каждый следующий элемент меньше предыдущего. Количество инверсий в возрастающей последовательности максимально и равно $n(n-1)/2$, где $n$ — длина последовательности.\",\"generated_as_correct\":false},{\"text\":\"Инверсия в последовательности используется для определения цикличности элементов и их периодичности, что может быть полезно при анализе временных рядов.\",\"generated_as_correct\":false},{\"text\":\"Инверсия показывает, сколько раз элементы последовательности увеличиваются по сравнению с предыдущими элементами.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать понятие инверсии для анализа упорядоченности заданной последовательности?\"},{\"answers\":[{\"text\":\"Количество инверсий — это число неправильно расположенных пар элементов в последовательности.\",\"generated_as_correct\":true},{\"text\":\"Количество инверсий в последовательности — это общее количество элементов в последовательности, которые больше среднего значения всех элементов.\",\"generated_as_correct\":false},{\"text\":\"Количество инверсий в последовательности связано с количеством операций, необходимых для полного перебора всех возможных комбинаций элементов в последовательности.\",\"generated_as_correct\":false},{\"text\":\"Количество инверсий — это количество элементов, которые нужно переместить для сортировки последовательности.\",\"generated_as_correct\":false}],\"question\":\"Что такое количество инверсий в последовательности?\"},{\"answers\":[{\"text\":\"Количество инверсий показывает степень отсортированности последовательности.\",\"generated_as_correct\":true},{\"text\":\"Количество инверсий отражает максимальное значение в последовательности, что позволяет судить об её упорядоченности.\",\"generated_as_correct\":false},{\"text\":\"Количество инверсий используется для определения частоты встречаемости определённых элементов в наборе данных, что помогает в анализе их распределения.\",\"generated_as_correct\":false},{\"text\":\"Количество инверсий определяет минимальное значение в последовательности.\",\"generated_as_correct\":false}],\"question\":\"Почему количество инверсий важно для анализа упорядоченности данных?\"},{\"answers\":[{\"text\":\"Количество инверсий применяют в алгоритмах сортировки для оценки упорядоченности данных.\",\"generated_as_correct\":true},{\"text\":\"Количество инверсий используется в алгоритмах машинного обучения для определения важности признаков.\",\"generated_as_correct\":false},{\"text\":\"Количество инверсий может быть использовано в алгоритмах сжатия данных для оптимизации хранения информации.\",\"generated_as_correct\":false},{\"text\":\"Количество инверсий используют в алгоритмах поиска для определения позиции элемента в списке.\",\"generated_as_correct\":false}],\"question\":\"В каких алгоритмах может быть использовано количество инверсий и для каких целей?\"},{\"answers\":[{\"text\":\"Алгоритм «разделяй и властвуй» разделяет задачу на более простые подзадачи, решает их рекурсивно и объединяет решения.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм «разделяй и властвуй» — это метод, при котором задача решается путём случайного выбора подзадач и их последовательного решения без рекурсии и объединения результатов.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» используется для классификации данных и не предполагает разделения задачи на подзадачи.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» заключается в последовательном решении всех возможных подзадач без их объединения.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается суть алгоритма «разделяй и властвуй»?\"},{\"answers\":[{\"text\":\"Алгоритм «разделяй и властвуй» эффективнее примитивных алгоритмов, так как разделяет задачу на подзадачи и решает их рекурсивно.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм «разделяй и властвуй» более эффективен, поскольку он использует параллельные вычисления для одновременного решения всех подзадач, что значительно ускоряет процесс по сравнению с последовательными вычислениями примитивных алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» эффективен благодаря использованию сложных математических моделей, которые позволяют предсказывать результаты без необходимости полного перебора данных, что делает его предпочтительным в задачах прогнозирования.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» более эффективен, потому что он использует итеративный подход для решения задачи, что позволяет быстрее находить решение по сравнению с рекурсивными методами.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритм «разделяй и властвуй» считается более эффективным по сравнению с примитивными алгоритмами?\"},{\"answers\":[{\"text\":\"Алгоритм «разделяй и властвуй» решает сложные задачи путём разделения их на более простые подзадачи, рекурсивного решения и объединения решений.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм «разделяй и властвуй» заключается в последовательном решении всех возможных подзадач без разделения исходной задачи и последующем их сложении для получения общего решения.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» можно использовать для оптимизации процессов в различных областях, например, в логистике для планирования маршрутов, хотя его основное применение — это математические и компьютерные задачи.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» работает путём случайного выбора подзадач из исходной задачи и их независимого решения без последующего объединения.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм «разделяй и властвуй» для решения сложных задач?\"},{\"answers\":[{\"text\":\"Разделенные инверсии — это инверсии между элементами разных половин последовательности.\",\"generated_as_correct\":true},{\"text\":\"Разделенные инверсии — это любые инверсии в последовательности, независимо от того, в каких частях последовательности они находятся.\",\"generated_as_correct\":false},{\"text\":\"Разделенные инверсии — это концепция, используемая в теории графов для анализа связности узлов в сети.\",\"generated_as_correct\":false},{\"text\":\"Разделенные инверсии — это инверсии внутри одной половины последовательности.\",\"generated_as_correct\":false}],\"question\":\"Что такое разделённые инверсии?\"},{\"answers\":[{\"text\":\"Подсчёт разделённых инверсий важен для метода «разделяй и властвуй», так как позволяет эффективно вычислить общее количество инверсий.\",\"generated_as_correct\":true},{\"text\":\"Подсчёт разделённых инверсий важен для алгоритмов, использующих метод «разделяй и властвуй», потому что он помогает определить количество элементов в каждой половине последовательности.\",\"generated_as_correct\":false},{\"text\":\"Подсчёт разделённых инверсий важен для алгоритмов сортировки, так как он помогает определить порядок элементов в последовательности без учёта их происхождения из разных половин.\",\"generated_as_correct\":false},{\"text\":\"Подсчёт разделённых инверсий важен для метода «разделяй и властвуй», так как помогает определить количество элементов в последовательности.\",\"generated_as_correct\":false}],\"question\":\"Почему подсчёт разделённых инверсий важен для алгоритмов, использующих метод «разделяй и властвуй»?\"},{\"answers\":[{\"text\":\"Знание о разделённых инверсиях помогает оптимизировать алгоритмы сортировки методом «разделяй и властвуй».\",\"generated_as_correct\":true},{\"text\":\"Разделенные инверсии применяются в алгоритмах сортировки для определения максимального элемента в последовательности, что позволяет сразу поместить его в нужное место.\",\"generated_as_correct\":false},{\"text\":\"Разделенные инверсии могут быть использованы для анализа стабильности алгоритмов сортировки, но не влияют на их эффективность.\",\"generated_as_correct\":false},{\"text\":\"Разделенные инверсии используются для прямого обмена элементами в алгоритмах сортировки.\",\"generated_as_correct\":false}],\"question\":\"Как знание о разделённых инверсиях может быть применено в алгоритмах сортировки?\"},{\"answers\":[{\"text\":\"Сортировка с подсчётом инверсий — это алгоритм для сортировки последовательности и подсчёта инверсий в ней.\",\"generated_as_correct\":true},{\"text\":\"Сортировка с подсчётом инверсий — это метод сортировки, который определяет количество элементов в последовательности и на основе этого строит отсортированный массив, не учитывая инверсии.\",\"generated_as_correct\":false},{\"text\":\"Сортировка с подсчётом инверсий — это техника, используемая в криптографии для шифрования данных путём перестановки элементов и подсчёта их взаимного расположения.\",\"generated_as_correct\":false},{\"text\":\"Сортировка с подсчётом инверсий — это метод, который только подсчитывает количество элементов в последовательности, не занимаясь их сортировкой.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой сортировка с подсчётом инверсий?\"},{\"answers\":[{\"text\":\"Сортировка с подсчётом инверсий эффективна, так как одновременно сортирует и подсчитывает инверсии.\",\"generated_as_correct\":true},{\"text\":\"Сортировка с подсчётом инверсий эффективна, потому что она использует метод полного перебора всех возможных пар элементов для точного подсчёта инверсий, что делает её быстрой.\",\"generated_as_correct\":false},{\"text\":\"Сортировка с подсчётом инверсий эффективна благодаря применению сложных математических функций, которые не связаны напрямую с процессом сортировки или подсчёта инверсий.\",\"generated_as_correct\":false},{\"text\":\"Сортировка с подсчётом инверсий эффективна, потому что выполняет сортировку быстрее, чем другие алгоритмы.\",\"generated_as_correct\":false}],\"question\":\"Почему сортировка с подсчётом инверсий считается эффективным методом для решения задачи подсчёта инверсий?\"},{\"answers\":[{\"text\":\"Сортировка с подсчётом инверсий позволяет одновременно отсортировать данные и подсчитать количество инверсий.\",\"generated_as_correct\":true},{\"text\":\"Сортировка с подсчётом инверсий используется исключительно для определения среднего значения элементов в последовательности, не имея отношения к подсчёту инверсий или сортировке.\",\"generated_as_correct\":false},{\"text\":\"Сортировка с подсчётом инверсий применяется для определения частоты встречаемости каждого элемента в последовательности данных, что помогает в анализе распределения значений.\",\"generated_as_correct\":false},{\"text\":\"Сортировка с подсчётом инверсий используется только для сортировки данных без учёта количества инверсий.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить сортировку с подсчётом инверсий для анализа последовательности данных?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение описывает зависимость текущего значения функции от предыдущих.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение — это формула, которая определяет значение функции через её производную. Она применяется для решения дифференциальных уравнений.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение связано с теорией вероятностей и используется для расчёта статистических характеристик случайных процессов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение определяет зависимость текущего значения функции от её максимального значения.\",\"generated_as_correct\":false}],\"question\":\"Что такое рекуррентное соотношение?\"},{\"answers\":[{\"text\":\"Рекуррентные соотношения помогают анализировать время выполнения рекурсивных алгоритмов и определять их сложность.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентные соотношения используются для анализа времени выполнения рекурсивных алгоритмов, но они не позволяют определить сложность алгоритма, а только описывают его поведение на конкретных примерах входных данных.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения применяются в теории чисел и комбинаторике для решения задач, связанных с последовательностями, что имеет косвенное отношение к анализу времени выполнения алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения используются для определения памяти, необходимой рекурсивным алгоритмам.\",\"generated_as_correct\":false}],\"question\":\"Почему рекуррентные соотношения важны для анализа времени выполнения рекурсивных алгоритмов?\"},{\"answers\":[{\"text\":\"Рекуррентные соотношения описывают зависимость текущего значения функции от предыдущих и используются для анализа сложности рекурсивных алгоритмов.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентные соотношения применяются для вычисления количества операций в алгоритме путём прямого подсчёта без учёта предыдущих значений функции.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения помогают в построении графиков функций и анализе их поведения, что может быть полезно при оптимизации алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентные соотношения применяются для определения сложности алгоритмов путём сравнения их с другими алгоритмами.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентные соотношения для определения сложности алгоритма?\"}],\"StoreCardId\":null,\"numberInCourse\":\"9.4\"},{\"Name\":\"algo | 9.5. Задача «Пара ближайших точек»\",\"Slug\":\"zadacha-para-blizhajshih-tochek\",\"createdAt\":\"2024-07-03T08:57:10.576Z\",\"updatedAt\":\"2026-01-10T12:07:08.927Z\",\"publishedAt\":\"2024-07-03T08:57:11.719Z\",\"ContestURL\":\"https://new.contest.yandex.ru/contest/80776/problem\",\"Lead\":null,\"Content\":\"$8a\",\"Title\":\"Задача «Пара ближайших точек»\",\"LikesCount\":21,\"Quiz\":[{\"answers\":[{\"text\":\"Задача о поиске ближайшей пары точек — это нахождение двух ближайших точек в заданном множестве.\",\"generated_as_correct\":true},{\"text\":\"Задача о поиске ближайшей пары точек заключается в нахождении двух точек, которые находятся на одной прямой и имеют одинаковое расстояние от начала координат.\",\"generated_as_correct\":false},{\"text\":\"Задача о поиске ближайшей пары точек связана с анализом временных рядов и используется для прогнозирования будущих событий на основе исторических данных.\",\"generated_as_correct\":false},{\"text\":\"Задача о поиске ближайшей пары точек — это определение двух точек с наибольшим расстоянием между ними.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается задача о поиске ближайшей пары точек?\"},{\"answers\":[{\"text\":\"Задача о поиске ближайшей пары точек — классическая в вычислительной геометрии, так как ищет минимальное расстояние между двумя точками в заданном множестве.\",\"generated_as_correct\":true},{\"text\":\"Задача о поиске ближайшей пары точек считается классической, так как она предполагает поиск точек, которые находятся на одинаковом расстоянии от центра заданного множества точек, что используется в компьютерной графике.\",\"generated_as_correct\":false},{\"text\":\"Задача о поиске ближайшей пары точек связана с анализом сложных геометрических структур и используется для оптимизации алгоритмов машинного обучения.\",\"generated_as_correct\":false},{\"text\":\"Задача о поиске ближайшей пары точек считается классической, потому что определяет максимальное расстояние между всеми точками в множестве.\",\"generated_as_correct\":false}],\"question\":\"Почему задача о поиске ближайшей пары точек считается классической в области вычислительной геометрии?\"},{\"answers\":[{\"text\":\"Решение задачи о поиске ближайшей пары точек помогает определить минимальное расстояние между объектами в компьютерной графике и зрении.\",\"generated_as_correct\":true},{\"text\":\"Решение задачи о поиске ближайшей пары точек применяется для расчёта площади, охватываемой набором точек, что используется в компьютерной графике для определения размеров объектов.\",\"generated_as_correct\":false},{\"text\":\"Решение задачи о поиске ближайшей пары точек связано с алгоритмами сортировки и используется для упорядочивания точек по их координатам в компьютерной графике.\",\"generated_as_correct\":false},{\"text\":\"Решение задачи о поиске ближайшей пары точек используется для определения центра масс группы точек в компьютерной графике.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить решение задачи о поиске ближайшей пары точек в компьютерной графике или зрении?\"},{\"answers\":[{\"text\":\"Метод «разделяй и властвуй» — это разделение задачи на подзадачи, их рекурсивное решение и объединение результатов.\",\"generated_as_correct\":true},{\"text\":\"Метод «разделяй и властвуй» подразумевает случайный выбор подзадач из исходной задачи, их решение и объединение в произвольном порядке для получения окончательного результата.\",\"generated_as_correct\":false},{\"text\":\"Метод «разделяй и властвуй» используется для классификации данных и построения иерархических структур в машинном обучении.\",\"generated_as_correct\":false},{\"text\":\"Метод «разделяй и властвуй» заключается в однократном делении задачи на две равные части без последующего объединения решений.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается суть метода «разделяй и властвуй»?\"},{\"answers\":[{\"text\":\"Алгоритм «разделяй и властвуй» эффективнее для поиска ближайшей пары точек благодаря разделению задачи на подзадачи и рекурсивному решению, что даёт время выполнения O(n log n).\",\"generated_as_correct\":true},{\"text\":\"Алгоритм «разделяй и властвуй» эффективен для задачи о поиске ближайшей пары точек, потому что он использует параллельные вычисления, что позволяет сократить время выполнения до O(n), в то время как примитивный алгоритм работает за O(n^2).\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» применяется для оптимизации задач поиска, но его эффективность в контексте задачи о поиске ближайшей пары точек обусловлена использованием дополнительных структур данных, таких как деревья поиска.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» неэффективен для поиска ближайшей пары точек, так как требует больше памяти по сравнению с примитивным алгоритмом.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритм «разделяй и властвуй» более эффективен для задачи о поиске ближайшей пары точек по сравнению с примитивным алгоритмом?\"},{\"answers\":[{\"text\":\"Метод «разделяй и властвуй» позволяет эффективно найти ближайшую пару точек, разделяя множество точек на меньшие подмножества и рекурсивно решая задачу.\",\"generated_as_correct\":true},{\"text\":\"Метод «разделяй и властвуй» для поиска ближайшей пары точек предполагает случайный выбор точек из множества и их попарное сравнение до тех пор, пока не будет найдена ближайшая пара.\",\"generated_as_correct\":false},{\"text\":\"Метод «разделяй и властвуй» используется для решения задачи о поиске ближайшей пары точек путём построения дерева решений, где каждый узел представляет собой точку, а рёбра — расстояния между точками.\",\"generated_as_correct\":false},{\"text\":\"Метод «разделяй и властвуй» для поиска ближайшей пары точек заключается в сортировке всех точек по координатам и последовательном сравнении соседних точек.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить метод «разделяй и властвуй» для решения задачи о поиске ближайшей пары точек?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение T(n) = 2 · T(n/2) + O(n log n) описывает время работы алгоритма «разделяй и властвуй».\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение T(n) = 2 · T(n/2) + O(n log n) определяет количество итераций, необходимых для сортировки массива методом пузырька.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение T(n) = 2 · T(n/2) + O(n log n) используется для описания роста популяции в биологических моделях.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение T(n) = 2 · T(n/2) + O(n log n) определяет пространственную сложность алгоритма быстрой сортировки.\",\"generated_as_correct\":false}],\"question\":\"Что описывает рекуррентное соотношение T(n) = 2 · T(n/2) + O(n log n)?\"},{\"answers\":[{\"text\":\"Член O(n log n) описывает время объединения решений подзадач в алгоритмах «разделяй и властвуй».\",\"generated_as_correct\":true},{\"text\":\"Член O(n log n) в рекуррентном соотношении указывает на линейную зависимость времени выполнения алгоритма от размера входных данных.\",\"generated_as_correct\":false},{\"text\":\"Член O(n log n) связан с оценкой сложности алгоритма сортировки вставками и не имеет отношения к рекуррентным соотношениям.\",\"generated_as_correct\":false},{\"text\":\"Член O(n log n) отражает время, необходимое для итеративного решения задачи без разделения на подзадачи.\",\"generated_as_correct\":false}],\"question\":\"Почему в рекуррентном соотношении для времени выполнения алгоритма присутствует член O(n log n)?\"},{\"answers\":[{\"text\":\"Рекуррентное соотношение T(n) = 2 · T(n/2) + O(n log n) описывает время выполнения алгоритма «разделяй и властвуй», учитывая разделение, рекурсивное решение и объединение подзадач.\",\"generated_as_correct\":true},{\"text\":\"Рекуррентное соотношение T(n) = T(n−1) + O(n) описывает время выполнения алгоритма «разделяй и властвуй». Оно учитывает линейное увеличение времени выполнения с ростом размера задачи.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение используется для анализа стабильности алгоритма, а не для определения времени его выполнения.\",\"generated_as_correct\":false},{\"text\":\"Рекуррентное соотношение T(n) = T(n/2) + O(n) описывает время выполнения алгоритма «разделяй и властвуй».\",\"generated_as_correct\":false}],\"question\":\"Как можно применить рекуррентное соотношение для анализа времени выполнения алгоритма «разделяй и властвуй»?\"},{\"answers\":[{\"text\":\"Сортировка точек по координатам — это упорядочивание точек для упрощения вычислений в алгоритмах.\",\"generated_as_correct\":true},{\"text\":\"Сортировка точек по координатам — это процесс определения расстояния между каждой парой точек для выявления ближайших соседей без упорядочивания по координатам.\",\"generated_as_correct\":false},{\"text\":\"Сортировка точек по координатам используется в методах интерполяции для построения графиков функций.\",\"generated_as_correct\":false},{\"text\":\"Сортировка точек по координатам — это метод определения центра масс множества точек.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой процесс сортировки точек по координатам?\"},{\"answers\":[{\"text\":\"Сортировка точек по координатам упрощает деление множества на подмножества и поиск ближайших точек.\",\"generated_as_correct\":true},{\"text\":\"Сортировка точек по координатам важна для алгоритма «разделяй и властвуй», потому что она помогает визуализировать расположение точек на плоскости, что упрощает их восприятие человеком.\",\"generated_as_correct\":false},{\"text\":\"Сортировка точек по координатам важна для алгоритма «разделяй и властвуй», поскольку позволяет оптимизировать хранение данных в памяти компьютера.\",\"generated_as_correct\":false},{\"text\":\"Сортировка точек по координатам нужна для алгоритма «разделяй и властвуй» для подсчёта общего количества точек в множестве.\",\"generated_as_correct\":false}],\"question\":\"Почему сортировка точек по координатам важна для алгоритма «разделяй и властвуй»?\"},{\"answers\":[{\"text\":\"Сортировка точек по координатам помогает упростить поиск ближайшей пары точек за счёт эффективного деления множества точек на подмножества.\",\"generated_as_correct\":true},{\"text\":\"Сортировка точек по координатам не влияет на поиск ближайшей пары точек, так как расстояние между точками определяется независимо от их упорядочивания.\",\"generated_as_correct\":false},{\"text\":\"Сортировка точек по координатам используется для построения графиков функций и не имеет отношения к поиску ближайшей пары точек.\",\"generated_as_correct\":false},{\"text\":\"Сортировка точек по координатам усложняет поиск ближайшей пары точек, так как требует дополнительных вычислений для каждого подмножества.\",\"generated_as_correct\":false}],\"question\":\"Как сортировка точек по координатам помогает упростить поиск ближайшей пары точек?\"},{\"answers\":[{\"text\":\"Минимальное расстояние между точками — это наименьшее расстояние между двумя точками из множества.\",\"generated_as_correct\":true},{\"text\":\"Минимальное расстояние между точками определяется как среднее арифметическое расстояний между всеми парами точек в заданном множестве.\",\"generated_as_correct\":false},{\"text\":\"Минимальное расстояние между точками связано с определением выпуклой оболочки множества точек и используется для построения триангуляции Делоне.\",\"generated_as_correct\":false},{\"text\":\"Минимальное расстояние между точками — это расстояние между начальной и конечной точками заданного множества.\",\"generated_as_correct\":false}],\"question\":\"Что такое минимальное расстояние между точками в контексте вычислительной геометрии?\"},{\"answers\":[{\"text\":\"Поиск минимального расстояния между точками важен для вычислительной геометрии, так как это основа для решения многих прикладных задач.\",\"generated_as_correct\":true},{\"text\":\"Задача поиска минимального расстояния между точками важна для вычислительной геометрии, потому что она позволяет определить центр масс системы точек, что необходимо для многих физических расчётов.\",\"generated_as_correct\":false},{\"text\":\"Задача поиска минимального расстояния между точками связана с теорией графов и используется для анализа связности сетей в вычислительной геометрии.\",\"generated_as_correct\":false},{\"text\":\"Задача поиска минимального расстояния между точками важна для вычислительной геометрии, поскольку она позволяет определить максимальное количество точек в заданном множестве.\",\"generated_as_correct\":false}],\"question\":\"Почему задача поиска минимального расстояния между точками важна для вычислительной геометрии?\"},{\"answers\":[{\"text\":\"Алгоритм «разделяй и властвуй» делит множество точек на подмножества для нахождения минимального расстояния между ними.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм «разделяй и властвуй» позволяет найти минимальное расстояние между точками путём случайного выбора пар точек и вычисления расстояния между ними до тех пор, пока не будет найдено наименьшее значение.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» может быть использован для классификации точек по их координатам, что помогает в организации данных для дальнейшего анализа.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм «разделяй и властвуй» находит минимальное расстояние между точками путём последовательного сравнения всех возможных пар точек.\",\"generated_as_correct\":false}],\"question\":\"Как алгоритм «разделяй и властвуй» может быть применён для решения задачи поиска минимального расстояния между точками?\"}],\"StoreCardId\":null,\"numberInCourse\":\"9.5\"},{\"Name\":\"algo | 9.6. Чему вы научились\",\"Slug\":\"chemu-vi-nauchilis-nine\",\"createdAt\":\"2024-07-03T08:57:10.576Z\",\"updatedAt\":\"2025-09-11T19:23:37.395Z\",\"publishedAt\":\"2025-09-09T09:32:03.958Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$8b\",\"Title\":\" Чему вы научились\",\"LikesCount\":21,\"Quiz\":null,\"StoreCardId\":null,\"numberInCourse\":\"9.6\"}]}],\"activeArticleSlug\":\"zadacha-kolichestvo-prizov\",\"csrfToken\":\"\",\"hasNotes\":true,\"children\":\"$L8c\"}]}]}]\n"])</script><script nonce="">self.__next_f.push([1,"8c:[[[\"$\",\"meta\",null,{\"property\":\"og:type\",\"content\":\"article\",\"itemProp\":\"\"}],[\"$\",\"meta\",null,{\"property\":\"article:modified_time\",\"content\":\"2026-01-10T12:07:08.588Z\",\"itemProp\":\"\"}],[[\"$\",\"meta\",\"tolstikov\",{\"property\":\"article:author\",\"content\":\"Алексей Толстиков\",\"itemProp\":\"\"}],[\"$\",\"meta\",\"kulikov\",{\"property\":\"article:author\",\"content\":\"Александр Куликов\",\"itemProp\":\"\"}]],[\"$\",\"meta\",null,{\"property\":\"article:section\",\"content\":\"Основы алгоритмов\",\"itemProp\":\"\"}]],\"$L8d\"]\n"])</script><script nonce="">self.__next_f.push([1,"8e:I[9348,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"ReadingProgress\"]\n8f:I[16524,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"BookBreadcrumbs\"]\n90:I[12430,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"\"]\n91:I[91859,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"Image\"]\n92:I[87301,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/"])</script><script nonce="">self.__next_f.push([1,"8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"WYSIWYGClient\"]\n93:T1b5e,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе вы разберёте задачу, в которой нужно раздать ограниченное количество конфет максимально возможному числу призёров, соблюдая строгий порядок награждения. Это пример нестандартной задачи, которую можно решить с помощью жадного подхода и внимательного анализа. Вы научитесь строить возрастающие последовательности и использовать арифметические свойства для оптимального распределения.\n\n## Ключевые вопросы параграфа\n\n* Как спланировать последовательность наград, чтобы максимизировать число получателей?\n* Почему здесь работает жадный подход и как доказать его корректность?\n* Как использовать свойства суммы арифметической прогрессии при решении алгоритмических задач?\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_6_5_1_c964476899_f29fc8d130.svg)\n\n## Нестандартная задача и жадный алгоритм\n\nВы занимаетесь организацией соревнований для детей, и у вас есть $n$ конфет, которые собираетесь раздать в качестве призов. Вы хотите отдать эти конфеты тем, кто займёт первые $k$ мест в соревнованиях, и распределить конфеты так, чтобы за более высокое место всегда выходило больше конфет. Чтобы порадовать как можно больше детей, вам понадобится найти самое большое значение $k$, при котором это возможно.\n\n* Входные данные: Целое число $n$.\n* Выходные данные: Первая строка содержит максимальное число $k$, при котором $n$ можно представить как сумму $k$ пар неповторяющихся положительных целых чисел. Вторая строка — $k$ пар неповторяющихся положительных целых чисел, сумма которых будет $n$ (если есть несколько таких вариантов, то можно использовать любой из них).\n* Ограничения: $1 \\le n \\le 10^9$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n6\n\n|\n\n3\u003cbr\u003e1 2 3\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n8\n\n|\n\n3\u003cbr\u003e1 2 5\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\n\n|\n\n1\u003cbr\u003e2\n\n||\n|#\n\n### Упражнение\n\nМожно ли представить 8 как сумму четырёх неповторяющихся положительных целых чисел?\n\nНетрудно понять, что ответ на этот вопрос: «Нет». Предположим, что $8=a_1+a_2+a_3+a_4$ и $a_1 \\lt a_2 \\lt a_3 \\lt a_4$ . Тогда $a_1 \\ge 1$, $a_2 \\ge 2$, $a_3 \\ge 3$ и $a_4 \\ge 4$. Однако тогда $a_1+a_2+a_3+a_4 \\ge 10$.\n\nПо этой же причине, если $n$ равно сумме $k$ неповторяющихся положительных целых чисел $a_1, \\dots, a_k$, то $n=a_1+\\dots+a_k \\ge 1+\\dots+k = \\frac{k(k+1)}{2}$. Верно и обратное: если $n \\ge \\frac{k(k+1)}{2}$, то можно представить $n$ как сумму $k$ неповторяющихся целых чисел.\n\nДействительно, пусть $\\delta=n - \\frac{k(k+1)}{2} \\ge 0$. Тогда $n$ будет равно сумме следующих целых чисел: $1, 2, \\dots, k-1,k+\\delta$. Несложно заметить, что все они отличаются друг от друга.\n\nАлгоритм состоит в нахождении самого большого значения $k$, при котором $\\frac{k(k+1)}{2} \\le n$.\n\nВремя выполнения — $O(k)$ или $O(\\sqrt{n})$.\n\n## Что дальше\n\nТеперь вы умеете применять жадные алгоритмы для распределения ограниченного ресурса и знаете, в каких случаях такая стратегия приводит к оптимальному решению.\n\nДалее — финальная задача главы. Она покажет, что даже на собеседовании можно столкнуться с подводными камнями жадной стратегии: чтобы получить максимальный «оклад», придётся сравнивать не числа, а строки.\n\nА пока вы не ушли дальше — закрепите материал на практике:\n\n* Отметьте, что урок прочитан, при помощи кнопки ниже.\n* Пройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\n* Перейдите к [задачам](https://new.contest.yandex.ru/contest/80770) этого параграфа и потренируйтесь.\n* Перед этим — загляните в короткий [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как работает система проверки.\n\nХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в [сообщество Хендбука](https://t.me/handbook_algorithms)! Там студенты помогают друг другу разобраться.\n\n### Ключевые выводы параграфа\n\n* Жадные алгоритмы хорошо работают в задачах распределения, когда нужно покрыть максимум с минимальными затратами.\n* Иногда достаточно отсортировать входные данные и обрабатывать их по порядку — это уже даёт оптимальный результат.\n* Простые стратегии требуют точной формулировки и аккуратной реализации — особенно при работе с ограничениями."])</script><script nonce="">self.__next_f.push([1,"94:T2ae9,"])</script><script nonce="">self.__next_f.push([1,"\u003cp\u003eВ этом параграфе вы разберёте задачу, в которой нужно раздать ограниченное количество конфет максимально возможному числу призёров, соблюдая строгий порядок награждения. Это пример нестандартной задачи, которую можно решить с помощью жадного подхода и внимательного анализа. Вы научитесь строить возрастающие последовательности и использовать арифметические свойства для оптимального распределения.\u003c/p\u003e\n\u003ch2 id=\"klyuchevye-voprosy-paragrafa\"\u003eКлючевые вопросы параграфа\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eКак спланировать последовательность наград, чтобы максимизировать число получателей?\u003c/li\u003e\n\u003cli\u003eПочему здесь работает жадный подход и как доказать его корректность?\u003c/li\u003e\n\u003cli\u003eКак использовать свойства суммы арифметической прогрессии при решении алгоритмических задач?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\u003cfigure class=\"fig-img\"\u003e\u003cimg class=\"img\" src=\"https://yastatic.net/s3/education-portal/media/algosy_6_5_1_c964476899_f29fc8d130.svg\" alt=\"algosy\" /\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003ch2 id=\"nestandartnaya-zadacha-i-zhadnyj-algoritm\"\u003eНестандартная задача и жадный алгоритм\u003c/h2\u003e\n\u003cp\u003eВы занимаетесь организацией соревнований для детей, и у вас есть \u003cspan class=\"yfm-latex\" data-content=\"n\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e конфет, которые собираетесь раздать в качестве призов. Вы хотите отдать эти конфеты тем, кто займёт первые \u003cspan class=\"yfm-latex\" data-content=\"k\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e мест в соревнованиях, и распределить конфеты так, чтобы за более высокое место всегда выходило больше конфет. Чтобы порадовать как можно больше детей, вам понадобится найти самое большое значение \u003cspan class=\"yfm-latex\" data-content=\"k\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e, при котором это возможно.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eВходные данные: Целое число \u003cspan class=\"yfm-latex\" data-content=\"n\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e.\u003c/li\u003e\n\u003cli\u003eВыходные данные: Первая строка содержит максимальное число \u003cspan class=\"yfm-latex\" data-content=\"k\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e, при котором \u003cspan class=\"yfm-latex\" data-content=\"n\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e можно представить как сумму \u003cspan class=\"yfm-latex\" data-content=\"k\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e пар неповторяющихся положительных целых чисел. Вторая строка — \u003cspan class=\"yfm-latex\" data-content=\"k\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e пар неповторяющихся положительных целых чисел, сумма которых будет \u003cspan class=\"yfm-latex\" data-content=\"n\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e (если есть несколько таких вариантов, то можно использовать любой из них).\u003c/li\u003e\n\u003cli\u003eОграничения: \u003cspan class=\"yfm-latex\" data-content=\"1%20%5Cle%20n%20%5Cle%2010%5E9\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"primer-1\"\u003eПример 1\u003c/h4\u003e\n\u003ctable\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003eВвод\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003eВывод\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003e6\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e3\u003cbr /\u003e1 2 3\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4 id=\"primer-2\"\u003eПример 2\u003c/h4\u003e\n\u003ctable\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003eВвод\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003eВывод\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003e8\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e3\u003cbr /\u003e1 2 5\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4 id=\"primer-3\"\u003eПример 3\u003c/h4\u003e\n\u003ctable\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003eВвод\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003eВывод\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003e2\u003c/p\u003e\n\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e1\u003cbr /\u003e2\u003c/p\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"uprazhnenie\"\u003eУпражнение\u003c/h3\u003e\n\u003cp\u003eМожно ли представить 8 как сумму четырёх неповторяющихся положительных целых чисел?\u003c/p\u003e\n\u003cp\u003eНетрудно понять, что ответ на этот вопрос: «Нет». Предположим, что \u003cspan class=\"yfm-latex\" data-content=\"8%3Da_1%2Ba_2%2Ba_3%2Ba_4\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e и \u003cspan class=\"yfm-latex\" data-content=\"a_1%20%5Clt%20a_2%20%5Clt%20a_3%20%5Clt%20a_4\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e . Тогда \u003cspan class=\"yfm-latex\" data-content=\"a_1%20%5Cge%201\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e, \u003cspan class=\"yfm-latex\" data-content=\"a_2%20%5Cge%202\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e, \u003cspan class=\"yfm-latex\" data-content=\"a_3%20%5Cge%203\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e и \u003cspan class=\"yfm-latex\" data-content=\"a_4%20%5Cge%204\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e. Однако тогда \u003cspan class=\"yfm-latex\" data-content=\"a_1%2Ba_2%2Ba_3%2Ba_4%20%5Cge%2010\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e.\u003c/p\u003e\n\u003cp\u003eПо этой же причине, если \u003cspan class=\"yfm-latex\" data-content=\"n\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e равно сумме \u003cspan class=\"yfm-latex\" data-content=\"k\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e неповторяющихся положительных целых чисел \u003cspan class=\"yfm-latex\" data-content=\"a_1%2C%20%5Cdots%2C%20a_k\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e, то \u003cspan class=\"yfm-latex\" data-content=\"n%3Da_1%2B%5Cdots%2Ba_k%20%5Cge%201%2B%5Cdots%2Bk%20%3D%20%5Cfrac%7Bk(k%2B1)%7D%7B2%7D\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e. Верно и обратное: если \u003cspan class=\"yfm-latex\" data-content=\"n%20%5Cge%20%5Cfrac%7Bk(k%2B1)%7D%7B2%7D\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e, то можно представить \u003cspan class=\"yfm-latex\" data-content=\"n\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e как сумму \u003cspan class=\"yfm-latex\" data-content=\"k\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e неповторяющихся целых чисел.\u003c/p\u003e\n\u003cp\u003eДействительно, пусть \u003cspan class=\"yfm-latex\" data-content=\"%5Cdelta%3Dn%20-%20%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cge%200\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e. Тогда \u003cspan class=\"yfm-latex\" data-content=\"n\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e будет равно сумме следующих целых чисел: \u003cspan class=\"yfm-latex\" data-content=\"1%2C%202%2C%20%5Cdots%2C%20k-1%2Ck%2B%5Cdelta\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e. Несложно заметить, что все они отличаются друг от друга.\u003c/p\u003e\n\u003cp\u003eАлгоритм состоит в нахождении самого большого значения \u003cspan class=\"yfm-latex\" data-content=\"k\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e, при котором \u003cspan class=\"yfm-latex\" data-content=\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e.\u003c/p\u003e\n\u003cp\u003eВремя выполнения — \u003cspan class=\"yfm-latex\" data-content=\"O(k)\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e или \u003cspan class=\"yfm-latex\" data-content=\"O(%5Csqrt%7Bn%7D)\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e.\u003c/p\u003e\n\u003ch2 id=\"chto-dalshe\"\u003eЧто дальше\u003c/h2\u003e\n\u003cp\u003eТеперь вы умеете применять жадные алгоритмы для распределения ограниченного ресурса и знаете, в каких случаях такая стратегия приводит к оптимальному решению.\u003c/p\u003e\n\u003cp\u003eДалее — финальная задача главы. Она покажет, что даже на собеседовании можно столкнуться с подводными камнями жадной стратегии: чтобы получить максимальный «оклад», придётся сравнивать не числа, а строки.\u003c/p\u003e\n\u003cp\u003eА пока вы не ушли дальше — закрепите материал на практике:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eОтметьте, что урок прочитан, при помощи кнопки ниже.\u003c/li\u003e\n\u003cli\u003eПройдите мини-квиз, чтобы проверить, насколько хорошо вы усвоили тему.\u003c/li\u003e\n\u003cli\u003eПерейдите к \u003ca href=\"https://new.contest.yandex.ru/contest/80770\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eзадачам\u003c/a\u003e этого параграфа и потренируйтесь.\u003c/li\u003e\n\u003cli\u003eПеред этим — загляните в короткий \u003ca href=\"https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii\"\u003eгайд\u003c/a\u003e о том, как работает система проверки.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eХотите обсудить, задать вопрос или не понимаете, почему код не работает? Мы всё предусмотрели — вступайте в \u003ca href=\"https://t.me/handbook_algorithms\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eсообщество Хендбука\u003c/a\u003e! Там студенты помогают друг другу разобраться.\u003c/p\u003e\n\u003ch3 id=\"klyuchevye-vyvody-paragrafa\"\u003eКлючевые выводы параграфа\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eЖадные алгоритмы хорошо работают в задачах распределения, когда нужно покрыть максимум с минимальными затратами.\u003c/li\u003e\n\u003cli\u003eИногда достаточно отсортировать входные данные и обрабатывать их по порядку — это уже даёт оптимальный результат.\u003c/li\u003e\n\u003cli\u003eПростые стратегии требуют точной формулировки и аккуратной реализации — особенно при работе с ограничениями.\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script nonce="">self.__next_f.push([1,"8d:[\"$\",\"div\",null,{\"className\":\"styles_container__SBhDc\",\"children\":[[\"$\",\"$L8e\",null,{\"targetEl\":\"#article-content\",\"offset\":60}],[\"$\",\"div\",null,{\"className\":\"styles_articleCover__EKYZn\",\"children\":[[\"$\",\"$L8f\",null,{\"className\":\"styles_breadcrumbs__nMPkF\",\"items\":[{\"title\":\"Хендбуки\",\"href\":\"/handbook\",\"hardNavigate\":true},{\"title\":\"Основы алгоритмов\",\"href\":\"/handbook/algorithms\",\"showMobile\":true},{\"title\":\"Задача «Количество призов»\"}]}],null,[\"$\",\"h1\",null,{\"ref\":\"$undefined\",\"className\":\"styles_root__EmBCZ styles_title__Ae0WW\",\"style\":{},\"data-search-hidden\":true,\"children\":\"7.5 Задача «Количество призов»\",\"data-variant\":\"heading\",\"data-weight\":\"medium\",\"data-color\":\"primary\"}],[\"$\",\"div\",null,{\"className\":\"styles_authors__hRs06\",\"children\":[[\"$\",\"span\",null,{\"ref\":\"$undefined\",\"className\":\"styles_root__EmBCZ styles_title__rlqZz\",\"style\":{},\"children\":\"Авторы\",\"data-variant\":\"$undefined\",\"data-weight\":\"medium\",\"data-color\":\"primary\"}],[[\"$\",\"$L90\",\"author-70\",{\"href\":\"../team#tolstikov\",\"className\":\"styles_author__OycJw\",\"children\":[[\"$\",\"div\",null,{\"className\":\"styles_avatar__hR8ST\",\"children\":[\"$\",\"$L91\",null,{\"aria-hidden\":true,\"name\":\"Алексей Толстиков\",\"caption\":null,\"width\":1863,\"height\":1809,\"hash\":\"tolstikov_60bac4f4ce_9fe4041647\",\"ext\":\".webp\",\"mime\":\"image/webp\",\"size\":208.27,\"url\":\"https://yastatic.net/s3/education-portal/media/tolstikov_60bac4f4ce_9fe4041647.webp\",\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"ref\":\"$undefined\",\"src\":\"https://yastatic.net/s3/education-portal/media/tolstikov_60bac4f4ce_9fe4041647.webp\",\"alt\":\"Алексей Толстиков\",\"className\":\"$undefined\"}]}],[\"$\",\"div\",null,{\"className\":\"styles_name__Fz_z2\",\"children\":[\"$\",\"span\",null,{\"children\":\"Алексей Толстиков\"}]}]]}],[\"$\",\"$L90\",\"author-71\",{\"href\":\"../team#kulikov\",\"className\":\"styles_author__OycJw\",\"children\":[[\"$\",\"div\",null,{\"className\":\"styles_avatar__hR8ST\",\"children\":[\"$\",\"$L91\",null,{\"aria-hidden\":true,\"name\":\"Александр Куликов\",\"caption\":null,\"width\":1135,\"height\":1280,\"hash\":\"kulikov_75205593a5_f3f4036ed9\",\"ext\":\".webp\",\"mime\":\"image/webp\",\"size\":90.21,\"url\":\"https://yastatic.net/s3/education-portal/media/kulikov_75205593a5_f3f4036ed9.webp\",\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"ref\":\"$undefined\",\"src\":\"https://yastatic.net/s3/education-portal/media/kulikov_75205593a5_f3f4036ed9.webp\",\"alt\":\"Александр Куликов\",\"className\":\"$undefined\"}]}],[\"$\",\"div\",null,{\"className\":\"styles_name__Fz_z2\",\"children\":[\"$\",\"span\",null,{\"children\":\"Александр Куликов\"}]}]]}]]]}]]}],[\"$\",\"main\",null,{\"className\":\"styles_root__R5rVX\",\"data-testid\":\"ArticleContent-root\",\"data-ai-main-material\":true,\"children\":[null,[\"$\",\"div\",null,{\"className\":\"hljs_hljs-atelier-heath__2Efzm styles_content__jb6Og\",\"id\":\"article-content\",\"children\":[\"$\",\"$L92\",null,{\"Content\":\"$93\",\"csrfToken\":\"\",\"isNotesAvailable\":true,\"vars\":{},\"html\":\"$94\"}]}]]}],\"$L95\",\"$L96\",\"$L97\",null,\"$L98\"]}]\n"])</script><script nonce="">self.__next_f.push([1,"99:I[78166,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"ArticleProgressConnected\"]\n9a:I[87289,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"ArticleActionConnected\"]\ndc:I[554,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"NavigationBlock\"]\ndd:I[30885,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"HanbookCommunityBanner\"]\n95:[\"$\",\"$L99\",null,{\"bookSlug\":\"algorithms\",\"articleSlug\":\"zadacha-kolichestvo-prizov\",\"passportUrl\":\"https://passport.yandex.ru/auth/?origin=education\u0026retpath=https%3A%2F%2Feduc"])</script><script nonce="">self.__next_f.push([1,"ation.yandex.ru%2Fhandbook%2Falgorithms%2Farticle%2Fzadacha-kolichestvo-prizov\",\"csrfToken\":\"\",\"ErrorAction\":{\"id\":3761,\"Text\":\"Сообщить об ошибке\",\"URL\":\"https://forms.yandex.ru/surveys/academy/?proekt=handbooks\",\"Title\":\"Сообщить об ошибке\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":null,\"Description\":null,\"MetrikaGoalParams\":null},\"paragraphV2\":true,\"isAuthorized\":false}]\n"])</script><script nonce="">self.__next_f.push([1,"96:[\"$\",\"$L9a\",null,{\"contestURL\":\"https://new.contest.yandex.ru/contest/80770/problem\",\"CTAs\":[],\"ErrorAction\":\"$95:props:ErrorAction\",\"questions\":[{\"question\":[\"$\",\"$L92\",null,{\"Content\":\"В чём заключается основная задача при распределении $n$ конфет между участниками, занявшими первые $k$ мест?\",\"html\":\"\u003cp\u003eВ чём заключается основная задача при распределении \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e конфет между участниками, занявшими первые \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e мест?\u003c/p\u003e\\n\"}],\"answers\":[{\"text\":[\"$\",\"$L92\",null,{\"Content\":\"Задача — распределить $n$ конфет так, чтобы за более высокое место давали больше конфет.\",\"html\":\"\u003cp\u003eЗадача — распределить \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e конфет так, чтобы за более высокое место давали больше конфет.\u003c/p\u003e\\n\"}],\"generated_as_correct\":true},{\"text\":[\"$\",\"$L92\",null,{\"Content\":\"Основная задача заключается в распределении конфет таким образом, чтобы участники, занявшие последние места, получили больше конфет, чем те, кто занял первые места.\",\"html\":\"\u003cp\u003eОсновная задача заключается в распределении конфет таким образом, чтобы участники, занявшие последние места, получили больше конфет, чем те, кто занял первые места.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false},{\"text\":[\"$\",\"$L92\",null,{\"Content\":\"Основная задача при распределении конфет — это разработка алгоритма для случайного распределения конфет между всеми участниками без учёта занятых мест.\",\"html\":\"\u003cp\u003eОсновная задача при распределении конфет — это разработка алгоритма для случайного распределения конфет между всеми участниками без учёта занятых мест.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false},{\"text\":[\"$\",\"$L92\",null,{\"Content\":\"Задача — распределить $n$ конфет поровну между всеми участниками.\",\"html\":\"\u003cp\u003eЗадача — распределить \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e конфет поровну между всеми участниками.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false}]},{\"question\":[\"$\",\"$L92\",null,{\"Content\":\"Почему в задаче распределения конфет важно, чтобы за более высокое место всегда выходило больше конфет?\",\"html\":\"\u003cp\u003eПочему в задаче распределения конфет важно, чтобы за более высокое место всегда выходило больше конфет?\u003c/p\u003e\\n\"}],\"answers\":[{\"text\":[\"$\",\"$L92\",null,{\"Content\":\"Чтобы обеспечить мотивацию участников и оптимально распределить конфеты, за более высокое место должно быть больше конфет.\",\"html\":\"\u003cp\u003eЧтобы обеспечить мотивацию участников и оптимально распределить конфеты, за более высокое место должно быть больше конфет.\u003c/p\u003e\\n\"}],\"generated_as_correct\":true},{\"text\":[\"$\",\"$L92\",null,{\"Content\":\"В задаче распределения конфет не имеет значения, сколько конфет получает участник за место, главное — чтобы общее количество конфет было распределено поровну между всеми участниками.\",\"html\":\"\u003cp\u003eВ задаче распределения конфет не имеет значения, сколько конфет получает участник за место, главное — чтобы общее количество конфет было распределено поровну между всеми участниками.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false},{\"text\":[\"$\",\"$L92\",null,{\"Content\":\"В задаче распределения конфет важно учитывать вкусовые предпочтения участников, чтобы каждый получил конфеты, которые ему нравятся.\",\"html\":\"\u003cp\u003eВ задаче распределения конфет важно учитывать вкусовые предпочтения участников, чтобы каждый получил конфеты, которые ему нравятся.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false},{\"text\":[\"$\",\"$L92\",null,{\"Content\":\"Чтобы сделать распределение более справедливым, за более высокое место должно быть меньше конфет.\",\"html\":\"\u003cp\u003eЧтобы сделать распределение более справедливым, за более высокое место должно быть меньше конфет.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false}]},{\"question\":\"$L9b\",\"answers\":[{\"text\":\"$L9c\",\"generated_as_correct\":true},{\"text\":\"$L9d\",\"generated_as_correct\":false},{\"text\":\"$L9e\",\"generated_as_correct\":false},{\"text\":\"$L9f\",\"generated_as_correct\":false}]},{\"question\":\"$La0\",\"answers\":[{\"text\":\"$La1\",\"generated_as_correct\":true},{\"text\":\"$La2\",\"generated_as_correct\":false},{\"text\":\"$La3\",\"generated_as_correct\":false},{\"text\":\"$La4\",\"generated_as_correct\":false}]},{\"question\":\"$La5\",\"answers\":[{\"text\":\"$La6\",\"generated_as_correct\":true},{\"text\":\"$La7\",\"generated_as_correct\":false},{\"text\":\"$La8\",\"generated_as_correct\":false},{\"text\":\"$La9\",\"generated_as_correct\":false}]},{\"question\":\"$Laa\",\"answers\":[{\"text\":\"$Lab\",\"generated_as_correct\":true},{\"text\":\"$Lac\",\"generated_as_correct\":false},{\"text\":\"$Lad\",\"generated_as_correct\":false},{\"text\":\"$Lae\",\"generated_as_correct\":false}]},{\"question\":\"$Laf\",\"answers\":[{\"text\":\"$Lb0\",\"generated_as_correct\":true},{\"text\":\"$Lb1\",\"generated_as_correct\":false},{\"text\":\"$Lb2\",\"generated_as_correct\":false},{\"text\":\"$Lb3\",\"generated_as_correct\":false}]},{\"question\":\"$Lb4\",\"answers\":[{\"text\":\"$Lb5\",\"generated_as_correct\":true},{\"text\":\"$Lb6\",\"generated_as_correct\":false},{\"text\":\"$Lb7\",\"generated_as_correct\":false},{\"text\":\"$Lb8\",\"generated_as_correct\":false}]},{\"question\":\"$Lb9\",\"answers\":[{\"text\":\"$Lba\",\"generated_as_correct\":true},{\"text\":\"$Lbb\",\"generated_as_correct\":false},{\"text\":\"$Lbc\",\"generated_as_correct\":false},{\"text\":\"$Lbd\",\"generated_as_correct\":false}]},{\"question\":\"$Lbe\",\"answers\":[{\"text\":\"$Lbf\",\"generated_as_correct\":true},{\"text\":\"$Lc0\",\"generated_as_correct\":false},{\"text\":\"$Lc1\",\"generated_as_correct\":false},{\"text\":\"$Lc2\",\"generated_as_correct\":false}]},{\"question\":\"$Lc3\",\"answers\":[{\"text\":\"$Lc4\",\"generated_as_correct\":true},{\"text\":\"$Lc5\",\"generated_as_correct\":false},{\"text\":\"$Lc6\",\"generated_as_correct\":false},{\"text\":\"$Lc7\",\"generated_as_correct\":false}]},{\"question\":\"$Lc8\",\"answers\":[{\"text\":\"$Lc9\",\"generated_as_correct\":true},{\"text\":\"$Lca\",\"generated_as_correct\":false},{\"text\":\"$Lcb\",\"generated_as_correct\":false},{\"text\":\"$Lcc\",\"generated_as_correct\":false}]},{\"question\":\"$Lcd\",\"answers\":[{\"text\":\"$Lce\",\"generated_as_correct\":true},{\"text\":\"$Lcf\",\"generated_as_correct\":false},{\"text\":\"$Ld0\",\"generated_as_correct\":false},{\"text\":\"$Ld1\",\"generated_as_correct\":false}]},{\"question\":\"$Ld2\",\"answers\":[{\"text\":\"$Ld3\",\"generated_as_correct\":true},{\"text\":\"$Ld4\",\"generated_as_correct\":false},{\"text\":\"$Ld5\",\"generated_as_correct\":false},{\"text\":\"$Ld6\",\"generated_as_correct\":false}]},{\"question\":\"$Ld7\",\"answers\":[{\"text\":\"$Ld8\",\"generated_as_correct\":true},{\"text\":\"$Ld9\",\"generated_as_correct\":false},{\"text\":\"$Lda\",\"generated_as_correct\":false},{\"text\":\"$Ldb\",\"generated_as_correct\":false}]}],\"passportUrl\":\"https://passport.yandex.ru/auth/?origin=education\u0026retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Falgorithms%2Farticle%2Fzadacha-kolichestvo-prizov\",\"isAuthorized\":false,\"csrfToken\":\"\",\"paragraphV2\":true}]\n"])</script><script nonce="">self.__next_f.push([1,"97:[\"$\",\"div\",null,{\"className\":\"styles_article-navigate__SKki7\",\"data-testid\":\"ArticleNavigate-root\",\"children\":[[\"$\",\"$Ldc\",\"zadacha-sbor-podpisej\",{\"label\":\"Предыдущий параграф\",\"title\":\"7.4. Задача «Сбор подписей»\",\"lead\":null,\"url\":\"./zadacha-sbor-podpisej\",\"direction\":\"back\"}],[\"$\",\"$Ldc\",\"zadacha-maksimalnyj-oklad\",{\"label\":\"Следующий параграф\",\"title\":\"7.6. Задача «Максимальный оклад»\",\"lead\":null,\"url\":\"./zadacha-maksimalnyj-oklad\",\"direction\":\"forward\"}]]}]\n"])</script><script nonce="">self.__next_f.push([1,"98:[\"$\",\"$Ldd\",null,{\"banner\":{\"id\":109,\"Title\":\"Вступайте в\u0026nbsp;сообщество хендбука\",\"Description\":\"Здесь можно найти единомышленников, экспертов и\u0026nbsp;просто интересных собеседников. А\u0026nbsp;ещё\u0026nbsp;— получить помощь или поделиться знаниями.\",\"ActionType\":null,\"Icon\":{\"data\":{\"id\":16699,\"attributes\":{\"name\":\"Poluchajte\",\"alternativeText\":null,\"caption\":null,\"width\":237,\"height\":124,\"formats\":null,\"hash\":\"Poluchajte_obnovleniya_ot_obrazovaniya_30910b54df_61ea47b298\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":33.89,\"url\":\"https://yastatic.net/s3/education-portal/media/Poluchajte_obnovleniya_ot_obrazovaniya_30910b54df_61ea47b298.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2025-09-02T08:53:15.484Z\",\"updatedAt\":\"2025-12-23T22:37:04.357Z\"}}},\"Action\":{\"id\":5541,\"Text\":\"Вступить\",\"URL\":\"https://t.me/handbook_algorithms\",\"Title\":\"Вступить\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null}},\"referer\":null}]\n"])</script><script nonce="">self.__next_f.push([1,"9b:[\"$\",\"$L92\",null,{\"Content\":\"Как можно применить принцип распределения конфет для определения максимального количества участников, которые могут получить призы?\",\"html\":\"\u003cp\u003eКак можно применить принцип распределения конфет для определения максимального количества участников, которые могут получить призы?\u003c/p\u003e\\n\"}]\n9c:[\"$\",\"$L92\",null,{\"Content\":\"Распределение конфет между $k$ участниками так, чтобы за более высокое место было больше конфет, позволяет найти максимальное количество участников.\",\"html\":\"\u003cp\u003eРаспределение конфет между \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e участниками так, чтобы за более высокое место было больше конфет, позволяет найти максимальное количество участников.\u003c/p\u003e\\n\"}]\n9d:[\"$\",\"$L92\",null,{\"Content\":\"Принцип распределения конфет заключается в равномерном распределении $n$ конфет между всеми участниками, независимо от занятого места. Задача заключается в определении общего количества конфет, необходимых для такого распределения.\",\"html\":\"\u003cp\u003eПринцип распределения конфет заключается в равномерном распределении \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e конфет между всеми участниками, независимо от занято"])</script><script nonce="">self.__next_f.push([1,"го места. Задача заключается в определении общего количества конфет, необходимых для такого распределения.\u003c/p\u003e\\n\"}]\n9e:[\"$\",\"$L92\",null,{\"Content\":\"Принцип распределения конфет связан с теорией вероятностей и может быть использован для определения вероятности получения определённого количества конфет каждым участником.\",\"html\":\"\u003cp\u003eПринцип распределения конфет связан с теорией вероятностей и может быть использован для определения вероятности получения определённого количества конфет каждым участником.\u003c/p\u003e\\n\"}]\n9f:[\"$\",\"$L92\",null,{\"Content\":\"Распределение конфет между участниками происходит таким образом, что за каждое место даётся одинаковое количество конфет.\",\"html\":\"\u003cp\u003eРаспределение конфет между участниками происходит таким образом, что за каждое место даётся одинаковое количество конфет.\u003c/p\u003e\\n\"}]\na0:[\"$\",\"$L92\",null,{\"Content\":\"Что требуется сделать для представления числа \\\\( n \\\\) в виде суммы \\\\( k \\\\) пар неповторяющихся положительных целых чисел?\",\"html\":\"\u003cp\u003eЧто требуется сделать для представления числа ( n ) в виде суммы ( k ) пар неповторяющихся положительных целых чисел?\u003c/p\u003e\\n\"}]\na1:[\"$\",\"$L92\",null,{\"Content\":\"Найти $k$ пар уникальных положительных чисел, сумма которых равна $"])</script><script nonce="">self.__next_f.push([1,"n$.\",\"html\":\"\u003cp\u003eНайти \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e пар уникальных положительных чисел, сумма которых равна \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\na2:[\"$\",\"$L92\",null,{\"Content\":\"Нужно представить число $n$ как сумму $k$ отдельных чисел (не пар), где каждое число уникально и положительно.\",\"html\":\"\u003cp\u003eНужно представить число \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e как сумму \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e отдельных чисел (не пар), где каждое число уникально и положительно.\u003c/p\u003e\\n\"}]\na3:[\"$\",\"$L92\",null,{\"Content\":\"Для представления числа $n$ в виде суммы $k$ пар чисел необходимо использовать теорему о сумме арифметической прогрессии.\",\"html\":\"\u003cp\u003eДля представления числа \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e в виде суммы \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e пар чисел необходимо использовать теорему о сумме арифметической прогрессии.\u003c/p\u003e\\n\"}]\na4:[\"$\",\"$L92\",null,{\"Content\":\"Представить $n$ как сумму $k$ одинаковых пар положительных чисел.\",\"html\":\"\u003cp\u003eПредставить \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e как сумму \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displa"])</script><script nonce="">self.__next_f.push([1,"yMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e одинаковых пар положительных чисел.\u003c/p\u003e\\n\"}]\na5:[\"$\",\"$L92\",null,{\"Content\":\"Почему важно, чтобы все числа в парах были уникальными при представлении числа \\\\( n \\\\)?\",\"html\":\"\u003cp\u003eПочему важно, чтобы все числа в парах были уникальными при представлении числа ( n )?\u003c/p\u003e\\n\"}]\na6:[\"$\",\"$L92\",null,{\"Content\":\"Уникальность чисел в парах необходима для правильного распределения призов, чтобы избежать повторений.\",\"html\":\"\u003cp\u003eУникальность чисел в парах необходима для правильного распределения призов, чтобы избежать повторений.\u003c/p\u003e\\n\"}]\na7:[\"$\",\"$L92\",null,{\"Content\":\"Уникальность чисел в парах важна, потому что это позволяет упростить подсчёт общего количества призов, так как каждое число вносит уникальный вклад в сумму \\\\( n \\\\).\",\"html\":\"\u003cp\u003eУникальность чисел в парах важна, потому что это позволяет упростить подсчёт общего количества призов, так как каждое число вносит уникальный вклад в сумму ( n ).\u003c/p\u003e\\n\"}]\na8:[\"$\",\"$L92\",null,{\"Content\":\"Уникальность чисел в парах важна для обеспечения уникальности идентификаторов в системах управления данными, что не связано напрямую с представлением числа \\\\( n \\\\) в виде суммы пар.\",\"html\":\"\u003cp\u003eУникальность чисел в парах важна для обеспечения уникальности иде"])</script><script nonce="">self.__next_f.push([1,"нтификаторов в системах управления данными, что не связано напрямую с представлением числа ( n ) в виде суммы пар.\u003c/p\u003e\\n\"}]\na9:[\"$\",\"$L92\",null,{\"Content\":\"Уникальность чисел в парах не важна, так как главное — достичь суммы \\\\( n \\\\), а повторения чисел не влияют на результат.\",\"html\":\"\u003cp\u003eУникальность чисел в парах не важна, так как главное — достичь суммы ( n ), а повторения чисел не влияют на результат.\u003c/p\u003e\\n\"}]\naa:[\"$\",\"$L92\",null,{\"Content\":\"Как можно применить задачу представления числа \\\\( n \\\\) в виде суммы пар для распределения призов?\",\"html\":\"\u003cp\u003eКак можно применить задачу представления числа ( n ) в виде суммы пар для распределения призов?\u003c/p\u003e\\n\"}]\nab:[\"$\",\"$L92\",null,{\"Content\":\"Задача представления числа \\\\( n \\\\) в виде суммы \\\\( k \\\\) пар уникальных чисел применяется для распределения призов, где каждая пара определяет количество конфет за место.\",\"html\":\"\u003cp\u003eЗадача представления числа ( n ) в виде суммы ( k ) пар уникальных чисел применяется для распределения призов, где каждая пара определяет количество конфет за место.\u003c/p\u003e\\n\"}]\nac:[\"$\",\"$L92\",null,{\"Content\":\"Задача представления числа \\\\( n \\\\) в виде суммы \\\\( k \\\\) пар чисел может быть использована для распределения призов, где количество конфет, выданных з"])</script><script nonce="">self.__next_f.push([1,"а каждое место, определяется случайным образом без учёта уникальности чисел в парах.\",\"html\":\"\u003cp\u003eЗадача представления числа ( n ) в виде суммы ( k ) пар чисел может быть использована для распределения призов, где количество конфет, выданных за каждое место, определяется случайным образом без учёта уникальности чисел в парах.\u003c/p\u003e\\n\"}]\nad:[\"$\",\"$L92\",null,{\"Content\":\"Задача представления числа \\\\( n \\\\) в виде суммы пар чисел связана с теорией чисел и может быть использована для анализа статистических данных о распределении призов, но не для непосредственного распределения.\",\"html\":\"\u003cp\u003eЗадача представления числа ( n ) в виде суммы пар чисел связана с теорией чисел и может быть использована для анализа статистических данных о распределении призов, но не для непосредственного распределения.\u003c/p\u003e\\n\"}]\nae:[\"$\",\"$L92\",null,{\"Content\":\"Задача представления числа \\\\( n \\\\) в виде суммы \\\\( k \\\\) пар чисел используется для распределения призов, где пары могут содержать повторяющиеся числа.\",\"html\":\"\u003cp\u003eЗадача представления числа ( n ) в виде суммы ( k ) пар чисел используется для распределения призов, где пары могут содержать повторяющиеся числа.\u003c/p\u003e\\n\"}]\naf:[\"$\",\"$L92\",null,{\"Content\":\"Что позволяет "])</script><script nonce="">self.__next_f.push([1,"определить формула $\\\\frac{k(k+1)}{2} \\\\le n$?\",\"html\":\"\u003cp\u003eЧто позволяет определить формула \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e?\u003c/p\u003e\\n\"}]\nb0:[\"$\",\"$L92\",null,{\"Content\":\"Формула $\\\\frac{k(k+1)}{2} \\\\le n$ определяет максимальное $k$ для количества пар чисел с суммой, не превышающей $n$.\",\"html\":\"\u003cp\u003eФормула \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e определяет максимальное \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e для количества пар чисел с суммой, не превышающей \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\nb1:[\"$\",\"$L92\",null,{\"Content\":\"Формула $\\\\frac{k(k+1)}{2} \\\\le n$ применяется для вычисления суммы всех чисел от 1 до $n$, не учитывая при этом максимальное значение $k$.\",\"html\":\"\u003cp\u003eФормула \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e применяется для вычисления суммы всех чисел от 1 до \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e, не учитывая при этом максимальное значение \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\nb2:[\"$\",\"$L92\",null,{\"Content\":\"Формула $\\\\frac{k(k+1)}{2} \\\\le n$ связана с вычислением площади под кривой и используется в интегральном"])</script><script nonce="">self.__next_f.push([1," исчислении.\",\"html\":\"\u003cp\u003eФормула \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e связана с вычислением площади под кривой и используется в интегральном исчислении.\u003c/p\u003e\\n\"}]\nb3:[\"$\",\"$L92\",null,{\"Content\":\"Формула $\\\\frac{k(k+1)}{2} \\\\le n$ служит для нахождения минимального $k$, при котором сумма чисел равна $n$.\",\"html\":\"\u003cp\u003eФормула \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e служит для нахождения минимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e, при котором сумма чисел равна \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\nb4:[\"$\",\"$L92\",null,{\"Content\":\"На каком математическом принципе основана данная формула?\",\"html\":\"\u003cp\u003eНа каком математическом принципе основана данная формула?\u003c/p\u003e\\n\"}]\nb5:[\"$\",\"$L92\",null,{\"Content\":\"Формула для определения максимального $k$ основана на сумме арифметической прогрессии.\",\"html\":\"\u003cp\u003eФормула для определения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e основана на сумме арифметической прогрессии.\u003c/p\u003e\\n\"}]\nb6:[\"$\",\"$L92\",null,{\"Content\":\"Формула для определения максимального $k$ базируется на принципе комбинаторики, который используется для вычислени"])</script><script nonce="">self.__next_f.push([1,"я количества возможных комбинаций чисел без учёта их суммы.\",\"html\":\"\u003cp\u003eФормула для определения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e базируется на принципе комбинаторики, который используется для вычисления количества возможных комбинаций чисел без учёта их суммы.\u003c/p\u003e\\n\"}]\nb7:[\"$\",\"$L92\",null,{\"Content\":\"Формула для определения максимального $k$ связана с теорией вероятностей и используется для расчёта вероятности выпадения определённых чисел в случайном эксперименте.\",\"html\":\"\u003cp\u003eФормула для определения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e связана с теорией вероятностей и используется для расчёта вероятности выпадения определённых чисел в случайном эксперименте.\u003c/p\u003e\\n\"}]\nb8:[\"$\",\"$L92\",null,{\"Content\":\"Формула для определения максимального $k$ основана на принципе факторизации чисел.\",\"html\":\"\u003cp\u003eФормула для определения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e основана на принципе факторизации чисел.\u003c/p\u003e\\n\"}]\nb9:[\"$\",\"$L92\",null,{\"Content\":\"В каких ситуациях может быть полезно применение этой формулы для определения максимального $k$?\",\"html\":\"\u003cp\u003eВ каких ситуациях может быть"])</script><script nonce="">self.__next_f.push([1," полезно применение этой формулы для определения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e?\u003c/p\u003e\\n\"}]\nba:[\"$\",\"$L92\",null,{\"Content\":\"Формула для определения максимального $k$ полезна для нахождения оптимального количества пар чисел с суммой, не превышающей $n$.\",\"html\":\"\u003cp\u003eФормула для определения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e полезна для нахождения оптимального количества пар чисел с суммой, не превышающей \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\nbb:[\"$\",\"$L92\",null,{\"Content\":\"Формула для определения максимального $k$ используется для расчёта количества комбинаций, при которых сумма случайных чисел равна $n$, без учёта порядка их следования.\",\"html\":\"\u003cp\u003eФормула для определения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e используется для расчёта количества комбинаций, при которых сумма случайных чисел равна \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e, без учёта порядка их следования.\u003c/p\u003e\\n\"}]\nbc:[\"$\",\"$L92\",null,{\"Content\":\"Формула для определения максимального $k$ может быть использована для анализа последовательностей в теории чисел и "])</script><script nonce="">self.__next_f.push([1,"для определения свойств арифметических прогрессий.\",\"html\":\"\u003cp\u003eФормула для определения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e может быть использована для анализа последовательностей в теории чисел и для определения свойств арифметических прогрессий.\u003c/p\u003e\\n\"}]\nbd:[\"$\",\"$L92\",null,{\"Content\":\"Формула для определения максимального $k$ используется для вычисления минимального количества чисел, сумма которых равна $n$.\",\"html\":\"\u003cp\u003eФормула для определения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e используется для вычисления минимального количества чисел, сумма которых равна \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\nbe:[\"$\",\"$L92\",null,{\"Content\":\"Что представляет собой алгоритм нахождения максимального $k$?\",\"html\":\"\u003cp\u003eЧто представляет собой алгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e?\u003c/p\u003e\\n\"}]\nbf:[\"$\",\"$L92\",null,{\"Content\":\"Алгоритм нахождения максимального $k$ определяет наибольшее $k$, для которого $\\\\frac{k(k+1)}{2} \\\\le n$.\",\"html\":\"\u003cp\u003eАлгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e определяет наибольшее \u003cspan class=\\\"yfm-la"])</script><script nonce="">self.__next_f.push([1,"tex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e, для которого \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\n"])</script><script nonce="">self.__next_f.push([1,"c0:[\"$\",\"$L92\",null,{\"Content\":\"Алгоритм нахождения максимального $k$ предполагает поиск такого значения $k$, что $k^2 \\\\le n$, где $n$ — общее количество конфет. Это значение используется для определения максимального количества участников, которые могут получить призы.\",\"html\":\"\u003cp\u003eАлгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e предполагает поиск такого значения \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e, что \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k%5E2%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e, где \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e — общее количество конфет. Это значение используется для определения максимального количества участников, которые могут получить призы.\u003c/p\u003e\\n\"}]\n"])</script><script nonce="">self.__next_f.push([1,"c1:[\"$\",\"$L92\",null,{\"Content\":\"Алгоритм нахождения максимального $k$ связан с методами оптимизации и используется для распределения ресурсов в условиях ограниченного бюджета.\",\"html\":\"\u003cp\u003eАлгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e связан с методами оптимизации и используется для распределения ресурсов в условиях ограниченного бюджета.\u003c/p\u003e\\n\"}]\nc2:[\"$\",\"$L92\",null,{\"Content\":\"Алгоритм нахождения максимального $k$ ищет такое $k$, что $k \\\\le n$.\",\"html\":\"\u003cp\u003eАлгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e ищет такое \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e, что \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\nc3:[\"$\",\"$L92\",null,{\"Content\":\"Почему в алгоритме нахождения максимального $k$ используется неравенство $\\\\frac{k(k+1)}{2} \\\\le n$?\",\"html\":\"\u003cp\u003eПочему в алгоритме нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e используется неравенство \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e?\u003c/p\u003e\\n\"}]\nc4:[\"$\",\"$L92\",null,{\"Content\":\"Неравенство $\\\\frac{k(k+1)}{2} \\\\le n$ используется для нахождения максимального количества участ"])</script><script nonce="">self.__next_f.push([1,"ников, получающих призы, при заданном количестве конфет $n$.\",\"html\":\"\u003cp\u003eНеравенство \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e используется для нахождения максимального количества участников, получающих призы, при заданном количестве конфет \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\nc5:[\"$\",\"$L92\",null,{\"Content\":\"В алгоритме нахождения максимального $k$ используется неравенство $\\\\frac{k(k+1)}{2} \\\\le n$, чтобы найти минимальное количество конфет, необходимых для распределения среди участников.\",\"html\":\"\u003cp\u003eВ алгоритме нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e используется неравенство \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e, чтобы найти минимальное количество конфет, необходимых для распределения среди участников.\u003c/p\u003e\\n\"}]\nc6:[\"$\",\"$L92\",null,{\"Content\":\"В алгоритме нахождения максимального $k$ используется неравенство $\\\\frac{k(k+1)}{2} \\\\le n$ для определения оптимального количества раундов в соревновании, не связанного с распределением призов.\",\"html\":\"\u003cp\u003eВ алгоритме нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%"])</script><script nonce="">self.__next_f.push([1,"22%3Afalse%7D\\\"\u003e\u003c/span\u003e используется неравенство \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e для определения оптимального количества раундов в соревновании, не связанного с распределением призов.\u003c/p\u003e\\n\"}]\nc7:[\"$\",\"$L92\",null,{\"Content\":\"Неравенство $\\\\frac{k(k+1)}{2} \\\\le n$ применяется для вычисления общего количества конфет, необходимых для всех участников соревнования.\",\"html\":\"\u003cp\u003eНеравенство \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e применяется для вычисления общего количества конфет, необходимых для всех участников соревнования.\u003c/p\u003e\\n\"}]\nc8:[\"$\",\"$L92\",null,{\"Content\":\"Как можно применить алгоритм нахождения максимального $k$ для организации соревнований с призами?\",\"html\":\"\u003cp\u003eКак можно применить алгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e для организации соревнований с призами?\u003c/p\u003e\\n\"}]\nc9:[\"$\",\"$L92\",null,{\"Content\":\"Алгоритм нахождения максимального $k$ определяет максимальное количество участников, получающих призы, по формуле $\\\\frac{k(k+1)}{2} \\\\le n$.\",\"html\":\"\u003cp\u003eАлгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e определяет максима"])</script><script nonce="">self.__next_f.push([1,"льное количество участников, получающих призы, по формуле \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"%5Cfrac%7Bk(k%2B1)%7D%7B2%7D%20%5Cle%20n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\nca:[\"$\",\"$L92\",null,{\"Content\":\"Алгоритм нахождения максимального $k$ применяется для расчёта общего количества призов, которые нужно подготовить для участников соревнований, исходя из количества участников $n$.\",\"html\":\"\u003cp\u003eАлгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e применяется для расчёта общего количества призов, которые нужно подготовить для участников соревнований, исходя из количества участников \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\ncb:[\"$\",\"$L92\",null,{\"Content\":\"Алгоритм нахождения максимального $k$ связан с определением количества раундов в соревновании, где каждый раунд требует определённое количество конфет для проведения.\",\"html\":\"\u003cp\u003eАлгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e связан с определением количества раундов в соревновании, где каждый раунд требует определённое количество конфет для проведения.\u003c/p\u003e\\n\"}]\ncc:[\"$\",\"$L92\",null,{\"Content\":\"Алгоритм нахождения максимального $k$ помог"])</script><script nonce="">self.__next_f.push([1,"ает определить минимальное количество призов, необходимых для награждения участников соревнований.\",\"html\":\"\u003cp\u003eАлгоритм нахождения максимального \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e помогает определить минимальное количество призов, необходимых для награждения участников соревнований.\u003c/p\u003e\\n\"}]\ncd:[\"$\",\"$L92\",null,{\"Content\":\"Что означает запись времени выполнения алгоритма в виде $O(k)$ или $O(\\\\sqrt{n})$?\",\"html\":\"\u003cp\u003eЧто означает запись времени выполнения алгоритма в виде \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e?\u003c/p\u003e\\n\"}]\nce:[\"$\",\"$L92\",null,{\"Content\":\"Запись $O(k)$ или $O(\\\\sqrt{n})$ показывает сложность алгоритма и его эффективность в зависимости от $n$.\",\"html\":\"\u003cp\u003eЗапись \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e показывает сложность алгоритма и его эффективность в зависимости от \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\n"])</script><script nonce="">self.__next_f.push([1,"cf:[\"$\",\"$L92\",null,{\"Content\":\"Запись времени выполнения алгоритма в виде $O(k)$ или $O(\\\\sqrt{n})$ указывает на то, что время выполнения алгоритма прямо пропорционально квадрату значения $n$ и не зависит от $k$.\",\"html\":\"\u003cp\u003eЗапись времени выполнения алгоритма в виде \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e указывает на то, что время выполнения алгоритма прямо пропорционально квадрату значения \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e и не зависит от \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\n"])</script><script nonce="">self.__next_f.push([1,"d0:[\"$\",\"$L92\",null,{\"Content\":\"Запись времени выполнения алгоритма в виде $O(k)$ или $O(\\\\sqrt{n})$ относится к методам сортировки данных и не имеет отношения к оценке эффективности алгоритма.\",\"html\":\"\u003cp\u003eЗапись времени выполнения алгоритма в виде \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e относится к методам сортировки данных и не имеет отношения к оценке эффективности алгоритма.\u003c/p\u003e\\n\"}]\nd1:[\"$\",\"$L92\",null,{\"Content\":\"Запись $O(k)$ или $O(\\\\sqrt{n})$ определяет точное время выполнения алгоритма независимо от значения $n$.\",\"html\":\"\u003cp\u003eЗапись \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e определяет точное время выполнения алгоритма независимо от значения \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\nd2:[\"$\",\"$L92\",null,{\"Content\":\"Почему оценка времени выполнения алгоритма важна для понимания его эффективности?\",\"html\":\"\u003cp\u003eПочему оценка времени выполнения алгоритма важна для понимания его эффективности?\u003c/p\u003e\\n\"}]\nd3:[\"$\",\"$L92\",null,{\"Content\":\"Оценка времени выполнения алгоритма важна для понимания, как быстро он рабо"])</script><script nonce="">self.__next_f.push([1,"тает при разных \\\\( n \\\\).\",\"html\":\"\u003cp\u003eОценка времени выполнения алгоритма важна для понимания, как быстро он работает при разных ( n ).\u003c/p\u003e\\n\"}]\nd4:[\"$\",\"$L92\",null,{\"Content\":\"Оценка времени выполнения алгоритма важна, потому что она определяет количество памяти, необходимое для хранения данных при различных значениях \\\\( n \\\\), что влияет на его эффективность.\",\"html\":\"\u003cp\u003eОценка времени выполнения алгоритма важна, потому что она определяет количество памяти, необходимое для хранения данных при различных значениях ( n ), что влияет на его эффективность.\u003c/p\u003e\\n\"}]\nd5:[\"$\",\"$L92\",null,{\"Content\":\"Оценка времени выполнения алгоритма важна для определения его сложности в терминах вычислительной геометрии и анализа графов.\",\"html\":\"\u003cp\u003eОценка времени выполнения алгоритма важна для определения его сложности в терминах вычислительной геометрии и анализа графов.\u003c/p\u003e\\n\"}]\nd6:[\"$\",\"$L92\",null,{\"Content\":\"Оценка времени выполнения алгоритма важна для определения объёма памяти, который потребуется для его выполнения.\",\"html\":\"\u003cp\u003eОценка времени выполнения алгоритма важна для определения объёма памяти, который потребуется для его выполнения.\u003c/p\u003e\\n\"}]\nd7:[\"$\",\"$L92\",null,{\"Content\":\"Как оценка времени выполнения $"])</script><script nonce="">self.__next_f.push([1,"O(k)$ или $O(\\\\sqrt{n})$ может помочь при выборе алгоритма для решения задачи с определённым значением $n$?\",\"html\":\"\u003cp\u003eКак оценка времени выполнения \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e может помочь при выборе алгоритма для решения задачи с определённым значением \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e?\u003c/p\u003e\\n\"}]\n"])</script><script nonce="">self.__next_f.push([1,"d8:[\"$\",\"$L92\",null,{\"Content\":\"Оценка $O(k)$ или $O(\\\\sqrt{n})$ помогает оценить, насколько быстро алгоритм найдёт максимальное значение $k$ для заданного $n$.\",\"html\":\"\u003cp\u003eОценка \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e помогает оценить, насколько быстро алгоритм найдёт максимальное значение \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"k\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e для заданного \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\n"])</script><script nonce="">self.__next_f.push([1,"d9:[\"$\",\"$L92\",null,{\"Content\":\"Оценка времени выполнения $O(k)$ или $O(\\\\sqrt{n})$ определяет, сколько памяти потребуется алгоритму для решения задачи с заданным $n$, а не его скорость выполнения.\",\"html\":\"\u003cp\u003eОценка времени выполнения \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e определяет, сколько памяти потребуется алгоритму для решения задачи с заданным \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e, а не его скорость выполнения.\u003c/p\u003e\\n\"}]\n"])</script><script nonce="">self.__next_f.push([1,"da:[\"$\",\"$L92\",null,{\"Content\":\"Оценка времени выполнения $O(k)$ или $O(\\\\sqrt{n})$ используется для определения сложности алгоритма в терминах вычислительной геометрии и не связана напрямую с выбором алгоритма для решения задачи.\",\"html\":\"\u003cp\u003eОценка времени выполнения \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e используется для определения сложности алгоритма в терминах вычислительной геометрии и не связана напрямую с выбором алгоритма для решения задачи.\u003c/p\u003e\\n\"}]\ndb:[\"$\",\"$L92\",null,{\"Content\":\"Оценка $O(k)$ или $O(\\\\sqrt{n})$ указывает на количество памяти, необходимое алгоритму для работы с заданным $n$.\",\"html\":\"\u003cp\u003eОценка \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(k)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e или \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"O(%5Csqrt%7Bn%7D)\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e указывает на количество памяти, необходимое алгоритму для работы с заданным \u003cspan class=\\\"yfm-latex\\\" data-content=\\\"n\\\" data-options=\\\"%7B%22displayMode%22%3Afalse%7D\\\"\u003e\u003c/span\u003e.\u003c/p\u003e\\n\"}]\n"])</script><script src="https://yastatic.net/s3/cloud/forms/_/embed.js" nonce="" data-nscript="afterInteractive"></script><next-route-announcer style="position: absolute;"></next-route-announcer><div class="gdpr-popup-v3-main" role="alert" aria-labelledby="gdpr-popup-v3-main-title" aria-live="assertive" lang="ru-RU">
            <div class="gdpr-popup-v3-main__content-container">
                <h1 class="gdpr-popup-v3-main__main-title gdpr-popup-v3-main__title" id="gdpr-popup-v3-main-title">
                    Yandex uses cookies
                </h1>
                <div class="gdpr-popup-v3-main__main-description" id="gdpr-popup-v3-main-description">
                    They ensure the smooth operation of all Yandex sites and services. For more information, please read our <a href="https://yandex.com/legal/cookies_policy_eng/" target="_blank">Cookie Policy</a>
                </div>
                <div class="gdpr-popup-v3-main__main-buttons gdpr-popup-v3-main__buttons">
                <div class="gdpr-popup-v3-button gdpr-popup-v3-button_id_all" aria-label="" role="button" tabindex="0" id="gdpr-popup-v3-button-all">Allow all</div><div class="gdpr-popup-v3-button gdpr-popup-v3-button_id_mandatory" aria-label="" role="button" tabindex="0" id="gdpr-popup-v3-button-mandatory">Allow essential cookies</div><div class="gdpr-popup-v3-button gdpr-popup-v3-button_theme_dark gdpr-popup-v3-button_id_settings" aria-label="" role="button" tabindex="0" id="gdpr-popup-v3-button-settings">Settings</div></div>
            </div>
            <div class="gdpr-popup-v3-main__settings-container gdpr-popup-v3-hidden">
                <div class="gdpr-popup-v3-main__settings-title"><div class="gdpr-popup-v3-button gdpr-popup-v3-button_theme_transparent gdpr-popup-v3-button_id_mobile-back" aria-label="Back to home page" role="button" tabindex="0" id="gdpr-popup-v3-button-mobile-back">
        <svg class="gdpr-popup-v3-svg" height="1em" width="1em" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M10.471 12.195a.667.667 0 0 1-.942.943l-4.431-4.43a1 1 0 0 1 0-1.415l4.43-4.431a.667.667 0 0 1 .943.943L6.276 8l4.195 4.195Z" fill="currentColor" fill-opacity="1">
        </path></svg></div>
                    <h1 class="gdpr-popup-v3-main__title">Cookie settings</h1>
                </div>
                <div class="gdpr-popup-v3-main__settings-description">
                    Yandex uses technical cookies to ensure the site/app functions properly. However, we would also like to use optional marketing, analytics, and other types of cookies. These cookies help Yandex improve services, your experience, and ad relevancy. For more information about cookies, please read our <a href="https://yandex.com/legal/cookies_policy_eng/" target="_blank">Cookie Policy</a>
                </div>
                <div class="gdpr-popup-v3-main__spoilers">
                <div class="gdpr-popup-v3-spoiler gdpr-popup-v3-spoiler_id_technical">
        <div class="gdpr-popup-v3-spoiler__header">
            <div class="gdpr-popup-v3-spoiler__opener" role="button" tabindex="0" aria-label="Show cookie descriptions" id="gdpr-popup-v3-spoiler-opener-technical" aria-controls="gdpr-popup-v3-spoiler-content-technical" aria-expanded="false">
            <svg class="gdpr-popup-v3-svg" height="1.5em" width="1.5em" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M10 2.5a.833.833 0 0 0-.833.833v5.834H3.333a.833.833 0 0 0 0 1.666h5.834v5.834a.833.833 0 0 0 1.666 0v-5.834h5.834a.833.833 0 0 0 0-1.666h-5.834V3.333A.833.833 0 0 0 10 2.5Z" fill="currentColor" fill-opacity="0.5">
        </path></svg></div>
            <h3 class="gdpr-popup-v3-spoiler__label" id="gdpr-popup-v3-spoiler-label-technical">
                Technical, always active
            </h3>
            <div class="gdpr-popup-v3-spoiler__checkbox-container">
            <div class="gdpr-popup-v3-checkbox gdpr-popup-v3-checkbox_checked_yes gdpr-popup-v3-checkbox_disabled_yes" aria-checked="true" aria-disabled="true" role="switch" aria-labelledby="gdpr-popup-v3-spoiler-label-technical" tabindex="0" id="gdpr-popup-v3-check-technical">   
            <div class="gdpr-popup-v3-checkbox__check"></div>
        </div></div>
        </div>
        <div class="gdpr-popup-v3-spoiler__content gdpr-popup-v3-hidden" role="region" id="gdpr-popup-v3-spoiler-content-technical" aria-labelledby="gdpr-popup-v3-spoiler-label-technical">
            <p class="gdpr-popup-v3-spoiler__description" id="gdpr-popup-v3-spoiler-description-technical">
                These cookies are necessary for crucial web browsing functions, such as authorization or navigation. They are essential to the service's functionality, so they are used by default.
            </p>
            
        </div>
    </div><div class="gdpr-popup-v3-spoiler gdpr-popup-v3-spoiler_id_analytics">
        <div class="gdpr-popup-v3-spoiler__header">
            <div class="gdpr-popup-v3-spoiler__opener" role="button" tabindex="0" aria-label="Show cookie descriptions" id="gdpr-popup-v3-spoiler-opener-analytics" aria-controls="gdpr-popup-v3-spoiler-content-analytics" aria-expanded="false">
            <svg class="gdpr-popup-v3-svg" height="1.5em" width="1.5em" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M10 2.5a.833.833 0 0 0-.833.833v5.834H3.333a.833.833 0 0 0 0 1.666h5.834v5.834a.833.833 0 0 0 1.666 0v-5.834h5.834a.833.833 0 0 0 0-1.666h-5.834V3.333A.833.833 0 0 0 10 2.5Z" fill="currentColor" fill-opacity="0.5">
        </path></svg></div>
            <h3 class="gdpr-popup-v3-spoiler__label" id="gdpr-popup-v3-spoiler-label-analytics">
                Analytics/marketing
            </h3>
            <div class="gdpr-popup-v3-spoiler__checkbox-container">
            <div class="gdpr-popup-v3-checkbox gdpr-popup-v3-checkbox_checked_yes gdpr-popup-v3-checkbox_disabled_no" aria-checked="true" aria-disabled="false" role="switch" aria-labelledby="gdpr-popup-v3-spoiler-label-analytics" tabindex="0" id="gdpr-popup-v3-check-analytics">   
            <div class="gdpr-popup-v3-checkbox__check"></div>
        </div></div>
        </div>
        <div class="gdpr-popup-v3-spoiler__content gdpr-popup-v3-hidden" role="region" id="gdpr-popup-v3-spoiler-content-analytics" aria-labelledby="gdpr-popup-v3-spoiler-label-analytics">
            <p class="gdpr-popup-v3-spoiler__description" id="gdpr-popup-v3-spoiler-description-analytics">
                These cookies improve the quality of Yandex services. They remember preference settings, anonymously analyze website traffic, and help displaying relevant ads.
            </p>
            
        </div>
    </div><div class="gdpr-popup-v3-spoiler gdpr-popup-v3-spoiler_id_other">
        <div class="gdpr-popup-v3-spoiler__header">
            <div class="gdpr-popup-v3-spoiler__opener" role="button" tabindex="0" aria-label="Show cookie descriptions" id="gdpr-popup-v3-spoiler-opener-other" aria-controls="gdpr-popup-v3-spoiler-content-other" aria-expanded="false">
            <svg class="gdpr-popup-v3-svg" height="1.5em" width="1.5em" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M10 2.5a.833.833 0 0 0-.833.833v5.834H3.333a.833.833 0 0 0 0 1.666h5.834v5.834a.833.833 0 0 0 1.666 0v-5.834h5.834a.833.833 0 0 0 0-1.666h-5.834V3.333A.833.833 0 0 0 10 2.5Z" fill="currentColor" fill-opacity="0.5">
        </path></svg></div>
            <h3 class="gdpr-popup-v3-spoiler__label" id="gdpr-popup-v3-spoiler-label-other">
                Other cookies
            </h3>
            <div class="gdpr-popup-v3-spoiler__checkbox-container">
            <div class="gdpr-popup-v3-checkbox gdpr-popup-v3-checkbox_checked_yes gdpr-popup-v3-checkbox_disabled_no" aria-checked="true" aria-disabled="false" role="switch" aria-labelledby="gdpr-popup-v3-spoiler-label-other" tabindex="0" id="gdpr-popup-v3-check-other">   
            <div class="gdpr-popup-v3-checkbox__check"></div>
        </div></div>
        </div>
        <div class="gdpr-popup-v3-spoiler__content gdpr-popup-v3-hidden" role="region" id="gdpr-popup-v3-spoiler-content-other" aria-labelledby="gdpr-popup-v3-spoiler-label-other">
            <p class="gdpr-popup-v3-spoiler__description" id="gdpr-popup-v3-spoiler-description-other">
                These cookies are non-essential. They help to improve the experience of working on Yandex services and websites. They help to restore web page sessions, remember preferred regions, save personal preferences, and more.
            </p>
            
        </div>
    </div></div>
                <div class="gdpr-popup-v3-main__settings-buttons  gdpr-popup-v3-main__buttons">
                <div class="gdpr-popup-v3-button gdpr-popup-v3-button_theme_dark gdpr-popup-v3-button_id_back" aria-label="Back to home page" role="button" tabindex="0" id="gdpr-popup-v3-button-back">
        <svg class="gdpr-popup-v3-svg" height="1em" width="1em" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M10.471 12.195a.667.667 0 0 1-.942.943l-4.431-4.43a1 1 0 0 1 0-1.415l4.43-4.431a.667.667 0 0 1 .943.943L6.276 8l4.195 4.195Z" fill="currentColor" fill-opacity="1">
        </path></svg></div><div class="gdpr-popup-v3-button gdpr-popup-v3-button_id_selected" aria-label="" role="button" tabindex="0" id="gdpr-popup-v3-button-selected">Allow selected cookies</div><div class="gdpr-popup-v3-button gdpr-popup-v3-button_theme_dark gdpr-popup-v3-button_id_settings-mandatory" aria-label="" role="button" tabindex="0" id="gdpr-popup-v3-button-settings-mandatory">Allow essential cookies</div></div>
            </div>
        </div></body></html>