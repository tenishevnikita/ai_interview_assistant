<html lang="ru" class="__className_a39d3e __variable_a39d3e __variable_5a49b6 __variable_2ac229 HR-9-31-0"><head><style id="react-aria-pressable-style">@layer {
  [data-react-aria-pressable] {
    touch-action: pan-x pan-y pinch-zoom;
  }
}</style><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="viewport" content="initial-scale=1, width=device-width"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/edu_logo_simple_9790e70002.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/social_icon_vk_97bf858cd5.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/social_icon_yt_d20daea655.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/social_icon_tg_9faafb663e.svg"><link rel="preload" as="image" href="https://yastatic.net/s3/education-portal/media/logo_mobile_8bc5eb38fb.svg"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/00e25bd25bbd0437.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb46cd5c40721db6.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/85781da132a474d7.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/df0a82ffea795a48.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c800df164b7b8c22.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/033fa3e38f305e9b.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/80e3798aa7f5abc0.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/17fdf933d7378e89.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a2f4cf3f3bb12d85.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d844ab516aaccc48.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb0e02f100b08559.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/381835674ab7c3f7.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/8268a37c4890f71e.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/e2bd809ab2e171e9.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84f1d4eada6960dd.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cee7c32dde4c9323.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ef486034b69d75eb.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/4453bad77d6636b4.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dfbd22c99f7f399e.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5c966d7ef241f1d1.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b1ea991da29cd10f.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cb7ec9243c9cb1bf.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ca947b8fe9734df5.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a412a0891b49ea16.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ddb8c975b9776637.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9425ba6f0e81e31a.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/feca8288b0586eb3.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d238d176bd8ae895.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9fc77bcede8e7238.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/daf421f1dcbde59d.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/bd270492e7e016dc.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/500049d7c719a090.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/3e9ccf27ab1f71e9.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b6dc735f8f16428c.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/094d7d6ad311c845.css" crossorigin="anonymous" nonce="" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84de599a45688bb1.css" data-precedence="next"><link rel="stylesheet" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c08d5e89b37d645e.css" data-precedence="next"><link rel="preload" as="script" fetchpriority="low" nonce="" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/webpack-05f11ea662126375.js" crossorigin=""><script async="" src="https://mc.yandex.ru/metrika/tag.js"></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/2a182bb7-47baf338ad7d9e66.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/9500-a8aeea1077b58079.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/main-app-3c64833220c523df.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/1281-08bad9a3d2a60887.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/5080-82f4daed94452227.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/4194-172db2b948bd13ee.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/5609-185e25579372eca4.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/8619-3a701f3773450188.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/9275-7c8f52465eb2613c.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/9515-b7b857111af67561.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/layout-e3a20ad13303521f.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/app/layout-e78d4be001a57a28.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/2665-c77f7b9517a535fe.js" async="" crossorigin="" nonce=""></script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/app/error-da5ebf8e69abf3a6.js" async="" crossorigin="" nonce=""></script><link rel="preload" href="https://yastatic.net/s3/cloud/forms/_/embed.js" as="script" nonce=""><meta name="theme-color" content="#a48eef"><meta name="next-size-adjust" content=""><link rel="icon" href="https://yastatic.net/s3/education-portal/web/favicon.ico" sizes="any"><link rel="icon" href="https://yastatic.net/s3/education-portal/web/icon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="https://yastatic.net/s3/education-portal/web/apple-touch-icon.png"><title>Типы данных - Основы С++</title><meta name="description" content="Здесь мы&nbsp;познакомимся с&nbsp;некоторыми базовыми типами данных и&nbsp;с&nbsp;понятием области видимости переменных."><link rel="manifest" href="/manifest.webmanifest"><meta name="mobile-web-app-capable" content="yes"><meta name="BookSlug" content="cpp"><link rel="canonical" href="https://education.yandex.ru/handbook/cpp/article/data-types"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Яндекс Образование"><link href="https://yastatic.net/s3/education-portal/pwa/logos/ios/512.png" rel="apple-touch-startup-image"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta property="og:title" content="Типы данных - Основы С++"><meta property="og:description" content="Здесь мы&nbsp;познакомимся с&nbsp;некоторыми базовыми типами данных и&nbsp;с&nbsp;понятием области видимости переменных."><meta property="og:url" content="https://education.yandex.ru/handbook/cpp/article/data-types"><meta property="og:image" content="https://yastatic.net/s3/education-portal/media/opengraph_handbook_1_64d50710b1_29555467af.webp"><meta property="og:type" content="website"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Типы данных - Основы С++"><meta name="twitter:description" content="Здесь мы&nbsp;познакомимся с&nbsp;некоторыми базовыми типами данных и&nbsp;с&nbsp;понятием области видимости переменных."><meta name="twitter:image" content="https://yastatic.net/s3/education-portal/media/opengraph_handbook_1_64d50710b1_29555467af.webp"><script id="ab-test-data" nonce="">window.__AB_TEST_DATA = {"flags":{},"experiments":"P54lnS9LcLo,"};</script><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/polyfills-42372ed130431b0a.js" crossorigin="anonymous" nomodule="" nonce=""></script><script nonce="" id="rum-error">!function(e,t){if(e.Ya=e.Ya||{},Ya.Rum)throw new Error("Rum: interface is already defined");var n=e.performance,i=n&&n.timing&&n.timing.navigationStart||Ya.startPageLoad||+new Date,s=e.requestAnimationFrame,r=function(){},a=Ya.Rum={_defTimes:[],_defRes:[],_countersToExposeAsEvents:["2325","2616.85.1928","react.inited"],enabled:!!n,version:"6.1.21",vsStart:document.visibilityState,vsChanged:!1,vsChangeTime:1/0,_deltaMarks:{},_markListeners:{},_onComplete:[],_onInit:[],_unsubscribers:[],_eventLisneters:{},_settings:{},_vars:{},init:function(e,t){a._settings=e,a._vars=t},getTime:n&&n.now?function(){return n.now()}:Date.now?function(){return Date.now()-i}:function(){return new Date-i},time:function(e){a._deltaMarks[e]=[a.getTime()]},timeEnd:function(e,t){var n=a._deltaMarks[e];n&&0!==n.length&&n.push(a.getTime(),t)},sendTimeMark:function(e,t,n,i){void 0===t&&(t=a.getTime()),a.emit({metricName:"defTimes",data:[e,t,i]}),a.mark(e,t)},sendDelta:function(e,t,n,i){var s,r=a._deltaMarks;r[e]||void 0===t||(s=i&&i.originalEndTime?i.originalEndTime:a.getTime(),r[e]=[s-t,s,n])},sendResTiming:function(e,t){a.emit({metricName:"defRes",data:[e,t]})},sendRaf:function(e){var t=a.getSetting("forcePaintTimeSending");if(s&&(t||a.isTimeAfterPageShow(a.getTime()))){var n="2616."+e;s((function(){a.getSetting("sendFirstRaf")&&a.sendTimeMark(n+".205"),s((function(){a.sendTimeMark(n+".1928")}))}))}},isVisibilityChanged:function(){return a.vsStart&&("visible"!==a.vsStart||a.vsChanged)},isTimeAfterPageShow:function(e){return"visible"===a.vsStart||a.vsChangeTime<e},mark:n&&n.mark?function(e,t){n.mark(e+(t?": "+t:""))}:function(){},getSetting:function(e){var t=a._settings[e];return null===t?null:t||""},on:function(e,t){if("function"==typeof t)return(a._markListeners[e]=a._markListeners[e]||[]).push(t),function(){if(a._markListeners[e]){var n=a._markListeners[e].indexOf(t);n>-1&&a._markListeners[e].splice(n,1)}}},noop:r,sendTrafficData:r,finalizeLayoutShiftScore:r,finalizeLargestContentfulPaint:r,getLCPAdditionalParams:r,getCLSAdditionalParams:r,getINPAdditionalParams:r,getImageGoodnessAdditionalParams:r,_eventListeners:{},_eventsBuffer:{},subscribe:function(e,t){if(!a.getSetting("noEvents"))return this._eventLisneters[e]=this._eventLisneters[e]||new Set,this._eventLisneters[e].add(t),function(){this.unsubscribe(e,t)}.bind(this)},unsubscribe:function(e,t){this._eventLisneters[e].delete(t)},emit:function(e){if(!a.getSetting("noEvents")){var t=a.getSetting("eventsLimits")&&a.getSetting("eventsLimits")[e.metricName]||20;this._eventLisneters[e.metricName]&&this._eventLisneters[e.metricName].forEach((function(t){t(e)})),this._eventsBuffer[e.metricName]=this._eventsBuffer[e.metricName]||[],this._eventsBuffer[e.metricName].push(e),this._eventsBuffer[e.metricName].length>t&&(this._eventsBuffer[e.metricName].length=Math.floor(t/2))}},getBufferedEvents:function(e){var t=this._eventsBuffer,n={};return Object.keys(t).forEach((function(i){-1!==e.indexOf(i)&&(n[i]=t[i])})),n},clearEvents:function(e){this._eventsBuffer[e]&&(this._eventsBuffer[e].length=0)}};function f(){Ya.Rum.vsChanged=!0,Ya.Rum.vsChangeTime=a.getTime(),removeEventListener("visibilitychange",f)}addEventListener("visibilitychange",f),a._onVisibilityChange=f}(window);
!function(){if(window.PerformanceLongTaskTiming){var e=function(e,n){return(e=e.concat(n)).length>300&&(e=e.slice(e.length-300)),e},n="undefined"!=typeof PerformanceLongAnimationFrameTiming,t=n?["longtask","long-animation-frame"]:["longtask"];function r(){var r=Ya.Rum._tti={events:[],loafEvents:n?[]:void 0,eventsAfterTTI:[],fired:!1,observer:new PerformanceObserver((function(t){var o=t.getEntriesByType("longtask"),s=t.getEntriesByType("long-animation-frame");r.events=e(r.events,o),n&&(r.loafEvents=e(r.loafEvents,s)),r.fired&&(r.eventsAfterTTI=e(r.eventsAfterTTI,o))}))};r.observer.observe({entryTypes:t}),Ya.Rum._unsubscribers&&Ya.Rum._unsubscribers.push((function(){r.observer.disconnect()}))}r(),Ya.Rum._onInit.push(r)}}();
Ya.Rum.observeDOMNode=window.IntersectionObserver?function(e,i,n){var t=this,o=Ya.Rum.getSetting("forcePaintTimeSending");!function r(){if(o||!t.isVisibilityChanged()){var s="string"==typeof i?document.querySelector(i):i;s?new IntersectionObserver((function(i,n){!o&&t.isVisibilityChanged()||(Ya.Rum.sendTimeMark(e),n.unobserve(s))}),n).observe(s):setTimeout(r,100)}}()}:function(){};
var rum_platform = window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop';
    var rum_segment = window.location.pathname.replace(/^\//, "").replace(/\/.*/);
    
    if (["knowledge", "journal", "profile", "handbook"].indexOf(rum_segment) === -1) {
      rum_segment = "portal";
    }

    Ya.Rum.init({ beacon: true, clck: 'https://yandex.ru/clck/click', reqid: '1768063131643963-5455682025770295793'},
    {
        rum_id: 'ru.education.' + rum_platform + '.' + rum_segment,
        '-env': 'production',
        '-project': 'education-web',
        '-page': window.location.pathname,
        '-version': 'undefined',
        '-platform': rum_platform
    });Ya.Rum.observeDOMNode('2876', 'body');!function(){var e,t,n,i=Ya.Rum,o=42,r=4e4,g=15,a=[],s="\r\n",l=i.getSetting("countersInitialDelay")||0;if(l){var c;function u(){removeEventListener("visibilitychange",h),clearTimeout(c),l=0,f()}function h(){document.hidden&&u()}c=setTimeout(u,l),addEventListener("visibilitychange",h)}function f(){if(t&&a.length){for(var n=0,i=0,l=0;i<a.length&&l<=r&&n<o;i++)(l+=(i?s.length:0)+a[i].length)<=r&&n++;var c=a.splice(0,n);d(t,c.join(s)),a.length&&(e=setTimeout(f,g))}else a.length=0}function d(e,t){if(!(navigator.sendBeacon&&n&&navigator.sendBeacon(e,t))){var o=Boolean(i.getSetting("sendCookie")),r=new XMLHttpRequest;r.open("POST",e),r.withCredentials=o,r.send(t)}}i.send=function(c,u,h,d,v,m,S,p){t=i.getSetting("clck"),n=i.getSetting("beacon"),o=i.getSetting("maxBatchCounters")||o,r=i.getSetting("maxBatchLength")||r,g=i.getSetting("countersBatchTimeout")||g,function(t,n,i,c,u,h,d,v,m,S){clearTimeout(e);var p=[t?"/reqid="+t:"",n?"/"+n.join("/"):"",i?"/path="+i:"",c?"/events="+c:"",u?"/slots="+u.join(";"):"",h?"/experiments="+h.join(";"):"",d?"/vars="+d:"","/cts="+(new Date).getTime(),"","/*"].join("");p.length>r?"undefined"!=typeof console&&console.error&&console.error("Counter length "+p.length+" is more than allowed "+r,p):(a.push(p),l||(function(){if(a.length>=o)return!0;for(var e=0,t=0;t<a.length;t++)if((e+=(t?s.length:0)+a[t].length)>=r)return!0;return!1}()?f():e=setTimeout(f,g)))}(i.getSetting("reqid"),S,u,v,i.getSetting("slots"),i.getSetting("experiments"),h)}}();
!function(){var e=Ya.Rum,n=!window.BigInt||!("PerformanceObserver"in window);function t(n){e._unsubscribers.push(n)}function i(e,i,o){if(!n){var a=o||{};if(e){a.type=e,a.hasOwnProperty("buffered")||(a.buffered=!0);var s=new PerformanceObserver((function(e,n){return i(e.getEntries(),n)}));return r((function(){try{s.observe(a)}catch(e){return void console.error(e.message)}t((function(){s.disconnect()}))}),0),s}throw new Error("PO without type field is forbidden")}}function r(e,n){var i=setTimeout(e,n);return t((function(){clearInterval(i)})),i}function o(e,n,i){addEventListener(e,n,i),t((function(){removeEventListener(e,n,i)}))}function a(e,n,t){o("visibilitychange",(function i(){if("hidden"===document.visibilityState){try{t||(removeEventListener("visibilitychange",i),e.disconnect())}catch(e){}n()}})),o("beforeunload",n)}function s(e,n){return"string"==typeof e?encodeURIComponent(e):Math.round(1e3*(e-(n||0)))/1e3}function u(e){if(!e)return"";var n=(e.tagName||"").toLowerCase(),t=e.className&&void 0!==e.className.baseVal?e.className.baseVal:e.className;return n+(t?(" "+t).replace(/\s+/g,"."):"")}function c(e){function n(){removeEventListener("DOMContentLoaded",n),removeEventListener("load",n),e()}"loading"===document.readyState?(o("DOMContentLoaded",n),o("load",n)):e()}function d(n){e._onComplete.push(n)}function f(){return e._periodicTasks}function l(){var n=e._vars;return Object.keys(n).map((function(e){return e+"="+encodeURIComponent(n[e]).replace(/\*/g,"%2A")}))}var m={connectEnd:2116,connectStart:2114,decodedBodySize:2886,domComplete:2124,domContentLoadedEventEnd:2131,domContentLoadedEventStart:2123,domInteractive:2770,domLoading:2769,domainLookupEnd:2113,domainLookupStart:2112,duration:2136,encodedBodySize:2887,entryType:2888,fetchStart:2111,initiatorType:2889,loadEventEnd:2126,loadEventStart:2125,nextHopProtocol:2890,redirectCount:1385,redirectEnd:2110,redirectStart:2109,requestStart:2117,responseEnd:2120,responseStart:2119,secureConnectionStart:2115,startTime:2322,transferSize:2323,type:76,unloadEventEnd:2128,unloadEventStart:2127,workerStart:2137},v=625;function g(n,t){Object.keys(m).forEach((function(e){if(e in t){var i=t[e];(i||0===i)&&n.push(m[e]+"="+s(i))}})),n.push("".concat(v,"=").concat(e.version))}var p,h,y,S,T,b="690.2096.2877",w="690.2096.207",E="690.2096.2044",C=3,k=e.getSetting("savedDeltasLimit")||0,L=document.createElement("link"),P=window.performance||{},M="function"==typeof P.getEntriesByType,_=0;function O(n,t,i,r,o){void 0===t&&(t=e.getTime()),void 0!==i&&!0!==i||e.mark(n,t);var a=I(n);if(a.push("207="+s(t)),x(a,r)){j(w,a,o&&o.force),p[n]=p[n]||[],p[n].push(t);var u=e._markListeners[n];u&&u.length&&u.forEach((function(e){e(t)})),e.emit({metricName:n,value:t,params:r})}}function I(n){return T.concat([e.isVisibilityChanged()?"-vsChanged=1":"","1701="+n,e.ajaxStart&&"1201.2154="+s(e.ajaxStart),e.ajaxComplete&&"1201.2052="+s(e.ajaxComplete)])}function N(){S=l(),e.getSetting("sendClientUa")&&S.push("1042="+encodeURIComponent(navigator.userAgent))}function R(){var e=window.performance&&window.performance.timing&&window.performance.timing.navigationStart;T=S.concat(["143.2129="+e])}function x(e,n){if(n){if(n.isCanceled&&n.isCanceled())return!1;var t=e.reduce((function(e,n,t){return"string"==typeof n&&(e[n.split("=")[0]]=t),e}),{});Object.keys(n).forEach((function(i){if("function"!=typeof n[i]){var r=t[i],o=i+"="+n[i];void 0===r?e.push(o):e[r]=o}}))}return!0}function j(n,t,i){var r=encodeURIComponent(window.YaStaticRegion||"unknown");t.push("-cdn="+r);var o=t.filter(Boolean).join(",");e.send(null,n,o,void 0,void 0,void 0,void 0,i)}function z(e,n,t){j(e,F().concat(n),t)}function B(n,t){var i=y[n];i&&0!==i.length&&(i.push(e.getTime(),t),A(n))}function A(n,t,i,r){var o,a,u,c=y[n];if(void 0!==t?o=(a=r&&r.originalEndTime?r.originalEndTime:e.getTime())-t:c&&(o=c[0],a=c[1],u=c[2]),void 0!==o&&void 0!==a){var d=I(n);d.push("207.2154="+s(o),"207.1428="+s(a),"2877="+s(a-o)),x(d,i)&&x(d,u)&&(j(b,d,r&&r.force),_<k&&(h[n]=h[n]||[],h[n].push(a-o),_++),e.emit({metricName:n,value:a-o,params:{start:o,end:a}}),delete y[n])}}function V(e,n){if(!M)return n(null);L.href=e;var t=0,i=100,o=L.href;r((function e(){var a=P.getEntriesByName(o);if(a.length)return n(a);t++<C?(r(e,i),i+=i):n(null)}),0)}function U(e,n,t){V(n,(function(i){i&&D(e,i[i.length-1],n,t)}))}function D(n,t,i,r){var o=I(n);e.getSetting("sendUrlInResTiming")&&o.push("13="+encodeURIComponent(i)),g(o,t),x(o,r),j(E,o)}function F(){return S}var W={bluetooth:2064,cellular:2065,ethernet:2066,none:1229,wifi:2067,wimax:2068,other:861,unknown:836,0:836,1:2066,2:2067,3:2070,4:2071,5:2768},H=navigator.connection;function Q(e){if(H){var n=W[H.type];e.push("2437="+(n||2771),void 0!==H.downlinkMax&&"2439="+H.downlinkMax,H.effectiveType&&"2870="+H.effectiveType,void 0!==H.rtt&&"rtt="+H.rtt,void 0!==H.downlink&&"dwl="+H.downlink,!n&&"rawType="+H.type)}}var Y,q,G,J,$,K,X,Z,ee="690.2096.4004",ne=!1,te=1/0,ie=1/0,re=("layout-shift",Boolean(window.PerformanceObserver&&window.PerformanceObserver.supportedEntryTypes&&-1!==window.PerformanceObserver.supportedEntryTypes.indexOf("layout-shift"))?0:null);function oe(){$>q&&(q=$,G=J,e.emit({metricName:"cls-debug",value:q,params:{clsEntries:G,target:ae(G)}}))}function ae(e){var n;if(!e)return null;var t=null;if((n=e.reduce((function(e,n){return e&&e.value>n.value?e:n})))&&n.sources&&n.sources.length){for(var i=0;i<n.sources.length;i++){var r=n.sources[i];if(r.node&&1===r.node.nodeType){t=r;break}}t=t||n.sources[0]}return t}function se(e){null==q&&(q=0);for(var n=0;n<e.length;n++){var t=e[n];t.hadRecentInput||($&&t.startTime-J[J.length-1].startTime<te&&t.startTime-J[0].startTime<ie?($+=t.value,J.push(t)):(oe(),$=t.value,J=[t]))}oe()}function ue(){q=re,Y=void 0,G=null,J=null,$=null,ne=!1}function ce(n){if(null!=q&&!ne){var t=Math.round(1e6*q)/1e6;if(Y!==t){Y=t,e.getSetting("enableContinuousCollection")||(ne=!0);var i=ae(G),r=["s="+t];r.push("target="+u(i&&i.node));var o=e.getCLSAdditionalParams(i);o&&x(r,o),z(ee,r,n),e.emit({metricName:"cls-debug",value:q,params:{clsEntries:J,target:i,isFinalized:ne}})}}}function de(n){var t=n[n.length-1];K=t.renderTime||t.loadTime,X=t,e.emit({metricName:"largest-contentful-paint-debug",value:K,params:{entry:t}}),Z||(O("largest-loading-elem-paint",K),Z=!0)}function fe(n){if(null!=K){var t=e.getLCPAdditionalParams(X);O("largest-contentful-paint",K,!1,t,n&&{force:!0}),e.emit({metricName:"largest-contentful-paint-debug",value:K,params:{additionalParams:t,entry:X,isFinalized:!0}}),K=null,X=null}}e.getLCPAdditionalParams===e.noop&&(e.getLCPAdditionalParams=function(){var n={},t=X.element;if(t){n["-className"]=e.getSelector(t),n["-tagName"]=t.tagName.toLowerCase();var i=t.getBoundingClientRect();n["-width"]=i.width,n["-height"]=i.height}return X.size&&(n["-size"]=X.size),n});var le={"first-paint":2793,"first-contentful-paint":2794},me=Object.keys(le).length,ve={},ge=window.performance||{},pe="function"==typeof ge.getEntriesByType,he=0;function ye(){if(pe&&(e.getSetting("forcePaintTimeSending")||!e.isVisibilityChanged()))for(var n=ge.getEntriesByType("paint"),t=0;t<n.length;t++){var i=n[t],r=le[i.name];r&&!ve[i.name]&&(ve[i.name]=!0,he++,O("1926."+r,i.startTime))}}var Se=3e3,Te=1;function be(){return e._tti.events||[]}function we(){return e._tti.loafEvents}function Ee(){return e._tti}function Ce(n){return n?n===e.getPageUrl()?"<page>":n.replace(/\?.*$/,""):n}function ke(n,t,i){if(Ee()){var r=e.getTime(),o="undefined"!=typeof PerformanceLongAnimationFrameTiming&&e.getSetting("sendLongAnimationFrames");Le((function(a){var u,c={2796.2797:Pe(be(),t),689.2322:s(r)};if(o){var d=function(e){var n=we();if(n)return e?n.filter((function(n){return n.startTime+n.duration>=e})):n}(t);d&&(c["loaf.2797"]=Pe(d,void 0,{useName:!1}),1===e.getSetting("longAnimationFramesMode")&&(c["-additional"]=encodeURIComponent(JSON.stringify({loaf:(u=d,u.map(Me))}))))}i&&Object.keys(i).forEach((function(e){c[e]=i[e]})),O(n||"2795",a,!0,c,{force:Boolean(o)}),e._tti.fired=!0}),t)}}function Le(n,t){var i=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).mode,o=void 0===i?Te:i;Ee()&&(t||(t=e.getTime()),function i(){var a,s=t,u=e.getTime(),c=o===Te?be():we()||[],d=c.length;0!==d&&(a=c[d-1],s=Math.max(s,Math.floor(a.startTime+a.duration))),u-s>=Se?n(s):r(i,1e3)}())}function Pe(e,n){var t=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).useName,i=void 0===t||t;return n=n||0,(e=e||[]).filter((function(e){return n-e.startTime<=50})).map((function(e){var n=Math.floor(e.startTime),t=Math.floor(n+e.duration);return i?(e.name?e.name.split("-").map((function(e){return e[0]})).join(""):"u")+"-"+n+"-"+t:n+"-"+t})).join(".")}function Me(e){var n=e.blockingDuration,t=e.duration,i=e.firstUIEventTimestamp,r=e.renderStart,o=e.scripts,a=e.startTime,s=e.styleAndLayoutStart;return[Math.round(a),Math.round(t),o.map(Oe),Math.round(n),Math.round(i),Math.round(r),Math.round(s)]}function _e(e){return{"user-callback":1,"event-listener":2,"resolve-promise":3,"reject-promise":4,"classic-script":5,"module-script":6}[e]||0}function Oe(e){var n=e.invoker,t=e.sourceURL,i=e.sourceFunctionName,r=e.sourceCharPosition,o=e.startTime,a=e.duration,s=e.windowAttribution,u=e.executionStart,c=e.forcedStyleAndLayoutDuration,d=e.pauseDuration,f=e.invokerType;return[Ce(n),Ce(t),i,r,Math.round(o),Math.round(a),s,Math.round(u),Math.round(c),Math.round(d),_e(f)]}var Ie="690.2096.361",Ne=document.createElement("a"),Re=0,xe={};function je(e){var n=e.transferSize;if(null!=n){Ne.href=e.name;var t=Ne.pathname;if(0!==t.indexOf("/clck")){var i=t.lastIndexOf("."),r="";return-1!==i&&t.lastIndexOf("/")<i&&t.length-i<=5&&(r=t.slice(i+1)),{size:n,domain:Ne.hostname,extension:r}}}}function ze(){var n=e.getSetting("maxTrafficCounters")||250;if(Re>=n)return!1;for(var t=Object.keys(xe),i="",r=0;r<t.length;r++){var o=t[r],a=xe[o];i+=encodeURIComponent(o)+"!"+a.count+"!"+a.size+";"}return i.length&&(Re++,z(Ie,["d="+i,"t="+s(e.getTime())])),xe={},Re<n}d(ze);var Be="690.1033",Ae={visible:1,hidden:2,prerender:3},Ve=window.performance||{},Ue=Ve.navigation||{},De=Ve.timing||{},Fe=De.navigationStart;function We(){var n=De.domContentLoadedEventStart,t=De.domContentLoadedEventEnd;if(0!==n||0!==t){var i=0===De.responseStart?Fe:De.responseStart,o=0===De.domainLookupStart?Fe:De.domainLookupStart,a=["2129="+Fe,"1036="+(o-Fe),"1037="+(De.domainLookupEnd-De.domainLookupStart),"1038="+(De.connectEnd-De.connectStart),De.secureConnectionStart&&"1383="+(De.connectEnd-De.secureConnectionStart),"1039="+(De.responseStart-De.connectEnd),"1040="+(De.responseEnd-i),"1040.906="+(De.responseEnd-o),"1310.2084="+(De.domLoading-i),"1310.2085="+(De.domInteractive-i),"1310.1309="+(t-n),"1310.1007="+(n-i),navigator.deviceMemory&&"3140="+navigator.deviceMemory,navigator.hardwareConcurrency&&"3141="+navigator.hardwareConcurrency];Object.keys(m).forEach((function(e){e in De&&De[e]&&a.push(m[e]+"="+s(De[e],Fe))})),e.vsStart?(a.push("1484="+(Ae[e.vsStart]||2771)),e.vsChanged&&a.push("1484.719=1")):a.push("1484="+Ae.visible),Ue&&(Ue.redirectCount&&a.push("1384.1385="+Ue.redirectCount),1!==Ue.type&&2!==Ue.type||a.push("770.76="+Ue.type)),Q(a),z(Be,a)}else r(We,50)}var He="690.2096.2892",Qe=window.performance||{},Ye="function"==typeof Qe.getEntriesByType;if(!e)throw new Error("Rum: interface is not included");if(e.enabled){function qe(){p={},h={},_=0,y=e._deltaMarks,N(),R(),e.ajaxStart=0,e.ajaxComplete=0,c(Je)}function Ge(){var n;e.sendTimeMark=O,e.sendResTiming=U,e.sendTiming=D,e.timeEnd=B;var t=(e.getBufferedEvents(["defRes"]).defRes||[]).map((function(e){return e.data}));for(n=0;n<t.length;n++)U(t[n][0],t[n][1]);e.clearEvents("defRes");var i=(e.getBufferedEvents(["defTimes"]).defTimes||[]).map((function(e){return e.data}));for(n=0;n<i.length;n++)O(i[n][0],i[n][1],!1,i[n][2]);e.clearEvents("defTimes"),Object.keys(y).forEach((function(e){A(e)}))}function Je(){var n=window.performance&&window.performance.timing&&window.performance.timing.navigationStart,t=e.getSetting("skipTiming"),a=e.getSetting("techParamsByVisible");n&&(a&&addEventListener("visibilitychange",(function n(){"visible"!==e.vsStart?"visible"===document.visibilityState&&(e.vsStart="visible",removeEventListener("visibilitychange",n),We()):removeEventListener("visibilitychange",n)})),r((function(){Ge(),(!t&&!a||a&&"visible"===e.vsStart)&&We(),e.getSetting("disableFCP")||(ye(),he<me&&i("paint",(function(e,n){ye(),n&&he>=me&&n.disconnect()}),{buffered:!0})),e.getSetting("sendAutoElementTiming")&&(!window.PerformanceObserver||!e.getSetting("forcePaintTimeSending")&&e.isVisibilityChanged()||i("element",(function(e){for(var n=0;n<e.length;n++){var t=e[n];O("element-timing."+t.identifier,t.startTime)}}))),o("pageshow",Xe),ke(),"complete"===document.readyState?$e({skipTimingApi:t}):o("load",$e.bind(void 0,{skipTimingApi:t}))}),0))}function $e(n){var r,s;e.getSetting("disableOnLoadTasks")||(removeEventListener("load",$e),n.skipTimingApi||function(){if(Ye){var e=Qe.getEntriesByType("navigation")[0];if(e){var n=[];g(n,e),Q(n);var t=Qe.getEntriesByName("yndxNavigationSource")[0];t&&n.push("2091.186="+t.value);var i=Qe.getEntriesByName("yndxNavigationToken","yndxEntry")[0];i&&n.push("2091.3649="+i.value),z(He,n)}}}(),(s=e.getSetting("periodicStatsIntervalMs"))||null===s||(s=15e3),s&&(r=setInterval(Ze,s),t((function(){clearInterval(r)})),Ke=r),o("beforeunload",Ze),function(){if(window.PerformanceObserver){xe={},Re=0;var e=function(e){!function(e){if(e&&e.length)for(var n=xe,t=0;t<e.length;t++){var i=je(e[t]);if(i){var r=i.domain+"-"+i.extension,o=n[r]=n[r]||{count:0,size:0};o.count++,o.size+=i.size}}}(e)};i("resource",e),i("navigation",e),f().push(ze)}}(),e.getSetting("disableFID")||i("first-input",(function(n,t){var i=n[0];if(i){var r=i.processingStart,o={duration:i.duration,js:i.processingEnd-r,name:i.name};i.target&&(o.target=u(i.target));var a=r-i.startTime;A("first-input",a,o),e.emit({metricName:"first-input-debug",value:a,params:{entry:i,additionalParams:o}}),t.disconnect()}}),{buffered:!0}),e.getSetting("disableCLS")||window.PerformanceObserver&&(d(ce),d(ue),q=re,G=null,J=null,$=null,te=e.getSetting("clsWindowGap")||te,ie=e.getSetting("clsWindowSize")||ie,a(i("layout-shift",se),(function(){return ce(!0)}),!0)),e.getSetting("disableLCP")||!window.PerformanceObserver||!e.getSetting("forcePaintTimeSending")&&e.isVisibilityChanged()||(d(fe),K=null,X=null,Z=!1,a(i("largest-contentful-paint",de),(function(){return fe(!0)}),!1)))}var Ke;function Xe(e){e.persisted&&O("bfcache")}function Ze(){var e=!1;f().forEach((function(n){n()&&(e=!0)})),e||clearInterval(Ke)}d(Ge),e.destroy=function(n){var t=e._unsubscribers;n.shouldComplete&&e.completeSession(!0),e._onComplete=[];for(var i=0;i<t.length;i++)t[i]();removeEventListener("visibilitychange",e._onVisibilityChange),e._unsubscribers=[],e._periodicTasks=[],e._markListeners={},e._deltaMarks={}},e.restart=function(n,t,i){e.destroy({shouldComplete:i}),e.init(n,t),addEventListener("visibilitychange",e._onVisibilityChange),qe(),function(){for(var n=0;n<e._onInit.length;n++)e._onInit[n]()}()},e.setVars=function(n){Object.keys(n).forEach((function(t){e._vars[t]=n[t]})),N(),R()},e.completeSession=function(n){for(var t=e._onComplete,i=0;i<t.length;i++)t[i](n)},qe(),e._periodicTasks=[],e.sendHeroElement=function(e){O("2876",e)},e.getPageUrl=function(){return window.location.href},e._subpages={},e.makeSubPage=function(n,t){var i=e._subpages[n];e._subpages[n]=void 0===i?i=0:++i;var r=!1;return{689.2322:s(void 0!==t?t:e.getTime()),2924:n,2925:i,isCanceled:function(){return r},cancel:function(){r=!0}}},e.getTimeMarks=function(){return p},e.getDeltas=function(){return h},e.getVarsList=l,e.getResourceTimings=V,e.pushConnectionTypeTo=Q,e.pushTimingTo=g,e.normalize=s,e.sendCounter=j,e.sendDelta=A,e.onReady=c,e.getSelector=u,e.getSetting("disableCLS")||(e.finalizeLayoutShiftScore=ce),e.getSetting("disableLCP")||(e.finalizeLargestContentfulPaint=fe),e.sendTrafficData=ze,e._getCommonVars=F,e._addListener=o,e._observe=i,e._timeout=r,e.sendTTI=ke,e._getLongtasksStringValue=Pe,e.onQuietWindow=Le,e.sendBFCacheTimeMark=Xe}else e.getSetting=function(){return""},e.getVarsList=function(){return[]},e.getResourceTimings=e.completeSession=e.pushConnectionTypeTo=e.pushTimingTo=e.normalize=e.sendCounter=e.destroy=e.restart=e.setVars=e.completeSession=e.sendDelta=e.sendTimeMark=e.sendResTiming=e.sendTiming=e.sendTTI=e.makeSubPage=e.sendHeroElement=e.onReady=e.onQuietWindow=function(){}}();
!function(n){if(!n.Ya||!Ya.Rum)throw new Error("Rum: interface is not defined");var e=Ya.Rum;e.getSetting=function(n){var t=e._settings[n];return null===t?null:t||""}}("undefined"!=typeof self?self:window);
!function(e,r){var n={client:["690.2354",1e3,100,0],uncaught:["690.2361",100,10,0],external:["690.2854",100,10,0],script:["690.2609",100,10,0]},t={};r.ERROR_LEVEL={INFO:"info",DEBUG:"debug",WARN:"warn",ERROR:"error",FATAL:"fatal"},r._errorSettings={clck:"https://yandex.ru/clck/click",beacon:!0,project:"unknown",page:"",env:"",experiments:[],additional:{},platform:"",region:"",dc:"",host:"",service:"",level:"",version:"",yandexuid:"",loggedin:!1,coordinates_gp:"",referrer:!0,preventError:!1,unhandledRejection:!1,traceUnhandledRejection:!1,uncaughtException:!0,debug:!1,limits:{},silent:{},filters:{},pageMaxAge:864e6,initTimestamp:+new Date};var o=!1;function a(e,r){for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n]);return e}function i(e){return"boolean"==typeof e&&(e=+e),"number"==typeof e?e+"":null}r.initErrors=function(n){var t=a(r._errorSettings,n);o||(t.uncaughtException&&function(){var n=r._errorSettings;if(e.addEventListener)e.addEventListener("error",s),n.resourceFails&&e.addEventListener("error",l,!0),"Promise"in e&&n.unhandledRejection&&e.addEventListener("unhandledrejection",function(e){var n,t,o=e.reason,a={};o&&(o.stack&&o.message?(n=o.message,t=o.stack):(n=String(o),t=r._parseTraceablePromiseStack(e.promise),"[object Event]"===n?n="event.type: "+o.type:"[object Object]"===n&&(a.unhandledObject=o)),o.target&&o.target.src&&(a.src=o.target.src),s({message:"Unhandled rejection: "+n,stack:t,additional:a}))});else{var t=e.onerror;e.onerror=function(e,r,n,o,a){s({error:a||new Error(e||"Empty error"),message:e,lineno:n,colno:o,filename:r}),t&&t.apply(this,arguments)}}}(),t.unhandledRejection&&t.traceUnhandledRejection&&r._traceUnhandledRejection&&r._traceUnhandledRejection(),o=!0)},r.updateErrors=function(e){a(r._errorSettings,e)},r.updateAdditional=function(e){r._errorSettings.additional=a(r._errorSettings.additional||{},e)},r._handleError=function(e,o,i){var s,l,c=r._errorSettings;if(c.preventError&&e.preventDefault&&e.preventDefault(),o)s=e,l="client";else{s=r._normalizeError(e),l=s.type;var d=c.onError;"function"==typeof d&&d(s);var u=c.transform;if("function"==typeof u&&(s=u(s)),!s)return;s.settings&&(i=s.settings)}var g=+new Date,f=c.initTimestamp,p=c.pageMaxAge;if(!(-1!==p&&f&&f+p<g)){var m=n[l][1];"number"==typeof c.limits[l]&&(m=c.limits[l]);var v=n[l][2];"number"==typeof c.silent[l]&&(v=c.silent[l]);var h=n[l][3];if(h<m||-1===m){s.path=n[l][0];var E=r._getErrorData(s,{silent:h<v||-1===v?"no":"yes",isCustom:Boolean(o)},a(a({},c),i)),_=function(e){t[s.message]=!1,r._sendError(e.path,e.vars),n[l][3]++}.bind(this,E);if(void 0===c.throttleSend)_();else{if(t[s.message])return;t[s.message]=!0,setTimeout(_,c.throttleSend)}}}},r._getReferrer=function(r){var n=r.referrer,t=typeof n;return"function"===t?n():"string"===t&&n?n:!1!==n&&e.location?e.location.href:void 0},r.getErrorSetting=function(e){return r._errorSettings[e]},r._buildExperiments=function(e){return e instanceof Array?e.join(";"):""},r._buildAdditional=function(e,r){var n="";try{var t=a(a({},e),r);0!==Object.keys(t).length&&(n=JSON.stringify(t))}catch(e){}return n},r._getErrorData=function(n,t,o){t=t||{};var a=r._buildExperiments(o.experiments),s=r._buildAdditional(o.additional,n.additional),l={"-stack":n.stack,"-url":n.file,"-line":n.line,"-col":n.col,"-block":n.block,"-method":n.method,"-msg":n.message,"-env":o.env,"-external":n.external,"-externalCustom":n.externalCustom,"-project":o.project,"-service":n.service||o.service,"-page":n.page||o.page,"-platform":o.platform,"-level":n.level,"-experiments":a,"-version":o.version,"-region":o.region,"-dc":o.dc,"-host":o.host,"-yandexuid":o.yandexuid,"-loggedin":o.loggedin,"-coordinates_gp":n.coordinates_gp||o.coordinates_gp,"-referrer":r._getReferrer(o),"-source":n.source,"-sourceMethod":n.sourceMethod,"-type":t.isCustom?n.type:"","-additional":s,"-adb":i(Ya.blocker)||i(o.blocker),"-cdn":e.YaStaticRegion,"-ua":navigator.userAgent,"-silent":t.silent,"-ts":+new Date,"-init-ts":o.initTimestamp};return o.debug&&e.console&&console[console[n.level]?n.level:"error"]("[error-counter] "+n.message,l,n.stack),{path:n.path,vars:l}},r._baseNormalizeError=function(e){var r=(e=e||{}).error,n=e.filename||e.fileName||"",t=r&&r.stack||e.stack||"",o=e.message||"",a=r&&r.additional||e.additional;return{file:n,line:e.lineno||e.lineNumber,col:e.colno||e.colNumber,stack:t,message:o,additional:a}},r._normalizeError=function(e){var n=r._baseNormalizeError(e),t="uncaught",o=r._isExternalError(n.file,n.message,n.stack),a="",i="";return o.hasExternal?(t="external",a=o.common,i=o.custom):/^Script error\.?$/.test(n.message)&&(t="script"),n.external=a,n.externalCustom=i,n.type=t,n},r._createVarsString=function(e){var r=[];for(var n in e)e.hasOwnProperty(n)&&(e[n]||0===e[n])&&r.push(n+"="+encodeURIComponent(e[n]).replace(/\*/g,"%2A"));return r.join(",")},r._sendError=function(e,n){r.send(null,e,r._createVarsString(n),null,null,null,null)};var s=function(e){r._handleError(e,!1)},l=function(e){var n=e.target;if(n){var t=n.srcset||n.src;if(t||(t=n.href),t){var o=n.tagName||"UNKNOWN";r.logError({message:o+" load error",additional:{src:t}})}}};r._parseTraceablePromiseStack=function(){}}("undefined"!=typeof self?self:window,Ya.Rum);
!function(e){var r={url:{0:/(miscellaneous|extension)_bindings/,1:/^chrome:/,2:/kaspersky-labs\.com\//,3:/^(?:moz|chrome|safari)-extension:\/\//,4:/^file:/,5:/^resource:\/\//,6:/webnetc\.top/,7:/local\.adguard\.com/},message:{0:/__adgRemoveDirect/,1:/Content Security Policy/,2:/vid_mate_check/,3:/ucapi/,4:/Access is denied/i,5:/^Uncaught SecurityError/i,6:/__ybro/,7:/__show__deepen/,8:/ntp is not defined/,9:/Cannot set property 'install' of undefined/,10:/NS_ERROR/,11:/Error loading script/,12:/^TypeError: undefined is not a function$/,13:/__firefox__\.(?:favicons|metadata|reader|searchQueryForField|searchLoginField)/},stack:{0:/(?:moz|chrome|safari)-extension:\/\//,1:/adguard.*\.user\.js/i}};function n(e,r){if(e&&r){var n=[];for(var o in r)if(r.hasOwnProperty(o)){var i=r[o];"string"==typeof i&&(i=new RegExp(i)),i instanceof RegExp&&i.test(e)&&n.push(o)}return n.join("_")}}function o(e,o){var i,a=[];for(var t in r)r.hasOwnProperty(t)&&(i=n(e[t],o[t]))&&a.push(t+"~"+i);return a.join(";")}e._isExternalError=function(n,i,a){var t=e._errorSettings.filters||{},s={url:(n||"")+"",message:(i||"")+"",stack:(a||"")+""},c=o(s,r),u=o(s,t);return{common:c,custom:u,hasExternal:!(!c&&!u)}}}(Ya.Rum);
Ya.Rum.initErrors({
        reqid: '1768063131643963-5455682025770295793',
        project: 'education-web',
        env: 'production',
        page: window.location.pathname,
        version: 'undefined',
        platform: window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop'
    });</script><style></style><style></style><script nonce="" id="yandex-metrika">
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
  m[i].l=1*new Date();
  for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
  k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
</script><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/0f6801932ea3fcf4-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/305b936a915bc48f-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/3fdc59da94114ecd-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/a853c69d3cf13b17-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/b4b0da158404816f-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/c8ae0fac15b37b16-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/cc87cb16fedd6384-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/dd32e121f6104240-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/e10f0a1f1c5bddfe-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/f2f0493f5123f937-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/f3f9c83d0bcb2176-s.p.woff2" as="font" crossorigin="" nonce="" type="font/woff2"><link rel="preload" as="style" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84de599a45688bb1.css"><link rel="preload" as="style" href="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c08d5e89b37d645e.css"></head><body class="utilityfocus HR-9-31-0 Theme Theme_color_hrLight Theme_root_hrLight Theme_controls_size_m styles_with-sticky-drawer__bAg_p" style="overflow: initial;"><div hidden=""><!--$--><!--/$--></div><script id="hasOwnPolyfill" nonce="">('hasOwn' in Object) || (Object.hasOwn = Object.call.bind(Object.hasOwnProperty));</script><script id="UserAGentUADataPolyfill" nonce="">
  function applyUADataPolyfill(){
    function e(a){let b=/Windows NT (\d+(\.\d+)*)/.exec(a);if(!b)return null;let c={"6.1":"0.1","6.2":"0.2","6.3":"0.3","10.0":"10.0","11.0":"13.0"}[b[1]],d=c?q(c,3):"",e="",f="";return/\b(WOW64|Win64|x64)\b/.test(a)&&(e="x86",f="64"),{platform:"Windows",platformVersion:d,architecture:e,bitness:f}}
    function f(a,b){let c=/Android (\d+(\.\d+)*)/.exec(a);if(!c)return null;let d="",e="",f=/Linux (\w+)/.exec(b);if(f&&f[1]){let a=p(f[1]);d=a[0],e=a[1]}return{platform:"Android",platformVersion:q(c[1]),architecture:d,bitness:e}}
    function g(a){let b=/(iPhone|iPod touch); CPU iPhone OS (\d+(_\d+)*)/.exec(a),c=/(iPad); CPU OS (\d+(_\d+)*)/.exec(a),d=b||c;return d?{platform:"iOS",platformVersion:q(d[2].replace(/_/g,"."))}:null}
    function h(a){let b=/Macintosh; (Intel|\w+) Mac OS X (\d+([_.]\d+)*)/.exec(a);return b?{platform:"macOS",platformVersion:q(b[2].replace(/_/g,"."))}:null}
    function i(a){let b=/CrOS (\w+) (\d+(\.\d+)*)/.exec(a);if(!b)return null;let c=p(b[1]);return{platform:"Chrome OS",platformVersion:q(b[2]),architecture:c[0],bitness:c[1]}}
    function j(a,b){for(let c of[()=>e(a),()=>f(a,b),()=>g(a),()=>h(a),()=>i(a)]){let a=c();if(a)return a}return/Linux/.test(a)?{platform:"Linux",platformVersion:""}:{platform:"Unknown",platformVersion:""}}
    function k(a,b,c){let d=/Chrome\/(\d+(\.\d+)*)/.exec(a);if(!d||"Google Inc."!==c)return null;let e=[{brand:"Chromium",version:q(d[1],4)}],f=/(Edge?)\/(\d+(\.\d+)*)/.exec(a);if(f){let a={Edge:"Microsoft Edge",Edg:"Microsoft Edge"}[f[1]];e.push({brand:a,version:q(f[2],4)})}else e.push({brand:"Google Chrome",version:q(d[1],4)});return e}
    function l(a,b){let c=/AppleWebKit\/(\d+(\.\d+)*)/.exec(a);return c&&"Apple Computer, Inc."===b?[{brand:"WebKit",version:q(c[1])}]:null}
    function m(a){let b=/Firefox\/(\d+(\.\d+)*)/.exec(a);return b?[{brand:"Firefox",version:q(b[1])}]:null}
    function n(a,b,c,d,e){let f=!1,g=[];for(let h of[()=>k(a,b,c),()=>l(a,c),()=>m(a)]){let c=h();if(c){g=c,h===k&&/\bwv\b/.test(b)&&(f=!0);let i=/(CriOS|EdgiOS|FxiOS|Version)\/(\d+(\.\d+)*)/.exec(a);if(h===l&&"iOS"===d&&i){let a={CriOS:"Google Chrome",EdgiOS:"Microsoft Edge",FxiOS:"Mozilla Firefox",Version:"Apple Safari"}[i[1]];g.push({brand:a,version:q(i[2])}),e&&!e.some(a=>a.startsWith("Safari/"))&&(f=!0)}break}}return 0===g.length&&(g=[{brand:"Not;A Brand",version:"99.0.0.0"}]),{fullVersionList:g,webview:f}}
    function o(a){let{userAgent:b,platform:c,vendor:d}=a,e=b,f=!1,g=b.replace(/\(([^)]+)\)/g,(a,b)=>(f||(e=b,f=!0),"")),h=g.match(/(\S+)\/(\S+)/g),i=b.includes("Mobile"),k=j(e,c),{fullVersionList:l,webview:m}=n(g,e,d,k.platform,h),o=l.length>0?l[l.length-1].version:"",p=l.map(a=>{let b=a.version.indexOf("."),c=-1===b?a.version:a.version.slice(0,b);return{brand:a.brand,version:c}});return{mobile:i,platform:k.platform,brands:p,platformVersion:k.platformVersion,architecture:k.architecture||"",bitness:k.bitness||"",model:"",uaFullVersion:o,fullVersionList:l,webview:m}}
    function p(a){switch(a){case"x86_64":case"x64":return["x86","64"];case"x86_32":case"x86":return["x86",""];case"armv6l":case"armv7l":case"armv8l":return[a,""];case"aarch64":return["arm","64"];default:return["",""]}}
    function q(a,b=3){let c=a.split(".");if(c.length<b)for(;c.length<b;)c.push("0");return c.join(".")}
    class r{constructor(a){this._clientHints=o(a),Object.defineProperties(this,{_clientHints:{enumerable:!1}})}get mobile(){return this._clientHints.mobile}get platform(){return this._clientHints.platform}get brands(){return this._clientHints.brands}getHighEntropyValues(a){return new Promise(b=>{if(!Array.isArray(a))throw TypeError("Argument hints must be an array");let c=new Set(a),d=this._clientHints,e={mobile:d.mobile,platform:d.platform,brands:d.brands};c.has("architecture")&&(e.architecture=d.architecture),c.has("bitness")&&(e.bitness=d.bitness),c.has("model")&&(e.model=d.model),c.has("platformVersion")&&(e.platformVersion=d.platformVersion),c.has("uaFullVersion")&&(e.uaFullVersion=d.uaFullVersion),c.has("fullVersionList")&&(e.fullVersionList=d.fullVersionList),b(e)})}toJSON(){return{mobile:this._clientHints.mobile,brands:this._clientHints.brands}}}
    function(){if("https:"===location.protocol&&!navigator.userAgentData){Object.defineProperty(r.prototype,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!1,value:"NavigatorUAData"});let a=new r(navigator);return Object.defineProperty(Navigator.prototype,"userAgentData",{enumerable:!0,configurable:!0,get:function(){return a}}),Object.defineProperty(window,"NavigatorUAData",{enumerable:!1,configurable:!0,writable:!0,value:r}),!0}return!1}
    polyfill();
  }
  applyUADataPolyfill();
</script><div class="styles_container__LRzqX"><div class="Toastify" id="defaultToastContainer"></div></div><div class="styles_container__LRzqX"><div class="Toastify" id="noCloseButtonToastContainer"></div></div><header class="styles_header__cN9zm styles_noContentWidth__pFPRk"><div class="styles_header__inset__mXfjd"><div class="styles_header__backdrop__ZkyIx"></div><section class="styles_root__IBJUG styles_header__container__J_Yo5" style="--gutter-size-xs:50px;--gutter-size-sm:50px;--gutter-size-lg:50px;--gutter-size-xl:50px"><div class="styles_header__row__nqo4h"><div class="styles_header__start__OHmLc"><div class="styles_header__logo__TIaUe"><div class="styles_logo-header_primary__Ezzwg"><a aria-label="Яндекс Образование" class="styles_logo-header__link__pDHX1 styles_logo-header__image__zuDpr" href="/"><img alt="Яндекс Образование" aria-hidden="true" class="styles_desktopOnly__j_5Ge" src="https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg"><img alt="Яндекс Образование" aria-hidden="true" class="styles_mobileOnly__3cLf9" src="https://yastatic.net/s3/education-portal/media/logo_mobile_8bc5eb38fb.svg"><h1 aria-hidden="true" class="Text Text_color_primary Text_typography_bodyS styles_logo-header__title__0_MiO styles_text__iQHEy">Яндекс Образование — Личный кабинет</h1></a></div></div></div><div aria-hidden="true" class="styles_header__controls-burger__WUP18"><div class="styles_header__swipe-element__q6aOO"></div><div class="styles_buttonsContainerMobile___WcOD"><div class="styles_header-buttons__WWn3B styles_header__buttons__z2b3Y"><a tabindex="-1" href="https://passport.yandex.ru/auth/?origin=education&amp;retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Fcpp%2Farticle%2Fdata-types"><span class="Button Button_view_primary Button_size_s Button_isInteractive Theme_controls_size_s styles_header-buttons__item__DNLsb" autocomplete="off"><span class="Button-Content Theme_palette_inverse"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span class="Text Text_hideOverflow Button-Text" aria-describedby="bfbc4b73-8fdb-4258-ab8e-cceaeaa2aca9" style="--text-max-visible-lines: 1;">Войти в ID</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></span></a></div></div><nav aria-label="Навигация по сайту" class="styles_top-menu__37_My"><div class="styles_top-menu__links__vkwzq"><a title="Школьникам" class="styles_top-menu__link__joHz8" id="19" tabindex="-1" href="/pupils">Школьникам</a><a aria-disabled="false" title="Студентам" class="styles_top-menu__link__joHz8" id="4136" tabindex="-1" href="/students">Студентам</a><a aria-disabled="false" title="Абитуриентам" class="styles_top-menu__link__joHz8" id="4137" tabindex="-1" href="/university">Абитуриентам</a><a aria-disabled="false" title="Партнёрам" class="styles_top-menu__link__joHz8" id="4138" tabindex="-1" href="https://edumakers.yandex.ru/">Партнёрам</a><a aria-disabled="false" title="События" class="styles_top-menu__link__joHz8" id="4139" tabindex="-1" href="/handbook">Хендбуки</a><a aria-disabled="false" title="Журнал" class="styles_top-menu__link__joHz8" id="4140" tabindex="-1" href="/journal">Журнал</a><a aria-disabled="false" title="AI" class="styles_top-menu__link__joHz8" id="4141" tabindex="-1" href="https://education.yandex.ru/ai">AI</a></div></nav></div><div class="styles_sideGroup__gWR7N"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_header-buttons__search__0Sfs6" aria-label="Поиск" autocomplete="off" type="button" data-testid="search-button"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_icon Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span class="Icon Icon_size_l Icon_hasGlyph_noFill Icon_oldFormat Icon_sizeManagement_self Icon_glyph_search Button-Icon styles_header-buttons__search-icon__6kEp0" aria-hidden="true" style="--hr-icon-color:var(--hr-color-text-secondary)"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11 5a6 6 0 1 0 0 12 6 6 0 0 0 0-12Zm-8 6a8 8 0 1 1 14.32 4.906l3.387 3.387a1 1 0 0 1-1.414 1.414l-3.387-3.387A8 8 0 0 1 3 11Z" fill="currentColor"></path></svg></span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_icon Button-Slot"></div><span class="Button-State"></span></span></button><div class="styles_buttonsContainerDesktop__W9OAy"><div class="styles_header-buttons__WWn3B styles_header__buttons__z2b3Y"><a tabindex="-1" href="https://passport.yandex.ru/auth/?origin=education&amp;retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Fcpp%2Farticle%2Fdata-types"><span class="Button Button_view_primary Button_size_s Button_isInteractive Theme_controls_size_s styles_header-buttons__item__DNLsb" autocomplete="off"><span class="Button-Content Theme_palette_inverse"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text">Войти в ID</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></span></a></div></div><div class="styles_header__toggle__xS3iB"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_toggle__n99_Y" aria-label="Меню" autocomplete="off" type="button" data-testid="header-menu-button"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_icon Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span class="Icon Icon_size_l Icon_hasGlyph_noFill Icon_oldFormat Icon_sizeManagement_self Icon_glyph_menu Button-Icon styles_toggleIcon__SAvbq" aria-hidden="true" style="--hr-icon-color:var(--hr-color-text-secondary)"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3 12a1 1 0 0 1 1-1h16a1 1 0 1 1 0 2H4a1 1 0 0 1-1-1ZM3 18a1 1 0 0 1 1-1h16a1 1 0 1 1 0 2H4a1 1 0 0 1-1-1ZM3 6a1 1 0 0 1 1-1h16a1 1 0 1 1 0 2H4a1 1 0 0 1-1-1Z" fill="currentColor"></path></svg></span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_icon Button-Slot"></div><span class="Button-State"></span></span></button></div></div></div></section></div></header><div class="TopDrawer_root__OZJVp TopDrawer_isOpening__po5Fn styles_drawer__QQFuJ" data-testid="TopDrawer" style="height: 812px;"><div class="TopDrawer_observer__KZrCY"><div class="TopDrawer_overlay__NhRuz"></div><div class="TopDrawer_curtain__RLie3"><div aria-label="Поиск" aria-modal="true" class="TopDrawer_content__qJybk" data-slot="content" role="dialog" tabindex="-1"><div class="styles_content__n9ucm"><button aria-label="Закрыть" class="styles_close__Tvrr3"><span class="Icon Icon_size_l Icon_hasGlyph_noFill Icon_oldFormat Icon_sizeManagement_self Icon_glyph_close" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.293 4.293a1 1 0 0 1 1.414 0L12 10.586l6.293-6.293a1 1 0 1 1 1.414 1.414L13.414 12l6.293 6.293a1 1 0 0 1-1.414 1.414L12 13.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L10.586 12 4.293 5.707a1 1 0 0 1 0-1.414Z" fill="currentColor"></path></svg></span></button><form class="styles_search__3lV53"><div class="styles_root__Yoz99" data-testid="borderlessInput-root"><span aria-hidden="true" class="Icon Icon_size_l Icon_hasGlyph_noFill Icon_oldFormat Icon_sizeManagement_self Icon_glyph_search styles_searchIcon__Fnqiw"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11 5a6 6 0 1 0 0 12 6 6 0 0 0 0-12Zm-8 6a8 8 0 1 1 14.32 4.906l3.387 3.387a1 1 0 0 1-1.414 1.414l-3.387-3.387A8 8 0 0 1 3 11Z" fill="currentColor"></path></svg></span><input autofocus="" maxlength="300" placeholder="Поиск по сайту" class="styles_search_input__xpJY1 styles_input__1iRua" value=""></div></form></div></div></div></div></div><section id="878" md="0" class="styles_root__IBJUG styles_gutter-bottom__5KdTv" style="--gutter-size-xs:0px;--gutter-size-sm:0px;--gutter-size-lg:0px;--gutter-size-xl:0px"><div><i data-ai="enable"></i></div></section><div class="hb"><div class="styles_article-side-panel__k1oHL"><div class="styles_drawer__zco4X"><div class="styles_drawerWrapper__yQ6Ju"><div class="styles_overlay__OqjzT"></div><div class="styles_drawerHeader__G3tPl"><div class="styles_panel-tabs__8BQ4K"><div class="styles_button-wrapper__A8ySg"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button__b2Aik styles_button__slVGb" aria-label="Содержание" autocomplete="off" type="button" data-testid="panel-contents-tab"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span data-icon="book" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__1BYeh" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 4.992a6.013 6.013 0 0 0-.107-.132C11.14 3.956 9.881 3 8 3H6a4 4 0 0 0-4 4v8a4 4 0 0 0 3.999 4H8c1.846 0 2.547.46 2.793.707C11.162 20.228 11.15 21 12 21c.85 0 .838-.771 1.207-1.293.246-.246.947-.707 2.793-.707h2.001A3.999 3.999 0 0 0 22 15V7a4 4 0 0 0-4-4h-2c-1.881 0-3.14.956-3.893 1.86a6.013 6.013 0 0 0-.107.132ZM6 5a2 2 0 0 0-2 2v8a2 2 0 0 0 1.999 2H8c1.28 0 2.259.19 3 .503V7.188a4.396 4.396 0 0 0-.643-1.048C9.86 5.544 9.119 5 8 5H6Zm7 12.503c.741-.313 1.72-.503 3-.503h2.001A1.999 1.999 0 0 0 20 15V7a2 2 0 0 0-2-2h-2c-1.119 0-1.86.544-2.357 1.14A4.396 4.396 0 0 0 13 7.188v10.315Z" fill="currentColor"></path></svg></span><span class="styles_text-wrapper__ap6Ri">Содержание</span></span><span class="Button-State"></span></span></button></div><div class="styles_button-wrapper__A8ySg"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button__b2Aik styles_button__slVGb" aria-label="Заметки" autocomplete="off" type="button" data-testid="panel-notes-tab"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span data-icon="bookmark" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__1BYeh" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 6a4 4 0 0 1 4-4h8a4 4 0 0 1 4 4v12.942c0 1.67-1.923 2.604-3.236 1.573L12 16.772l-4.764 3.743C5.923 21.546 4 20.611 4 18.942V6Zm4-2a2 2 0 0 0-2 2v12.942l4.764-3.743a2 2 0 0 1 2.472 0L18 18.942V6a2 2 0 0 0-2-2H8Z" fill="currentColor"></path></svg></span><span class="styles_text-wrapper__ap6Ri">Заметки</span></span><span class="Button-State"></span></span></button></div></div></div><div class="styles_drawerBody__Xqvde" aria-hidden="true" tabindex="-1" hidden=""><div class="styles_header__RdXaV"><h2 class="styles_root__EmBCZ styles_title__w1r1k" data-variant="heading" data-weight="medium" data-color="primary">Содержание</h2><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_close__InH6S styles_button__slVGb" autocomplete="off" type="button" title="закрыть"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_icon Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span data-icon="close" class="Icon Icon_size_s Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat Button-Icon" aria-hidden="true" style="--hr-icon-color:var(--hr-color-text-secondary)"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.293 4.293a1 1 0 0 1 1.414 0L12 10.586l6.293-6.293a1 1 0 1 1 1.414 1.414L13.414 12l6.293 6.293a1 1 0 0 1-1.414 1.414L12 13.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L10.586 12 4.293 5.707a1 1 0 0 1 0-1.414Z" fill="currentColor"></path></svg></span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_icon Button-Slot"></div><span class="Button-State"></span></span></button></div><div class="styles_content__rxXV3"><nav class="styles_menu__EGY9t" data-search-hidden="true" aria-label="Навигация по статье"><ul class="styles_menu-list__bqpuA"><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">1.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Введение</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->1</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">2.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Базовые конструкции C++</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->9</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp styles_open__iwALZ" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div><ul class="styles_menu-block__items-list__ZrouL"><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">2.1</span><a class="styles_menu-item__link___ZydP" href="./first-steps"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Первые шаги</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">2.2</span><span class="styles_menu-item__link___ZydP styles_menu-item__link_active__5CBIq"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__active__a59KG styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Типы данных</span><div class="styles_indicator__MC7hu styles_indicator__active__NjQNY" data-testid="sidepanel-indicator"></div></div><ul class="styles_sections__eCQId"><li class="styles_section__BUd09" data-top="212"><a href="#oblasti-vidimosti">Области видимости</a></li><li class="styles_section__BUd09" data-top="1336"><a href="#inicializaciya-lokalnyh-peremennyh">Инициализация локальных переменных</a></li><li class="styles_section__BUd09" data-top="2271"><a href="#prostye-tipy-dannyh">Простые типы данных</a></li><li class="styles_section__BUd09" data-top="3393"><a href="#razmery-standartnyh-tipov">Размеры стандартных типов</a></li><li class="styles_section__BUd09" data-top="4856"><a href="#perepolnenie-celochislennyh-tipov">Переполнение целочисленных типов</a></li><li class="styles_section__BUd09" data-top="6026"><a href="#arifmeticheskie-operacii">Арифметические операции</a></li><li class="styles_section__BUd09" data-top="8123"><a href="#chisla-s-plavayushej-tochkoj">Числа с плавающей точкой</a></li><li class="styles_section__BUd09" data-top="8815"><a href="#avtomaticheskij-vyvod-tipa">Автоматический вывод типа</a></li></ul></span></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">2.3</span><a class="styles_menu-item__link___ZydP" href="./branches-and-loops"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Ветвления и циклы</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">2.4</span><a class="styles_menu-item__link___ZydP" href="./vectors-and-strings"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Векторы и строки</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">2.5</span><a class="styles_menu-item__link___ZydP" href="./complex-data-types"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Составные типы данных</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">2.6</span><a class="styles_menu-item__link___ZydP" href="./references-pointers-const"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Ссылки, указатели, константность</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">2.7</span><a class="styles_menu-item__link___ZydP" href="./functions"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Функции</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">2.8</span><a class="styles_menu-item__link___ZydP" href="./templates"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Шаблоны</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li><li class="styles_menu-item__LxPcN"><span class="styles_root__EmBCZ styles_menu-item__label__tKCIB" data-weight="regular" data-color="primary">2.9</span><a class="styles_menu-item__link___ZydP" href="./basic-cpp-constructions"><div class="styles_menu-item__article-title__XdZVg"><span class="styles_root__EmBCZ styles_menu-item__article-title-text__BTrkr" data-weight="regular" data-color="primary">Разбор задач к главе «Базовые конструкции C++»</span><div class="styles_indicator__MC7hu styles_indicator__inactive__UTnKP" data-testid="sidepanel-indicator"></div></div></a></li></ul></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">3.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Стандартная библиотека C++</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->5</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">4.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Идиомы C++</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->7</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li><li class="styles_menu-block__WLHSg"><div class="styles_accordion__IP9mb" data-testid="sidepanel-accordion"><div class="styles_divider__vpyCs styles_divider__g8Mhh"></div><div class="styles_title__IKvyk" tabindex="0" role="button"><div class="styles_menu-block__chapter-title__juSkS"><h2 class="styles_root__EmBCZ styles_menu-block__title-number__Ru7_L" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">5.</h2><div class="styles_menu-block__progress__78kU4"><h2 class="styles_root__EmBCZ styles_menu-block__title__Msaqv" style="font-size:20px" data-variant="heading" data-weight="medium" data-color="primary">Приложение</h2><span class="styles_root__EmBCZ" style="font-size:16px" data-weight="regular" data-color="secondary">Пройдено<!-- --> <!-- -->0<!-- -->/<!-- -->2</span></div></div><span data-icon="arrowShortRight" class="Icon Icon_size_m Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_icon__Ppqtp" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></div></li></ul></nav></div></div></div><div class="styles_children__KSNca"><meta property="og:type" content="article" itemprop=""><meta property="article:modified_time" content="2026-01-10T12:07:10.674Z" itemprop=""><meta property="article:section" content="Основы С++" itemprop=""><div class="styles_container__SBhDc"><div class="styles_progressContainer__1vGGr"><div class="styles_progressBar__XS_vE" style="width:11px"></div></div><div class="styles_articleCover__EKYZn"><div class="styles_root__jRQsx styles_breadcrumbs__nMPkF" data-search-hidden="true"><div class="styles_backArrow__WbYmN"><span data-icon="arrowShortRight" aria-hidden="true" class="Icon Icon_size_xs Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div><nav aria-label="Хлебные крошки" class="styles_root__vgBQ1" data-search-hidden="true"><ol class="styles_items__QJQzv" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="styles_item__uyDoI" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/" tabindex="0" data-react-aria-pressable="true" itemprop="item" class=""><span class="styles_root__EmBCZ" itemprop="name" data-weight="regular" data-color="inherit">Главная</span></a><meta itemprop="position" content="0"></li><li aria-hidden="true" class="styles_separator__tQEdo">/</li><li class="styles_item__uyDoI" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/handbook" tabindex="0" data-react-aria-pressable="true" itemprop="item" class=""><span class="styles_root__EmBCZ" itemprop="name" data-weight="regular" data-color="inherit">Хендбуки</span></a><meta itemprop="position" content="1"></li><li aria-hidden="true" class="styles_separator__tQEdo">/</li><li class="styles_item__uyDoI styles_showMobile__l2S6V" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/handbook/cpp" tabindex="0" data-react-aria-pressable="true" itemprop="item" class=""><span class="styles_root__EmBCZ" itemprop="name" data-weight="regular" data-color="inherit">Основы С++</span></a><meta itemprop="position" content="2"></li><li aria-hidden="true" class="styles_separator__tQEdo">/</li><li class="styles_item__uyDoI" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><span class="styles_root__EmBCZ" itemprop="name" data-weight="regular" data-color="inherit">Типы данных</span><meta itemprop="position" content="3"></li></ol></nav></div><h1 class="styles_root__EmBCZ styles_title__Ae0WW" data-search-hidden="true" data-variant="heading" data-weight="medium" data-color="primary">2.2 Типы данных</h1></div><main class="styles_root__R5rVX" data-testid="ArticleContent-root" data-ai-main-material="true"><div class="hljs_hljs-atelier-heath__2Efzm styles_content__jb6Og" id="article-content"><div class="styles_notes-from-selected__d23uG"><div><div class="styles_content__Lzr6L"><div id="wysiwyg-client-content"><p>C++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.</p>
<p>В этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.</p>
<h2 id="oblasti-vidimosti">Области видимости</h2>
<p>В С++ существует понятие <a href="https://en.cppreference.com/w/cpp/language/scope" target="_blank" rel="noopener noreferrer">области видимости</a> (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="%23include%20%3Ciostream%3E%0A%0Aint%20a%20%3D%201%3B%20%20%2F%2F%20%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%0A%0Aint%20main()%20%7B%0A%20%20%20%20int%20b%20%3D%202%3B%20%20%2F%2F%20%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20int%20c%20%3D%203%3B%20%20%2F%2F%20%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B0%0A%20%20%20%20%20%20%20%20std%3A%3Acout%20%3C%3C%20a%20%3C%3C%20%22%20%22%20%3C%3C%20b%20%3C%3C%20%22%20%22%20%3C%3C%20c%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D0%BE%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20%D0%AD%D1%82%D0%B0%20%D1%81%D1%82%D1%80%D0%BE%D1%87%D0%BA%D0%B0%20%D0%BD%D0%B5%20%D1%81%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D0%B8%D1%80%D1%83%D0%B5%D1%82%D1%81%D1%8F%2C%0A%20%20%20%20%2F%2F%20%D1%82%D0%B0%D0%BA%20%D0%BA%D0%B0%D0%BA%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20c%20%D0%BD%D0%B5%20%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B0%20%D0%B2%20%D0%B4%D0%B0%D0%BD%D0%BD%D0%BE%D0%B9%20%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8%3A%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20c%20%3C%3C%20%22%5Cn%22%3B%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="line-number">2</span>
<span class="line-number">3</span><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// глобальная переменная</span>
<span class="line-number">4</span>
<span class="line-number">5</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">6</span>    <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;  <span class="hljs-comment">// локальная переменная</span>
<span class="line-number">7</span>    {
<span class="line-number">8</span>        <span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;  <span class="hljs-comment">// локальная переменная внутри блока</span>
<span class="line-number">9</span>        std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">"\n"</span>;  <span class="hljs-comment">// корректно</span>
<span class="line-number">10</span>    }
<span class="line-number">11</span>
<span class="line-number">12</span>    <span class="hljs-comment">// Эта строчка не скомпилируется,</span>
<span class="line-number">13</span>    <span class="hljs-comment">// так как переменная c не определена в данной области:</span>
<span class="line-number">14</span>    std::cout &lt;&lt; c &lt;&lt; <span class="hljs-string">"\n"</span>;
<span class="line-number">15</span>}
</code></pre>

  </div>
<p>В этом примере есть три области:</p>
<ul>
<li>глобальная, в которой определена переменная <code>a</code>;</li>
<li>тело функции <code>main</code>, в которой определена переменная <code>b</code>;</li>
<li>внутренний блок, в котором определена переменная <code>c</code>.</li>
</ul>
<p>В последней строке примера переменная <code>c</code> недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.</p>
<p>Рассмотрим пример:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="%23include%20%3Ciostream%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20int%20x%20%3D%201%3B%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20x%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D0%BD%D0%B0%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%B0%D0%B5%D1%82%201%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20int%20x%20%3D%202%3B%20%20%2F%2F%20%D0%BD%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%2C%20%D0%BA%20%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D0%B4%D1%83%D1%89%D0%B5%D0%BC%D1%83%20x%20%D0%BD%D0%B5%20%D0%B8%D0%BC%D0%B5%D0%B5%D1%82%20%D0%BE%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D1%8F%0A%20%20%20%20%20%20%20%20std%3A%3Acout%20%3C%3C%20x%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D0%BD%D0%B0%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%B0%D0%B5%D1%82%202%0A%20%20%20%20%7D%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20x%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D1%81%D0%BD%D0%BE%D0%B2%D0%B0%20%D0%BD%D0%B0%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%B0%D0%B5%D1%82%201%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="line-number">2</span>
<span class="line-number">3</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">4</span>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;
<span class="line-number">5</span>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">"\n"</span>;  <span class="hljs-comment">// напечатает 1</span>
<span class="line-number">6</span>    {
<span class="line-number">7</span>        <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// новая переменная, к предыдущему x не имеет отношения</span>
<span class="line-number">8</span>        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">"\n"</span>;  <span class="hljs-comment">// напечатает 2</span>
<span class="line-number">9</span>    }
<span class="line-number">10</span>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">"\n"</span>;  <span class="hljs-comment">// снова напечатает 1</span>
<span class="line-number">11</span>}
</code></pre>

  </div>
<h2 id="inicializaciya-lokalnyh-peremennyh">Инициализация локальных переменных</h2>
<p>Локальные переменные простых типов, таких как <code>int</code>, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: <a href="https://en.cppreference.com/w/cpp/language/Zero-overhead_principle" target="_blank" rel="noopener noreferrer"><em>мы не должны платить за то, что не используем</em></a>.</p>
<p>Следующий фрагмент кода может напечатать всё что угодно:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="%23include%20%3Ciostream%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20int%20x%3B%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20x%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D0%BD%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D0%BE%D0%B5%20%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5!%0A%20%20%20%20int%20y%3B%0A%20%20%20%20std%3A%3Acin%20%3E%3E%20y%3B%20%20%2F%2F%20%D0%B0%20%D1%8D%D1%82%D0%BE%20%D0%B4%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BC%D1%8B%D0%B9%20%D1%81%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D0%B9%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="line-number">2</span>
<span class="line-number">3</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">4</span>    <span class="hljs-type">int</span> x;
<span class="line-number">5</span>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">"\n"</span>;  <span class="hljs-comment">// неопределённое поведение!</span>
<span class="line-number">6</span>    <span class="hljs-type">int</span> y;
<span class="line-number">7</span>    std::cin &gt;&gt; y;  <span class="hljs-comment">// а это допустимый сценарий</span>
<span class="line-number">8</span>}
</code></pre>

  </div>
<p>Компиляторы <code>g++</code> и <code>clang++</code> обычно дают предупреждения о чтении неинициализированных переменных при использовании опции <code>-Wall</code> или <code>-Wuninitialized</code>:</p>
<pre>$ clang++ -Wall program.cpp
program.cpp:5:18: warning: variable 'x' is uninitialized when used here [-Wuninitialized]
    std::cout &lt;&lt; x &lt;&lt; "\n";  // неопределённое поведение!
                 ^
program.cpp:4:10: note: initialize the variable 'x' to silence this warning
    int x;
         ^
          = 0
1 warning generated.
</pre>
<p>Заметим, что <code>std::string</code> является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать <code>std::string s = "";</code>. Пишите просто <code>std::string s;</code>.</p>
<h2 id="prostye-tipy-dannyh">Простые типы данных</h2>
<p>С типом <code>int</code> мы уже знакомы. Рассмотрим другие <a href="https://en.cppreference.com/w/cpp/language/types" target="_blank" rel="noopener noreferrer">фундаментальные типы данных</a> в С++. Это так называемые интегральные типы и типы для вещественных чисел.</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="int%20main()%20%7B%0A%20%20%20%20char%20c%20%3D%20'1'%3B%20%20%20%20%2F%2F%20%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%0A%20%20%20%20bool%20b%20%3D%20true%3B%20%20%20%2F%2F%20%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%2C%20%D0%BF%D1%80%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D1%82%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%20false%20%D0%B8%20true%0A%20%20%20%20int%20i%20%3D%2042%3B%20%20%20%20%20%20%2F%2F%20%D1%86%D0%B5%D0%BB%D0%BE%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%20(%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D1%82%2C%20%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%204%20%D0%B1%D0%B0%D0%B9%D1%82%D0%B0)%0A%20%20%20%20short%20int%20si%20%3D%2017%3B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%D0%BA%D0%BE%D1%80%D0%BE%D1%82%D0%BA%D0%BE%D0%B5%20%D1%86%D0%B5%D0%BB%D0%BE%D0%B5%20(%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D1%82%202%20%D0%B1%D0%B0%D0%B9%D1%82%D0%B0)%0A%20%20%20%20long%20li%20%3D%2012321321312%3B%20%20%20%20%20%20%20%2F%2F%20%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%86%D0%B5%D0%BB%D0%BE%D0%B5%20(%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%208%20%D0%B1%D0%B0%D0%B9%D1%82)%0A%20%20%20%20long%20long%20lli%20%3D%2012321321312%3B%20%2F%2F%20%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%86%D0%B5%D0%BB%D0%BE%D0%B5%20(%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%208%20%D0%B1%D0%B0%D0%B9%D1%82)%0A%20%20%20%20float%20f%20%3D%202.71828%3B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%20%D1%81%20%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9%20%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9%20(4%20%D0%B1%D0%B0%D0%B9%D1%82%D0%B0)%0A%20%20%20%20double%20d%20%3D%203.141592%3B%20%20%20%20%20%20%20%20%20%2F%2F%20%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%20%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9%20%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20(8%20%D0%B1%D0%B0%D0%B9%D1%82)%0A%20%20%20%20long%20double%20ld%20%3D%201e15%3B%20%20%20%20%20%20%20%2F%2F%20%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5%20%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D0%B5%20(%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%2016%20%D0%B1%D0%B0%D0%B9%D1%82)%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">2</span>    <span class="hljs-type">char</span> c = <span class="hljs-string">'1'</span>;    <span class="hljs-comment">// символ</span>
<span class="line-number">3</span>    <span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// логическая переменная, принимает значения false и true</span>
<span class="line-number">4</span>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;      <span class="hljs-comment">// целое число (занимает, как правило, 4 байта)</span>
<span class="line-number">5</span>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> si = <span class="hljs-number">17</span>;           <span class="hljs-comment">// короткое целое (занимает 2 байта)</span>
<span class="line-number">6</span>    <span class="hljs-type">long</span> li = <span class="hljs-number">12321321312</span>;       <span class="hljs-comment">// длинное целое (как правило, 8 байт)</span>
<span class="line-number">7</span>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> lli = <span class="hljs-number">12321321312</span>; <span class="hljs-comment">// длинное целое (как правило, 8 байт)</span>
<span class="line-number">8</span>    <span class="hljs-type">float</span> f = <span class="hljs-number">2.71828</span>;           <span class="hljs-comment">// дробное число с плавающей запятой (4 байта)</span>
<span class="line-number">9</span>    <span class="hljs-type">double</span> d = <span class="hljs-number">3.141592</span>;         <span class="hljs-comment">// дробное число двойной точности (8 байт)</span>
<span class="line-number">10</span>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> ld = <span class="hljs-number">1e15</span>;       <span class="hljs-comment">// длинное дробное (как правило, 16 байт)</span>
<span class="line-number">11</span>}
</code></pre>

  </div>
<p>Обратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную <code>c</code> символ единицы. Фактически в памяти хранится <a href="https://en.cppreference.com/w/cpp/language/ascii" target="_blank" rel="noopener noreferrer">ASCII-код</a> этого символа, который равен 49.</p>
<p>Напомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.</p>
<p>О том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора <a href="https://en.cppreference.com/w/cpp/language/sizeof" target="_blank" rel="noopener noreferrer"><code>sizeof</code></a>.</p>
<p>Например, на 64-битной Linux-системе компилятор <code>clang++</code> использует такие размеры для типов:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="int%20main()%20%7B%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22char%3A%20%22%20%3C%3C%20sizeof(char)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%201%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22bool%3A%20%22%20%3C%3C%20sizeof(bool)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%201%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22short%20int%3A%20%22%20%3C%3C%20sizeof(short%20int)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%2F%2F%20%202%20(%D0%BF%D0%BE%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D1%83%20%3E%3D%202)%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22int%3A%20%22%20%3C%3C%20sizeof(int)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%204%20(%D0%BF%D0%BE%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D1%83%20%3E%3D%202)%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22long%20int%3A%20%22%20%3C%3C%20sizeof(long%20int)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%2F%2F%20%208%20(%D0%BF%D0%BE%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D1%83%20%3E%3D%204)%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22long%20long%20int%3A%20%22%20%3C%3C%20sizeof(long%20long)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%2F%2F%20%208%20(%D0%BF%D0%BE%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D1%83%20%3E%3D%208)%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22float%3A%20%22%20%3C%3C%20sizeof(float)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%204%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22double%3A%20%22%20%3C%3C%20sizeof(double)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%208%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22long%20double%3A%20%22%20%3C%3C%20sizeof(long%20double)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%2F%2F%2016%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">2</span>    std::cout &lt;&lt; <span class="hljs-string">"char: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;                 <span class="hljs-comment">//  1</span>
<span class="line-number">3</span>    std::cout &lt;&lt; <span class="hljs-string">"bool: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;                 <span class="hljs-comment">//  1</span>
<span class="line-number">4</span>    std::cout &lt;&lt; <span class="hljs-string">"short int: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">short</span> <span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;       <span class="hljs-comment">//  2 (по стандарту &gt;= 2)</span>
<span class="line-number">5</span>    std::cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;                   <span class="hljs-comment">//  4 (по стандарту &gt;= 2)</span>
<span class="line-number">6</span>    std::cout &lt;&lt; <span class="hljs-string">"long int: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;         <span class="hljs-comment">//  8 (по стандарту &gt;= 4)</span>
<span class="line-number">7</span>    std::cout &lt;&lt; <span class="hljs-string">"long long int: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;   <span class="hljs-comment">//  8 (по стандарту &gt;= 8)</span>
<span class="line-number">8</span>    std::cout &lt;&lt; <span class="hljs-string">"float: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;               <span class="hljs-comment">//  4</span>
<span class="line-number">9</span>    std::cout &lt;&lt; <span class="hljs-string">"double: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;             <span class="hljs-comment">//  8</span>
<span class="line-number">10</span>    std::cout &lt;&lt; <span class="hljs-string">"long double: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">double</span>) &lt;&lt; <span class="hljs-string">"\n"</span>;   <span class="hljs-comment">// 16</span>
<span class="line-number">11</span>}
</code></pre>

  </div>
<h2 id="razmery-standartnyh-tipov">Размеры стандартных типов</h2>
<p>По умолчанию числовые типы – знаковые. Они имеют диапазон значений от <span class="yfm-latex" data-content="-2%5E%7Bn-1%7D" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span> до <span class="yfm-latex" data-content="2%5E%7Bn-1%7D%20-%201" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{n-1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>, где <span class="yfm-latex" data-content="n" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> – количество битов, занимаемых типом. Приставка <code>unsigned</code> перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до <span class="yfm-latex" data-content="2%5En%20-%201" data-options="%7B%22displayMode%22%3Afalse%7D"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span>:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="int%20main()%20%7B%0A%20%20%20%20unsigned%20int%20ui%20%3D%204294967295%3B%20%20%2F%2F%202%5E32%20-%201%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">2</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ui = <span class="hljs-number">4294967295</span>;  <span class="hljs-comment">// 2^32 - 1</span>
<span class="line-number">3</span>}
</code></pre>

  </div>
<p>Минимальное и максимальное значение, помещающееся в данный числовой тип, можно получить так:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="%23include%20%3Ciostream%3E%0A%23include%20%3Climits%3E%20%20%2F%2F%20%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%BE%20%D0%B4%D0%BB%D1%8F%20numeric_limits%0A%0Aint%20main()%20%7B%0A%20%20%20%20%2F%2F%20%D0%BF%D0%BE%D1%81%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D0%BC%20%D0%B4%D0%BB%D1%8F%20%D1%82%D0%B8%D0%BF%D0%B0%20int%3A%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22minimum%20value%3A%20%22%20%3C%3C%20std%3A%3Anumeric_limits%3Cint%3E%3A%3Amin()%20%3C%3C%20%22%5Cn%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%3C%20%22maximum%20value%3A%20%22%20%3C%3C%20std%3A%3Anumeric_limits%3Cint%3E%3A%3Amax()%20%3C%3C%20%22%5Cn%22%3B%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="line-number">2</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span>  <span class="hljs-comment">// необходимо для numeric_limits</span></span>
<span class="line-number">3</span>
<span class="line-number">4</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">5</span>    <span class="hljs-comment">// посчитаем для типа int:</span>
<span class="line-number">6</span>    std::cout &lt;&lt; <span class="hljs-string">"minimum value: "</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">min</span>() &lt;&lt; <span class="hljs-string">"\n"</span>
<span class="line-number">7</span>              &lt;&lt; <span class="hljs-string">"maximum value: "</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">max</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;
<span class="line-number">8</span>}
</code></pre>

  </div>
<p>Данный пример на 64-битной Linux-системе напечатает:</p>
<pre>minimum value: -2147483648
maximum value: 2147483647
</pre>
<p>Приведённые выше примеры вывода оператора <code>sizeof</code> верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. Например, <code>sizeof(long int)</code> стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. Также бывают <a href="https://en.wikipedia.org/wiki/Embedded_system" target="_blank" rel="noopener noreferrer">встраиваемые системы</a>, под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.</p>
<p>В заголовочном файле <code>cstdint</code> стандартной библиотеки имеются <a href="https://en.cppreference.com/w/cpp/types/integer" target="_blank" rel="noopener noreferrer">целочисленные типы с фиксированным размером</a>:</p>
<ul>
<li><code>int8_t</code> / <code>uint8_t</code></li>
<li><code>int16_t</code> / <code>uint16_t</code></li>
<li><code>int32_t</code> / <code>uint32_t</code></li>
<li><code>int64_t</code> / <code>uint64_t</code></li>
</ul>
<p>Число в имени типа означает количество бит, используемых для хранения в памяти. Например, <code>int32_t</code> содержит 32 бита (4 байта) и часто соответствует типу <code>int</code>. Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.</p>
<h2 id="perepolnenie-celochislennyh-tipov">Переполнение целочисленных типов</h2>
<p>Стандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="%23include%20%3Ciostream%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20unsigned%20int%20a%20%3D%20123456%3B%20%20%2F%2F%20%D0%BD%D0%B0%2064-%D0%B1%D0%B8%D1%82%D0%BD%D0%BE%D0%B9%20%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D0%B5%20sizeof(a)%20%3D%3D%204%0A%0A%20%20%20%20%2F%2F%20%D0%9F%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20a%20*%20a%20%D0%BD%D0%B5%20%D0%BF%D0%BE%D0%BC%D0%B5%D1%89%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%B2%204%20%D0%B1%D0%B0%D0%B9%D1%82%D0%B0%2C%20%D1%82%D0%B0%D0%BA%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%BE%20%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B5%202%5E32%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20a%20*%20a%20%3C%3C%20%22%5Cn%22%3B%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="line-number">2</span>
<span class="line-number">3</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">4</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">123456</span>;  <span class="hljs-comment">// на 64-битной платформе sizeof(a) == 4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>    <span class="hljs-comment">// Произведение a * a не помещается в 4 байта, так как оно больше 2^32</span>
<span class="line-number">7</span>    std::cout &lt;&lt; a * a &lt;&lt; <span class="hljs-string">"\n"</span>;
<span class="line-number">8</span>}
</code></pre>

  </div>
<p>В этом примере выражение <code>a * a</code> будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.</p>
<p>Беззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="int%20main()%20%7B%0A%20%20%20%20unsigned%20int%20x%20%3D%200%3B%20%20%20%20%20%20%2F%2F%20%D0%BD%D0%B0%2064-%D0%B1%D0%B8%D1%82%D0%BD%D0%BE%D0%B9%20%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D0%B5%20sizeof(x)%20%3D%3D%204%0A%20%20%20%20unsigned%20int%20y%20%3D%20x%20-%201%3B%20%20%2F%2F%204294967295%2C%20%D1%82%D0%BE%20%D0%B5%D1%81%D1%82%D1%8C%202**32%20-%201%0A%20%20%20%20unsigned%20int%20z%20%3D%20y%20%2B%201%3B%20%20%2F%2F%200%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">2</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;      <span class="hljs-comment">// на 64-битной платформе sizeof(x) == 4</span>
<span class="line-number">3</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> y = x - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 4294967295, то есть 2**32 - 1</span>
<span class="line-number">4</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> z = y + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 0</span>
<span class="line-number">5</span>}
</code></pre>

  </div>
<p>Наоборот, для знаковых типов переполнение приводит к так называемому <a href="https://en.cppreference.com/w/cpp/language/ub" target="_blank" rel="noopener noreferrer">неопределённому поведению</a> (UB, undefined behavior).</p>
<p>Такая ситуация не считается ошибкой компиляции (в самом деле, на стадии компиляции значения переменных могут быть ещё неизвестны). Но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.</p>
<p><strong>Беззнаковые типы</strong> следует использовать, когда вы имеете дело с битовыми наборами. В остальных случаях предпочтительнее использовать <strong>знаковые типы</strong>.</p>
<h2 id="arifmeticheskie-operacii">Арифметические операции</h2>
<p>Бинарные операции <code>+</code>, <code>-</code> и <code>*</code> работают для чисел стандартным образом. Результат операции деления <code>/</code>, применённой к целым числам, всегда округляется в сторону нуля. Таким образом, для положительных чисел операция <code>/</code> возвращает неполное частное. Остаток от деления целых чисел можно получить с помощью операции <code>%</code>.</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="int%20main()%20%7B%0A%20%20%20%20int%20a%20%3D%207%2C%20b%20%3D%203%3B%0A%20%20%20%20int%20q%20%3D%20a%20%2F%20b%3B%20%20%2F%2F%202%0A%20%20%20%20int%20r%20%3D%20a%20%25%20b%3B%20%20%2F%2F%201%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">2</span>    <span class="hljs-type">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">3</span>;
<span class="line-number">3</span>    <span class="hljs-type">int</span> q = a / b;  <span class="hljs-comment">// 2</span>
<span class="line-number">4</span>    <span class="hljs-type">int</span> r = a % b;  <span class="hljs-comment">// 1</span>
<span class="line-number">5</span>}
</code></pre>

  </div>
<p>Если при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, <code>double</code>) с помощью оператора <code>static_cast</code>:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="int%20main()%20%7B%0A%20%20%20%20int%20a%20%3D%206%2C%20b%20%3D%204%3B%0A%20%20%20%20double%20q%20%3D%20static_cast%3Cdouble%3E(a)%20%2F%20b%3B%20%20%2F%2F%201.5%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">2</span>    <span class="hljs-type">int</span> a = <span class="hljs-number">6</span>, b = <span class="hljs-number">4</span>;
<span class="line-number">3</span>    <span class="hljs-type">double</span> q = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(a) / b;  <span class="hljs-comment">// 1.5</span>
<span class="line-number">4</span>}
</code></pre>

  </div>
<p>Можно было бы написать чуть более кратко: <code>double q = a * 1.0 / b;</code>. Тогда преобразование аргументов произошло бы неявно.</p>
<p>Арифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="%23include%20%3Ciostream%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20char%20c%20%3D%20'A'%3B%0A%20%20%20%20c%20%2B%3D%2025%3B%20%20%2F%2F%20%D1%83%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%20ASCII-%D0%BA%D0%BE%D0%B4%20%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%B0%20%D0%BD%D0%B0%2025%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20c%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20Z%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="line-number">2</span>
<span class="line-number">3</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">4</span>    <span class="hljs-type">char</span> c = <span class="hljs-string">'A'</span>;
<span class="line-number">5</span>    c += <span class="hljs-number">25</span>;  <span class="hljs-comment">// увеличиваем ASCII-код символа на 25</span>
<span class="line-number">6</span>    std::cout &lt;&lt; c &lt;&lt; <span class="hljs-string">"\n"</span>;  <span class="hljs-comment">// Z</span>
<span class="line-number">7</span>}
</code></pre>

  </div>
<figure>
  <img src="https://yastatic.net/s3/education-portal/media/C_1_869495082d_9c26d1f093.svg" loading="lazy" decoding="async" alt="">
  <figcaption>
    Таблица ASCII с шестнадцатеричными кодами символов. Слева указана старшая шестнадцатеричная цифра, сверху — младшая. Цветом выделены так называемые управляющие символы, обычно не имеющие графического представления.
  </figcaption>
</figure>
<p>Операция <code>+</code> применительно к строкам означает конкатенирование (то есть склейку). Это пример <em>перегрузки</em> операции: изначальному оператору сложения чисел в стандартной библиотеке для строки придали новый смысл.</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="%23include%20%3Cstring%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20std%3A%3Astring%20a%20%3D%20%22Hello%2C%20%22%3B%0A%20%20%20%20std%3A%3Astring%20b%20%3D%20%22world!%22%3B%0A%20%20%20%20std%3A%3Astring%20c%20%3D%20a%20%2B%20b%3B%20%20%2F%2F%20Hello%2C%20world!%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="line-number">2</span>
<span class="line-number">3</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">4</span>    std::string a = <span class="hljs-string">"Hello, "</span>;
<span class="line-number">5</span>    std::string b = <span class="hljs-string">"world!"</span>;
<span class="line-number">6</span>    std::string c = a + b;  <span class="hljs-comment">// Hello, world!</span>
<span class="line-number">7</span>}
</code></pre>

  </div>
<p>Для каждой бинарной операции (например, <code>+</code>) есть версия со знаком равенства (<code>+=</code>) для случая, когда левый аргумент совпадает с переменной, которой присваивается результат:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="int%20main()%20%7B%0A%20%20%20%20int%20x%20%3D%205%3B%0A%20%20%20%20x%20%2B%3D%203%3B%20%20%2F%2F%20x%20%3D%20x%20%2B%203%0A%20%20%20%20x%20*%3D%20x%3B%20%20%2F%2F%20x%20%3D%20x%20*%20x%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">2</span>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
<span class="line-number">3</span>    x += <span class="hljs-number">3</span>;  <span class="hljs-comment">// x = x + 3</span>
<span class="line-number">4</span>    x *= x;  <span class="hljs-comment">// x = x * x</span>
<span class="line-number">5</span>}
</code></pre>

  </div>
<p>Наконец, имеются операторы <code>++</code> и <code>--</code> для увеличения или уменьшения переменной на единицу. Они бывают префиксные (<code>++x</code>) и постфиксные (<code>x++</code>). Отличие состоит в значении выражения, которое будет вычисляться при применении такого оператора. Мы рассмотрим это позже, а пока привыкнем по умолчанию использовать префиксный оператор для обычных чисел:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="int%20main()%20%7B%0A%20%20%20%20int%20x%20%3D%205%3B%0A%20%20%20%20%2B%2Bx%3B%20%20%2F%2F%206%0A%20%20%20%20--x%3B%20%20%2F%2F%20%D1%81%D0%BD%D0%BE%D0%B2%D0%B0%205%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">2</span>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
<span class="line-number">3</span>    ++x;  <span class="hljs-comment">// 6</span>
<span class="line-number">4</span>    --x;  <span class="hljs-comment">// снова 5</span>
<span class="line-number">5</span>}
</code></pre>

  </div>
<h2 id="chisla-s-plavayushej-tochkoj">Числа с плавающей точкой</h2>
<p>В языке C++ существуют три встроенных типа для записи дробных чисел: <code>float</code> (4 байта), <code>double</code> (8 байт) и <code>long double</code> (16 или 8 байт, в зависимости от платформы). В большинстве случаев рекомендуется использовать тип <code>double</code>.Тип <code>float</code> разумно использовать там, где обрабатываются огромные массивы чисел, и возникает необходимость экономить память.</p>
<p>Как правило, хранение дробных чисел в С++ основано на стандарте <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener noreferrer">IEEE 754</a>. Число представляется в виде двоичной дроби в <a href="https://en.wikipedia.org/wiki/Scientific_notation" target="_blank" rel="noopener noreferrer">экспоненциальной записи</a>: отдельно хранятся бит знака, порядок и <a href="https://en.wikipedia.org/wiki/Significand" target="_blank" rel="noopener noreferrer">мантисса</a>.</p>
<p></p><figure class="fig-img"><img class="img" src="https://yastatic.net/s3/education-portal/media/C_2_5f62557ba8_ec6023e6f3.svg" alt="C"></figure><p></p>
<p>Такое представление выгодно отличается от чисел с фиксированной точкой, где хранится фиксированное количество разрядов. Оно позволяет, хотя и с разной степенью точности, представлять числа, отличающиеся на порядки.</p>
<p>При работе с рациональными числами, знаменатель которых не является степенью двойки, неизбежно возникают погрешности представления. В следующем параграфе мы разберём как следует сравнивать такие числа.</p>
<h2 id="avtomaticheskij-vyvod-tipa">Автоматический вывод типа</h2>
<p>Компилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово <code>auto</code>:</p>

  <div class="code-block">
    <div class="code-block-header" data-content-ignore="1">
      <button class="copy-code-button">
        Скопировать код
      </button>
    </div>
    <pre class="pre-code-lines" data-content="int%20main()%20%7B%0A%20%20%20%20auto%20x%20%3D%2042%3B%20%20%2F%2F%20int%0A%20%20%20%20auto%20pi%20%3D%203.14159%3B%20%20%2F%2F%20double%0A%7D%0A" data-options="%7B%22langName%22%3A%22cpp%22%7D"><code class="hljs cpp"><span class="line-number">1</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="line-number">2</span>    <span class="hljs-keyword">auto</span> x = <span class="hljs-number">42</span>;  <span class="hljs-comment">// int</span>
<span class="line-number">3</span>    <span class="hljs-keyword">auto</span> pi = <span class="hljs-number">3.14159</span>;  <span class="hljs-comment">// double</span>
<span class="line-number">4</span>}
</code></pre>

  </div>
<p>Ключевое слово <code>auto</code> позволяет сократить код и не выписывать сложные типы (нам встретятся дальше монстры вроде <code>std::unordered_multimap&lt;Key, Value&gt;::const_iterator</code>). Важно подчеркнуть, что точный тип переменной всё равно становится известен в момент компиляции.</p>
<p>При использовании <code>auto</code> со строками нужно быть осторожным. Важно знать, что конструкция <code>auto s = "hello"</code> выведет низкоуровневый тип <code>const char *</code> (указатель на неизменяемый набор символов в памяти), а не тип-обёртку <code>std::string</code>.</p>
<p>Точные правила вывода типов похожи на правила вывода шаблонных параметров, с которыми мы познакомимся в <a href="https://education.yandex.ru/handbook/cpp/article/templates">параграфе про шаблоны</a>.</p>
<p>В следующем параграфе мы подробнее поговорим о ветвлении и циклах.</p>
</div></div></div><div class="styles_action-wrapper__qGgRM"><span class="styles_visually-hidden__mtWeI">Чтобы добавить в заметки выделенный текст, нажмите <!-- -->Command<!-- --> + E</span><button class="Button Button_view_primary Button_size_m Button_isInteractive Theme_controls_size_m styles_button__slVGb" aria-label="Добавить в заметки" autocomplete="off" type="button" role="button"><span class="Button-Content Theme_palette_inverse"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"><div class="Slot Slot_gap_s Slot_padding_s"><span class="Slot-Item"><span data-icon="bookmark" class="Icon Icon_size_s Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat Button-Icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 6a4 4 0 0 1 4-4h8a4 4 0 0 1 4 4v12.942c0 1.67-1.923 2.604-3.236 1.573L12 16.772l-4.764 3.743C5.923 21.546 4 20.611 4 18.942V6Zm4-2a2 2 0 0 0-2 2v12.942l4.764-3.743a2 2 0 0 1 2.472 0L18 18.942V6a2 2 0 0 0-2-2H8Z" fill="currentColor"></path></svg></span></span></div></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text">Добавить в заметки</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></button></div></div></div></main><div class="styles_articleProgress__u3phH"><div class="styles_root__jW9gl" data-testid="article-progress"><div class="styles_progress__YrkcK"><label class="styles_toggleLabel__YStHs styles_cursorPointer__c_j28" style="flex-direction: row; align-items: center; gap: 8px;"><div class="styles_customToggle__qxU9H styles_sizeM__LwBcS styles_cursorPointer__c_j28"><input aria-label="Параграф не прочитан" id="article-progress-checkbox" tabindex="0" type="checkbox"><span class="styles_slider__llbkm"><span class="styles_knob__Tcd6o"></span></span></div><p id="article-progress-checkbox-text" class="Text styles_label__vdsz7 styles_labelNotRead__UoDiw">Параграф прочитан</p></label></div></div><div class="styles_errorLinkWrapper__IREsd"><a target="_blank" rel="noopener noreferrer" title="Сообщить об ошибке" aria-disabled="false" id="3760" class="styles_errorLink__LlWps" href="https://forms.yandex.ru/surveys/academy/?proekt=handbooks"><svg width="18" height="19" viewBox="0 0 18 19" fill="none" xmlns="http://www.w3.org/2000/svg" class="styles_icon__6R_y4" aria-hidden="true"><path d="M0.25 9.5C0.25 11.2306 0.763179 12.9223 1.72464 14.3612C2.6861 15.8002 4.05267 16.9217 5.65152 17.5839C7.25037 18.2462 9.00971 18.4195 10.707 18.0819C12.4044 17.7442 13.9635 16.9109 15.1872 15.6872C16.4109 14.4635 17.2442 12.9044 17.5819 11.207C17.9195 9.50971 17.7462 7.75037 17.0839 6.15152C16.4217 4.55267 15.3002 3.1861 13.8612 2.22464C12.4223 1.26318 10.7306 0.75 9 0.75C6.67936 0.75 4.45376 1.67187 2.81282 3.31282C1.17187 4.95376 0.25 7.17936 0.25 9.5ZM14.7188 14.3438L4.15625 3.78125C5.59415 2.58437 7.42745 1.96811 9.29636 2.05341C11.1653 2.13872 12.9348 2.91942 14.2577 4.24231C15.5806 5.5652 16.3613 7.33474 16.4466 9.20364C16.5319 11.0725 15.9156 12.9059 14.7188 14.3438ZM4.15 15.225C2.63645 13.9397 1.69438 12.1066 1.53035 10.1278C1.36632 8.14888 1.99373 6.18572 3.275 4.66875L13.8312 15.225C12.4776 16.3688 10.7628 16.9963 8.99062 16.9963C7.21849 16.9963 5.50361 16.3688 4.15 15.225Z" fill="#666666"></path></svg><span class="styles_root__EmBCZ" data-weight="regular" data-color="primary">Сообщить об ошибке</span></a></div></div><div class="styles_v2ContestQuiz__mOOqZ"><section class="styles_articleCTA__G_f8_" data-testid="articleCTAQuiz"><div class="styles_rootInline__JE944"><div class="styles_startQuizCard__SOyLA"><img aria-hidden="true" url="https://yastatic.net/s3/education-portal/media/Group_2131327674_d995d0f6fc.svg" ext=".svg" name="icon.svg" mime="image/svg+xml" alt="Знак вопроса" loading="lazy" width="56" height="56" decoding="async" data-nimg="1" src="https://yastatic.net/s3/education-portal/media/Group_2131327674_d995d0f6fc.svg" style="color: transparent;"><h2 class="styles_root__EmBCZ styles_title__bNN0s" data-weight="medium" data-color="primary">Пройдите квиз по параграфу</h2><div class="styles_description__Lf8CO"><span class="styles_root__EmBCZ" data-weight="regular" data-color="primary">Чтобы закрепить пройденный материал</span></div><button class="Button Button_view_primary Button_size_m Button_isInteractive Theme_controls_size_m styles_startButton__NcS1s styles_button__slVGb" autocomplete="off" type="button"><span class="Button-Content Theme_palette_inverse"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span class="Text Text_hideOverflow Button-Text" style="--text-max-visible-lines: 1;">Начать</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></button></div></div></section><section class="styles_articleCTA__G_f8_" data-testid="articleCTAContest"><div class="styles_card__dqdb6" data-testid="articleCTAContest"><div class="styles_progressBlock__N2qKx"><div class="styles_title__lYW_l"><h2 class="styles_root__EmBCZ styles_title__lYW_l" data-weight="medium" data-color="inverse">Выполните задачи урока</h2><div class="styles_description__Cg_Cd"><div class="styles_mobile__ndVMS"><div aria-hidden="true" data-testid="ProgressCircle-root"><div class="RadialProgress styles_progressCircle__4EKQY" style="--radial-progress-diameter: 60px; --radial-progress-stroke: white; --radial-progress-stroke-bg: var(--color-divider-dark); --radial-progress-content: var(--progress-color-accent); --radial-progress-inner-fill: transparent; --progress-stroke-width: 8px;"><svg class="RadialProgress-Radial" width="60" height="60" viewBox="0 0 60 60"><circle class="RadialProgress-CircleBackground" cx="50%" cy="50%" r="26"></circle><circle class="RadialProgress-Circle" cx="50%" cy="50%" r="26" transform="rotate(-90 30 30)" style="stroke-dasharray: 163.363; stroke-dashoffset: 163.363;"></circle><circle class="RadialProgress-InnerCircle" cx="50%" cy="50%" r="14"></circle></svg></div></div></div><span class="styles_root__EmBCZ styles_progress__6Rwpl" data-weight="regular" data-color="inverse">0 / 2 выполнено</span></div></div></div><a class="Button Button_view_surface Button_size_m Button_isInteractive Theme_controls_size_m styles_contestButton__Q4zCt styles_button__slVGb" autocomplete="off" href="https://new.contest.yandex.ru/42154/problem" target="_blank"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span class="Text Text_hideOverflow Button-Text" style="--text-max-visible-lines: 1;">Выполнять задачи</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></a></div></section></div><section class="styles_callToAction__XgopL styles_bookCTA__HRQex"><div></div></section><div class="styles_errorLinkWrapper__pz4ZU"><a target="_blank" rel="noopener noreferrer" title="Сообщить об ошибке" aria-disabled="false" id="3760" class="styles_errorLink__e38cf" href="https://forms.yandex.ru/surveys/academy/?proekt=handbooks"><svg width="18" height="19" viewBox="0 0 18 19" fill="none" xmlns="http://www.w3.org/2000/svg" class="styles_icon__z8p3U" aria-hidden="true"><path d="M0.25 9.5C0.25 11.2306 0.763179 12.9223 1.72464 14.3612C2.6861 15.8002 4.05267 16.9217 5.65152 17.5839C7.25037 18.2462 9.00971 18.4195 10.707 18.0819C12.4044 17.7442 13.9635 16.9109 15.1872 15.6872C16.4109 14.4635 17.2442 12.9044 17.5819 11.207C17.9195 9.50971 17.7462 7.75037 17.0839 6.15152C16.4217 4.55267 15.3002 3.1861 13.8612 2.22464C12.4223 1.26318 10.7306 0.75 9 0.75C6.67936 0.75 4.45376 1.67187 2.81282 3.31282C1.17187 4.95376 0.25 7.17936 0.25 9.5ZM14.7188 14.3438L4.15625 3.78125C5.59415 2.58437 7.42745 1.96811 9.29636 2.05341C11.1653 2.13872 12.9348 2.91942 14.2577 4.24231C15.5806 5.5652 16.3613 7.33474 16.4466 9.20364C16.5319 11.0725 15.9156 12.9059 14.7188 14.3438ZM4.15 15.225C2.63645 13.9397 1.69438 12.1066 1.53035 10.1278C1.36632 8.14888 1.99373 6.18572 3.275 4.66875L13.8312 15.225C12.4776 16.3688 10.7628 16.9963 8.99062 16.9963C7.21849 16.9963 5.50361 16.3688 4.15 15.225Z" fill="#666666"></path></svg><span class="styles_root__EmBCZ" data-weight="regular" data-color="primary">Сообщить об ошибке</span></a></div><div class="styles_article-navigate__SKki7" data-testid="ArticleNavigate-root"><a class="styles_navigation-block__p937C" href="./first-steps"><span class="styles_root__EmBCZ styles_label__QNj9q" data-weight="regular" data-color="primary">Предыдущий параграф</span><span class="styles_root__EmBCZ styles_title___sZy2" data-weight="medium" data-color="primary">2.1. Первые шаги</span><p class="styles_root__EmBCZ styles_description__owkSL" data-weight="regular" data-color="secondary">В&nbsp;этом параграфе мы&nbsp;напишем первую программу на&nbsp;C++ и&nbsp;научимся печатать и&nbsp;считывать с&nbsp;клавиатуры строки и&nbsp;числа.</p><div class="styles_arrow-line__qoKkm"><span data-icon="arrowShortRight" aria-hidden="true" class="Icon Icon_size_xl Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_arrow__BhuvQ styles_back__1E0f1"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></a><a class="styles_navigation-block__p937C" href="./branches-and-loops"><span class="styles_root__EmBCZ styles_label__QNj9q" data-weight="regular" data-color="primary">Следующий параграф</span><span class="styles_root__EmBCZ styles_title___sZy2" data-weight="medium" data-color="primary">2.3. Ветвления и циклы</span><p class="styles_root__EmBCZ styles_description__owkSL" data-weight="regular" data-color="secondary">В&nbsp;этом параграфе мы&nbsp;познакомимся с&nbsp;операторами ветвления if&nbsp;и&nbsp;switch, циклами while, do-while и&nbsp;for, а&nbsp;также с&nbsp;оператором goto.</p><div class="styles_arrow-line__qoKkm"><span data-icon="arrowShortRight" aria-hidden="true" class="Icon Icon_size_xl Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat styles_arrow__BhuvQ styles_forward__d5yy6"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.293 4.293a1 1 0 0 0 0 1.414L14.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414l7-7a1 1 0 0 0 0-1.414l-7-7a1 1 0 0 0-1.414 0Z" fill="currentColor"></path></svg></span></div></a></div><section class="styles_hanbookCommunityBannerPopup__iqwEt" data-testid="HanbookCommunityBanner-root"><div><div class="styles_popupHeadderTitle__Fs756" data-test-inaccessible="true"><h3 class="styles_root__EmBCZ styles_inlineTitle__xD8ER" data-weight="medium" data-color="inverse">Вступайте в&nbsp;сообщество хендбука</h3><div class="styles_closeWrapper__WIcWK"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_popupClose__P2HBL styles_button__slVGb" aria-label="закрыть" autocomplete="off" type="button" title="закрыть"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_icon Button-Slot"></div><span class="Text Text_hideOverflow Button-Text" style="--text-max-visible-lines: 1;"><span data-icon="close" class="Icon Icon_size_s Icon_sizeManagement_self Icon_hasGlyph Icon_newFormat Button-Icon" aria-hidden="true" style="--hr-icon-color: var(--hr-color-text-secondary);"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.293 4.293a1 1 0 0 1 1.414 0L12 10.586l6.293-6.293a1 1 0 1 1 1.414 1.414L13.414 12l6.293 6.293a1 1 0 0 1-1.414 1.414L12 13.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L10.586 12 4.293 5.707a1 1 0 0 1 0-1.414Z" fill="currentColor"></path></svg></span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_icon Button-Slot"></div><span class="Button-State"></span></span></button></div></div><div data-test-inaccessible="true"><span class="styles_root__EmBCZ styles_popupHeadderDescription__9B8Oa" data-weight="regular" data-color="inverse">Здесь можно найти единомышленников, экспертов и&nbsp;просто интересных собеседников. А&nbsp;ещё&nbsp;— получить помощь или поделиться знаниями.</span><a target="_blank" rel="noopener noreferrer" title="Вступить" aria-disabled="false" id="5540" href="https://t.me/handbook_cpp"><button class="Button Button_view_ghost Button_size_m Button_isInteractive Theme_controls_size_m styles_popupJoinButton__KSomV styles_button__slVGb" autocomplete="off" type="button"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span class="Text Text_hideOverflow Button-Text" style="--text-max-visible-lines: 1;">Вступить</span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></button></a></div></div></section></div></div></div></div><!--$--><!--/$--></div><footer md="0" data-testid="Footer-root" class="styles_root__IBJUG styles_gutter-top__lwtYx styles_footer___2teW" style="background-color:#FFFFFF;--gutter-size-xs:0px;--gutter-size-sm:0px;--gutter-size-lg:0px;--gutter-size-xl:0px"><div class="styles_root__IBJUG styles_inner__lwcI4" style="--gutter-size-xs:50px;--gutter-size-sm:50px;--gutter-size-lg:50px;--gutter-size-xl:50px"><div class="styles_logo__oFZ4z"><a aria-label="Яндекс Образование" href="/"><img alt="Яндекс Образование" aria-hidden="true" class="styles_desktopOnly__j_5Ge" src="https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg"><img alt="Яндекс Образование" aria-hidden="true" class="styles_mobileOnly__3cLf9" src="https://yastatic.net/s3/education-portal/media/edu_logo_simple_9790e70002.svg"></a></div><div class="styles_columns__n2ryY"><div class="styles_column__XW85v"><ul><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4460" href="https://education.yandex.ru/uchebnik/main"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Яндекс Учебник</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4458" href="https://lyceum.yandex.ru/"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Яндекс Лицей</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4459" href="https://practicum.yandex.ru/?utm_source=partners&amp;utm_medium=partners&amp;utm_campaign=yandexeducation_partners_RF_Common_Unde_b2c_Landing-page_None_None"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Яндекс Практикум</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4461" href="https://shad.yandex.ru/"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Школа анализа данных</span></a></li><li><a aria-disabled="false" id="4463" href="/university"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Программы в университетах</span></a></li></ul></div><div class="styles_column__XW85v"><ul><li><a aria-disabled="false" id="4462" href="/research"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Исследования</span></a></li><li><a aria-disabled="false" id="4464" href="/handbook"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Хендбуки</span></a></li><li><a aria-disabled="false" id="5881" href="/roadmap"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Карты IT-навыков</span></a></li><li><a aria-disabled="false" id="4466" href="/knowledge"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">База знаний</span></a></li><li><a aria-disabled="false" id="4465" href="/journal"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Журнал</span></a></li><li><a aria-disabled="false" id="4467" href="/events"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">События</span></a></li></ul></div><div class="styles_column__XW85v"><ul><li><a aria-disabled="false" id="4468" href="/about"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">О нас</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4469" href="https://forms.yandex.ru/surveys/13457493.e7112b8cdd8c782bfe6e4b1ab1b73f49438edacf/"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Обратная связь</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4470" href="https://yandex.ru/legal/education_termsofuse/ru/"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Пользовательское соглашение</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4471" href="https://yandex.ru/edtech"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Сайт образовательной организации</span></a></li><li><a aria-disabled="false" rel="noopener noreferrer" target="_blank" id="4472" href="https://yandex.ru/edtech/sveden"><span class="Text Text_color_primary Text_typography_bodyS styles_text__iQHEy">Сведения об образовательной организации</span></a></li></ul></div></div><ul class="styles_socials__WWBdN styles_socials__Is6By"><li class="styles_social__pAnot"><a title="Рассылка" class="Button Button_view_secondary Button_size_m Button_isInteractive Theme_controls_size_m styles_button___Ftu4" aria-label="Рассылка" autocomplete="off" href="/subscribe"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span aria-hidden="true">Рассылка</span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></a></li><li class="styles_social__pAnot"><a title="Бот" class="Button Button_view_secondary Button_size_m Button_isInteractive Theme_controls_size_m styles_button___Ftu4" aria-label="Бот" autocomplete="off" href="https://t.me/yaeducation_bot?start=n_113083__c_7628"><span class="Button-Content"><div class="Slot-Wrapper Slot-Wrapper_place_left Slot-Wrapper_type_action Button-Slot"></div><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><span aria-hidden="true">Бот</span></span><div class="Slot-Wrapper Slot-Wrapper_place_right Slot-Wrapper_type_action Button-Slot"></div><span class="Button-State"></span></span></a></li><li class="styles_social__pAnot"><a title="ВКонтакте" class="Button Button_view_secondary Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button___Ftu4" aria-label="ВКонтакте" autocomplete="off" href="https://vk.com/yandex_education"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><img alt="ВКонтакте" aria-hidden="true" src="https://yastatic.net/s3/education-portal/media/social_icon_vk_97bf858cd5.svg" color="secondary" class="Button-Icon"></span><span class="Button-State"></span></span></a></li><li class="styles_social__pAnot"><a title="YouTube" class="Button Button_view_secondary Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button___Ftu4" aria-label="YouTube" autocomplete="off" href="https://www.youtube.com/@Education_Yandex"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><img alt="YouTube" aria-hidden="true" src="https://yastatic.net/s3/education-portal/media/social_icon_yt_d20daea655.svg" color="secondary" class="Button-Icon"></span><span class="Button-State"></span></span></a></li><li class="styles_social__pAnot"><a title="Telegram" class="Button Button_view_secondary Button_size_m Button_isInteractive Button_withoutSlots Theme_controls_size_m styles_button___Ftu4" aria-label="Telegram" autocomplete="off" href="https://t.me/education_yandex"><span class="Button-Content"><span style="--text-max-visible-lines:1" class="Text Text_hideOverflow Button-Text"><img alt="Telegram" aria-hidden="true" src="https://yastatic.net/s3/education-portal/media/social_icon_tg_9faafb663e.svg" color="secondary" class="Button-Icon"></span><span class="Button-State"></span></span></a></li></ul><p class="Text Text_color_primary Text_typography_bodyS styles_disclaimer__ga29X styles_text__iQHEy">Образовательные услуги оказываются АНО ДПО «Образовательные технологии Яндекса»
на&nbsp;основании <a rel="noopener noreferrer" target="_self" href="https://yastatic.net/s3/academy/docs/license-ysda.pdf">Лицензии № Л035-01298-77/00185314</a> от 24 марта 2015 года.<!-- -->
<!-- -->© 2025 Яндекс, АНО ДПО «Образовательные технологии Яндекса».</p></div></footer><script nonce="">(self.__next_s=self.__next_s||[]).push([0,{"nonce":"b15ba19d-652e-4fa7-952c-300fefd77282","children":"!function(e,t){if(e.Ya=e.Ya||{},Ya.Rum)throw new Error(\"Rum: interface is already defined\");var n=e.performance,i=n&&n.timing&&n.timing.navigationStart||Ya.startPageLoad||+new Date,s=e.requestAnimationFrame,r=function(){},a=Ya.Rum={_defTimes:[],_defRes:[],_countersToExposeAsEvents:[\"2325\",\"2616.85.1928\",\"react.inited\"],enabled:!!n,version:\"6.1.21\",vsStart:document.visibilityState,vsChanged:!1,vsChangeTime:1/0,_deltaMarks:{},_markListeners:{},_onComplete:[],_onInit:[],_unsubscribers:[],_eventLisneters:{},_settings:{},_vars:{},init:function(e,t){a._settings=e,a._vars=t},getTime:n&&n.now?function(){return n.now()}:Date.now?function(){return Date.now()-i}:function(){return new Date-i},time:function(e){a._deltaMarks[e]=[a.getTime()]},timeEnd:function(e,t){var n=a._deltaMarks[e];n&&0!==n.length&&n.push(a.getTime(),t)},sendTimeMark:function(e,t,n,i){void 0===t&&(t=a.getTime()),a.emit({metricName:\"defTimes\",data:[e,t,i]}),a.mark(e,t)},sendDelta:function(e,t,n,i){var s,r=a._deltaMarks;r[e]||void 0===t||(s=i&&i.originalEndTime?i.originalEndTime:a.getTime(),r[e]=[s-t,s,n])},sendResTiming:function(e,t){a.emit({metricName:\"defRes\",data:[e,t]})},sendRaf:function(e){var t=a.getSetting(\"forcePaintTimeSending\");if(s&&(t||a.isTimeAfterPageShow(a.getTime()))){var n=\"2616.\"+e;s((function(){a.getSetting(\"sendFirstRaf\")&&a.sendTimeMark(n+\".205\"),s((function(){a.sendTimeMark(n+\".1928\")}))}))}},isVisibilityChanged:function(){return a.vsStart&&(\"visible\"!==a.vsStart||a.vsChanged)},isTimeAfterPageShow:function(e){return\"visible\"===a.vsStart||a.vsChangeTime<e},mark:n&&n.mark?function(e,t){n.mark(e+(t?\": \"+t:\"\"))}:function(){},getSetting:function(e){var t=a._settings[e];return null===t?null:t||\"\"},on:function(e,t){if(\"function\"==typeof t)return(a._markListeners[e]=a._markListeners[e]||[]).push(t),function(){if(a._markListeners[e]){var n=a._markListeners[e].indexOf(t);n>-1&&a._markListeners[e].splice(n,1)}}},noop:r,sendTrafficData:r,finalizeLayoutShiftScore:r,finalizeLargestContentfulPaint:r,getLCPAdditionalParams:r,getCLSAdditionalParams:r,getINPAdditionalParams:r,getImageGoodnessAdditionalParams:r,_eventListeners:{},_eventsBuffer:{},subscribe:function(e,t){if(!a.getSetting(\"noEvents\"))return this._eventLisneters[e]=this._eventLisneters[e]||new Set,this._eventLisneters[e].add(t),function(){this.unsubscribe(e,t)}.bind(this)},unsubscribe:function(e,t){this._eventLisneters[e].delete(t)},emit:function(e){if(!a.getSetting(\"noEvents\")){var t=a.getSetting(\"eventsLimits\")&&a.getSetting(\"eventsLimits\")[e.metricName]||20;this._eventLisneters[e.metricName]&&this._eventLisneters[e.metricName].forEach((function(t){t(e)})),this._eventsBuffer[e.metricName]=this._eventsBuffer[e.metricName]||[],this._eventsBuffer[e.metricName].push(e),this._eventsBuffer[e.metricName].length>t&&(this._eventsBuffer[e.metricName].length=Math.floor(t/2))}},getBufferedEvents:function(e){var t=this._eventsBuffer,n={};return Object.keys(t).forEach((function(i){-1!==e.indexOf(i)&&(n[i]=t[i])})),n},clearEvents:function(e){this._eventsBuffer[e]&&(this._eventsBuffer[e].length=0)}};function f(){Ya.Rum.vsChanged=!0,Ya.Rum.vsChangeTime=a.getTime(),removeEventListener(\"visibilitychange\",f)}addEventListener(\"visibilitychange\",f),a._onVisibilityChange=f}(window);\n!function(){if(window.PerformanceLongTaskTiming){var e=function(e,n){return(e=e.concat(n)).length>300&&(e=e.slice(e.length-300)),e},n=\"undefined\"!=typeof PerformanceLongAnimationFrameTiming,t=n?[\"longtask\",\"long-animation-frame\"]:[\"longtask\"];function r(){var r=Ya.Rum._tti={events:[],loafEvents:n?[]:void 0,eventsAfterTTI:[],fired:!1,observer:new PerformanceObserver((function(t){var o=t.getEntriesByType(\"longtask\"),s=t.getEntriesByType(\"long-animation-frame\");r.events=e(r.events,o),n&&(r.loafEvents=e(r.loafEvents,s)),r.fired&&(r.eventsAfterTTI=e(r.eventsAfterTTI,o))}))};r.observer.observe({entryTypes:t}),Ya.Rum._unsubscribers&&Ya.Rum._unsubscribers.push((function(){r.observer.disconnect()}))}r(),Ya.Rum._onInit.push(r)}}();\nYa.Rum.observeDOMNode=window.IntersectionObserver?function(e,i,n){var t=this,o=Ya.Rum.getSetting(\"forcePaintTimeSending\");!function r(){if(o||!t.isVisibilityChanged()){var s=\"string\"==typeof i?document.querySelector(i):i;s?new IntersectionObserver((function(i,n){!o&&t.isVisibilityChanged()||(Ya.Rum.sendTimeMark(e),n.unobserve(s))}),n).observe(s):setTimeout(r,100)}}()}:function(){};\nvar rum_platform = window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop';\n    var rum_segment = window.location.pathname.replace(/^\\//, \"\").replace(/\\/.*/);\n    \n    if ([\"knowledge\", \"journal\", \"profile\", \"handbook\"].indexOf(rum_segment) === -1) {\n      rum_segment = \"portal\";\n    }\n\n    Ya.Rum.init({ beacon: true, clck: 'https://yandex.ru/clck/click', reqid: '1768063131643963-5455682025770295793'},\n    {\n        rum_id: 'ru.education.' + rum_platform + '.' + rum_segment,\n        '-env': 'production',\n        '-project': 'education-web',\n        '-page': window.location.pathname,\n        '-version': 'undefined',\n        '-platform': rum_platform\n    });Ya.Rum.observeDOMNode('2876', 'body');!function(){var e,t,n,i=Ya.Rum,o=42,r=4e4,g=15,a=[],s=\"\\r\\n\",l=i.getSetting(\"countersInitialDelay\")||0;if(l){var c;function u(){removeEventListener(\"visibilitychange\",h),clearTimeout(c),l=0,f()}function h(){document.hidden&&u()}c=setTimeout(u,l),addEventListener(\"visibilitychange\",h)}function f(){if(t&&a.length){for(var n=0,i=0,l=0;i<a.length&&l<=r&&n<o;i++)(l+=(i?s.length:0)+a[i].length)<=r&&n++;var c=a.splice(0,n);d(t,c.join(s)),a.length&&(e=setTimeout(f,g))}else a.length=0}function d(e,t){if(!(navigator.sendBeacon&&n&&navigator.sendBeacon(e,t))){var o=Boolean(i.getSetting(\"sendCookie\")),r=new XMLHttpRequest;r.open(\"POST\",e),r.withCredentials=o,r.send(t)}}i.send=function(c,u,h,d,v,m,S,p){t=i.getSetting(\"clck\"),n=i.getSetting(\"beacon\"),o=i.getSetting(\"maxBatchCounters\")||o,r=i.getSetting(\"maxBatchLength\")||r,g=i.getSetting(\"countersBatchTimeout\")||g,function(t,n,i,c,u,h,d,v,m,S){clearTimeout(e);var p=[t?\"/reqid=\"+t:\"\",n?\"/\"+n.join(\"/\"):\"\",i?\"/path=\"+i:\"\",c?\"/events=\"+c:\"\",u?\"/slots=\"+u.join(\";\"):\"\",h?\"/experiments=\"+h.join(\";\"):\"\",d?\"/vars=\"+d:\"\",\"/cts=\"+(new Date).getTime(),\"\",\"/*\"].join(\"\");p.length>r?\"undefined\"!=typeof console&&console.error&&console.error(\"Counter length \"+p.length+\" is more than allowed \"+r,p):(a.push(p),l||(function(){if(a.length>=o)return!0;for(var e=0,t=0;t<a.length;t++)if((e+=(t?s.length:0)+a[t].length)>=r)return!0;return!1}()?f():e=setTimeout(f,g)))}(i.getSetting(\"reqid\"),S,u,v,i.getSetting(\"slots\"),i.getSetting(\"experiments\"),h)}}();\n!function(){var e=Ya.Rum,n=!window.BigInt||!(\"PerformanceObserver\"in window);function t(n){e._unsubscribers.push(n)}function i(e,i,o){if(!n){var a=o||{};if(e){a.type=e,a.hasOwnProperty(\"buffered\")||(a.buffered=!0);var s=new PerformanceObserver((function(e,n){return i(e.getEntries(),n)}));return r((function(){try{s.observe(a)}catch(e){return void console.error(e.message)}t((function(){s.disconnect()}))}),0),s}throw new Error(\"PO without type field is forbidden\")}}function r(e,n){var i=setTimeout(e,n);return t((function(){clearInterval(i)})),i}function o(e,n,i){addEventListener(e,n,i),t((function(){removeEventListener(e,n,i)}))}function a(e,n,t){o(\"visibilitychange\",(function i(){if(\"hidden\"===document.visibilityState){try{t||(removeEventListener(\"visibilitychange\",i),e.disconnect())}catch(e){}n()}})),o(\"beforeunload\",n)}function s(e,n){return\"string\"==typeof e?encodeURIComponent(e):Math.round(1e3*(e-(n||0)))/1e3}function u(e){if(!e)return\"\";var n=(e.tagName||\"\").toLowerCase(),t=e.className&&void 0!==e.className.baseVal?e.className.baseVal:e.className;return n+(t?(\" \"+t).replace(/\\s+/g,\".\"):\"\")}function c(e){function n(){removeEventListener(\"DOMContentLoaded\",n),removeEventListener(\"load\",n),e()}\"loading\"===document.readyState?(o(\"DOMContentLoaded\",n),o(\"load\",n)):e()}function d(n){e._onComplete.push(n)}function f(){return e._periodicTasks}function l(){var n=e._vars;return Object.keys(n).map((function(e){return e+\"=\"+encodeURIComponent(n[e]).replace(/\\*/g,\"%2A\")}))}var m={connectEnd:2116,connectStart:2114,decodedBodySize:2886,domComplete:2124,domContentLoadedEventEnd:2131,domContentLoadedEventStart:2123,domInteractive:2770,domLoading:2769,domainLookupEnd:2113,domainLookupStart:2112,duration:2136,encodedBodySize:2887,entryType:2888,fetchStart:2111,initiatorType:2889,loadEventEnd:2126,loadEventStart:2125,nextHopProtocol:2890,redirectCount:1385,redirectEnd:2110,redirectStart:2109,requestStart:2117,responseEnd:2120,responseStart:2119,secureConnectionStart:2115,startTime:2322,transferSize:2323,type:76,unloadEventEnd:2128,unloadEventStart:2127,workerStart:2137},v=625;function g(n,t){Object.keys(m).forEach((function(e){if(e in t){var i=t[e];(i||0===i)&&n.push(m[e]+\"=\"+s(i))}})),n.push(\"\".concat(v,\"=\").concat(e.version))}var p,h,y,S,T,b=\"690.2096.2877\",w=\"690.2096.207\",E=\"690.2096.2044\",C=3,k=e.getSetting(\"savedDeltasLimit\")||0,L=document.createElement(\"link\"),P=window.performance||{},M=\"function\"==typeof P.getEntriesByType,_=0;function O(n,t,i,r,o){void 0===t&&(t=e.getTime()),void 0!==i&&!0!==i||e.mark(n,t);var a=I(n);if(a.push(\"207=\"+s(t)),x(a,r)){j(w,a,o&&o.force),p[n]=p[n]||[],p[n].push(t);var u=e._markListeners[n];u&&u.length&&u.forEach((function(e){e(t)})),e.emit({metricName:n,value:t,params:r})}}function I(n){return T.concat([e.isVisibilityChanged()?\"-vsChanged=1\":\"\",\"1701=\"+n,e.ajaxStart&&\"1201.2154=\"+s(e.ajaxStart),e.ajaxComplete&&\"1201.2052=\"+s(e.ajaxComplete)])}function N(){S=l(),e.getSetting(\"sendClientUa\")&&S.push(\"1042=\"+encodeURIComponent(navigator.userAgent))}function R(){var e=window.performance&&window.performance.timing&&window.performance.timing.navigationStart;T=S.concat([\"143.2129=\"+e])}function x(e,n){if(n){if(n.isCanceled&&n.isCanceled())return!1;var t=e.reduce((function(e,n,t){return\"string\"==typeof n&&(e[n.split(\"=\")[0]]=t),e}),{});Object.keys(n).forEach((function(i){if(\"function\"!=typeof n[i]){var r=t[i],o=i+\"=\"+n[i];void 0===r?e.push(o):e[r]=o}}))}return!0}function j(n,t,i){var r=encodeURIComponent(window.YaStaticRegion||\"unknown\");t.push(\"-cdn=\"+r);var o=t.filter(Boolean).join(\",\");e.send(null,n,o,void 0,void 0,void 0,void 0,i)}function z(e,n,t){j(e,F().concat(n),t)}function B(n,t){var i=y[n];i&&0!==i.length&&(i.push(e.getTime(),t),A(n))}function A(n,t,i,r){var o,a,u,c=y[n];if(void 0!==t?o=(a=r&&r.originalEndTime?r.originalEndTime:e.getTime())-t:c&&(o=c[0],a=c[1],u=c[2]),void 0!==o&&void 0!==a){var d=I(n);d.push(\"207.2154=\"+s(o),\"207.1428=\"+s(a),\"2877=\"+s(a-o)),x(d,i)&&x(d,u)&&(j(b,d,r&&r.force),_<k&&(h[n]=h[n]||[],h[n].push(a-o),_++),e.emit({metricName:n,value:a-o,params:{start:o,end:a}}),delete y[n])}}function V(e,n){if(!M)return n(null);L.href=e;var t=0,i=100,o=L.href;r((function e(){var a=P.getEntriesByName(o);if(a.length)return n(a);t++<C?(r(e,i),i+=i):n(null)}),0)}function U(e,n,t){V(n,(function(i){i&&D(e,i[i.length-1],n,t)}))}function D(n,t,i,r){var o=I(n);e.getSetting(\"sendUrlInResTiming\")&&o.push(\"13=\"+encodeURIComponent(i)),g(o,t),x(o,r),j(E,o)}function F(){return S}var W={bluetooth:2064,cellular:2065,ethernet:2066,none:1229,wifi:2067,wimax:2068,other:861,unknown:836,0:836,1:2066,2:2067,3:2070,4:2071,5:2768},H=navigator.connection;function Q(e){if(H){var n=W[H.type];e.push(\"2437=\"+(n||2771),void 0!==H.downlinkMax&&\"2439=\"+H.downlinkMax,H.effectiveType&&\"2870=\"+H.effectiveType,void 0!==H.rtt&&\"rtt=\"+H.rtt,void 0!==H.downlink&&\"dwl=\"+H.downlink,!n&&\"rawType=\"+H.type)}}var Y,q,G,J,$,K,X,Z,ee=\"690.2096.4004\",ne=!1,te=1/0,ie=1/0,re=(\"layout-shift\",Boolean(window.PerformanceObserver&&window.PerformanceObserver.supportedEntryTypes&&-1!==window.PerformanceObserver.supportedEntryTypes.indexOf(\"layout-shift\"))?0:null);function oe(){$>q&&(q=$,G=J,e.emit({metricName:\"cls-debug\",value:q,params:{clsEntries:G,target:ae(G)}}))}function ae(e){var n;if(!e)return null;var t=null;if((n=e.reduce((function(e,n){return e&&e.value>n.value?e:n})))&&n.sources&&n.sources.length){for(var i=0;i<n.sources.length;i++){var r=n.sources[i];if(r.node&&1===r.node.nodeType){t=r;break}}t=t||n.sources[0]}return t}function se(e){null==q&&(q=0);for(var n=0;n<e.length;n++){var t=e[n];t.hadRecentInput||($&&t.startTime-J[J.length-1].startTime<te&&t.startTime-J[0].startTime<ie?($+=t.value,J.push(t)):(oe(),$=t.value,J=[t]))}oe()}function ue(){q=re,Y=void 0,G=null,J=null,$=null,ne=!1}function ce(n){if(null!=q&&!ne){var t=Math.round(1e6*q)/1e6;if(Y!==t){Y=t,e.getSetting(\"enableContinuousCollection\")||(ne=!0);var i=ae(G),r=[\"s=\"+t];r.push(\"target=\"+u(i&&i.node));var o=e.getCLSAdditionalParams(i);o&&x(r,o),z(ee,r,n),e.emit({metricName:\"cls-debug\",value:q,params:{clsEntries:J,target:i,isFinalized:ne}})}}}function de(n){var t=n[n.length-1];K=t.renderTime||t.loadTime,X=t,e.emit({metricName:\"largest-contentful-paint-debug\",value:K,params:{entry:t}}),Z||(O(\"largest-loading-elem-paint\",K),Z=!0)}function fe(n){if(null!=K){var t=e.getLCPAdditionalParams(X);O(\"largest-contentful-paint\",K,!1,t,n&&{force:!0}),e.emit({metricName:\"largest-contentful-paint-debug\",value:K,params:{additionalParams:t,entry:X,isFinalized:!0}}),K=null,X=null}}e.getLCPAdditionalParams===e.noop&&(e.getLCPAdditionalParams=function(){var n={},t=X.element;if(t){n[\"-className\"]=e.getSelector(t),n[\"-tagName\"]=t.tagName.toLowerCase();var i=t.getBoundingClientRect();n[\"-width\"]=i.width,n[\"-height\"]=i.height}return X.size&&(n[\"-size\"]=X.size),n});var le={\"first-paint\":2793,\"first-contentful-paint\":2794},me=Object.keys(le).length,ve={},ge=window.performance||{},pe=\"function\"==typeof ge.getEntriesByType,he=0;function ye(){if(pe&&(e.getSetting(\"forcePaintTimeSending\")||!e.isVisibilityChanged()))for(var n=ge.getEntriesByType(\"paint\"),t=0;t<n.length;t++){var i=n[t],r=le[i.name];r&&!ve[i.name]&&(ve[i.name]=!0,he++,O(\"1926.\"+r,i.startTime))}}var Se=3e3,Te=1;function be(){return e._tti.events||[]}function we(){return e._tti.loafEvents}function Ee(){return e._tti}function Ce(n){return n?n===e.getPageUrl()?\"<page>\":n.replace(/\\?.*$/,\"\"):n}function ke(n,t,i){if(Ee()){var r=e.getTime(),o=\"undefined\"!=typeof PerformanceLongAnimationFrameTiming&&e.getSetting(\"sendLongAnimationFrames\");Le((function(a){var u,c={2796.2797:Pe(be(),t),689.2322:s(r)};if(o){var d=function(e){var n=we();if(n)return e?n.filter((function(n){return n.startTime+n.duration>=e})):n}(t);d&&(c[\"loaf.2797\"]=Pe(d,void 0,{useName:!1}),1===e.getSetting(\"longAnimationFramesMode\")&&(c[\"-additional\"]=encodeURIComponent(JSON.stringify({loaf:(u=d,u.map(Me))}))))}i&&Object.keys(i).forEach((function(e){c[e]=i[e]})),O(n||\"2795\",a,!0,c,{force:Boolean(o)}),e._tti.fired=!0}),t)}}function Le(n,t){var i=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).mode,o=void 0===i?Te:i;Ee()&&(t||(t=e.getTime()),function i(){var a,s=t,u=e.getTime(),c=o===Te?be():we()||[],d=c.length;0!==d&&(a=c[d-1],s=Math.max(s,Math.floor(a.startTime+a.duration))),u-s>=Se?n(s):r(i,1e3)}())}function Pe(e,n){var t=(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).useName,i=void 0===t||t;return n=n||0,(e=e||[]).filter((function(e){return n-e.startTime<=50})).map((function(e){var n=Math.floor(e.startTime),t=Math.floor(n+e.duration);return i?(e.name?e.name.split(\"-\").map((function(e){return e[0]})).join(\"\"):\"u\")+\"-\"+n+\"-\"+t:n+\"-\"+t})).join(\".\")}function Me(e){var n=e.blockingDuration,t=e.duration,i=e.firstUIEventTimestamp,r=e.renderStart,o=e.scripts,a=e.startTime,s=e.styleAndLayoutStart;return[Math.round(a),Math.round(t),o.map(Oe),Math.round(n),Math.round(i),Math.round(r),Math.round(s)]}function _e(e){return{\"user-callback\":1,\"event-listener\":2,\"resolve-promise\":3,\"reject-promise\":4,\"classic-script\":5,\"module-script\":6}[e]||0}function Oe(e){var n=e.invoker,t=e.sourceURL,i=e.sourceFunctionName,r=e.sourceCharPosition,o=e.startTime,a=e.duration,s=e.windowAttribution,u=e.executionStart,c=e.forcedStyleAndLayoutDuration,d=e.pauseDuration,f=e.invokerType;return[Ce(n),Ce(t),i,r,Math.round(o),Math.round(a),s,Math.round(u),Math.round(c),Math.round(d),_e(f)]}var Ie=\"690.2096.361\",Ne=document.createElement(\"a\"),Re=0,xe={};function je(e){var n=e.transferSize;if(null!=n){Ne.href=e.name;var t=Ne.pathname;if(0!==t.indexOf(\"/clck\")){var i=t.lastIndexOf(\".\"),r=\"\";return-1!==i&&t.lastIndexOf(\"/\")<i&&t.length-i<=5&&(r=t.slice(i+1)),{size:n,domain:Ne.hostname,extension:r}}}}function ze(){var n=e.getSetting(\"maxTrafficCounters\")||250;if(Re>=n)return!1;for(var t=Object.keys(xe),i=\"\",r=0;r<t.length;r++){var o=t[r],a=xe[o];i+=encodeURIComponent(o)+\"!\"+a.count+\"!\"+a.size+\";\"}return i.length&&(Re++,z(Ie,[\"d=\"+i,\"t=\"+s(e.getTime())])),xe={},Re<n}d(ze);var Be=\"690.1033\",Ae={visible:1,hidden:2,prerender:3},Ve=window.performance||{},Ue=Ve.navigation||{},De=Ve.timing||{},Fe=De.navigationStart;function We(){var n=De.domContentLoadedEventStart,t=De.domContentLoadedEventEnd;if(0!==n||0!==t){var i=0===De.responseStart?Fe:De.responseStart,o=0===De.domainLookupStart?Fe:De.domainLookupStart,a=[\"2129=\"+Fe,\"1036=\"+(o-Fe),\"1037=\"+(De.domainLookupEnd-De.domainLookupStart),\"1038=\"+(De.connectEnd-De.connectStart),De.secureConnectionStart&&\"1383=\"+(De.connectEnd-De.secureConnectionStart),\"1039=\"+(De.responseStart-De.connectEnd),\"1040=\"+(De.responseEnd-i),\"1040.906=\"+(De.responseEnd-o),\"1310.2084=\"+(De.domLoading-i),\"1310.2085=\"+(De.domInteractive-i),\"1310.1309=\"+(t-n),\"1310.1007=\"+(n-i),navigator.deviceMemory&&\"3140=\"+navigator.deviceMemory,navigator.hardwareConcurrency&&\"3141=\"+navigator.hardwareConcurrency];Object.keys(m).forEach((function(e){e in De&&De[e]&&a.push(m[e]+\"=\"+s(De[e],Fe))})),e.vsStart?(a.push(\"1484=\"+(Ae[e.vsStart]||2771)),e.vsChanged&&a.push(\"1484.719=1\")):a.push(\"1484=\"+Ae.visible),Ue&&(Ue.redirectCount&&a.push(\"1384.1385=\"+Ue.redirectCount),1!==Ue.type&&2!==Ue.type||a.push(\"770.76=\"+Ue.type)),Q(a),z(Be,a)}else r(We,50)}var He=\"690.2096.2892\",Qe=window.performance||{},Ye=\"function\"==typeof Qe.getEntriesByType;if(!e)throw new Error(\"Rum: interface is not included\");if(e.enabled){function qe(){p={},h={},_=0,y=e._deltaMarks,N(),R(),e.ajaxStart=0,e.ajaxComplete=0,c(Je)}function Ge(){var n;e.sendTimeMark=O,e.sendResTiming=U,e.sendTiming=D,e.timeEnd=B;var t=(e.getBufferedEvents([\"defRes\"]).defRes||[]).map((function(e){return e.data}));for(n=0;n<t.length;n++)U(t[n][0],t[n][1]);e.clearEvents(\"defRes\");var i=(e.getBufferedEvents([\"defTimes\"]).defTimes||[]).map((function(e){return e.data}));for(n=0;n<i.length;n++)O(i[n][0],i[n][1],!1,i[n][2]);e.clearEvents(\"defTimes\"),Object.keys(y).forEach((function(e){A(e)}))}function Je(){var n=window.performance&&window.performance.timing&&window.performance.timing.navigationStart,t=e.getSetting(\"skipTiming\"),a=e.getSetting(\"techParamsByVisible\");n&&(a&&addEventListener(\"visibilitychange\",(function n(){\"visible\"!==e.vsStart?\"visible\"===document.visibilityState&&(e.vsStart=\"visible\",removeEventListener(\"visibilitychange\",n),We()):removeEventListener(\"visibilitychange\",n)})),r((function(){Ge(),(!t&&!a||a&&\"visible\"===e.vsStart)&&We(),e.getSetting(\"disableFCP\")||(ye(),he<me&&i(\"paint\",(function(e,n){ye(),n&&he>=me&&n.disconnect()}),{buffered:!0})),e.getSetting(\"sendAutoElementTiming\")&&(!window.PerformanceObserver||!e.getSetting(\"forcePaintTimeSending\")&&e.isVisibilityChanged()||i(\"element\",(function(e){for(var n=0;n<e.length;n++){var t=e[n];O(\"element-timing.\"+t.identifier,t.startTime)}}))),o(\"pageshow\",Xe),ke(),\"complete\"===document.readyState?$e({skipTimingApi:t}):o(\"load\",$e.bind(void 0,{skipTimingApi:t}))}),0))}function $e(n){var r,s;e.getSetting(\"disableOnLoadTasks\")||(removeEventListener(\"load\",$e),n.skipTimingApi||function(){if(Ye){var e=Qe.getEntriesByType(\"navigation\")[0];if(e){var n=[];g(n,e),Q(n);var t=Qe.getEntriesByName(\"yndxNavigationSource\")[0];t&&n.push(\"2091.186=\"+t.value);var i=Qe.getEntriesByName(\"yndxNavigationToken\",\"yndxEntry\")[0];i&&n.push(\"2091.3649=\"+i.value),z(He,n)}}}(),(s=e.getSetting(\"periodicStatsIntervalMs\"))||null===s||(s=15e3),s&&(r=setInterval(Ze,s),t((function(){clearInterval(r)})),Ke=r),o(\"beforeunload\",Ze),function(){if(window.PerformanceObserver){xe={},Re=0;var e=function(e){!function(e){if(e&&e.length)for(var n=xe,t=0;t<e.length;t++){var i=je(e[t]);if(i){var r=i.domain+\"-\"+i.extension,o=n[r]=n[r]||{count:0,size:0};o.count++,o.size+=i.size}}}(e)};i(\"resource\",e),i(\"navigation\",e),f().push(ze)}}(),e.getSetting(\"disableFID\")||i(\"first-input\",(function(n,t){var i=n[0];if(i){var r=i.processingStart,o={duration:i.duration,js:i.processingEnd-r,name:i.name};i.target&&(o.target=u(i.target));var a=r-i.startTime;A(\"first-input\",a,o),e.emit({metricName:\"first-input-debug\",value:a,params:{entry:i,additionalParams:o}}),t.disconnect()}}),{buffered:!0}),e.getSetting(\"disableCLS\")||window.PerformanceObserver&&(d(ce),d(ue),q=re,G=null,J=null,$=null,te=e.getSetting(\"clsWindowGap\")||te,ie=e.getSetting(\"clsWindowSize\")||ie,a(i(\"layout-shift\",se),(function(){return ce(!0)}),!0)),e.getSetting(\"disableLCP\")||!window.PerformanceObserver||!e.getSetting(\"forcePaintTimeSending\")&&e.isVisibilityChanged()||(d(fe),K=null,X=null,Z=!1,a(i(\"largest-contentful-paint\",de),(function(){return fe(!0)}),!1)))}var Ke;function Xe(e){e.persisted&&O(\"bfcache\")}function Ze(){var e=!1;f().forEach((function(n){n()&&(e=!0)})),e||clearInterval(Ke)}d(Ge),e.destroy=function(n){var t=e._unsubscribers;n.shouldComplete&&e.completeSession(!0),e._onComplete=[];for(var i=0;i<t.length;i++)t[i]();removeEventListener(\"visibilitychange\",e._onVisibilityChange),e._unsubscribers=[],e._periodicTasks=[],e._markListeners={},e._deltaMarks={}},e.restart=function(n,t,i){e.destroy({shouldComplete:i}),e.init(n,t),addEventListener(\"visibilitychange\",e._onVisibilityChange),qe(),function(){for(var n=0;n<e._onInit.length;n++)e._onInit[n]()}()},e.setVars=function(n){Object.keys(n).forEach((function(t){e._vars[t]=n[t]})),N(),R()},e.completeSession=function(n){for(var t=e._onComplete,i=0;i<t.length;i++)t[i](n)},qe(),e._periodicTasks=[],e.sendHeroElement=function(e){O(\"2876\",e)},e.getPageUrl=function(){return window.location.href},e._subpages={},e.makeSubPage=function(n,t){var i=e._subpages[n];e._subpages[n]=void 0===i?i=0:++i;var r=!1;return{689.2322:s(void 0!==t?t:e.getTime()),2924:n,2925:i,isCanceled:function(){return r},cancel:function(){r=!0}}},e.getTimeMarks=function(){return p},e.getDeltas=function(){return h},e.getVarsList=l,e.getResourceTimings=V,e.pushConnectionTypeTo=Q,e.pushTimingTo=g,e.normalize=s,e.sendCounter=j,e.sendDelta=A,e.onReady=c,e.getSelector=u,e.getSetting(\"disableCLS\")||(e.finalizeLayoutShiftScore=ce),e.getSetting(\"disableLCP\")||(e.finalizeLargestContentfulPaint=fe),e.sendTrafficData=ze,e._getCommonVars=F,e._addListener=o,e._observe=i,e._timeout=r,e.sendTTI=ke,e._getLongtasksStringValue=Pe,e.onQuietWindow=Le,e.sendBFCacheTimeMark=Xe}else e.getSetting=function(){return\"\"},e.getVarsList=function(){return[]},e.getResourceTimings=e.completeSession=e.pushConnectionTypeTo=e.pushTimingTo=e.normalize=e.sendCounter=e.destroy=e.restart=e.setVars=e.completeSession=e.sendDelta=e.sendTimeMark=e.sendResTiming=e.sendTiming=e.sendTTI=e.makeSubPage=e.sendHeroElement=e.onReady=e.onQuietWindow=function(){}}();\n!function(n){if(!n.Ya||!Ya.Rum)throw new Error(\"Rum: interface is not defined\");var e=Ya.Rum;e.getSetting=function(n){var t=e._settings[n];return null===t?null:t||\"\"}}(\"undefined\"!=typeof self?self:window);\n!function(e,r){var n={client:[\"690.2354\",1e3,100,0],uncaught:[\"690.2361\",100,10,0],external:[\"690.2854\",100,10,0],script:[\"690.2609\",100,10,0]},t={};r.ERROR_LEVEL={INFO:\"info\",DEBUG:\"debug\",WARN:\"warn\",ERROR:\"error\",FATAL:\"fatal\"},r._errorSettings={clck:\"https://yandex.ru/clck/click\",beacon:!0,project:\"unknown\",page:\"\",env:\"\",experiments:[],additional:{},platform:\"\",region:\"\",dc:\"\",host:\"\",service:\"\",level:\"\",version:\"\",yandexuid:\"\",loggedin:!1,coordinates_gp:\"\",referrer:!0,preventError:!1,unhandledRejection:!1,traceUnhandledRejection:!1,uncaughtException:!0,debug:!1,limits:{},silent:{},filters:{},pageMaxAge:864e6,initTimestamp:+new Date};var o=!1;function a(e,r){for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n]);return e}function i(e){return\"boolean\"==typeof e&&(e=+e),\"number\"==typeof e?e+\"\":null}r.initErrors=function(n){var t=a(r._errorSettings,n);o||(t.uncaughtException&&function(){var n=r._errorSettings;if(e.addEventListener)e.addEventListener(\"error\",s),n.resourceFails&&e.addEventListener(\"error\",l,!0),\"Promise\"in e&&n.unhandledRejection&&e.addEventListener(\"unhandledrejection\",function(e){var n,t,o=e.reason,a={};o&&(o.stack&&o.message?(n=o.message,t=o.stack):(n=String(o),t=r._parseTraceablePromiseStack(e.promise),\"[object Event]\"===n?n=\"event.type: \"+o.type:\"[object Object]\"===n&&(a.unhandledObject=o)),o.target&&o.target.src&&(a.src=o.target.src),s({message:\"Unhandled rejection: \"+n,stack:t,additional:a}))});else{var t=e.onerror;e.onerror=function(e,r,n,o,a){s({error:a||new Error(e||\"Empty error\"),message:e,lineno:n,colno:o,filename:r}),t&&t.apply(this,arguments)}}}(),t.unhandledRejection&&t.traceUnhandledRejection&&r._traceUnhandledRejection&&r._traceUnhandledRejection(),o=!0)},r.updateErrors=function(e){a(r._errorSettings,e)},r.updateAdditional=function(e){r._errorSettings.additional=a(r._errorSettings.additional||{},e)},r._handleError=function(e,o,i){var s,l,c=r._errorSettings;if(c.preventError&&e.preventDefault&&e.preventDefault(),o)s=e,l=\"client\";else{s=r._normalizeError(e),l=s.type;var d=c.onError;\"function\"==typeof d&&d(s);var u=c.transform;if(\"function\"==typeof u&&(s=u(s)),!s)return;s.settings&&(i=s.settings)}var g=+new Date,f=c.initTimestamp,p=c.pageMaxAge;if(!(-1!==p&&f&&f+p<g)){var m=n[l][1];\"number\"==typeof c.limits[l]&&(m=c.limits[l]);var v=n[l][2];\"number\"==typeof c.silent[l]&&(v=c.silent[l]);var h=n[l][3];if(h<m||-1===m){s.path=n[l][0];var E=r._getErrorData(s,{silent:h<v||-1===v?\"no\":\"yes\",isCustom:Boolean(o)},a(a({},c),i)),_=function(e){t[s.message]=!1,r._sendError(e.path,e.vars),n[l][3]++}.bind(this,E);if(void 0===c.throttleSend)_();else{if(t[s.message])return;t[s.message]=!0,setTimeout(_,c.throttleSend)}}}},r._getReferrer=function(r){var n=r.referrer,t=typeof n;return\"function\"===t?n():\"string\"===t&&n?n:!1!==n&&e.location?e.location.href:void 0},r.getErrorSetting=function(e){return r._errorSettings[e]},r._buildExperiments=function(e){return e instanceof Array?e.join(\";\"):\"\"},r._buildAdditional=function(e,r){var n=\"\";try{var t=a(a({},e),r);0!==Object.keys(t).length&&(n=JSON.stringify(t))}catch(e){}return n},r._getErrorData=function(n,t,o){t=t||{};var a=r._buildExperiments(o.experiments),s=r._buildAdditional(o.additional,n.additional),l={\"-stack\":n.stack,\"-url\":n.file,\"-line\":n.line,\"-col\":n.col,\"-block\":n.block,\"-method\":n.method,\"-msg\":n.message,\"-env\":o.env,\"-external\":n.external,\"-externalCustom\":n.externalCustom,\"-project\":o.project,\"-service\":n.service||o.service,\"-page\":n.page||o.page,\"-platform\":o.platform,\"-level\":n.level,\"-experiments\":a,\"-version\":o.version,\"-region\":o.region,\"-dc\":o.dc,\"-host\":o.host,\"-yandexuid\":o.yandexuid,\"-loggedin\":o.loggedin,\"-coordinates_gp\":n.coordinates_gp||o.coordinates_gp,\"-referrer\":r._getReferrer(o),\"-source\":n.source,\"-sourceMethod\":n.sourceMethod,\"-type\":t.isCustom?n.type:\"\",\"-additional\":s,\"-adb\":i(Ya.blocker)||i(o.blocker),\"-cdn\":e.YaStaticRegion,\"-ua\":navigator.userAgent,\"-silent\":t.silent,\"-ts\":+new Date,\"-init-ts\":o.initTimestamp};return o.debug&&e.console&&console[console[n.level]?n.level:\"error\"](\"[error-counter] \"+n.message,l,n.stack),{path:n.path,vars:l}},r._baseNormalizeError=function(e){var r=(e=e||{}).error,n=e.filename||e.fileName||\"\",t=r&&r.stack||e.stack||\"\",o=e.message||\"\",a=r&&r.additional||e.additional;return{file:n,line:e.lineno||e.lineNumber,col:e.colno||e.colNumber,stack:t,message:o,additional:a}},r._normalizeError=function(e){var n=r._baseNormalizeError(e),t=\"uncaught\",o=r._isExternalError(n.file,n.message,n.stack),a=\"\",i=\"\";return o.hasExternal?(t=\"external\",a=o.common,i=o.custom):/^Script error\\.?$/.test(n.message)&&(t=\"script\"),n.external=a,n.externalCustom=i,n.type=t,n},r._createVarsString=function(e){var r=[];for(var n in e)e.hasOwnProperty(n)&&(e[n]||0===e[n])&&r.push(n+\"=\"+encodeURIComponent(e[n]).replace(/\\*/g,\"%2A\"));return r.join(\",\")},r._sendError=function(e,n){r.send(null,e,r._createVarsString(n),null,null,null,null)};var s=function(e){r._handleError(e,!1)},l=function(e){var n=e.target;if(n){var t=n.srcset||n.src;if(t||(t=n.href),t){var o=n.tagName||\"UNKNOWN\";r.logError({message:o+\" load error\",additional:{src:t}})}}};r._parseTraceablePromiseStack=function(){}}(\"undefined\"!=typeof self?self:window,Ya.Rum);\n!function(e){var r={url:{0:/(miscellaneous|extension)_bindings/,1:/^chrome:/,2:/kaspersky-labs\\.com\\//,3:/^(?:moz|chrome|safari)-extension:\\/\\//,4:/^file:/,5:/^resource:\\/\\//,6:/webnetc\\.top/,7:/local\\.adguard\\.com/},message:{0:/__adgRemoveDirect/,1:/Content Security Policy/,2:/vid_mate_check/,3:/ucapi/,4:/Access is denied/i,5:/^Uncaught SecurityError/i,6:/__ybro/,7:/__show__deepen/,8:/ntp is not defined/,9:/Cannot set property 'install' of undefined/,10:/NS_ERROR/,11:/Error loading script/,12:/^TypeError: undefined is not a function$/,13:/__firefox__\\.(?:favicons|metadata|reader|searchQueryForField|searchLoginField)/},stack:{0:/(?:moz|chrome|safari)-extension:\\/\\//,1:/adguard.*\\.user\\.js/i}};function n(e,r){if(e&&r){var n=[];for(var o in r)if(r.hasOwnProperty(o)){var i=r[o];\"string\"==typeof i&&(i=new RegExp(i)),i instanceof RegExp&&i.test(e)&&n.push(o)}return n.join(\"_\")}}function o(e,o){var i,a=[];for(var t in r)r.hasOwnProperty(t)&&(i=n(e[t],o[t]))&&a.push(t+\"~\"+i);return a.join(\";\")}e._isExternalError=function(n,i,a){var t=e._errorSettings.filters||{},s={url:(n||\"\")+\"\",message:(i||\"\")+\"\",stack:(a||\"\")+\"\"},c=o(s,r),u=o(s,t);return{common:c,custom:u,hasExternal:!(!c&&!u)}}}(Ya.Rum);\nYa.Rum.initErrors({\n        reqid: '1768063131643963-5455682025770295793',\n        project: 'education-web',\n        env: 'production',\n        page: window.location.pathname,\n        version: 'undefined',\n        platform: window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop'\n    });","id":"rum-error"}])</script><script nonce="">(self.__next_s=self.__next_s||[]).push([0,{"nonce":"b15ba19d-652e-4fa7-952c-300fefd77282","children":"\n  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};\n  m[i].l=1*new Date();\n  for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}\n  k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})\n  (window, document, \"script\", \"https://mc.yandex.ru/metrika/tag.js\", \"ym\");\n","id":"yandex-metrika"}])</script><noscript><div><img loading="lazy" src="https://mc.yandex.ru/watch/26760489" style="position:absolute;left:-9999px" alt=""/></div></noscript><script src="https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/chunks/webpack-05f11ea662126375.js" nonce="" crossorigin="" id="_R_" async=""></script><script nonce="">(self.__next_f=self.__next_f||[]).push([0])</script><script nonce="">self.__next_f.push([1,"1:\"$Sreact.fragment\"\n3:I[78919,[],\"\"]\n4:I[74619,[],\"\"]\n1a:I[34733,[],\"\"]\n1d:I[7918,[],\"OutletBoundary\"]\n1f:I[33443,[],\"AsyncMetadataOutlet\"]\n21:I[7918,[],\"ViewportBoundary\"]\n23:I[7918,[],\"MetadataBoundary\"]\n24:\"$Sreact.suspense\"\n26:I[71311,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"\"]\n28:I[45866,[\"1666\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/layout-e3a20ad13303521f.js\"],\"UseLatexRuntime\"]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/0f6801932ea3fcf4-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/305b936a915bc48f-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/3fdc59da94114ecd-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/a853c69d3cf13b17-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/b4b0da158404816f-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-"])</script><script nonce="">self.__next_f.push([1,"portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/c8ae0fac15b37b16-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/cc87cb16fedd6384-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/dd32e121f6104240-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/e10f0a1f1c5bddfe-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/f2f0493f5123f937-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/media/f3f9c83d0bcb2176-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"type\":\"font/woff2\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/00e25bd25bbd0437.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb46cd5c40721db6.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/85781da132a474d7.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]"])</script><script nonce="">self.__next_f.push([1,"\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/df0a82ffea795a48.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c800df164b7b8c22.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/033fa3e38f305e9b.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/80e3798aa7f5abc0.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/17fd"])</script><script nonce="">self.__next_f.push([1,"f933d7378e89.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a2f4cf3f3bb12d85.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d844ab516aaccc48.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb0e02f100b08559.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/381835674ab7c3f7.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/8268a37c4890f71e.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/e2bd809ab2e171e9.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84f1d4eada6960dd.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cee7c32dde4c9323.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ef486034b69d75eb.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/"])</script><script nonce="">self.__next_f.push([1,"education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/4453bad77d6636b4.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dfbd22c99f7f399e.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5c966d7ef241f1d1.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b1ea991da29cd10f.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cb7ec9243c9cb1bf.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ca947b8fe9734df5.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a412a0891b49ea16.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ddb8c975b9776637.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9425ba6f0e81e31a.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/feca8288b0586eb3.css\",\"style\",{\"cr"])</script><script nonce="">self.__next_f.push([1,"ossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d238d176bd8ae895.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9fc77bcede8e7238.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/daf421f1dcbde59d.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/bd270492e7e016dc.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/500049d7c719a090.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/3e9ccf27ab1f71e9.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b6dc735f8f16428c.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n:HL[\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/094d7d6ad311c845.css\",\"style\",{\"crossOrigin\":\"\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n"])</script><script nonce="">self.__next_f.push([1,"0:{\"P\":null,\"b\":\"xZcdS5roGxWU4G4BMA8rx\",\"p\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e\",\"c\":[\"\",\"handbook\",\"cpp\",\"article\",\"data-types\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"handbook\",{\"children\":[[\"book\",\"cpp\",\"d\"],{\"children\":[\"article\",{\"children\":[[\"article\",\"data-types\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/00e25bd25bbd0437.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb46cd5c40721db6.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/85781da132a474d7.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/df0a82ffea795a48.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/c800df164b7b8c22.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"5\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/033fa3e38f305e9b.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"6\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/80e3798aa7f5abc0.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]],\"$L2\"]}],{\"children\":[\"handbook\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"book\",\"cpp\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],\"$L5\",\"$L6\",\"$L7\",\"$L8\",\"$L9\",\"$La\",\"$Lb\",\"$Lc\",\"$Ld\",\"$Le\",\"$Lf\",\"$L10\",\"$L11\",\"$L12\",\"$L13\",\"$L14\"],\"$L15\"]}],{\"children\":[\"article\",\"$L16\",{\"children\":[[\"article\",\"data-types\",\"d\"],\"$L17\",{\"children\":[\"__PAGE__\",\"$L18\",{},null,false]},null,false]},null,false]},null,false]},null,false]},null,false],\"$L19\",false]],\"m\":\"$undefined\",\"G\":[\"$1a\",[]],\"s\":false,\"S\":false}\n"])</script><script nonce="">self.__next_f.push([1,"5:[\"$\",\"link\",\"5\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/17fdf933d7378e89.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n6:[\"$\",\"link\",\"6\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a2f4cf3f3bb12d85.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n7:[\"$\",\"link\",\"7\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d844ab516aaccc48.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n8:[\"$\",\"link\",\"8\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb0e02f100b08559.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n9:[\"$\",\"link\",\"9\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/381835674ab7c3f7.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\na:[\"$\",\"link\",\"10\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/8268a37c4890f71e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\nb:[\"$\",\"link\",\"11\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/e2bd809ab2e171e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\nc:[\"$\",\"link\",\"12\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00"])</script><script nonce="">self.__next_f.push([1,"b204e9800998ecf8427e/_next/static/css/84f1d4eada6960dd.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\nd:[\"$\",\"link\",\"13\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cee7c32dde4c9323.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\ne:[\"$\",\"link\",\"14\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ef486034b69d75eb.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\nf:[\"$\",\"link\",\"15\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/4453bad77d6636b4.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n10:[\"$\",\"link\",\"16\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dfbd22c99f7f399e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n11:[\"$\",\"link\",\"17\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5c966d7ef241f1d1.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n12:[\"$\",\"link\",\"18\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b1ea991da29cd10f.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n13:[\"$\",\"link\",\"19\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cb7ec9243c9cb1bf.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce"])</script><script nonce="">self.__next_f.push([1,"\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n14:[\"$\",\"link\",\"20\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ca947b8fe9734df5.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n16:[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}]\n17:[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L1b\"]}]\n"])</script><script nonce="">self.__next_f.push([1,"18:[\"$\",\"$1\",\"c\",{\"children\":[\"$L1c\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a412a0891b49ea16.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ddb8c975b9776637.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9425ba6f0e81e31a.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/feca8288b0586eb3.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d238d176bd8ae895.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"5\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/9fc77bcede8e7238.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"6\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/daf421f1dcbde59d.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"7\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/bd270492e7e016dc.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"8\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/500049d7c719a090.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"9\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/3e9ccf27ab1f71e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"10\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b6dc735f8f16428c.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"11\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/094d7d6ad311c845.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]],[\"$\",\"$L1d\",null,{\"children\":[\"$L1e\",[\"$\",\"$L1f\",null,{\"promise\":\"$@20\"}]]}]]}]\n"])</script><script nonce="">self.__next_f.push([1,"19:[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$L21\",null,{\"children\":\"$L22\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]],[\"$\",\"$L23\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$24\",null,{\"fallback\":null,\"children\":\"$L25\"}]}]}]]}]\n1b:[[\"$\",\"$L26\",null,{\"src\":\"https://yastatic.net/s3/cloud/forms/_/embed.js\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],\"$@27\",[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"$L28\",null,{}]]\n27:null\n22:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"2\",{\"name\":\"theme-color\",\"content\":\"#a48eef\"}]]\n1e:null\n"])</script><script nonce="">self.__next_f.push([1,"15:[\"$L29\",[\"$\",\"div\",null,{\"className\":\"hb\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],\"$L2a\"]\n2b:T1248,"])</script><script nonce="">self.__next_f.push([1,"\n  function applyUADataPolyfill(){\n    function e(a){let b=/Windows NT (\\d+(\\.\\d+)*)/.exec(a);if(!b)return null;let c={\"6.1\":\"0.1\",\"6.2\":\"0.2\",\"6.3\":\"0.3\",\"10.0\":\"10.0\",\"11.0\":\"13.0\"}[b[1]],d=c?q(c,3):\"\",e=\"\",f=\"\";return/\\b(WOW64|Win64|x64)\\b/.test(a)\u0026\u0026(e=\"x86\",f=\"64\"),{platform:\"Windows\",platformVersion:d,architecture:e,bitness:f}}\n    function f(a,b){let c=/Android (\\d+(\\.\\d+)*)/.exec(a);if(!c)return null;let d=\"\",e=\"\",f=/Linux (\\w+)/.exec(b);if(f\u0026\u0026f[1]){let a=p(f[1]);d=a[0],e=a[1]}return{platform:\"Android\",platformVersion:q(c[1]),architecture:d,bitness:e}}\n    function g(a){let b=/(iPhone|iPod touch); CPU iPhone OS (\\d+(_\\d+)*)/.exec(a),c=/(iPad); CPU OS (\\d+(_\\d+)*)/.exec(a),d=b||c;return d?{platform:\"iOS\",platformVersion:q(d[2].replace(/_/g,\".\"))}:null}\n    function h(a){let b=/Macintosh; (Intel|\\w+) Mac OS X (\\d+([_.]\\d+)*)/.exec(a);return b?{platform:\"macOS\",platformVersion:q(b[2].replace(/_/g,\".\"))}:null}\n    function i(a){let b=/CrOS (\\w+) (\\d+(\\.\\d+)*)/.exec(a);if(!b)return null;let c=p(b[1]);return{platform:\"Chrome OS\",platformVersion:q(b[2]),architecture:c[0],bitness:c[1]}}\n    function j(a,b){for(let c of[()=\u003ee(a),()=\u003ef(a,b),()=\u003eg(a),()=\u003eh(a),()=\u003ei(a)]){let a=c();if(a)return a}return/Linux/.test(a)?{platform:\"Linux\",platformVersion:\"\"}:{platform:\"Unknown\",platformVersion:\"\"}}\n    function k(a,b,c){let d=/Chrome\\/(\\d+(\\.\\d+)*)/.exec(a);if(!d||\"Google Inc.\"!==c)return null;let e=[{brand:\"Chromium\",version:q(d[1],4)}],f=/(Edge?)\\/(\\d+(\\.\\d+)*)/.exec(a);if(f){let a={Edge:\"Microsoft Edge\",Edg:\"Microsoft Edge\"}[f[1]];e.push({brand:a,version:q(f[2],4)})}else e.push({brand:\"Google Chrome\",version:q(d[1],4)});return e}\n    function l(a,b){let c=/AppleWebKit\\/(\\d+(\\.\\d+)*)/.exec(a);return c\u0026\u0026\"Apple Computer, Inc.\"===b?[{brand:\"WebKit\",version:q(c[1])}]:null}\n    function m(a){let b=/Firefox\\/(\\d+(\\.\\d+)*)/.exec(a);return b?[{brand:\"Firefox\",version:q(b[1])}]:null}\n    function n(a,b,c,d,e){let f=!1,g=[];for(let h of[()=\u003ek(a,b,c),()=\u003el(a,c),()=\u003em(a)]){let c=h();if(c){g=c,h===k\u0026\u0026/\\bwv\\b/.test(b)\u0026\u0026(f=!0);let i=/(CriOS|EdgiOS|FxiOS|Version)\\/(\\d+(\\.\\d+)*)/.exec(a);if(h===l\u0026\u0026\"iOS\"===d\u0026\u0026i){let a={CriOS:\"Google Chrome\",EdgiOS:\"Microsoft Edge\",FxiOS:\"Mozilla Firefox\",Version:\"Apple Safari\"}[i[1]];g.push({brand:a,version:q(i[2])}),e\u0026\u0026!e.some(a=\u003ea.startsWith(\"Safari/\"))\u0026\u0026(f=!0)}break}}return 0===g.length\u0026\u0026(g=[{brand:\"Not;A Brand\",version:\"99.0.0.0\"}]),{fullVersionList:g,webview:f}}\n    function o(a){let{userAgent:b,platform:c,vendor:d}=a,e=b,f=!1,g=b.replace(/\\(([^)]+)\\)/g,(a,b)=\u003e(f||(e=b,f=!0),\"\")),h=g.match(/(\\S+)\\/(\\S+)/g),i=b.includes(\"Mobile\"),k=j(e,c),{fullVersionList:l,webview:m}=n(g,e,d,k.platform,h),o=l.length\u003e0?l[l.length-1].version:\"\",p=l.map(a=\u003e{let b=a.version.indexOf(\".\"),c=-1===b?a.version:a.version.slice(0,b);return{brand:a.brand,version:c}});return{mobile:i,platform:k.platform,brands:p,platformVersion:k.platformVersion,architecture:k.architecture||\"\",bitness:k.bitness||\"\",model:\"\",uaFullVersion:o,fullVersionList:l,webview:m}}\n    function p(a){switch(a){case\"x86_64\":case\"x64\":return[\"x86\",\"64\"];case\"x86_32\":case\"x86\":return[\"x86\",\"\"];case\"armv6l\":case\"armv7l\":case\"armv8l\":return[a,\"\"];case\"aarch64\":return[\"arm\",\"64\"];default:return[\"\",\"\"]}}\n    function q(a,b=3){let c=a.split(\".\");if(c.length\u003cb)for(;c.length\u003cb;)c.push(\"0\");return c.join(\".\")}\n    class r{constructor(a){this._clientHints=o(a),Object.defineProperties(this,{_clientHints:{enumerable:!1}})}get mobile(){return this._clientHints.mobile}get platform(){return this._clientHints.platform}get brands(){return this._clientHints.brands}getHighEntropyValues(a){return new Promise(b=\u003e{if(!Array.isArray(a))throw TypeError(\"Argument hints must be an array\");let c=new Set(a),d=this._clientHints,e={mobile:d.mobile,platform:d.platform,brands:d.brands};c.has(\"architecture\")\u0026\u0026(e.architecture=d.architecture),c.has(\"bitness\")\u0026\u0026(e.bitness=d.bitness),c.has(\"model\")\u0026\u0026(e.model=d.model),c.has(\"platformVersion\")\u0026\u0026(e.platformVersion=d.platformVersion),c.has(\"uaFullVersion\")\u0026\u0026(e.uaFullVersion=d.uaFullVersion),c.has(\"fullVersionList\")\u0026\u0026(e.fullVersionList=d.fullVersionList),b(e)})}toJSON(){return{mobile:this._clientHints.mobile,brands:this._clientHints.brands}}}\n    function(){if(\"https:\"===location.protocol\u0026\u0026!navigator.userAgentData){Object.defineProperty(r.prototype,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!1,value:\"NavigatorUAData\"});let a=new r(navigator);return Object.defineProperty(Navigator.prototype,\"userAgentData\",{enumerable:!0,configurable:!0,get:function(){return a}}),Object.defineProperty(window,\"NavigatorUAData\",{enumerable:!1,configurable:!0,writable:!0,value:r}),!0}return!1}\n    polyfill();\n  }\n  applyUADataPolyfill();\n"])</script><script nonce="">self.__next_f.push([1,"2:[\"$\",\"html\",null,{\"lang\":\"ru\",\"className\":\"__className_a39d3e __variable_a39d3e __variable_5a49b6 __variable_2ac229 HR-9-31-0\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"https://yastatic.net/s3/education-portal/web/favicon.ico\",\"sizes\":\"any\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"https://yastatic.net/s3/education-portal/web/icon.svg\",\"type\":\"image/svg+xml\"}],[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"href\":\"https://yastatic.net/s3/education-portal/web/apple-touch-icon.png\"}],[\"$\",\"script\",null,{\"id\":\"ab-test-data\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"dangerouslySetInnerHTML\":{\"__html\":\"window.__AB_TEST_DATA = {\\\"flags\\\":{},\\\"experiments\\\":\\\"P54lnS9LcLo,\\\"};\"},\"suppressHydrationWarning\":true}]]}],[\"$\",\"body\",null,{\"className\":\"Theme Theme_color_hrLight Theme_root_hrLight utilityfocus\",\"children\":[[[\"$\",\"script\",null,{\"id\":\"hasOwnPolyfill\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"suppressHydrationWarning\":true,\"children\":\"('hasOwn' in Object) || (Object.hasOwn = Object.call.bind(Object.hasOwnProperty));\"}],[\"$\",\"script\",null,{\"id\":\"UserAGentUADataPolyfill\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"suppressHydrationWarning\":true,\"children\":\"$2b\"}]],\"$L2c\",\"$L2d\",\"$L2e\",\"$L2f\",\"$L30\"]}]]}]\n"])</script><script nonce="">self.__next_f.push([1,"31:I[87609,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"ErrorBoundary\"]\n32:I[46262,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"ToastContainer\"]\n33:I[85137,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"Theme\"]\n34:I[12665,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"2665\",\"static/chunks/2665-c77f7b9517a535fe.js\",\"8039\",\"static/chunks/app/error-da5ebf8e69abf3a6.js\"],\"default\"]\n43:I[79949,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"PortalMetrika\"]\n44:I[46678,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"YandexMetrikaCounter\"]\n47:I[15552,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"ScrollToTopOnPathnameChange\"]\n48:I[78705,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"7177\",\"static/chunks/app/layout-e78d4be001a57a28.js\"],\"SW\"]\n4b:I[75076,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701"])</script><script nonce="">self.__next_f.push([1,"f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"FooterPlain\"]\n2c:[\"$\",\"$L31\",null,{\"fallback\":null,\"children\":[[\"$\",\"$L32\",null,{\"containerId\":\"defaultToastContainer\",\"enableMultiContainer\":true}],[\"$\",\"$L32\",null,{\"containerId\":\"noCloseButtonToastContainer\",\"closeButton\":false,\"enableMultiContainer\":true}]]}]\n2d:[\"$\",\"$L33\",null,{}]\n"])</script><script nonce="">self.__next_f.push([1,"2e:[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$34\",\"errorStyles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]],\"errorScripts\":[],\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$L35\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/991aec17f3093e7d.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5f16a3a32691d755.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dbd806e03d28c8cc.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5dfa285aa1529eec.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"4\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/051319dc975c787e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"5\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/17fdf933d7378e89.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"6\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/a2f4cf3f3bb12d85.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"7\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/d844ab516aaccc48.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],[\"$\",\"link\",\"8\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/fb0e02f100b08559.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}],\"$L36\",\"$L37\",\"$L38\",\"$L39\",\"$L3a\",\"$L3b\",\"$L3c\",\"$L3d\",\"$L3e\",\"$L3f\",\"$L40\"]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]\n"])</script><script nonce="">self.__next_f.push([1,"2f:[\"$\",\"$L31\",null,{\"fallback\":null,\"children\":[\"$L41\",[\"$L42\",[\"$\",\"$L43\",null,{}],[\"$\",\"$L44\",null,{\"id\":26760489,\"settings\":\"defer=1,webvisor=1,hitOnInit=1,fullUrl=1\",\"firstPartyParams\":{},\"experiments\":\"P54lnS9LcLo,\"}],\"$undefined\",\"$L45\",\"$L46\"]]}]\n30:[[\"$\",\"$L31\",null,{\"fallback\":null,\"children\":[\"$\",\"$L47\",null,{}]}],[\"$\",\"$L31\",null,{\"fallback\":null,\"children\":[\"$\",\"$L48\",null,{}]}]]\n29:[[\"$\",\"$1\",\"web-page.block-0\",{\"children\":[\"$L49\"]}],\"$L4a\"]\n"])</script><script nonce="">self.__next_f.push([1,"2a:[[\"$\",\"$1\",\"web-page.block-0\",{\"children\":[[\"$\",\"$L4b\",\"web-page.footer-plain\",{\"id\":2,\"Anchor\":null,\"Theme\":\"#FFFFFF\",\"Disclaimer\":\"Образовательные услуги оказываются АНО ДПО «Образовательные технологии Яндекса»\\nна\u0026nbsp;основании [Лицензии № Л035-01298-77/00185314](https://yastatic.net/s3/academy/docs/license-ysda.pdf) от 24 марта 2015 года.\\n\\n© 2025 Яндекс, АНО ДПО «Образовательные технологии Яндекса».\",\"Columns\":[{\"id\":8,\"Name\":null,\"Links\":[{\"id\":4460,\"Text\":\"Яндекс Учебник\",\"URL\":\"https://education.yandex.ru/uchebnik/main\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4458,\"Text\":\"Яндекс Лицей\",\"URL\":\"https://lyceum.yandex.ru/\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4459,\"Text\":\"Яндекс Практикум\",\"URL\":\"https://practicum.yandex.ru/?utm_source=partners\u0026utm_medium=partners\u0026utm_campaign=yandexeducation_partners_RF_Common_Unde_b2c_Landing-page_None_None\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4461,\"Text\":\"Школа анализа данных\",\"URL\":\"https://shad.yandex.ru/\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4463,\"Text\":\"Программы в университетах\",\"URL\":\"/university\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null}]},{\"id\":9,\"Name\":null,\"Links\":[{\"id\":4462,\"Text\":\"Исследования\",\"URL\":\"/research\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4464,\"Text\":\"Хендбуки\",\"URL\":\"/handbook\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":5881,\"Text\":\"Карты IT-навыков\",\"URL\":\"/roadmap\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4466,\"Text\":\"База знаний\",\"URL\":\"/knowledge\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4465,\"Text\":\"Журнал\",\"URL\":\"/journal\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4467,\"Text\":\"События\",\"URL\":\"/events\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null}]},{\"id\":10,\"Name\":null,\"Links\":[{\"id\":4468,\"Text\":\"О нас\",\"URL\":\"/about\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4469,\"Text\":\"Обратная связь\",\"URL\":\"https://forms.yandex.ru/surveys/13457493.e7112b8cdd8c782bfe6e4b1ab1b73f49438edacf/\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4470,\"Text\":\"Пользовательское соглашение\",\"URL\":\"https://yandex.ru/legal/education_termsofuse/ru/\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4471,\"Text\":\"Сайт образовательной организации\",\"URL\":\"https://yandex.ru/edtech\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4472,\"Text\":\"Сведения об образовательной организации\",\"URL\":\"https://yandex.ru/edtech/sveden\",\"Title\":null,\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null}]}],\"Socials\":[{\"id\":4454,\"Text\":\"Рассылка\",\"URL\":\"/subscribe\",\"Title\":\"Рассылка\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":null}},{\"id\":4473,\"Text\":\"Бот\",\"URL\":\"https://t.me/yaeducation_bot?start=n_113083__c_7628\",\"Title\":\"Бот\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":null}},{\"id\":4455,\"Text\":\"ВКонтакте\",\"URL\":\"https://vk.com/yandex_education\",\"Title\":\"ВКонтакте\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":{\"id\":5,\"attributes\":{\"name\":\"social_icon_vk.svg\",\"alternativeText\":\"\",\"caption\":\"\",\"width\":40,\"height\":40,\"formats\":null,\"hash\":\"social_icon_vk_97bf858cd5\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":0.49,\"url\":\"https://yastatic.net/s3/education-portal/media/social_icon_vk_97bf858cd5.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-01T08:03:45.007Z\",\"updatedAt\":\"2024-02-09T11:21:16.497Z\"}}}},{\"id\":4456,\"Text\":\"YouTube\",\"URL\":\"https://www.youtube.com/@Education_Yandex\",\"Title\":\"YouTube\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":{\"id\":6,\"attributes\":{\"name\":\"social_icon_yt.svg\",\"alternativeText\":\"\",\"caption\":\"\",\"width\":40,\"height\":40,\"formats\":null,\"hash\":\"social_icon_yt_d20daea655\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":0.77,\"url\":\"https://yastatic.net/s3/education-portal/media/social_icon_yt_d20daea655.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-01T08:03:45.307Z\",\"updatedAt\":\"2024-02-01T08:03:45.307Z\"}}}},{\"id\":4457,\"Text\":\"Telegram\",\"URL\":\"https://t.me/education_yandex\",\"Title\":\"Telegram\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null,\"Image\":{\"data\":{\"id\":7,\"attributes\":{\"name\":\"social_icon_tg.svg\",\"alternativeText\":\"\",\"caption\":\"\",\"width\":40,\"height\":40,\"formats\":null,\"hash\":\"social_icon_tg_9faafb663e\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":1.04,\"url\":\"https://yastatic.net/s3/education-portal/media/social_icon_tg_9faafb663e.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-01T08:03:45.537Z\",\"updatedAt\":\"2024-02-01T08:03:45.537Z\"}}}}],\"Gutter\":{\"id\":569,\"xs\":0,\"sm\":0,\"md\":0,\"lg\":0,\"xl\":0},\"Logo\":{\"id\":77,\"URL\":\"/\",\"Title\":\"Яндекс Образование\",\"Image\":{\"data\":{\"id\":8,\"attributes\":{\"name\":\"edu_logo.svg\",\"alternativeText\":null,\"caption\":null,\"width\":233,\"height\":24,\"formats\":null,\"hash\":\"edu_logo_9eee76ff17\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":13.44,\"url\":\"https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-09T11:00:59.235Z\",\"updatedAt\":\"2024-12-04T04:36:42.717Z\"}}},\"ImageMobile\":{\"data\":{\"id\":3190,\"attributes\":{\"name\":\"edu-logo-simple.svg\",\"alternativeText\":\"edu-logo-simple.svg\",\"caption\":\"edu-logo-simple.svg\",\"width\":204,\"height\":21,\"formats\":null,\"hash\":\"edu_logo_simple_9790e70002\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":7.25,\"url\":\"https://yastatic.net/s3/education-portal/media/edu_logo_simple_9790e70002.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-20T11:27:57.767Z\",\"updatedAt\":\"2024-12-04T12:30:44.339Z\"}}}}}]]}]]\n"])</script><script nonce="">self.__next_f.push([1,"4d:I[93982,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"default\"]\n36:[\"$\",\"link\",\"9\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/381835674ab7c3f7.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n37:[\"$\",\"link\",\"10\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/8268a37c4890f71e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n38:[\"$\",\"link\",\"11\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/e2bd809ab2e171e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n39:[\"$\",\"link\",\"12\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/84f1d4eada6960dd.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n3a:[\"$\",\"link\",\"13\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cee7c32dde4c9323.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n3b:[\"$\",\"link\",\"14\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/ef486034b69d75eb.css\",\"precedence\":\"next\",\"crossOr"])</script><script nonce="">self.__next_f.push([1,"igin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n3c:[\"$\",\"link\",\"15\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/4453bad77d6636b4.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n3d:[\"$\",\"link\",\"16\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/dfbd22c99f7f399e.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n3e:[\"$\",\"link\",\"17\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/b1ea991da29cd10f.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n3f:[\"$\",\"link\",\"18\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/cb7ec9243c9cb1bf.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n40:[\"$\",\"link\",\"19\",{\"rel\":\"stylesheet\",\"href\":\"https://yastatic.net/s3/education-portal/web/3250da4636185ea5-d41d8cd98f00b204e9800998ecf8427e/_next/static/css/5c966d7ef241f1d1.css\",\"precedence\":\"next\",\"crossOrigin\":\"anonymous\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\"}]\n42:[\"$\",\"$L26\",null,{\"id\":\"yandex-metrika\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"strategy\":\"beforeInteractive\",\"dangerouslySetInnerHTML\":{\"__html\":\"\\n  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};\\n  m[i].l=1*new Date();\\n  for (var j = 0; j \u003c document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}\\n  k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})\\n  (window, document, \\\"script\\\", \\\"https://mc.yandex.ru/metrika/tag.js\\\", \\\"ym\\\");\\n\"}}]\n45:null\n46:null\n4c:T74e8,"])</script><script nonce="">self.__next_f.push([1,"!function(e,t){if(e.Ya=e.Ya||{},Ya.Rum)throw new Error(\"Rum: interface is already defined\");var n=e.performance,i=n\u0026\u0026n.timing\u0026\u0026n.timing.navigationStart||Ya.startPageLoad||+new Date,s=e.requestAnimationFrame,r=function(){},a=Ya.Rum={_defTimes:[],_defRes:[],_countersToExposeAsEvents:[\"2325\",\"2616.85.1928\",\"react.inited\"],enabled:!!n,version:\"6.1.21\",vsStart:document.visibilityState,vsChanged:!1,vsChangeTime:1/0,_deltaMarks:{},_markListeners:{},_onComplete:[],_onInit:[],_unsubscribers:[],_eventLisneters:{},_settings:{},_vars:{},init:function(e,t){a._settings=e,a._vars=t},getTime:n\u0026\u0026n.now?function(){return n.now()}:Date.now?function(){return Date.now()-i}:function(){return new Date-i},time:function(e){a._deltaMarks[e]=[a.getTime()]},timeEnd:function(e,t){var n=a._deltaMarks[e];n\u0026\u00260!==n.length\u0026\u0026n.push(a.getTime(),t)},sendTimeMark:function(e,t,n,i){void 0===t\u0026\u0026(t=a.getTime()),a.emit({metricName:\"defTimes\",data:[e,t,i]}),a.mark(e,t)},sendDelta:function(e,t,n,i){var s,r=a._deltaMarks;r[e]||void 0===t||(s=i\u0026\u0026i.originalEndTime?i.originalEndTime:a.getTime(),r[e]=[s-t,s,n])},sendResTiming:function(e,t){a.emit({metricName:\"defRes\",data:[e,t]})},sendRaf:function(e){var t=a.getSetting(\"forcePaintTimeSending\");if(s\u0026\u0026(t||a.isTimeAfterPageShow(a.getTime()))){var n=\"2616.\"+e;s((function(){a.getSetting(\"sendFirstRaf\")\u0026\u0026a.sendTimeMark(n+\".205\"),s((function(){a.sendTimeMark(n+\".1928\")}))}))}},isVisibilityChanged:function(){return a.vsStart\u0026\u0026(\"visible\"!==a.vsStart||a.vsChanged)},isTimeAfterPageShow:function(e){return\"visible\"===a.vsStart||a.vsChangeTime\u003ce},mark:n\u0026\u0026n.mark?function(e,t){n.mark(e+(t?\": \"+t:\"\"))}:function(){},getSetting:function(e){var t=a._settings[e];return null===t?null:t||\"\"},on:function(e,t){if(\"function\"==typeof t)return(a._markListeners[e]=a._markListeners[e]||[]).push(t),function(){if(a._markListeners[e]){var n=a._markListeners[e].indexOf(t);n\u003e-1\u0026\u0026a._markListeners[e].splice(n,1)}}},noop:r,sendTrafficData:r,finalizeLayoutShiftScore:r,finalizeLargestContentfulPaint:r,getLCPAdditionalParams:r,getCLSAdditionalParams:r,getINPAdditionalParams:r,getImageGoodnessAdditionalParams:r,_eventListeners:{},_eventsBuffer:{},subscribe:function(e,t){if(!a.getSetting(\"noEvents\"))return this._eventLisneters[e]=this._eventLisneters[e]||new Set,this._eventLisneters[e].add(t),function(){this.unsubscribe(e,t)}.bind(this)},unsubscribe:function(e,t){this._eventLisneters[e].delete(t)},emit:function(e){if(!a.getSetting(\"noEvents\")){var t=a.getSetting(\"eventsLimits\")\u0026\u0026a.getSetting(\"eventsLimits\")[e.metricName]||20;this._eventLisneters[e.metricName]\u0026\u0026this._eventLisneters[e.metricName].forEach((function(t){t(e)})),this._eventsBuffer[e.metricName]=this._eventsBuffer[e.metricName]||[],this._eventsBuffer[e.metricName].push(e),this._eventsBuffer[e.metricName].length\u003et\u0026\u0026(this._eventsBuffer[e.metricName].length=Math.floor(t/2))}},getBufferedEvents:function(e){var t=this._eventsBuffer,n={};return Object.keys(t).forEach((function(i){-1!==e.indexOf(i)\u0026\u0026(n[i]=t[i])})),n},clearEvents:function(e){this._eventsBuffer[e]\u0026\u0026(this._eventsBuffer[e].length=0)}};function f(){Ya.Rum.vsChanged=!0,Ya.Rum.vsChangeTime=a.getTime(),removeEventListener(\"visibilitychange\",f)}addEventListener(\"visibilitychange\",f),a._onVisibilityChange=f}(window);\n!function(){if(window.PerformanceLongTaskTiming){var e=function(e,n){return(e=e.concat(n)).length\u003e300\u0026\u0026(e=e.slice(e.length-300)),e},n=\"undefined\"!=typeof PerformanceLongAnimationFrameTiming,t=n?[\"longtask\",\"long-animation-frame\"]:[\"longtask\"];function r(){var r=Ya.Rum._tti={events:[],loafEvents:n?[]:void 0,eventsAfterTTI:[],fired:!1,observer:new PerformanceObserver((function(t){var o=t.getEntriesByType(\"longtask\"),s=t.getEntriesByType(\"long-animation-frame\");r.events=e(r.events,o),n\u0026\u0026(r.loafEvents=e(r.loafEvents,s)),r.fired\u0026\u0026(r.eventsAfterTTI=e(r.eventsAfterTTI,o))}))};r.observer.observe({entryTypes:t}),Ya.Rum._unsubscribers\u0026\u0026Ya.Rum._unsubscribers.push((function(){r.observer.disconnect()}))}r(),Ya.Rum._onInit.push(r)}}();\nYa.Rum.observeDOMNode=window.IntersectionObserver?function(e,i,n){var t=this,o=Ya.Rum.getSetting(\"forcePaintTimeSending\");!function r(){if(o||!t.isVisibilityChanged()){var s=\"string\"==typeof i?document.querySelector(i):i;s?new IntersectionObserver((function(i,n){!o\u0026\u0026t.isVisibilityChanged()||(Ya.Rum.sendTimeMark(e),n.unobserve(s))}),n).observe(s):setTimeout(r,100)}}()}:function(){};\nvar rum_platform = window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop';\n    var rum_segment = window.location.pathname.replace(/^\\//, \"\").replace(/\\/.*/);\n    \n    if ([\"knowledge\", \"journal\", \"profile\", \"handbook\"].indexOf(rum_segment) === -1) {\n      rum_segment = \"portal\";\n    }\n\n    Ya.Rum.init({ beacon: true, clck: 'https://yandex.ru/clck/click', reqid: '1768063131643963-5455682025770295793'},\n    {\n        rum_id: 'ru.education.' + rum_platform + '.' + rum_segment,\n        '-env': 'production',\n        '-project': 'education-web',\n        '-page': window.location.pathname,\n        '-version': 'undefined',\n        '-platform': rum_platform\n    });Ya.Rum.observeDOMNode('2876', 'body');!function(){var e,t,n,i=Ya.Rum,o=42,r=4e4,g=15,a=[],s=\"\\r\\n\",l=i.getSetting(\"countersInitialDelay\")||0;if(l){var c;function u(){removeEventListener(\"visibilitychange\",h),clearTimeout(c),l=0,f()}function h(){document.hidden\u0026\u0026u()}c=setTimeout(u,l),addEventListener(\"visibilitychange\",h)}function f(){if(t\u0026\u0026a.length){for(var n=0,i=0,l=0;i\u003ca.length\u0026\u0026l\u003c=r\u0026\u0026n\u003co;i++)(l+=(i?s.length:0)+a[i].length)\u003c=r\u0026\u0026n++;var c=a.splice(0,n);d(t,c.join(s)),a.length\u0026\u0026(e=setTimeout(f,g))}else a.length=0}function d(e,t){if(!(navigator.sendBeacon\u0026\u0026n\u0026\u0026navigator.sendBeacon(e,t))){var o=Boolean(i.getSetting(\"sendCookie\")),r=new XMLHttpRequest;r.open(\"POST\",e),r.withCredentials=o,r.send(t)}}i.send=function(c,u,h,d,v,m,S,p){t=i.getSetting(\"clck\"),n=i.getSetting(\"beacon\"),o=i.getSetting(\"maxBatchCounters\")||o,r=i.getSetting(\"maxBatchLength\")||r,g=i.getSetting(\"countersBatchTimeout\")||g,function(t,n,i,c,u,h,d,v,m,S){clearTimeout(e);var p=[t?\"/reqid=\"+t:\"\",n?\"/\"+n.join(\"/\"):\"\",i?\"/path=\"+i:\"\",c?\"/events=\"+c:\"\",u?\"/slots=\"+u.join(\";\"):\"\",h?\"/experiments=\"+h.join(\";\"):\"\",d?\"/vars=\"+d:\"\",\"/cts=\"+(new Date).getTime(),\"\",\"/*\"].join(\"\");p.length\u003er?\"undefined\"!=typeof console\u0026\u0026console.error\u0026\u0026console.error(\"Counter length \"+p.length+\" is more than allowed \"+r,p):(a.push(p),l||(function(){if(a.length\u003e=o)return!0;for(var e=0,t=0;t\u003ca.length;t++)if((e+=(t?s.length:0)+a[t].length)\u003e=r)return!0;return!1}()?f():e=setTimeout(f,g)))}(i.getSetting(\"reqid\"),S,u,v,i.getSetting(\"slots\"),i.getSetting(\"experiments\"),h)}}();\n!function(){var e=Ya.Rum,n=!window.BigInt||!(\"PerformanceObserver\"in window);function t(n){e._unsubscribers.push(n)}function i(e,i,o){if(!n){var a=o||{};if(e){a.type=e,a.hasOwnProperty(\"buffered\")||(a.buffered=!0);var s=new PerformanceObserver((function(e,n){return i(e.getEntries(),n)}));return r((function(){try{s.observe(a)}catch(e){return void console.error(e.message)}t((function(){s.disconnect()}))}),0),s}throw new Error(\"PO without type field is forbidden\")}}function r(e,n){var i=setTimeout(e,n);return t((function(){clearInterval(i)})),i}function o(e,n,i){addEventListener(e,n,i),t((function(){removeEventListener(e,n,i)}))}function a(e,n,t){o(\"visibilitychange\",(function i(){if(\"hidden\"===document.visibilityState){try{t||(removeEventListener(\"visibilitychange\",i),e.disconnect())}catch(e){}n()}})),o(\"beforeunload\",n)}function s(e,n){return\"string\"==typeof e?encodeURIComponent(e):Math.round(1e3*(e-(n||0)))/1e3}function u(e){if(!e)return\"\";var n=(e.tagName||\"\").toLowerCase(),t=e.className\u0026\u0026void 0!==e.className.baseVal?e.className.baseVal:e.className;return n+(t?(\" \"+t).replace(/\\s+/g,\".\"):\"\")}function c(e){function n(){removeEventListener(\"DOMContentLoaded\",n),removeEventListener(\"load\",n),e()}\"loading\"===document.readyState?(o(\"DOMContentLoaded\",n),o(\"load\",n)):e()}function d(n){e._onComplete.push(n)}function f(){return e._periodicTasks}function l(){var n=e._vars;return Object.keys(n).map((function(e){return e+\"=\"+encodeURIComponent(n[e]).replace(/\\*/g,\"%2A\")}))}var m={connectEnd:2116,connectStart:2114,decodedBodySize:2886,domComplete:2124,domContentLoadedEventEnd:2131,domContentLoadedEventStart:2123,domInteractive:2770,domLoading:2769,domainLookupEnd:2113,domainLookupStart:2112,duration:2136,encodedBodySize:2887,entryType:2888,fetchStart:2111,initiatorType:2889,loadEventEnd:2126,loadEventStart:2125,nextHopProtocol:2890,redirectCount:1385,redirectEnd:2110,redirectStart:2109,requestStart:2117,responseEnd:2120,responseStart:2119,secureConnectionStart:2115,startTime:2322,transferSize:2323,type:76,unloadEventEnd:2128,unloadEventStart:2127,workerStart:2137},v=625;function g(n,t){Object.keys(m).forEach((function(e){if(e in t){var i=t[e];(i||0===i)\u0026\u0026n.push(m[e]+\"=\"+s(i))}})),n.push(\"\".concat(v,\"=\").concat(e.version))}var p,h,y,S,T,b=\"690.2096.2877\",w=\"690.2096.207\",E=\"690.2096.2044\",C=3,k=e.getSetting(\"savedDeltasLimit\")||0,L=document.createElement(\"link\"),P=window.performance||{},M=\"function\"==typeof P.getEntriesByType,_=0;function O(n,t,i,r,o){void 0===t\u0026\u0026(t=e.getTime()),void 0!==i\u0026\u0026!0!==i||e.mark(n,t);var a=I(n);if(a.push(\"207=\"+s(t)),x(a,r)){j(w,a,o\u0026\u0026o.force),p[n]=p[n]||[],p[n].push(t);var u=e._markListeners[n];u\u0026\u0026u.length\u0026\u0026u.forEach((function(e){e(t)})),e.emit({metricName:n,value:t,params:r})}}function I(n){return T.concat([e.isVisibilityChanged()?\"-vsChanged=1\":\"\",\"1701=\"+n,e.ajaxStart\u0026\u0026\"1201.2154=\"+s(e.ajaxStart),e.ajaxComplete\u0026\u0026\"1201.2052=\"+s(e.ajaxComplete)])}function N(){S=l(),e.getSetting(\"sendClientUa\")\u0026\u0026S.push(\"1042=\"+encodeURIComponent(navigator.userAgent))}function R(){var e=window.performance\u0026\u0026window.performance.timing\u0026\u0026window.performance.timing.navigationStart;T=S.concat([\"143.2129=\"+e])}function x(e,n){if(n){if(n.isCanceled\u0026\u0026n.isCanceled())return!1;var t=e.reduce((function(e,n,t){return\"string\"==typeof n\u0026\u0026(e[n.split(\"=\")[0]]=t),e}),{});Object.keys(n).forEach((function(i){if(\"function\"!=typeof n[i]){var r=t[i],o=i+\"=\"+n[i];void 0===r?e.push(o):e[r]=o}}))}return!0}function j(n,t,i){var r=encodeURIComponent(window.YaStaticRegion||\"unknown\");t.push(\"-cdn=\"+r);var o=t.filter(Boolean).join(\",\");e.send(null,n,o,void 0,void 0,void 0,void 0,i)}function z(e,n,t){j(e,F().concat(n),t)}function B(n,t){var i=y[n];i\u0026\u00260!==i.length\u0026\u0026(i.push(e.getTime(),t),A(n))}function A(n,t,i,r){var o,a,u,c=y[n];if(void 0!==t?o=(a=r\u0026\u0026r.originalEndTime?r.originalEndTime:e.getTime())-t:c\u0026\u0026(o=c[0],a=c[1],u=c[2]),void 0!==o\u0026\u0026void 0!==a){var d=I(n);d.push(\"207.2154=\"+s(o),\"207.1428=\"+s(a),\"2877=\"+s(a-o)),x(d,i)\u0026\u0026x(d,u)\u0026\u0026(j(b,d,r\u0026\u0026r.force),_\u003ck\u0026\u0026(h[n]=h[n]||[],h[n].push(a-o),_++),e.emit({metricName:n,value:a-o,params:{start:o,end:a}}),delete y[n])}}function V(e,n){if(!M)return n(null);L.href=e;var t=0,i=100,o=L.href;r((function e(){var a=P.getEntriesByName(o);if(a.length)return n(a);t++\u003cC?(r(e,i),i+=i):n(null)}),0)}function U(e,n,t){V(n,(function(i){i\u0026\u0026D(e,i[i.length-1],n,t)}))}function D(n,t,i,r){var o=I(n);e.getSetting(\"sendUrlInResTiming\")\u0026\u0026o.push(\"13=\"+encodeURIComponent(i)),g(o,t),x(o,r),j(E,o)}function F(){return S}var W={bluetooth:2064,cellular:2065,ethernet:2066,none:1229,wifi:2067,wimax:2068,other:861,unknown:836,0:836,1:2066,2:2067,3:2070,4:2071,5:2768},H=navigator.connection;function Q(e){if(H){var n=W[H.type];e.push(\"2437=\"+(n||2771),void 0!==H.downlinkMax\u0026\u0026\"2439=\"+H.downlinkMax,H.effectiveType\u0026\u0026\"2870=\"+H.effectiveType,void 0!==H.rtt\u0026\u0026\"rtt=\"+H.rtt,void 0!==H.downlink\u0026\u0026\"dwl=\"+H.downlink,!n\u0026\u0026\"rawType=\"+H.type)}}var Y,q,G,J,$,K,X,Z,ee=\"690.2096.4004\",ne=!1,te=1/0,ie=1/0,re=(\"layout-shift\",Boolean(window.PerformanceObserver\u0026\u0026window.PerformanceObserver.supportedEntryTypes\u0026\u0026-1!==window.PerformanceObserver.supportedEntryTypes.indexOf(\"layout-shift\"))?0:null);function oe(){$\u003eq\u0026\u0026(q=$,G=J,e.emit({metricName:\"cls-debug\",value:q,params:{clsEntries:G,target:ae(G)}}))}function ae(e){var n;if(!e)return null;var t=null;if((n=e.reduce((function(e,n){return e\u0026\u0026e.value\u003en.value?e:n})))\u0026\u0026n.sources\u0026\u0026n.sources.length){for(var i=0;i\u003cn.sources.length;i++){var r=n.sources[i];if(r.node\u0026\u00261===r.node.nodeType){t=r;break}}t=t||n.sources[0]}return t}function se(e){null==q\u0026\u0026(q=0);for(var n=0;n\u003ce.length;n++){var t=e[n];t.hadRecentInput||($\u0026\u0026t.startTime-J[J.length-1].startTime\u003cte\u0026\u0026t.startTime-J[0].startTime\u003cie?($+=t.value,J.push(t)):(oe(),$=t.value,J=[t]))}oe()}function ue(){q=re,Y=void 0,G=null,J=null,$=null,ne=!1}function ce(n){if(null!=q\u0026\u0026!ne){var t=Math.round(1e6*q)/1e6;if(Y!==t){Y=t,e.getSetting(\"enableContinuousCollection\")||(ne=!0);var i=ae(G),r=[\"s=\"+t];r.push(\"target=\"+u(i\u0026\u0026i.node));var o=e.getCLSAdditionalParams(i);o\u0026\u0026x(r,o),z(ee,r,n),e.emit({metricName:\"cls-debug\",value:q,params:{clsEntries:J,target:i,isFinalized:ne}})}}}function de(n){var t=n[n.length-1];K=t.renderTime||t.loadTime,X=t,e.emit({metricName:\"largest-contentful-paint-debug\",value:K,params:{entry:t}}),Z||(O(\"largest-loading-elem-paint\",K),Z=!0)}function fe(n){if(null!=K){var t=e.getLCPAdditionalParams(X);O(\"largest-contentful-paint\",K,!1,t,n\u0026\u0026{force:!0}),e.emit({metricName:\"largest-contentful-paint-debug\",value:K,params:{additionalParams:t,entry:X,isFinalized:!0}}),K=null,X=null}}e.getLCPAdditionalParams===e.noop\u0026\u0026(e.getLCPAdditionalParams=function(){var n={},t=X.element;if(t){n[\"-className\"]=e.getSelector(t),n[\"-tagName\"]=t.tagName.toLowerCase();var i=t.getBoundingClientRect();n[\"-width\"]=i.width,n[\"-height\"]=i.height}return X.size\u0026\u0026(n[\"-size\"]=X.size),n});var le={\"first-paint\":2793,\"first-contentful-paint\":2794},me=Object.keys(le).length,ve={},ge=window.performance||{},pe=\"function\"==typeof ge.getEntriesByType,he=0;function ye(){if(pe\u0026\u0026(e.getSetting(\"forcePaintTimeSending\")||!e.isVisibilityChanged()))for(var n=ge.getEntriesByType(\"paint\"),t=0;t\u003cn.length;t++){var i=n[t],r=le[i.name];r\u0026\u0026!ve[i.name]\u0026\u0026(ve[i.name]=!0,he++,O(\"1926.\"+r,i.startTime))}}var Se=3e3,Te=1;function be(){return e._tti.events||[]}function we(){return e._tti.loafEvents}function Ee(){return e._tti}function Ce(n){return n?n===e.getPageUrl()?\"\u003cpage\u003e\":n.replace(/\\?.*$/,\"\"):n}function ke(n,t,i){if(Ee()){var r=e.getTime(),o=\"undefined\"!=typeof PerformanceLongAnimationFrameTiming\u0026\u0026e.getSetting(\"sendLongAnimationFrames\");Le((function(a){var u,c={2796.2797:Pe(be(),t),689.2322:s(r)};if(o){var d=function(e){var n=we();if(n)return e?n.filter((function(n){return n.startTime+n.duration\u003e=e})):n}(t);d\u0026\u0026(c[\"loaf.2797\"]=Pe(d,void 0,{useName:!1}),1===e.getSetting(\"longAnimationFramesMode\")\u0026\u0026(c[\"-additional\"]=encodeURIComponent(JSON.stringify({loaf:(u=d,u.map(Me))}))))}i\u0026\u0026Object.keys(i).forEach((function(e){c[e]=i[e]})),O(n||\"2795\",a,!0,c,{force:Boolean(o)}),e._tti.fired=!0}),t)}}function Le(n,t){var i=(arguments.length\u003e2\u0026\u0026void 0!==arguments[2]?arguments[2]:{}).mode,o=void 0===i?Te:i;Ee()\u0026\u0026(t||(t=e.getTime()),function i(){var a,s=t,u=e.getTime(),c=o===Te?be():we()||[],d=c.length;0!==d\u0026\u0026(a=c[d-1],s=Math.max(s,Math.floor(a.startTime+a.duration))),u-s\u003e=Se?n(s):r(i,1e3)}())}function Pe(e,n){var t=(arguments.length\u003e2\u0026\u0026void 0!==arguments[2]?arguments[2]:{}).useName,i=void 0===t||t;return n=n||0,(e=e||[]).filter((function(e){return n-e.startTime\u003c=50})).map((function(e){var n=Math.floor(e.startTime),t=Math.floor(n+e.duration);return i?(e.name?e.name.split(\"-\").map((function(e){return e[0]})).join(\"\"):\"u\")+\"-\"+n+\"-\"+t:n+\"-\"+t})).join(\".\")}function Me(e){var n=e.blockingDuration,t=e.duration,i=e.firstUIEventTimestamp,r=e.renderStart,o=e.scripts,a=e.startTime,s=e.styleAndLayoutStart;return[Math.round(a),Math.round(t),o.map(Oe),Math.round(n),Math.round(i),Math.round(r),Math.round(s)]}function _e(e){return{\"user-callback\":1,\"event-listener\":2,\"resolve-promise\":3,\"reject-promise\":4,\"classic-script\":5,\"module-script\":6}[e]||0}function Oe(e){var n=e.invoker,t=e.sourceURL,i=e.sourceFunctionName,r=e.sourceCharPosition,o=e.startTime,a=e.duration,s=e.windowAttribution,u=e.executionStart,c=e.forcedStyleAndLayoutDuration,d=e.pauseDuration,f=e.invokerType;return[Ce(n),Ce(t),i,r,Math.round(o),Math.round(a),s,Math.round(u),Math.round(c),Math.round(d),_e(f)]}var Ie=\"690.2096.361\",Ne=document.createElement(\"a\"),Re=0,xe={};function je(e){var n=e.transferSize;if(null!=n){Ne.href=e.name;var t=Ne.pathname;if(0!==t.indexOf(\"/clck\")){var i=t.lastIndexOf(\".\"),r=\"\";return-1!==i\u0026\u0026t.lastIndexOf(\"/\")\u003ci\u0026\u0026t.length-i\u003c=5\u0026\u0026(r=t.slice(i+1)),{size:n,domain:Ne.hostname,extension:r}}}}function ze(){var n=e.getSetting(\"maxTrafficCounters\")||250;if(Re\u003e=n)return!1;for(var t=Object.keys(xe),i=\"\",r=0;r\u003ct.length;r++){var o=t[r],a=xe[o];i+=encodeURIComponent(o)+\"!\"+a.count+\"!\"+a.size+\";\"}return i.length\u0026\u0026(Re++,z(Ie,[\"d=\"+i,\"t=\"+s(e.getTime())])),xe={},Re\u003cn}d(ze);var Be=\"690.1033\",Ae={visible:1,hidden:2,prerender:3},Ve=window.performance||{},Ue=Ve.navigation||{},De=Ve.timing||{},Fe=De.navigationStart;function We(){var n=De.domContentLoadedEventStart,t=De.domContentLoadedEventEnd;if(0!==n||0!==t){var i=0===De.responseStart?Fe:De.responseStart,o=0===De.domainLookupStart?Fe:De.domainLookupStart,a=[\"2129=\"+Fe,\"1036=\"+(o-Fe),\"1037=\"+(De.domainLookupEnd-De.domainLookupStart),\"1038=\"+(De.connectEnd-De.connectStart),De.secureConnectionStart\u0026\u0026\"1383=\"+(De.connectEnd-De.secureConnectionStart),\"1039=\"+(De.responseStart-De.connectEnd),\"1040=\"+(De.responseEnd-i),\"1040.906=\"+(De.responseEnd-o),\"1310.2084=\"+(De.domLoading-i),\"1310.2085=\"+(De.domInteractive-i),\"1310.1309=\"+(t-n),\"1310.1007=\"+(n-i),navigator.deviceMemory\u0026\u0026\"3140=\"+navigator.deviceMemory,navigator.hardwareConcurrency\u0026\u0026\"3141=\"+navigator.hardwareConcurrency];Object.keys(m).forEach((function(e){e in De\u0026\u0026De[e]\u0026\u0026a.push(m[e]+\"=\"+s(De[e],Fe))})),e.vsStart?(a.push(\"1484=\"+(Ae[e.vsStart]||2771)),e.vsChanged\u0026\u0026a.push(\"1484.719=1\")):a.push(\"1484=\"+Ae.visible),Ue\u0026\u0026(Ue.redirectCount\u0026\u0026a.push(\"1384.1385=\"+Ue.redirectCount),1!==Ue.type\u0026\u00262!==Ue.type||a.push(\"770.76=\"+Ue.type)),Q(a),z(Be,a)}else r(We,50)}var He=\"690.2096.2892\",Qe=window.performance||{},Ye=\"function\"==typeof Qe.getEntriesByType;if(!e)throw new Error(\"Rum: interface is not included\");if(e.enabled){function qe(){p={},h={},_=0,y=e._deltaMarks,N(),R(),e.ajaxStart=0,e.ajaxComplete=0,c(Je)}function Ge(){var n;e.sendTimeMark=O,e.sendResTiming=U,e.sendTiming=D,e.timeEnd=B;var t=(e.getBufferedEvents([\"defRes\"]).defRes||[]).map((function(e){return e.data}));for(n=0;n\u003ct.length;n++)U(t[n][0],t[n][1]);e.clearEvents(\"defRes\");var i=(e.getBufferedEvents([\"defTimes\"]).defTimes||[]).map((function(e){return e.data}));for(n=0;n\u003ci.length;n++)O(i[n][0],i[n][1],!1,i[n][2]);e.clearEvents(\"defTimes\"),Object.keys(y).forEach((function(e){A(e)}))}function Je(){var n=window.performance\u0026\u0026window.performance.timing\u0026\u0026window.performance.timing.navigationStart,t=e.getSetting(\"skipTiming\"),a=e.getSetting(\"techParamsByVisible\");n\u0026\u0026(a\u0026\u0026addEventListener(\"visibilitychange\",(function n(){\"visible\"!==e.vsStart?\"visible\"===document.visibilityState\u0026\u0026(e.vsStart=\"visible\",removeEventListener(\"visibilitychange\",n),We()):removeEventListener(\"visibilitychange\",n)})),r((function(){Ge(),(!t\u0026\u0026!a||a\u0026\u0026\"visible\"===e.vsStart)\u0026\u0026We(),e.getSetting(\"disableFCP\")||(ye(),he\u003cme\u0026\u0026i(\"paint\",(function(e,n){ye(),n\u0026\u0026he\u003e=me\u0026\u0026n.disconnect()}),{buffered:!0})),e.getSetting(\"sendAutoElementTiming\")\u0026\u0026(!window.PerformanceObserver||!e.getSetting(\"forcePaintTimeSending\")\u0026\u0026e.isVisibilityChanged()||i(\"element\",(function(e){for(var n=0;n\u003ce.length;n++){var t=e[n];O(\"element-timing.\"+t.identifier,t.startTime)}}))),o(\"pageshow\",Xe),ke(),\"complete\"===document.readyState?$e({skipTimingApi:t}):o(\"load\",$e.bind(void 0,{skipTimingApi:t}))}),0))}function $e(n){var r,s;e.getSetting(\"disableOnLoadTasks\")||(removeEventListener(\"load\",$e),n.skipTimingApi||function(){if(Ye){var e=Qe.getEntriesByType(\"navigation\")[0];if(e){var n=[];g(n,e),Q(n);var t=Qe.getEntriesByName(\"yndxNavigationSource\")[0];t\u0026\u0026n.push(\"2091.186=\"+t.value);var i=Qe.getEntriesByName(\"yndxNavigationToken\",\"yndxEntry\")[0];i\u0026\u0026n.push(\"2091.3649=\"+i.value),z(He,n)}}}(),(s=e.getSetting(\"periodicStatsIntervalMs\"))||null===s||(s=15e3),s\u0026\u0026(r=setInterval(Ze,s),t((function(){clearInterval(r)})),Ke=r),o(\"beforeunload\",Ze),function(){if(window.PerformanceObserver){xe={},Re=0;var e=function(e){!function(e){if(e\u0026\u0026e.length)for(var n=xe,t=0;t\u003ce.length;t++){var i=je(e[t]);if(i){var r=i.domain+\"-\"+i.extension,o=n[r]=n[r]||{count:0,size:0};o.count++,o.size+=i.size}}}(e)};i(\"resource\",e),i(\"navigation\",e),f().push(ze)}}(),e.getSetting(\"disableFID\")||i(\"first-input\",(function(n,t){var i=n[0];if(i){var r=i.processingStart,o={duration:i.duration,js:i.processingEnd-r,name:i.name};i.target\u0026\u0026(o.target=u(i.target));var a=r-i.startTime;A(\"first-input\",a,o),e.emit({metricName:\"first-input-debug\",value:a,params:{entry:i,additionalParams:o}}),t.disconnect()}}),{buffered:!0}),e.getSetting(\"disableCLS\")||window.PerformanceObserver\u0026\u0026(d(ce),d(ue),q=re,G=null,J=null,$=null,te=e.getSetting(\"clsWindowGap\")||te,ie=e.getSetting(\"clsWindowSize\")||ie,a(i(\"layout-shift\",se),(function(){return ce(!0)}),!0)),e.getSetting(\"disableLCP\")||!window.PerformanceObserver||!e.getSetting(\"forcePaintTimeSending\")\u0026\u0026e.isVisibilityChanged()||(d(fe),K=null,X=null,Z=!1,a(i(\"largest-contentful-paint\",de),(function(){return fe(!0)}),!1)))}var Ke;function Xe(e){e.persisted\u0026\u0026O(\"bfcache\")}function Ze(){var e=!1;f().forEach((function(n){n()\u0026\u0026(e=!0)})),e||clearInterval(Ke)}d(Ge),e.destroy=function(n){var t=e._unsubscribers;n.shouldComplete\u0026\u0026e.completeSession(!0),e._onComplete=[];for(var i=0;i\u003ct.length;i++)t[i]();removeEventListener(\"visibilitychange\",e._onVisibilityChange),e._unsubscribers=[],e._periodicTasks=[],e._markListeners={},e._deltaMarks={}},e.restart=function(n,t,i){e.destroy({shouldComplete:i}),e.init(n,t),addEventListener(\"visibilitychange\",e._onVisibilityChange),qe(),function(){for(var n=0;n\u003ce._onInit.length;n++)e._onInit[n]()}()},e.setVars=function(n){Object.keys(n).forEach((function(t){e._vars[t]=n[t]})),N(),R()},e.completeSession=function(n){for(var t=e._onComplete,i=0;i\u003ct.length;i++)t[i](n)},qe(),e._periodicTasks=[],e.sendHeroElement=function(e){O(\"2876\",e)},e.getPageUrl=function(){return window.location.href},e._subpages={},e.makeSubPage=function(n,t){var i=e._subpages[n];e._subpages[n]=void 0===i?i=0:++i;var r=!1;return{689.2322:s(void 0!==t?t:e.getTime()),2924:n,2925:i,isCanceled:function(){return r},cancel:function(){r=!0}}},e.getTimeMarks=function(){return p},e.getDeltas=function(){return h},e.getVarsList=l,e.getResourceTimings=V,e.pushConnectionTypeTo=Q,e.pushTimingTo=g,e.normalize=s,e.sendCounter=j,e.sendDelta=A,e.onReady=c,e.getSelector=u,e.getSetting(\"disableCLS\")||(e.finalizeLayoutShiftScore=ce),e.getSetting(\"disableLCP\")||(e.finalizeLargestContentfulPaint=fe),e.sendTrafficData=ze,e._getCommonVars=F,e._addListener=o,e._observe=i,e._timeout=r,e.sendTTI=ke,e._getLongtasksStringValue=Pe,e.onQuietWindow=Le,e.sendBFCacheTimeMark=Xe}else e.getSetting=function(){return\"\"},e.getVarsList=function(){return[]},e.getResourceTimings=e.completeSession=e.pushConnectionTypeTo=e.pushTimingTo=e.normalize=e.sendCounter=e.destroy=e.restart=e.setVars=e.completeSession=e.sendDelta=e.sendTimeMark=e.sendResTiming=e.sendTiming=e.sendTTI=e.makeSubPage=e.sendHeroElement=e.onReady=e.onQuietWindow=function(){}}();\n!function(n){if(!n.Ya||!Ya.Rum)throw new Error(\"Rum: interface is not defined\");var e=Ya.Rum;e.getSetting=function(n){var t=e._settings[n];return null===t?null:t||\"\"}}(\"undefined\"!=typeof self?self:window);\n!function(e,r){var n={client:[\"690.2354\",1e3,100,0],uncaught:[\"690.2361\",100,10,0],external:[\"690.2854\",100,10,0],script:[\"690.2609\",100,10,0]},t={};r.ERROR_LEVEL={INFO:\"info\",DEBUG:\"debug\",WARN:\"warn\",ERROR:\"error\",FATAL:\"fatal\"},r._errorSettings={clck:\"https://yandex.ru/clck/click\",beacon:!0,project:\"unknown\",page:\"\",env:\"\",experiments:[],additional:{},platform:\"\",region:\"\",dc:\"\",host:\"\",service:\"\",level:\"\",version:\"\",yandexuid:\"\",loggedin:!1,coordinates_gp:\"\",referrer:!0,preventError:!1,unhandledRejection:!1,traceUnhandledRejection:!1,uncaughtException:!0,debug:!1,limits:{},silent:{},filters:{},pageMaxAge:864e6,initTimestamp:+new Date};var o=!1;function a(e,r){for(var n in r)r.hasOwnProperty(n)\u0026\u0026(e[n]=r[n]);return e}function i(e){return\"boolean\"==typeof e\u0026\u0026(e=+e),\"number\"==typeof e?e+\"\":null}r.initErrors=function(n){var t=a(r._errorSettings,n);o||(t.uncaughtException\u0026\u0026function(){var n=r._errorSettings;if(e.addEventListener)e.addEventListener(\"error\",s),n.resourceFails\u0026\u0026e.addEventListener(\"error\",l,!0),\"Promise\"in e\u0026\u0026n.unhandledRejection\u0026\u0026e.addEventListener(\"unhandledrejection\",function(e){var n,t,o=e.reason,a={};o\u0026\u0026(o.stack\u0026\u0026o.message?(n=o.message,t=o.stack):(n=String(o),t=r._parseTraceablePromiseStack(e.promise),\"[object Event]\"===n?n=\"event.type: \"+o.type:\"[object Object]\"===n\u0026\u0026(a.unhandledObject=o)),o.target\u0026\u0026o.target.src\u0026\u0026(a.src=o.target.src),s({message:\"Unhandled rejection: \"+n,stack:t,additional:a}))});else{var t=e.onerror;e.onerror=function(e,r,n,o,a){s({error:a||new Error(e||\"Empty error\"),message:e,lineno:n,colno:o,filename:r}),t\u0026\u0026t.apply(this,arguments)}}}(),t.unhandledRejection\u0026\u0026t.traceUnhandledRejection\u0026\u0026r._traceUnhandledRejection\u0026\u0026r._traceUnhandledRejection(),o=!0)},r.updateErrors=function(e){a(r._errorSettings,e)},r.updateAdditional=function(e){r._errorSettings.additional=a(r._errorSettings.additional||{},e)},r._handleError=function(e,o,i){var s,l,c=r._errorSettings;if(c.preventError\u0026\u0026e.preventDefault\u0026\u0026e.preventDefault(),o)s=e,l=\"client\";else{s=r._normalizeError(e),l=s.type;var d=c.onError;\"function\"==typeof d\u0026\u0026d(s);var u=c.transform;if(\"function\"==typeof u\u0026\u0026(s=u(s)),!s)return;s.settings\u0026\u0026(i=s.settings)}var g=+new Date,f=c.initTimestamp,p=c.pageMaxAge;if(!(-1!==p\u0026\u0026f\u0026\u0026f+p\u003cg)){var m=n[l][1];\"number\"==typeof c.limits[l]\u0026\u0026(m=c.limits[l]);var v=n[l][2];\"number\"==typeof c.silent[l]\u0026\u0026(v=c.silent[l]);var h=n[l][3];if(h\u003cm||-1===m){s.path=n[l][0];var E=r._getErrorData(s,{silent:h\u003cv||-1===v?\"no\":\"yes\",isCustom:Boolean(o)},a(a({},c),i)),_=function(e){t[s.message]=!1,r._sendError(e.path,e.vars),n[l][3]++}.bind(this,E);if(void 0===c.throttleSend)_();else{if(t[s.message])return;t[s.message]=!0,setTimeout(_,c.throttleSend)}}}},r._getReferrer=function(r){var n=r.referrer,t=typeof n;return\"function\"===t?n():\"string\"===t\u0026\u0026n?n:!1!==n\u0026\u0026e.location?e.location.href:void 0},r.getErrorSetting=function(e){return r._errorSettings[e]},r._buildExperiments=function(e){return e instanceof Array?e.join(\";\"):\"\"},r._buildAdditional=function(e,r){var n=\"\";try{var t=a(a({},e),r);0!==Object.keys(t).length\u0026\u0026(n=JSON.stringify(t))}catch(e){}return n},r._getErrorData=function(n,t,o){t=t||{};var a=r._buildExperiments(o.experiments),s=r._buildAdditional(o.additional,n.additional),l={\"-stack\":n.stack,\"-url\":n.file,\"-line\":n.line,\"-col\":n.col,\"-block\":n.block,\"-method\":n.method,\"-msg\":n.message,\"-env\":o.env,\"-external\":n.external,\"-externalCustom\":n.externalCustom,\"-project\":o.project,\"-service\":n.service||o.service,\"-page\":n.page||o.page,\"-platform\":o.platform,\"-level\":n.level,\"-experiments\":a,\"-version\":o.version,\"-region\":o.region,\"-dc\":o.dc,\"-host\":o.host,\"-yandexuid\":o.yandexuid,\"-loggedin\":o.loggedin,\"-coordinates_gp\":n.coordinates_gp||o.coordinates_gp,\"-referrer\":r._getReferrer(o),\"-source\":n.source,\"-sourceMethod\":n.sourceMethod,\"-type\":t.isCustom?n.type:\"\",\"-additional\":s,\"-adb\":i(Ya.blocker)||i(o.blocker),\"-cdn\":e.YaStaticRegion,\"-ua\":navigator.userAgent,\"-silent\":t.silent,\"-ts\":+new Date,\"-init-ts\":o.initTimestamp};return o.debug\u0026\u0026e.console\u0026\u0026console[console[n.level]?n.level:\"error\"](\"[error-counter] \"+n.message,l,n.stack),{path:n.path,vars:l}},r._baseNormalizeError=function(e){var r=(e=e||{}).error,n=e.filename||e.fileName||\"\",t=r\u0026\u0026r.stack||e.stack||\"\",o=e.message||\"\",a=r\u0026\u0026r.additional||e.additional;return{file:n,line:e.lineno||e.lineNumber,col:e.colno||e.colNumber,stack:t,message:o,additional:a}},r._normalizeError=function(e){var n=r._baseNormalizeError(e),t=\"uncaught\",o=r._isExternalError(n.file,n.message,n.stack),a=\"\",i=\"\";return o.hasExternal?(t=\"external\",a=o.common,i=o.custom):/^Script error\\.?$/.test(n.message)\u0026\u0026(t=\"script\"),n.external=a,n.externalCustom=i,n.type=t,n},r._createVarsString=function(e){var r=[];for(var n in e)e.hasOwnProperty(n)\u0026\u0026(e[n]||0===e[n])\u0026\u0026r.push(n+\"=\"+encodeURIComponent(e[n]).replace(/\\*/g,\"%2A\"));return r.join(\",\")},r._sendError=function(e,n){r.send(null,e,r._createVarsString(n),null,null,null,null)};var s=function(e){r._handleError(e,!1)},l=function(e){var n=e.target;if(n){var t=n.srcset||n.src;if(t||(t=n.href),t){var o=n.tagName||\"UNKNOWN\";r.logError({message:o+\" load error\",additional:{src:t}})}}};r._parseTraceablePromiseStack=function(){}}(\"undefined\"!=typeof self?self:window,Ya.Rum);\n!function(e){var r={url:{0:/(miscellaneous|extension)_bindings/,1:/^chrome:/,2:/kaspersky-labs\\.com\\//,3:/^(?:moz|chrome|safari)-extension:\\/\\//,4:/^file:/,5:/^resource:\\/\\//,6:/webnetc\\.top/,7:/local\\.adguard\\.com/},message:{0:/__adgRemoveDirect/,1:/Content Security Policy/,2:/vid_mate_check/,3:/ucapi/,4:/Access is denied/i,5:/^Uncaught SecurityError/i,6:/__ybro/,7:/__show__deepen/,8:/ntp is not defined/,9:/Cannot set property 'install' of undefined/,10:/NS_ERROR/,11:/Error loading script/,12:/^TypeError: undefined is not a function$/,13:/__firefox__\\.(?:favicons|metadata|reader|searchQueryForField|searchLoginField)/},stack:{0:/(?:moz|chrome|safari)-extension:\\/\\//,1:/adguard.*\\.user\\.js/i}};function n(e,r){if(e\u0026\u0026r){var n=[];for(var o in r)if(r.hasOwnProperty(o)){var i=r[o];\"string\"==typeof i\u0026\u0026(i=new RegExp(i)),i instanceof RegExp\u0026\u0026i.test(e)\u0026\u0026n.push(o)}return n.join(\"_\")}}function o(e,o){var i,a=[];for(var t in r)r.hasOwnProperty(t)\u0026\u0026(i=n(e[t],o[t]))\u0026\u0026a.push(t+\"~\"+i);return a.join(\";\")}e._isExternalError=function(n,i,a){var t=e._errorSettings.filters||{},s={url:(n||\"\")+\"\",message:(i||\"\")+\"\",stack:(a||\"\")+\"\"},c=o(s,r),u=o(s,t);return{common:c,custom:u,hasExternal:!(!c\u0026\u0026!u)}}}(Ya.Rum);\nYa.Rum.initErrors({\n        reqid: '1768063131643963-5455682025770295793',\n        project: 'education-web',\n        env: 'production',\n        page: window.location.pathname,\n        version: 'undefined',\n        platform: window.matchMedia('(max-width: 767px)').matches ? 'touch' : 'desktop'\n    });"])</script><script nonce="">self.__next_f.push([1,"41:[\"$\",\"$L26\",null,{\"id\":\"rum-error\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"strategy\":\"beforeInteractive\",\"dangerouslySetInnerHTML\":{\"__html\":\"$4c\"}}]\n4a:[\"$\",\"section\",\"web-page.html-1\",{\"id\":878,\"md\":0,\"className\":\"styles_root__IBJUG styles_gutter-bottom__5KdTv\",\"style\":{\"--gutter-size-xs\":\"0px\",\"--gutter-size-sm\":\"0px\",\"--gutter-size-lg\":\"0px\",\"--gutter-size-xl\":\"0px\"},\"children\":[\"$\",\"div\",null,{\"suppressHydrationWarning\":true,\"dangerouslySetInnerHTML\":{\"__html\":\"\u003ci data-ai=\\\"enable\\\"\u003e\u003c/i\u003e\"}}]}]\n"])</script><script nonce="">self.__next_f.push([1,"49:[\"$\",\"$L4d\",\"web-page.header-block\",{\"id\":2,\"Authorization\":true,\"Search\":true,\"ProfileUrl\":\"/profile\",\"Wide\":null,\"Notifications\":true,\"Gutter\":null,\"Buttons\":[],\"Menu\":[{\"id\":19,\"Text\":\"Школьникам\",\"URL\":\"/pupils\",\"Title\":\"Школьникам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_school\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":null,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4136,\"Text\":\"Студентам\",\"URL\":\"/students\",\"Title\":\"Студентам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_students\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4137,\"Text\":\"Абитуриентам\",\"URL\":\"/university\",\"Title\":\"Абитуриентам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_abit\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4138,\"Text\":\"Партнёрам\",\"URL\":\"https://edumakers.yandex.ru/\",\"Title\":\"Партнёрам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_partner\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4139,\"Text\":\"Хендбуки\",\"URL\":\"/handbook\",\"Title\":\"События\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4140,\"Text\":\"Журнал\",\"URL\":\"/journal\",\"Title\":\"Журнал\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_journal\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4141,\"Text\":\"AI\",\"URL\":\"https://education.yandex.ru/ai\",\"Title\":\"AI\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null}],\"Logo\":{\"id\":3,\"URL\":\"/\",\"Title\":\"Яндекс Образование\",\"Image\":{\"data\":{\"id\":8,\"attributes\":{\"name\":\"edu_logo.svg\",\"alternativeText\":null,\"caption\":null,\"width\":233,\"height\":24,\"formats\":null,\"hash\":\"edu_logo_9eee76ff17\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":13.44,\"url\":\"https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-09T11:00:59.235Z\",\"updatedAt\":\"2024-12-04T04:36:42.717Z\"}}},\"ImageMobile\":{\"data\":{\"id\":10764,\"attributes\":{\"name\":\"logo_mobile.svg\",\"alternativeText\":null,\"caption\":null,\"width\":179,\"height\":25,\"formats\":null,\"hash\":\"logo_mobile_8bc5eb38fb\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":18.25,\"url\":\"https://yastatic.net/s3/education-portal/media/logo_mobile_8bc5eb38fb.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-07-17T12:53:33.633Z\",\"updatedAt\":\"2024-12-04T04:35:29.061Z\"}}}},\"isLoggedIn\":false,\"passportUrl\":\"https://passport.yandex.ru/auth/?origin=education\u0026retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Fcpp%2Farticle%2Fdata-types\",\"passportEnv\":\"prod\",\"passportUserData\":{\"avatarId\":\"$undefined\",\"plus\":false,\"name\":\"$undefined\"}}]\n"])</script><script nonce="">self.__next_f.push([1,"20:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Типы данных - Основы С++\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Здесь мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.\"}],[\"$\",\"link\",\"2\",{\"rel\":\"manifest\",\"href\":\"/manifest.webmanifest\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"initial-scale=1, width=device-width\"}],[\"$\",\"meta\",\"4\",{\"name\":\"mobile-web-app-capable\",\"content\":\"yes\"}],[\"$\",\"meta\",\"5\",{\"name\":\"BookSlug\",\"content\":\"cpp\"}],[\"$\",\"link\",\"6\",{\"rel\":\"canonical\",\"href\":\"https://education.yandex.ru/handbook/cpp/article/data-types\"}],[\"$\",\"meta\",\"7\",{\"name\":\"mobile-web-app-capable\",\"content\":\"yes\"}],[\"$\",\"meta\",\"8\",{\"name\":\"apple-mobile-web-app-title\",\"content\":\"Яндекс Образование\"}],[\"$\",\"link\",\"9\",{\"href\":\"https://yastatic.net/s3/education-portal/pwa/logos/ios/512.png\",\"media\":\"$undefined\",\"rel\":\"apple-touch-startup-image\"}],[\"$\",\"meta\",\"10\",{\"name\":\"apple-mobile-web-app-status-bar-style\",\"content\":\"black-translucent\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:title\",\"content\":\"Типы данных - Основы С++\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:description\",\"content\":\"Здесь мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:url\",\"content\":\"https://education.yandex.ru/handbook/cpp/article/data-types\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:image\",\"content\":\"https://yastatic.net/s3/education-portal/media/opengraph_handbook_1_64d50710b1_29555467af.webp\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:title\",\"content\":\"Типы данных - Основы С++\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:description\",\"content\":\"Здесь мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:image\",\"content\":\"https://yastatic.net/s3/education-portal/media/opengraph_handbook_1_64d50710b1_29555467af.webp\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script nonce="">self.__next_f.push([1,"25:\"$20:metadata\"\n"])</script><script nonce="">self.__next_f.push([1,"4e:T1248,"])</script><script nonce="">self.__next_f.push([1,"\n  function applyUADataPolyfill(){\n    function e(a){let b=/Windows NT (\\d+(\\.\\d+)*)/.exec(a);if(!b)return null;let c={\"6.1\":\"0.1\",\"6.2\":\"0.2\",\"6.3\":\"0.3\",\"10.0\":\"10.0\",\"11.0\":\"13.0\"}[b[1]],d=c?q(c,3):\"\",e=\"\",f=\"\";return/\\b(WOW64|Win64|x64)\\b/.test(a)\u0026\u0026(e=\"x86\",f=\"64\"),{platform:\"Windows\",platformVersion:d,architecture:e,bitness:f}}\n    function f(a,b){let c=/Android (\\d+(\\.\\d+)*)/.exec(a);if(!c)return null;let d=\"\",e=\"\",f=/Linux (\\w+)/.exec(b);if(f\u0026\u0026f[1]){let a=p(f[1]);d=a[0],e=a[1]}return{platform:\"Android\",platformVersion:q(c[1]),architecture:d,bitness:e}}\n    function g(a){let b=/(iPhone|iPod touch); CPU iPhone OS (\\d+(_\\d+)*)/.exec(a),c=/(iPad); CPU OS (\\d+(_\\d+)*)/.exec(a),d=b||c;return d?{platform:\"iOS\",platformVersion:q(d[2].replace(/_/g,\".\"))}:null}\n    function h(a){let b=/Macintosh; (Intel|\\w+) Mac OS X (\\d+([_.]\\d+)*)/.exec(a);return b?{platform:\"macOS\",platformVersion:q(b[2].replace(/_/g,\".\"))}:null}\n    function i(a){let b=/CrOS (\\w+) (\\d+(\\.\\d+)*)/.exec(a);if(!b)return null;let c=p(b[1]);return{platform:\"Chrome OS\",platformVersion:q(b[2]),architecture:c[0],bitness:c[1]}}\n    function j(a,b){for(let c of[()=\u003ee(a),()=\u003ef(a,b),()=\u003eg(a),()=\u003eh(a),()=\u003ei(a)]){let a=c();if(a)return a}return/Linux/.test(a)?{platform:\"Linux\",platformVersion:\"\"}:{platform:\"Unknown\",platformVersion:\"\"}}\n    function k(a,b,c){let d=/Chrome\\/(\\d+(\\.\\d+)*)/.exec(a);if(!d||\"Google Inc.\"!==c)return null;let e=[{brand:\"Chromium\",version:q(d[1],4)}],f=/(Edge?)\\/(\\d+(\\.\\d+)*)/.exec(a);if(f){let a={Edge:\"Microsoft Edge\",Edg:\"Microsoft Edge\"}[f[1]];e.push({brand:a,version:q(f[2],4)})}else e.push({brand:\"Google Chrome\",version:q(d[1],4)});return e}\n    function l(a,b){let c=/AppleWebKit\\/(\\d+(\\.\\d+)*)/.exec(a);return c\u0026\u0026\"Apple Computer, Inc.\"===b?[{brand:\"WebKit\",version:q(c[1])}]:null}\n    function m(a){let b=/Firefox\\/(\\d+(\\.\\d+)*)/.exec(a);return b?[{brand:\"Firefox\",version:q(b[1])}]:null}\n    function n(a,b,c,d,e){let f=!1,g=[];for(let h of[()=\u003ek(a,b,c),()=\u003el(a,c),()=\u003em(a)]){let c=h();if(c){g=c,h===k\u0026\u0026/\\bwv\\b/.test(b)\u0026\u0026(f=!0);let i=/(CriOS|EdgiOS|FxiOS|Version)\\/(\\d+(\\.\\d+)*)/.exec(a);if(h===l\u0026\u0026\"iOS\"===d\u0026\u0026i){let a={CriOS:\"Google Chrome\",EdgiOS:\"Microsoft Edge\",FxiOS:\"Mozilla Firefox\",Version:\"Apple Safari\"}[i[1]];g.push({brand:a,version:q(i[2])}),e\u0026\u0026!e.some(a=\u003ea.startsWith(\"Safari/\"))\u0026\u0026(f=!0)}break}}return 0===g.length\u0026\u0026(g=[{brand:\"Not;A Brand\",version:\"99.0.0.0\"}]),{fullVersionList:g,webview:f}}\n    function o(a){let{userAgent:b,platform:c,vendor:d}=a,e=b,f=!1,g=b.replace(/\\(([^)]+)\\)/g,(a,b)=\u003e(f||(e=b,f=!0),\"\")),h=g.match(/(\\S+)\\/(\\S+)/g),i=b.includes(\"Mobile\"),k=j(e,c),{fullVersionList:l,webview:m}=n(g,e,d,k.platform,h),o=l.length\u003e0?l[l.length-1].version:\"\",p=l.map(a=\u003e{let b=a.version.indexOf(\".\"),c=-1===b?a.version:a.version.slice(0,b);return{brand:a.brand,version:c}});return{mobile:i,platform:k.platform,brands:p,platformVersion:k.platformVersion,architecture:k.architecture||\"\",bitness:k.bitness||\"\",model:\"\",uaFullVersion:o,fullVersionList:l,webview:m}}\n    function p(a){switch(a){case\"x86_64\":case\"x64\":return[\"x86\",\"64\"];case\"x86_32\":case\"x86\":return[\"x86\",\"\"];case\"armv6l\":case\"armv7l\":case\"armv8l\":return[a,\"\"];case\"aarch64\":return[\"arm\",\"64\"];default:return[\"\",\"\"]}}\n    function q(a,b=3){let c=a.split(\".\");if(c.length\u003cb)for(;c.length\u003cb;)c.push(\"0\");return c.join(\".\")}\n    class r{constructor(a){this._clientHints=o(a),Object.defineProperties(this,{_clientHints:{enumerable:!1}})}get mobile(){return this._clientHints.mobile}get platform(){return this._clientHints.platform}get brands(){return this._clientHints.brands}getHighEntropyValues(a){return new Promise(b=\u003e{if(!Array.isArray(a))throw TypeError(\"Argument hints must be an array\");let c=new Set(a),d=this._clientHints,e={mobile:d.mobile,platform:d.platform,brands:d.brands};c.has(\"architecture\")\u0026\u0026(e.architecture=d.architecture),c.has(\"bitness\")\u0026\u0026(e.bitness=d.bitness),c.has(\"model\")\u0026\u0026(e.model=d.model),c.has(\"platformVersion\")\u0026\u0026(e.platformVersion=d.platformVersion),c.has(\"uaFullVersion\")\u0026\u0026(e.uaFullVersion=d.uaFullVersion),c.has(\"fullVersionList\")\u0026\u0026(e.fullVersionList=d.fullVersionList),b(e)})}toJSON(){return{mobile:this._clientHints.mobile,brands:this._clientHints.brands}}}\n    function(){if(\"https:\"===location.protocol\u0026\u0026!navigator.userAgentData){Object.defineProperty(r.prototype,Symbol.toStringTag,{enumerable:!1,configurable:!0,writable:!1,value:\"NavigatorUAData\"});let a=new r(navigator);return Object.defineProperty(Navigator.prototype,\"userAgentData\",{enumerable:!0,configurable:!0,get:function(){return a}}),Object.defineProperty(window,\"NavigatorUAData\",{enumerable:!1,configurable:!0,writable:!0,value:r}),!0}return!1}\n    polyfill();\n  }\n  applyUADataPolyfill();\n"])</script><script nonce="">self.__next_f.push([1,"35:[[[\"$\",\"script\",null,{\"id\":\"hasOwnPolyfill\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"suppressHydrationWarning\":true,\"children\":\"('hasOwn' in Object) || (Object.hasOwn = Object.call.bind(Object.hasOwnProperty));\"}],[\"$\",\"script\",null,{\"id\":\"UserAGentUADataPolyfill\",\"nonce\":\"b15ba19d-652e-4fa7-952c-300fefd77282\",\"suppressHydrationWarning\":true,\"children\":\"$4e\"}]],\"$L4f\",\"$L50\",\"$L51\",\"$L52\",\"$L53\"]\n"])</script><script nonce="">self.__next_f.push([1,"54:I[40678,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"Link\"]\n55:I[18694,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"Button\"]\n"])</script><script nonce="">self.__next_f.push([1,"50:[\"$\",\"section\",null,{\"id\":\"error\",\"className\":\"styles_root__IBJUG styles_gutter-bottom__5KdTv styles_root__nqTMc\",\"style\":{\"--gutter-size-xs\":\"140px\",\"--gutter-size-sm\":\"140px\",\"--gutter-size-lg\":\"400px\",\"--gutter-size-xl\":\"400px\"},\"children\":[[\"$\",\"div\",null,{\"className\":\"styles_background-image__Etqcy\",\"style\":{\"backgroundImage\":\"url(https://yastatic.net/s3/education-portal/media/404_63c36c7c45.webp)\"}}],[\"$\",\"section\",null,{\"className\":\"styles_root__IBJUG styles_container__q8aSe\",\"style\":{\"--gutter-size-xs\":\"50px\",\"--gutter-size-sm\":\"50px\",\"--gutter-size-lg\":\"50px\",\"--gutter-size-xl\":\"50px\"},\"children\":[null,[\"$\",\"span\",null,{\"ref\":\"$undefined\",\"className\":\"styles_root__EmBCZ styles_description__ZE0yq\",\"style\":{},\"children\":\"Такой страницы нет,\\nвернитесь на главную\",\"data-variant\":\"$undefined\",\"data-weight\":\"regular\",\"data-color\":\"primary\"}],[\"$\",\"$L54\",null,{\"Text\":\"Вернуться на главную\",\"URL\":\"/\",\"Variant\":\"primary\",\"children\":[\"$\",\"$L55\",null,{\"as\":\"span\",\"view\":\"primary\",\"children\":\"Вернуться на главную\"}]}]]}]]}]\n"])</script><script nonce="">self.__next_f.push([1,"53:[\"$\",\"title\",null,{\"children\":\"Страница не найдена - 404 Not Found\"}]\n"])</script><script nonce="">self.__next_f.push([1,"4f:[[\"$\",\"$1\",\"web-page.block-0\",{\"children\":[\"$L56\"]}]]\n51:null\n52:null\n"])</script><script nonce="">self.__next_f.push([1,"56:[\"$\",\"$L4d\",\"web-page.header-block\",{\"id\":2,\"Authorization\":true,\"Search\":true,\"ProfileUrl\":\"/profile\",\"Wide\":null,\"Notifications\":true,\"Gutter\":null,\"Buttons\":[],\"Menu\":[{\"id\":19,\"Text\":\"Школьникам\",\"URL\":\"/pupils\",\"Title\":\"Школьникам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_school\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":null,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4136,\"Text\":\"Студентам\",\"URL\":\"/students\",\"Title\":\"Студентам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_students\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4137,\"Text\":\"Абитуриентам\",\"URL\":\"/university\",\"Title\":\"Абитуриентам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_abit\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4138,\"Text\":\"Партнёрам\",\"URL\":\"https://edumakers.yandex.ru/\",\"Title\":\"Партнёрам\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_partner\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4139,\"Text\":\"Хендбуки\",\"URL\":\"/handbook\",\"Title\":\"События\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4140,\"Text\":\"Журнал\",\"URL\":\"/journal\",\"Title\":\"Журнал\",\"MetrikaCounter\":null,\"MetrikaGoalId\":\"h_journal\",\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null},{\"id\":4141,\"Text\":\"AI\",\"URL\":\"https://education.yandex.ru/ai\",\"Title\":\"AI\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":false,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":true,\"Description\":null,\"MetrikaGoalParams\":null}],\"Logo\":{\"id\":3,\"URL\":\"/\",\"Title\":\"Яндекс Образование\",\"Image\":{\"data\":{\"id\":8,\"attributes\":{\"name\":\"edu_logo.svg\",\"alternativeText\":null,\"caption\":null,\"width\":233,\"height\":24,\"formats\":null,\"hash\":\"edu_logo_9eee76ff17\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":13.44,\"url\":\"https://yastatic.net/s3/education-portal/media/edu_logo_9eee76ff17.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-02-09T11:00:59.235Z\",\"updatedAt\":\"2024-12-04T04:36:42.717Z\"}}},\"ImageMobile\":{\"data\":{\"id\":10764,\"attributes\":{\"name\":\"logo_mobile.svg\",\"alternativeText\":null,\"caption\":null,\"width\":179,\"height\":25,\"formats\":null,\"hash\":\"logo_mobile_8bc5eb38fb\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":18.25,\"url\":\"https://yastatic.net/s3/education-portal/media/logo_mobile_8bc5eb38fb.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2024-07-17T12:53:33.633Z\",\"updatedAt\":\"2024-12-04T04:35:29.061Z\"}}}},\"isLoggedIn\":false,\"passportUrl\":\"https://passport.yandex.ru/auth/?origin=education\u0026retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Fcpp%2Farticle%2Fdata-types\",\"passportEnv\":\"prod\",\"passportUserData\":{\"avatarId\":\"$undefined\",\"plus\":false,\"name\":\"$undefined\"}}]\n"])</script><script nonce="">self.__next_f.push([1,"57:I[97469,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"HandbookBookProgressProvider\"]\n58:I[63314,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"SelectedNoteProvider\"]\n59:I[71379,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"ArticleSidePanel\"]\n5a:T1f48,"])</script><script nonce="">self.__next_f.push([1,"# Введение\n\nПеред вами учебник по основам языка C++. При его создании мы вдохновлялись специализацией «Искусство разработки на современном C++» на «Курсере», созданной при поддержке Яндекса, и курсом «Основы и методология программирования», который читался в 2014–2021 годах на [факультете компьютерных наук ВШЭ](https://cs.hse.ru/).\n\nЯзыку C++ почти 40 лет, но он по-прежнему очень актуален и востребован. Он оказал огромное влияние на индустрию и на другие языки. C++ был разработан [Бьярне Страуструпом](https://en.wikipedia.org/wiki/Bjarne_Stroustrup) в начале 1980-х годов как расширение языка C (и даже изначально назывался «Си с классами»).\n\nОднако для изучения C++ совсем не обязательно знать C. Тем не менее мы предполагаем, что вы знакомы с основами информатики и владеете каким-либо языком программирования на уровне школьной программы — например, языком Python.\n\nВпрочем, C++ во многом полностью противоположен Python:\n- это компилируемый, а не интерпретируемый язык;\n- С++ — язык со статической, а не динамической типизацией;\n- в C++ возможно ручное управление памятью (в отличие от автоматической [сборки мусора](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science))).\n\nЧтобы исходный код программы на C++ превратился в исполняемый файл для конкретной архитектуры процессора, программу нужно [скомпилировать](https://en.wikipedia.org/wiki/Compiler). Существует несколько популярных компиляторов C++:\n - [GNU Compiler Collection](https://en.wikipedia.org/wiki/GNU_Compiler_Collection) (GCC);\n - [Clang](https://en.wikipedia.org/wiki/Clang) — построен поверх инфраструктуры [LLVM](https://en.wikipedia.org/wiki/LLVM);\n - [Microsoft Visual C++](https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B) (MSVC) — входит в состав Microsoft Visual Studio;\n - [Intel C++ Compiler](https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler).\n\nМы будем использовать в примерах и при проверке задач компилятор Clang 16-й версии.\n\n{% cut \"Подробнее\" %}\n\nПри проверке задач мы используем следующие ключи компилятора:\n\n\u003cpre\u003e\nclang++ --std=c++20 -O3 -fsanitize=address,undefined -Wall -Wextra -Werror\n\u003c/pre\u003e\n\n{% endcut %}\n\nС 1998 года международный комитет по стандартизации C++ выпускает стандарты — версии языка, в которых описываются его возможности. В первую очередь это руководства для создателей компиляторов, но при возникновении спорных моментов всегда полезно обратиться к стандарту. Мы будем ориентироваться на стандарт [C++20](https://en.wikipedia.org/wiki/C%2B%2B20), а по ссылке можно ознакомиться с [черновиком](https://wg21.link/std) будущего стандарта. Важно понимать, что стандарт определяет лишь общие требования и не фиксирует детали реализации, которые в разных компиляторах могут отличаться.\n\nЧтобы проверить, поддерживает ли ваша версия компилятора ту или иную особенность C++, советуем пользоваться специальной [таблицей](https://en.cppreference.com/w/cpp/compiler_support).\n\nПри изучении вам будут полезны следующие англоязычные ресурсы:\n - [cppreference.com](https://en.cppreference.com/) — онлайн-документация по C++;\n - [isocpp.org](https://isocpp.org/) — сайт Standard C++ Foundation;\n - [C++ Core Guidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html) — гайдлайны по C++ от Бьярне Страуструпа и Герба Саттера;\n - [godbolt.org](https://godbolt.org/) — Compiler Explorer, онлайн-компилятор;\n - [learncpp.com](https://www.learncpp.com/) — современный учебник по C++;\n - [hacking C++](https://hackingcpp.com/index.html) — наглядный справочник по C++ с картинками и инфографикой.\n\nВ тексте мы будем часто ссылаться на англоязычную версию [cppreference.com](https://en.cppreference.com/) и на английскую «Википедию».\n\nНаписать программу для C++ можно в любом текстовом редакторе, но удобнее пользоваться средой разработки (IDE). IDE включают редактор кода с подсветкой синтаксиса, а также позволяют компилировать, запускать и отлаживать программы.\n\nПримеры IDE:\n - [Microsoft Visual Studio Community](https://visualstudio.microsoft.com/ru/vs/community/)\n - [Eclipse CDT](https://www.eclipse.org/cdt/)\n - [Code::Blocks](https://www.codeblocks.org/)\n - [Qt Creator](https://www.qt.io/ide)\n - [Xcode](https://developer.apple.com/xcode/)\n\nМы рассчитываем, что вы сможете самостоятельно разобраться с настройкой и использованием среды разработки, и не будем заострять на этом внимание. В наших примерах мы будем запускать компилятор из консоли.\n\nК нашему учебнику прилагается набор задач по соответствующим темам. Вы можете сдавать их в автоматическую проверяющую систему. В одних задачах требуется написать полноценную программу, а в других — сдать только код функции или класса. Обратите внимание, что ко всем задачам имеются разборы с авторскими решениями. Найти разборы вы можете в конце глав.\n\nHo прежде чем мы двинемся дальше — небольшое объявление: для этого хендбука у нас есть коммьюнити студентов. В нём можно найти единомышленников, обсудить материалы и задания. Вступить в него можно по [ссылке](https://t.me/handbook_cpp). А чтобы быть в курсе обновлений хендбука — советуем [подписаться](https://forms.yandex.ru/surveys/13462037.a200211ca860567c195edbc3e88d7a2c40eac2fa/) на рассылку."])</script><script nonce="">self.__next_f.push([1,"5b:T4db1,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе мы напишем первую программу на C++ и научимся печатать и считывать с клавиатуры строки и числа.\n\n\n## Функция `main`\n\nПожалуй, самая простая и короткая программа на C++ — это программа, которая ничего не делает. Она выглядит так:\n\n```cpp\nint main() {\n    return 0;\n}\n```\n\nЗдесь определяется функция с именем `main`, которая не принимает никаких аргументов (внутри круглых скобок ничего нет) и не выполняет никаких содержательных команд. В каждой программе на C++ должна быть ровно одна функция `main` — с неё начинается выполнение программы.\n\nУ функции указан тип возвращаемого значения `int` (целое число), и она возвращает `0` — в данном случае это сообщение для операционной системы, что программа выполнилась успешно. И наоборот, ненулевой код возврата означает, что при выполнении возникла ошибка (например, программа получила некорректные входные данные).\n\nДля функции `main` разрешается не писать завершающий `return 0`, чем мы и будем пользоваться далее для краткости. Поэтому самую короткую программу можно было бы написать вот так:\n\n```cpp\nint main() {\n}\n```\n\n## Hello, world!\n\nСоблюдая традиции, напишем простейшую программу на C++ — она выведет приветствие в консоль:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    std::cout \u003c\u003c \"Hello, world!\\n\";\n}\n```\n\nРазберём её подробнее.\n\nДиректива `#include \u003ciostream\u003e` подключает стандартный библиотечный заголовочный файл для работы с потоками ввода-вывода (input-output streams). Для печати мы используем поток вывода `std::cout`, где `cout` расшифровывается как character output, то есть «символьный вывод».\n\nВ теле функции `main` мы передаём в `std::cout` строку `Hello, world!` с завершающим [переводом строки](https://en.wikipedia.org/wiki/Newline) `\\n`. В зависимости от операционной системы `\\n` будет преобразован в один или в два управляющих байта с кодами `0A` или `0D 0A` соответственно.\n\nИнструкции внутри тела функции завершаются точками с запятой.\n\n## Компиляция из командной строки\n\nВы можете запустить эту программу из какой-нибудь IDE. Мы же покажем, как собрать её в консоли Linux с помощью компилятора `clang++`.\n\nПусть файл с программой называется `hello.cpp`. Запустим компилятор:\n\n\u003cpre\u003e\n$ clang++ hello.cpp -o hello\n\u003c/pre\u003e\n\nВ результате мы получим исполняемый файл с именем `hello`, который теперь можно просто запустить. Он напечатает на экране ожидаемую фразу:\n\n\u003cpre\u003e\n$ ./hello\nHello, world!\n\u003c/pre\u003e\n\nЕсли опцию `-o` не указать, то сгенерированный исполняемый файл будет по умолчанию назван `a.out`. В дальнейшем для простых примеров мы будем использовать краткую форму записи команды:\n\n\u003cpre\u003e\n$ clang++ hello.cpp \u0026\u0026 ./a.out\nHello, world!\n\u003c/pre\u003e\n\nС её помощью мы компилируем программу и в случае успеха компиляции сразу же запускаем.\n\n## Комментарии\n\nКомментарии — это фрагменты программы, которые игнорируются компилятором и предназначены для программиста. В C++ есть два вида комментариев — однострочные и многострочные:\n\n```cpp\nint main() {  // однострочный комментарий продолжается до конца строки\n\n/* Пример\n   многострочного\n   комментария */\n}\n```\n\nМы будем использовать комментарии в примерах кода для пояснений, а в реальных программах ими лучше не злоупотреблять.\n\n**Хорошо:** комментировать, что делает библиотека, функция или класс или почему этот код написан именно так.\n\n**Плохо:** комментировать, что происходит на отдельных строчках. Это признак того, что код можно написать лучше.\n\n\n## Библиотеки и заголовочные файлы\n\nБиблиотека — это код, который можно переиспользовать в разных программах. В стандарт языка C++ входит спецификация так называемой [стандартной библиотеки](https://en.cppreference.com/w/cpp/standard_library), которая поставляется вместе с компилятором. Она содержит различные структуры данных (контейнеры), типовые алгоритмы, средства ввода-вывода и т. д. Конструкции из этой библиотеки предваряются префиксом `std::`, который обозначает *пространство имён*.\n\nЧтобы воспользоваться теми или иными библиотечными конструкциями, в начале программы надо подключить нужные [заголовочные файлы](https://en.cppreference.com/w/cpp/header). Так, в программе, которая печатала `Hello, world!`, нам уже встречался заголовочный файл `iostream` и конструкция `std::cout` из стандартной библиотеки.\n\nДля C++ существует также [множество сторонних библиотек](https://en.cppreference.com/w/cpp/links/libs). Наиболее известной коллекцией сторонних библиотек для C++ является [Boost](https://en.wikipedia.org/wiki/Boost_(C%2B%2B_libraries)).\n\n## Ошибки компиляции\n\nПеред запуском программу необходимо *скомпилировать*. Компилятор проверяет корректность программы и генерирует исполняемый файл. Во время компиляции компилятор может обнаружить синтаксические ошибки.\n\nРассмотрим пример такой программы:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    cout \u003c\u003c \"Hello, world\\n\"\n```\n\nКомпилятор может выдать такие сообщения:\n\n\u003cpre\u003e\n$ clang++ hello.cpp\nhello.cpp:4:5: error: use of undeclared identifier 'cout'; did you mean 'std::cout'?\n    cout \u003c\u003c \"Hello, world!\\n\"\n    ^~~~\n    std::cout\n\nhello.cpp:4:30: error: expected ';' after expression\n    cout \u003c\u003c \"Hello, world!\\n\"\n                             ^\n                             ;\n\nhello.cpp:5:1: error: expected '}'\n^\na.cpp:3:12: note: to match this '{'\nint main() {\n           ^\n3 errors generated.\n\u003c/pre\u003e\n\nПервая ошибка — вместо `std::cout` мы написали `cout`. Вторая ошибка — не поставили точку запятой после `\"Hello, world!\\n\"`. Наконец, третья – не закрыли фигурную скобку с телом функции.\n\nОшибки компиляции (compile errors) следует отличать от возможных *ошибок времени выполнения* (runtime errors), которые происходят после запуска программы и, как правило, зависят от входных данных, неизвестных во время компиляции.\n\n\n## Отступы и оформление кода\n\nФрагменты программы на C++ могут быть иерархически вложены друг в друга. На верхнем уровне находятся функции, внутри них написаны их тела, в теле могут быть составные операторы, и так далее.\n\nСреди программистов есть соглашение — писать внутренние блоки кода с отступами вправо: компилятор полностью игнорирует эти отступы, а код читать удобнее. Мы будем использовать отступы в четыре пробела. Также мы будем придерживаться [стиля оформления кода, принятого в Яндексе](https://github.com/catboost/catboost/blob/master/CPP_STYLE_GUIDE.md). Имена переменных мы будем писать с маленькой буквы, имена функций и классов — с большой (если речь не идёт о конструкциях стандартной библиотеки, где действуют другие соглашения).\n\n\n## Переменные\n\nЛюбая содержательная программа так или иначе обрабатывает данные в памяти. Переменная — это именованный блок данных определённого типа. Чтобы определить переменную, нужно указать её тип и имя. В общем виде это выглядит так:\n\n```cpp\nType name;\n```\n\nгде `Type` — конкретный тип данных (например, строка или число), а `name` — имя переменной. Имена переменных [должны состоять](https://en.cppreference.com/w/cpp/language/identifiers) из латинских букв, цифр и знаков подчёркивания и не должны начинаться с цифры. Также можно в одной строке определить несколько переменных одного типа:\n\n```cpp\nType name1, name2, name3;\n```\n\nНапример:\n\n```cpp\n#include \u003cstring\u003e  // библиотека, в которой определён тип std::string\n\nint main() {\n    // Определяем переменную value целочисленного типа int\n    int value;\n\n    // Определяем переменные name и surname типа std::string (текстовая строка)\n    std::string name, surname;\n}\n```\n\nВ этом примере мы используем встроенный в язык тип `int` (от слова integer — целое число) и поставляемый со стандартной библиотекой тип `std::string`. (Можно было бы использовать для строк встроенный тип с массивом символов, но это неудобно.)\n\nТип переменной должен быть известен компилятору во время компиляции.\n\nОт типа зависит:\n- сколько байтов памяти потребуется для хранения данных;\n- как интерпретировать эти байты;\n- какие операции с этой переменной возможны.\n\nНапример, переменной типа `int` можно присваивать значения и с ней можно производить арифметические операции. Подробнее про разные типы данных и их размер в памяти мы поговорим ниже.\n\nВажно понимать, что тип остаётся с переменной навсегда. Например, присвоить целочисленной переменной строку не получится — это вызовет ошибку компиляции:\n\n```cpp\nint main() {\n    int value;\n    value = 42;  // OK\n    value = \"Hello!\";  // ошибка компиляции!\n}\n```\n\nПеременные можно сразу проинициализировать значением. В С++ есть [много разных способов инициализации](https://en.cppreference.com/w/cpp/language/initialization). Нам пока будет достаточно способа, который называется copy initialization:\n\n```cpp\n#include \u003cstring\u003e\n\nint main() {\n    int value = 42;\n    std::string title = \"Bjarne Stroustrup\";\n}\n```\n\nЕсли переменная была объявлена, но нигде дальше не использовалась, то компилятор выдаёт об этом предупреждение. При проверке решений мы используем опцию `-Werror`, которая считает предупреждения компилятора ошибками компиляции.\n\n\n## Потоковый ввод и вывод\n\nПоток — это абстракция для чтения и записи последовательности данных в форматированном виде.\n\nЗаписывать данные можно на экран консоли, в файл, буфер в памяти или в строку. Считывать их можно с клавиатуры, из файла, из памяти. Причём с каждым таким «устройством» можно связать свой поток.\n\nВажно, что потоки не просто пересылают байты памяти, а применяют форматированный человекочитаемый ввод-вывод. Например, числа печатаются и считываются в десятичной нотации, хотя в памяти компьютера они хранятся в двоичном виде.\n\nВ программе `Hello, world!` нам уже встречался поток вывода `std::cout`, по умолчанию связанный с экраном консоли. Познакомимся с потоком ввода `std::cin`, связанным с клавиатурой. Для его использования нужен тот же заголовочный файл `iostream`.\n\nРассмотрим программу, которая спрашивает имя пользователя и печатает персональное приветствие:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string name;  // объявляем переменную name\n    std::cout \u003c\u003c \"What is your name?\\n\";\n    std::cin \u003e\u003e name;  // считываем её значение с клавиатуры\n    std::cout \u003c\u003c \"Hello, \" \u003c\u003c name \u003c\u003c \"!\\n\";\n}\n```\n\nОбратите внимание на направление угловых скобок в этом примере — они условно показывают направление потока данных. При печати данные выводятся на экран, и стрелки направлены от текста к `cout`. При вводе данные поступают с клавиатуры, и стрелки направлены от `cin` к переменной.\n\nВ нашем примере в переменную `name` считается одно слово, которое будет выведено в ответном сообщении. Пример работы программы:\n\n\u003cpre\u003e\nWhat is your name?\nAlice\nHello, Alice!\n\u003c/pre\u003e\n\nОднако если ввести строку из нескольких слов с пробелами, то в `name` запишется только первое слово:\n\n\u003cpre\u003e\n$ ./a.out\nWhat is your name?\nAlice Liddell\nHello, Alice!\n\u003c/pre\u003e\n\nДело в том, что `cin` читает поток данных до ближайшего пробельного разделителя (пробела, табуляции, перевода строки или просто конца файла). Чтобы считать в строковую переменную всю строчку целиком (не включая завершающий символ перевода строки), нужно использовать функцию [`std::getline`](https://en.cppreference.com/w/cpp/string/basic_string/getline) из заголовочного файла `string`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string name;\n    std::getline(std::cin, name);\n    std::cout \u003c\u003c \"Hello, \" \u003c\u003c name \u003c\u003c \"!\\n\";\n}\n```\n\nВ этом примере мы печатаем в одном выражении друг за другом несколько строк (`\"Hello, \"`, `name` и `\"!\\n\"`), разделённых угловыми скобками `\u003c\u003c`. Таким образом, `cin` и `cout` позволяют кратко считывать и печатать несколько объектов одной командой.\n\nНапример, считывание нескольких чисел целого типа, набранных через пробельные разделители, может выглядеть так:\n\n```cpp\nint main() {\n    int a;\n    int b;\n    int c;\n    std::cin \u003e\u003e a \u003e\u003e b \u003e\u003e c;\n}\n```\n\nНапечатать их значения можно следующим образом:\n\n```cpp\nstd::cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c \" \" \u003c\u003c c \u003c\u003c \"\\n\";\n```\n\nОбратите внимание, что мы дополнительно вставляем между ними пробелы, чтобы в выводе числа не слиплись вместе. В конце вывода мы вставляем символ перевода строки `\\n`, чтобы отделить этот результат от последующего вывода или от сообщений командной строки.\n\nИтак, параграф позади! Впереди вас ждут первые задачи. Но прежде чем приступить к ним, советуем сперва взглянуть на небольшое [руководство](https://education.yandex.ru/handbook/cpp/article/cpp-kak-rabotat-s-sistemoi-proverki-zadanii) о том, как пользоваться системой проверки заданий.\n"])</script><script nonce="">self.__next_f.push([1,"5c:T5441,"])</script><script nonce="">self.__next_f.push([1,"C++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.\n\nВ этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.\n\n\n## Области видимости\nВ С++ существует понятие [области видимости](https://en.cppreference.com/w/cpp/language/scope) (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:\n\n```cpp\n#include \u003ciostream\u003e\n\nint a = 1;  // глобальная переменная\n\nint main() {\n    int b = 2;  // локальная переменная\n    {\n        int c = 3;  // локальная переменная внутри блока\n        std::cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c \" \" \u003c\u003c c \u003c\u003c \"\\n\";  // корректно\n    }\n\n    // Эта строчка не скомпилируется,\n    // так как переменная c не определена в данной области:\n    std::cout \u003c\u003c c \u003c\u003c \"\\n\";\n}\n```\n\nВ этом примере есть три области:\n- глобальная, в которой определена переменная `a`;\n- тело функции `main`, в которой определена переменная `b`;\n- внутренний блок, в котором определена переменная `c`.\n\nВ последней строке примера переменная `c` недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.\n\nРассмотрим пример:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int x = 1;\n    std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // напечатает 1\n    {\n        int x = 2;  // новая переменная, к предыдущему x не имеет отношения\n        std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // напечатает 2\n    }\n    std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // снова напечатает 1\n}\n```\n\n\n## Инициализация локальных переменных\n\nЛокальные переменные простых типов, таких как `int`, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: [*мы не должны платить за то, что не используем*](https://en.cppreference.com/w/cpp/language/Zero-overhead_principle).\n\nСледующий фрагмент кода может напечатать всё что угодно:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int x;\n    std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // неопределённое поведение!\n    int y;\n    std::cin \u003e\u003e y;  // а это допустимый сценарий\n}\n```\n\nКомпиляторы `g++` и `clang++` обычно дают предупреждения о чтении неинициализированных переменных при использовании опции `-Wall` или `-Wuninitialized`:\n\n\u003cpre\u003e\n$ clang++ -Wall program.cpp\nprogram.cpp:5:18: warning: variable 'x' is uninitialized when used here [-Wuninitialized]\n    std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // неопределённое поведение!\n                 ^\nprogram.cpp:4:10: note: initialize the variable 'x' to silence this warning\n    int x;\n         ^\n          = 0\n1 warning generated.\n\u003c/pre\u003e\n\nЗаметим, что `std::string` является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать `std::string s = \"\";`. Пишите просто `std::string s;`.\n\n\n## Простые типы данных\n\nС типом `int` мы уже знакомы. Рассмотрим другие [фундаментальные типы данных](https://en.cppreference.com/w/cpp/language/types) в С++. Это так называемые интегральные типы и типы для вещественных чисел.\n\n```cpp\nint main() {\n    char c = '1';    // символ\n    bool b = true;   // логическая переменная, принимает значения false и true\n    int i = 42;      // целое число (занимает, как правило, 4 байта)\n    short int si = 17;           // короткое целое (занимает 2 байта)\n    long li = 12321321312;       // длинное целое (как правило, 8 байт)\n    long long lli = 12321321312; // длинное целое (как правило, 8 байт)\n    float f = 2.71828;           // дробное число с плавающей запятой (4 байта)\n    double d = 3.141592;         // дробное число двойной точности (8 байт)\n    long double ld = 1e15;       // длинное дробное (как правило, 16 байт)\n}\n```\n\nОбратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную `c` символ единицы. Фактически в памяти хранится [ASCII-код](https://en.cppreference.com/w/cpp/language/ascii) этого символа, который равен 49.\n\nНапомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.\n\nО том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора [`sizeof`](https://en.cppreference.com/w/cpp/language/sizeof).\n\nНапример, на 64-битной Linux-системе компилятор `clang++` использует такие размеры для типов:\n\n```cpp\nint main() {\n    std::cout \u003c\u003c \"char: \" \u003c\u003c sizeof(char) \u003c\u003c \"\\n\";                 //  1\n    std::cout \u003c\u003c \"bool: \" \u003c\u003c sizeof(bool) \u003c\u003c \"\\n\";                 //  1\n    std::cout \u003c\u003c \"short int: \" \u003c\u003c sizeof(short int) \u003c\u003c \"\\n\";       //  2 (по стандарту \u003e= 2)\n    std::cout \u003c\u003c \"int: \" \u003c\u003c sizeof(int) \u003c\u003c \"\\n\";                   //  4 (по стандарту \u003e= 2)\n    std::cout \u003c\u003c \"long int: \" \u003c\u003c sizeof(long int) \u003c\u003c \"\\n\";         //  8 (по стандарту \u003e= 4)\n    std::cout \u003c\u003c \"long long int: \" \u003c\u003c sizeof(long long) \u003c\u003c \"\\n\";   //  8 (по стандарту \u003e= 8)\n    std::cout \u003c\u003c \"float: \" \u003c\u003c sizeof(float) \u003c\u003c \"\\n\";               //  4\n    std::cout \u003c\u003c \"double: \" \u003c\u003c sizeof(double) \u003c\u003c \"\\n\";             //  8\n    std::cout \u003c\u003c \"long double: \" \u003c\u003c sizeof(long double) \u003c\u003c \"\\n\";   // 16\n}\n```\n\n\n## Размеры стандартных типов\n\nПо умолчанию числовые типы – знаковые. Они имеют диапазон значений от $-2^{n-1}$ до $2^{n-1} - 1$, где $n$ – количество битов, занимаемых типом. Приставка `unsigned` перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до $2^n - 1$:\n\n```cpp\nint main() {\n    unsigned int ui = 4294967295;  // 2^32 - 1\n}\n```\n\nМинимальное и максимальное значение, помещающееся в данный числовой тип, можно получить так:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003climits\u003e  // необходимо для numeric_limits\n\nint main() {\n    // посчитаем для типа int:\n    std::cout \u003c\u003c \"minimum value: \" \u003c\u003c std::numeric_limits\u003cint\u003e::min() \u003c\u003c \"\\n\"\n              \u003c\u003c \"maximum value: \" \u003c\u003c std::numeric_limits\u003cint\u003e::max() \u003c\u003c \"\\n\";\n}\n```\n\nДанный пример на 64-битной Linux-системе напечатает:\n\n\u003cpre\u003e\nminimum value: -2147483648\nmaximum value: 2147483647\n\u003c/pre\u003e\n\nПриведённые выше примеры вывода оператора `sizeof` верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. Например, `sizeof(long int)` стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. Также бывают [встраиваемые системы](https://en.wikipedia.org/wiki/Embedded_system), под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.\n\nВ заголовочном файле `cstdint` стандартной библиотеки имеются [целочисленные типы с фиксированным размером](https://en.cppreference.com/w/cpp/types/integer):\n- `int8_t` / `uint8_t`\n- `int16_t` / `uint16_t`\n- `int32_t` / `uint32_t`\n- `int64_t` / `uint64_t`\n\nЧисло в имени типа означает количество бит, используемых для хранения в памяти. Например, `int32_t` содержит 32 бита (4 байта) и часто соответствует типу `int`. Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.\n\n\n## Переполнение целочисленных типов\n\nСтандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    unsigned int a = 123456;  // на 64-битной платформе sizeof(a) == 4\n\n    // Произведение a * a не помещается в 4 байта, так как оно больше 2^32\n    std::cout \u003c\u003c a * a \u003c\u003c \"\\n\";\n}\n```\n\nВ этом примере выражение `a * a` будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.\n\nБеззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:\n\n```cpp\nint main() {\n    unsigned int x = 0;      // на 64-битной платформе sizeof(x) == 4\n    unsigned int y = x - 1;  // 4294967295, то есть 2**32 - 1\n    unsigned int z = y + 1;  // 0\n}\n```\n\nНаоборот, для знаковых типов переполнение приводит к так называемому [неопределённому поведению](https://en.cppreference.com/w/cpp/language/ub) (UB, undefined behavior).\n\nТакая ситуация не считается ошибкой компиляции (в самом деле, на стадии компиляции значения переменных могут быть ещё неизвестны). Но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.\n\n**Беззнаковые типы** следует использовать, когда вы имеете дело с битовыми наборами. В остальных случаях предпочтительнее использовать **знаковые типы**.\n\n## Арифметические операции\n\nБинарные операции `+`, `-` и `*` работают для чисел стандартным образом. Результат операции деления `/`, применённой к целым числам, всегда округляется в сторону нуля. Таким образом, для положительных чисел операция `/` возвращает неполное частное. Остаток от деления целых чисел можно получить с помощью операции `%`.\n\n```cpp\nint main() {\n    int a = 7, b = 3;\n    int q = a / b;  // 2\n    int r = a % b;  // 1\n}\n```\n\nЕсли при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, `double`) с помощью оператора `static_cast`:\n\n```cpp\nint main() {\n    int a = 6, b = 4;\n    double q = static_cast\u003cdouble\u003e(a) / b;  // 1.5\n}\n```\n\nМожно было бы написать чуть более кратко: `double q = a * 1.0 / b;`. Тогда преобразование аргументов произошло бы неявно.\n\nАрифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    char c = 'A';\n    c += 25;  // увеличиваем ASCII-код символа на 25\n    std::cout \u003c\u003c c \u003c\u003c \"\\n\";  // Z\n}\n```\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://yastatic.net/s3/education-portal/media/C_1_869495082d_9c26d1f093.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\"\u003e\n  \u003cfigcaption\u003e\n    Таблица ASCII с шестнадцатеричными кодами символов. Слева указана старшая шестнадцатеричная цифра, сверху — младшая. Цветом выделены так называемые управляющие символы, обычно не имеющие графического представления.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\nОперация `+` применительно к строкам означает конкатенирование (то есть склейку). Это пример *перегрузки* операции: изначальному оператору сложения чисел в стандартной библиотеке для строки придали новый смысл.\n\n```cpp\n#include \u003cstring\u003e\n\nint main() {\n    std::string a = \"Hello, \";\n    std::string b = \"world!\";\n    std::string c = a + b;  // Hello, world!\n}\n```\n\nДля каждой бинарной операции (например, `+`) есть версия со знаком равенства (`+=`) для случая, когда левый аргумент совпадает с переменной, которой присваивается результат:\n\n```cpp\nint main() {\n    int x = 5;\n    x += 3;  // x = x + 3\n    x *= x;  // x = x * x\n}\n```\n\nНаконец, имеются операторы `++` и `--` для увеличения или уменьшения переменной на единицу. Они бывают префиксные (`++x`) и постфиксные (`x++`). Отличие состоит в значении выражения, которое будет вычисляться при применении такого оператора. Мы рассмотрим это позже, а пока привыкнем по умолчанию использовать префиксный оператор для обычных чисел:\n\n```cpp\nint main() {\n    int x = 5;\n    ++x;  // 6\n    --x;  // снова 5\n}\n```\n\n## Числа с плавающей точкой\n\nВ языке C++ существуют три встроенных типа для записи дробных чисел: `float` (4 байта), `double` (8 байт) и `long double` (16 или 8 байт, в зависимости от платформы). В большинстве случаев рекомендуется использовать тип `double`.Тип `float` разумно использовать там, где обрабатываются огромные массивы чисел, и возникает необходимость экономить память.\n\nКак правило, хранение дробных чисел в С++ основано на стандарте [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754). Число представляется в виде двоичной дроби в [экспоненциальной записи](https://en.wikipedia.org/wiki/Scientific_notation): отдельно хранятся бит знака, порядок и [мантисса](https://en.wikipedia.org/wiki/Significand).\n\n![C_2_5f62557ba8.svg](https://yastatic.net/s3/education-portal/media/C_2_5f62557ba8_ec6023e6f3.svg)\n\nТакое представление выгодно отличается от чисел с фиксированной точкой, где хранится фиксированное количество разрядов. Оно позволяет, хотя и с разной степенью точности, представлять числа, отличающиеся на порядки.\n\nПри работе с рациональными числами, знаменатель которых не является степенью двойки, неизбежно возникают погрешности представления. В следующем параграфе мы разберём как следует сравнивать такие числа.\n\n\n## Автоматический вывод типа\n\nКомпилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово `auto`:\n\n```cpp\nint main() {\n    auto x = 42;  // int\n    auto pi = 3.14159;  // double\n}\n```\n\nКлючевое слово `auto` позволяет сократить код и не выписывать сложные типы (нам встретятся дальше монстры вроде `std::unordered_multimap\u003cKey, Value\u003e::const_iterator`). Важно подчеркнуть, что точный тип переменной всё равно становится известен в момент компиляции.\n\nПри использовании `auto` со строками нужно быть осторожным. Важно знать, что конструкция `auto s = \"hello\"` выведет низкоуровневый тип `const char *` (указатель на неизменяемый набор символов в памяти), а не тип-обёртку `std::string`.\n\nТочные правила вывода типов похожи на правила вывода шаблонных параметров, с которыми мы познакомимся в [параграфе про шаблоны](https://education.yandex.ru/handbook/cpp/article/templates).\n\nВ следующем параграфе мы подробнее поговорим о ветвлении и циклах."])</script><script nonce="">self.__next_f.push([1,"5d:T587b,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе мы познакомимся с операторами ветвления `if` и `switch`, циклами `while`, `do-while` и `for`, а также с оператором `goto`.\n\n\n## Оператор if\n\nУсловный оператор `if` записывается так:\n\n```cpp\nif (condition) {\n    // код, который исполнится в случае, когда условие condition истинно\n}\n```\n\nДополнительно можно добавить ветку кода для случая, когда условие ложно:\n\n```cpp\nif (condition) {\n    // код, который исполнится, если condition истинно\n} else {\n    // код, который исполнится, если condition ложно\n}\n```\n\nТакже можно выстроить цепочку условных операторов:\n\n```cpp\nif (condition1) {\n    // случай, когда condition1 истинно\n} else if (condition2) {\n    // случай, когда condition1 ложно, а condition2 истинно\n} else if (condition3) {\n    // случай, когда condition1 и condition2 ложны, а condition3 истинно\n} else {\n    // случай, когда condition1, condition2 и condition3 ложны\n}\n```\n\nЕсли код внутри фигурных скобок состоит из одной инструкции, то фигурные скобки можно не писать. Однако рекомендуется ставить фигурные скобки всегда во избежание ошибок.\n\nНа месте `condition` может стоять любое выражение логического типа. Простейшие примеры таких выражений — это проверка на равенство (`==`) и неравенство (`!=`), а также сравнения на меньше / больше (`\u003c`, `\u003c=`, `\u003e` и `\u003e=`):\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int x;\n    std::cin \u003e\u003e x;\n    if (x \u003c= 0) {\n        std::cout \u003c\u003c \"zero or negative\\n\";\n    } else if (x == 1) {\n        std::cout \u003c\u003c \"one\\n\";\n    } else if (x == 2) {\n        std::cout \u003c\u003c \"two\\n\";\n    } else {\n        std::cout \u003c\u003c \"many\\n\";\n    }\n}\n```\n\n## Сложные условия\n\nУсловия можно комбинировать с помощью логических операторов `\u0026\u0026` (и), `||` (или) и `!` (не). Рассмотрим пример, где проверяется принадлежность точки разным интервалам на прямой.\n\n![C_3_d7d52bf9e2.svg](https://yastatic.net/s3/education-portal/media/C_3_d7d52bf9e2_9ceb4399c4.svg)\n\n```cpp\nint main() {\n    int a, b, x;\n    /* Тут должна быть логика заполнения объявленных переменных,\n    но мы её опустили, чтобы не отвлекаться */\n\n    if (a \u003c= x \u0026\u0026 x \u003c= b) {\n        // точка x лежит на отрезке [a; b]\n    } else {\n        // точка x лежит вне отрезка [a; b]\n    }\n\n    // то же самое можно было бы проверить так:\n    if (!(x \u003c a || x \u003e b)) {  // отрицание\n        // точка x лежит на отрезке [a; b]\n    } else {\n        // точка x лежит вне отрезка [a; b]\n    }\n}\n```\n\nОбратите внимание, что двойное неравенство некорректно проверять через `a \u003c= x \u003c= b`. Так можно написать, но смысл будет совсем другим: результат сравнения `a \u003c= x` будет приведён к нулю или единице, и полученное число будет сравниваться с `b`.\n\nОператоры сравнения имеют больший приоритет, чем логические операторы, поэтому скобки вокруг элементарных сравнений в сложных условиях не обязательны. А вот оператор отрицания имеет высокий приоритет, поэтому в последнем примере он применяется к условию в скобках. Таблицу приоритета операторов C++ можно посмотреть [здесь](https://en.cppreference.com/w/cpp/language/operator_precedence).\n\nОператоры `\u0026\u0026` и `||` ведут себя *лениво*: если первого аргумента уже достаточно для ответа, то второй аргумент вычисляться не будет. Например, в выражении `condition1 \u0026\u0026 condition2` второе условие не вычисляется, если первое ложно. Это часто используют для проверок корректности:\n\n```cpp\n    int a, b;\n    // ...\n    if (a != 0 \u0026\u0026 b % a == 0) {\n        // b делится на a\n    }\n```\n\n\n## Сравнение чисел с плавающей точкой\n\nРассмотрим программу, которая проверяет равенство `0.1 + 0.2 == 0.3`:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    double x = 0.1, y = 0.2;\n    if (x + y == 0.3) {\n        std::cout \u003c\u003c \"EQUAL \";\n    } else {\n        std::cout \u003c\u003c \"NOT EQUAL \";\n    }\n\n    std::cout \u003c\u003c x + y \u003c\u003c \"\\n\";\n}\n```\n\nЛогично было бы предположить, что программа выведет `EQUAL 0.3`, потому что $0.1 + 0.2 = 0.3$. Однако программа напечатает `NOT EQUAL 0.3`. Данная «ошибка вычисления» встречается в большинстве современных языков программирования и обусловлена погрешностью представления этих чисел. Если повысить число знаков дробной части в выводе, мы увидим, что `0.1 + 0.2 == 0.30000000000000004`. Подробнее об этом можно прочитать [здесь](https://0.30000000000000004.com/) и в [этой статье](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html).\n\nПоскольку операции над числами с плавающей точкой могут содержать погрешность, обычное сравнение через `==` некорректно. Поэтому правильнее сравнивать модуль разности величин с некой допустимой для нас погрешностью. Модуль дробного числа можно получить с помощью функции `std::abs` из заголовочного файла `cmath`. Исходную программу можно было бы переписать так:\n\n```cpp\n#include \u003ccmath\u003e\n#include \u003ciostream\u003e\n\nint main() {\n    double delta = 0.000001;\n\n    double x = 0.1, y = 0.2;\n    double sum = x + y;\n\n    if (std::abs(sum - 0.3) \u003c delta) {\n        std::cout \u003c\u003c \"EQUAL \";\n    } else {\n        std::cout \u003c\u003c \"NOT EQUAL \";\n    }\n\n    std::cout \u003c\u003c sum \u003c\u003c \"\\n\";\n}\n```\n\nТеперь программа выведет `EQUAL 0.3`.\n\n\n## Оператор switch\n\nРассмотрим простейший калькулятор, считывающий число, затем знак арифметической операции, а затем другое число и печатающий результат. Напишем сначала программу с помощью `if` и `else`.\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003ciostream\u003e\n\nint main() {\n    int64_t a, b;\n    char operation;\n    std::cin \u003e\u003e a \u003e\u003e operation \u003e\u003e b;\n\n    int64_t result = 0;\n    if (operation == '+') {\n        result = a + b;\n    } else if (operation == '-') {\n        result = a - b;\n    } else if (operation == '*') {\n        result = a * b;\n    } else if (operation == '/' || operation == ':') {\n        result = a / b;\n    } else if (operation == '%') {  // остаток от деления\n        result = a % b;\n    }\n\n    std::cout \u003c\u003c result \u003c\u003c \"\\n\";\n}\n```\n\n{% cut \"Вопросы для самопроверки\" %}\n\nЧто будет, если ввести `2 / 3`?\n\n* Так как всё вычисление происходит в целых числах, то напечатается `0`. Деление целых положительных чисел в C\\+\\+ — это всегда неполное частное.\n\nЧто будет, если ввести `2 @ 3`?\n\n* Обработку значка `@` мы не предусмотрели. Программа напечатает `0`, но тут необходимо напомнить, что у локальных переменных типа `int` [нет дефолтных значений](https://education.yandex.ru/handbook/cpp/article/data-types#inicializaciya-lokalnyh-peremennyh), и если бы мы не присвоили изначально `result = 0`, то программа напечатала бы какое-то неизвестное заранее число, лежащее в ячейках памяти, в которых поселился `result`.\n\n{% endcut %}\n\nПерепишем эту программу через оператор `switch`. Этот оператор следует рассматривать как условный прыжок на соответствующую метку в зависимости от значения выражения.\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003ciostream\u003e\n\nint main() {\n    int64_t a, b;\n    char operation;\n    std::cin \u003e\u003e a \u003e\u003e operation \u003e\u003e b;\n\n    int64_t result;\n    switch (operation) {\n        case '+':\n            result = a + b;\n            break;  // если не написать этот break, программа просто пойдёт дальше в код следующего блока case\n        case '-':\n            result = a - b;\n            break;\n        case '*':\n            result = a * b;\n            break;\n        case '/':\n        case ':':\n            result = a / b;\n            break;\n        case '%':\n            result = a % b;\n            break;\n        default:  // здесь обрабатывается случай, когда ни один case не сработал.\n            result = 0;\n    }\n\n    std::cout \u003c\u003c result \u003c\u003c \"\\n\";\n}\n```\n\nВыражения внутри скобок оператора `switch` и в блоках `case` должны быть простого целочисленного или символьного типа. В приведённой выше программе значение `+` относится к типу `char`. Использование сложных типов (например, строк) приведёт к ошибке компиляции:\n\n```cpp\nint main() {\n    std::string name;\n    std::cin \u003e\u003e name;\n    switch (name) {  // ошибка компиляции\n        case \"Alice\":\n           std::cout \u003c\u003c \"Hello, Alice!\\n\";\n           break;\n    }\n}\n```\n\n## Оператор goto\n\nЕсть шутка, что [оператор безусловного перехода](https://en.cppreference.com/w/cpp/language/goto) `goto` — это ругательное слово из четырёх букв. Безусловные переходы ломают иерархичность программы, затрудняют чтение и отладку. [Доказано](https://en.wikipedia.org/wiki/Structured_program_theorem), что любую программу можно переписать без оператора `goto`. Поэтому во многих современных языках `goto` отсутствует.\n\nОднако в C++ этот оператор есть по следующим причинам:\n- обратная совместимость с языком С;\n- удобный выход из вложенных циклов;\n- применение в автосгенерированном коде (например, коде конечного автомата), не предназначенном для чтения человеком.\n\nМы познакомимся с его синтаксисом, но дальше использовать нигде не будем — и вам не советуем.\n\n```cpp\nint main() {\n    again:  // метка — это произвольное имя с двоеточием\n\n    std::cout \u003c\u003c \"How old are you?\\n\";\n    int age;\n    std::cin \u003e\u003e age;\n\n    if (age \u003c 0 || age \u003e= 128) {\n        std::cout \u003c\u003c \"Wrong age...\\n\";\n        goto again;  // безусловный прыжок в место, помеченное меткой\n    }\n\n    std::cout \u003c\u003c \"Your age is \" \u003c\u003c age \u003c\u003c \".\\n\";\n\n    // ...\n}\n```\n\nЗдесь вводится метка `again`, на которую осуществляется переход, если возраст введён некорректно. Ниже мы покажем, как можно избавиться от оператора `goto`.\n\nС помощью оператора `goto` нельзя выйти из функции или зайти в неё, а также нельзя перепрыгнуть через объявления переменных (кроме тривиальных случаев):\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    goto label;\n    int x = 42;\n    label:  // ошибка компиляции!\n    std::cout \u003c\u003c x \u003c\u003c \"\\n\";\n}\n```\n\n## Цикл `while`\n\nВ C++ существует несколько видов циклов. Цикл `while` — это цикл с предусловием. Перед очередной итерацией проверяется условие, и если оно истинно, то цикл продолжается. Рассмотрим пример печати таблицы квадратов чисел от 1 до 10:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int n = 1;\n    while (n \u003c= 10) {\n        std::cout \u003c\u003c n \u003c\u003c \"\\t\" \u003c\u003c n * n \u003c\u003c \"\\n\";  // выводим число и его квадрат через табуляцию\n        ++n;\n    }\n}\n```\n\nЗдесь мы намеренно разделяем числа и их квадраты не пробелом, а знаком табуляции `\\t`. В консоли такой вывод будет выглядеть выровненным по колонкам с фиксированной шириной:\n\n\u003cpre\u003e\n1\t1\n2\t4\n3\t9\n4\t16\n5\t25\n6\t36\n7\t49\n8\t64\n9\t81\n10\t100\n\u003c/pre\u003e\n\n## Цикл `do-while`\n\nЭто цикл с постусловием. Отличие от цикла `while` заключается в том, что первая итерация всегда выполняется безусловно. Только после её завершения проверяется условие цикла. Если оно истинно, то цикл продолжается.\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int n = 1;\n    do {\n        std::cout \u003c\u003c n \u003c\u003c \"\\t\" \u003c\u003c n * n \u003c\u003c \"\\n\";\n        ++n;\n    } while (n \u003c= 10);\n}\n```\nБез особых причин пользоваться этим видом циклов не стоит, старайтесь использовать циклы `while` или `for`.\n\n## Цикл `for`\n\nЦикл `for` — самый гибкий. Он записывается так:\n\n```cpp\nfor (initialization; condition; action) {\n    // тело цикла\n}\n```\n\nКак правило, с циклом ассоциируется некоторый параметр, который меняется от итерации к итерации, а цикл выполняется до тех пор, пока некоторое условие на этот параметр истинно.\n\nНачальное значение такого параметра можно задать в разделе `initialization`, условие — в `condition`, а действие над параметром, выполняющееся после каждой итерации, — в `action`.\n\nНапечатаем таблицу квадратов через цикл `for`:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    for (int i = 1; i \u003c= 10; ++i) {\n        std::cout \u003c\u003c i \u003c\u003c \"\\t\" \u003c\u003c i * i \u003c\u003c \"\\n\";\n    }\n}\n```\n\nНапомним, что `++i` — традиционная краткая форма записи для выражения `i = i + 1`.\n\nЦикл `for` эквивалентен такому циклу `while`:\n\n```cpp\n{\n    initialization;\n    while (condition) {\n        // тело цикла\n        action;\n    }\n}\n```\n\n## Цикл range-based for\n\nЭтот цикл применим к контейнерам разной природы (массивам, векторам, спискам и т. д.), с которыми мы познакомимся позже. Пока рассмотрим его на примере строк. Цикл позволяет удобно проитерироваться по символам строки, не используя индексов. В этом примере мы считываем строку и печатаем отдельно все символы строки и их ASCII-коды:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string line;\n    std::getline(std::cin, line);\n    for (char symbol : line) {\n        std::cout \u003c\u003c symbol \u003c\u003c \"\\t\" \u003c\u003c static_cast\u003cint\u003e(symbol) \u003c\u003c \"\\n\";\n    }\n}\n```\n\nЗдесь оператор `static_cast` преобразует символ к числовому типу `int`, чтобы получить его код. Результат для строки `Hello, world!` выглядит так:\n\n\u003cpre\u003e\nH\t72\ne\t101\nl\t108\nl\t108\no\t111\n,\t44\n \t32\nw\t119\no\t111\nr\t114\nl\t108\nd\t100\n!\t33\n\u003c/pre\u003e\n\nОбратите внимание, что `std::string` хранит внутри байты. Если вы вводите символы русского алфавита и у вас используется [кодировка UTF-8](https://en.wikipedia.org/wiki/UTF-8), ставшая де-факто стандартом, то эти символы будут кодироваться парами байтов. И при такой итерации вы увидите отдельные байты, а не символы.\n\n## Вложенные циклы\n\nЦиклы могут быть вложенными. Напечатаем таблицу умножения:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    for (int i = 1; i \u003c= 10; ++i) {\n        for (int j = 1; j \u003c= 10; ++j) {\n            std::cout \u003c\u003c i * j \u003c\u003c \"\\t\";\n        }\n        std::cout \u003c\u003c \"\\n\";\n    }\n}\n```\n\nРезультат:\n\n\u003cpre\u003e\n1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t\n2\t4\t6\t8\t10\t12\t14\t16\t18\t20\t\n3\t6\t9\t12\t15\t18\t21\t24\t27\t30\t\n4\t8\t12\t16\t20\t24\t28\t32\t36\t40\t\n5\t10\t15\t20\t25\t30\t35\t40\t45\t50\t\n6\t12\t18\t24\t30\t36\t42\t48\t54\t60\t\n7\t14\t21\t28\t35\t42\t49\t56\t63\t70\t\n8\t16\t24\t32\t40\t48\t56\t64\t72\t80\t\n9\t18\t27\t36\t45\t54\t63\t72\t81\t90\t\n10\t20\t30\t40\t50\t60\t70\t80\t90\t100\t\n\u003c/pre\u003e\n\n\n## Операторы `break` и `continue`\n\nОператор `break` досрочно заканчивает текущий цикл. Оператор `continue` прыгает в самый конец тела цикла и, если условие цикла позволяет, переходит на следующую итерацию.\n\nТипичный пример использования оператора `break` — выход из формально бесконечного цикла:\n\n```cpp\nwhile (true) {\n    // ...\n    if (condition) {\n        break;\n    }\n    // ...\n}\n```\n\n{% cut \"Кстати, рассмотрим другие способы записать бесконечный цикл.\" %}\n\nЧерез цикл `do-while`:\n\n```cpp\ndo {\n    // ...\n} while (true);\n```\n\nЧерез цикл `for`:\n\n```cpp\nfor (;;) {\n    // ...\n}\n```\n\n{% endcut %}\n\nНапишем программу, которая считывает числа с клавиатуры до тех пор, пока пользователь не введёт ноль, а затем печатает их сумму:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int sum = 0;\n    while (true) {\n        int x;\n        std::cin \u003e\u003e x;\n        if (x == 0) {\n            break;\n        }\n        sum += x;\n    }\n    std::cout \u003c\u003c sum \u003c\u003c \"\\n\";\n}\n```\n\n(Здесь, конечно, неявно предполагается, что и сами числа, и результат суммирования помещаются в тип `int`, и в ходе вычислений не происходит переполнений.)\n\n\n## Считывание до конца ввода\n\nВ предыдущем примере мы считывали числа до тех пор, пока на вход не поступит ноль. Это не очень удобно. Предположим, что вместо ввода с клавиатуры мы читали бы эти числа из файла. Это легко сделать, перенаправив файл на стандартный ввод при запуске программы из консоли:\n\n\u003cpre\u003e\n./a.out \u0026lt; input.txt\n\u003c/pre\u003e\n\nСледующий цикл считывает числа до тех пор, пока поступающие данные не закончатся:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int sum = 0;\n    int x;\n    while (std::cin \u003e\u003e x) {\n        sum += x;\n    }\n    std::cout \u003c\u003c sum \u003c\u003c \"\\n\";\n}\n```\n\nЗдесь вместо условия цикла подставлено выражение `std::cin \u003e\u003e x`. Кроме считывания `x` это выражение преобразуется к логическому типу, показывающему, есть ли ещё данные в потоке ввода.\n\nПри вводе данных не из файла, а с клавиатуры можно сымитировать конец ввода комбинацией клавиш `Ctrl+D` в Linux и macOS или `Ctrl+Z` в Windows.\n\nАналогично можно прочитать строки до конца ввода с помощью `std::getline`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string name;\n    while (std::getline(std::cin, name)) {\n        std::cout \u003c\u003c \"Hello, \" \u003c\u003c name \u003c\u003c \"!\\n\";\n    }\n}\n```\n"])</script><script nonce="">self.__next_f.push([1,"5e:T64ce,"])</script><script nonce="">self.__next_f.push([1,"Вектор (`std::vector`) и строка (`std::string`) — это важные базовые контейнеры стандартной библиотеки C++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих контейнера предоставляют доступ к элементам по индексу и позволяют эффективно добавлять новые элементы в конец.\n\n\n## Контейнер `std::vector`\n\nВ стандартной библиотеке C++ *вектором* ([std::vector](https://en.cppreference.com/w/cpp/container/vector)) называется динамический массив, обеспечивающий быстрое добавление новых элементов в конец и меняющий свой размер при необходимости. Вектор гарантирует отсутствие утечек памяти (об этом мы поговорим в других параграфах, сейчас просто считайте, что это хорошо).\n\nДля работы с вектором нужно подключить заголовочный файл `vector`.\n\nЭлементы вектора должны быть одинакового типа, и этот тип должен быть известен при компиляции программы. Он задаётся в угловых скобках после `std::vector`: например, `std::vector\u003cint\u003e` — это вектор целых чисел типа `int`, а `std::vector\u003cstd::string\u003e` — вектор строк.\n\nСамо имя `std::vector` не является типом данных: это *шаблон*, в который требуется подставить нужные параметры (тип элемента), чтобы получился конкретный тип данных. Подробнее о том, что такое шаблоны и как их применять, мы расскажем в [параграфе «Шаблоны»](https://education.yandex.ru/handbook/cpp/article/templates).\n\nРассмотрим пример программы, которая заполняет вектор элементами и печатает их через пробел:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e data = {1, 2, 3, 4, 5};\n    for (int elem : data) {\n        std::cout \u003c\u003c elem \u003c\u003c \" \";\n    }\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\nЗдесь мы инициализируем вектор через [список инициализации](https://en.cppreference.com/w/cpp/utility/initializer_list), в котором элементы перечислены через запятую. Другой способ инициализации вектора — указать число элементов и (при необходимости) образец элемента:\n\n```cpp\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cstd::string\u003e v1;  // пустой вектор строк\n    std::vector\u003cstd::string\u003e v2(5);  // вектор из пяти пустых строк\n    std::vector\u003cstd::string\u003e v3(5, \"hello\");  // вектор из пяти строк \"hello\"\n}\n```\n\n\n## Обращение к элементам\n\nВыше мы использовали для печати элементов вектора цикл `range-for`. Но иногда удобнее работать с индексами. Вектор хранит элементы в памяти последовательно, поэтому по индексу элемента можно быстро найти его положение в памяти. Индексация начинается с нуля:\n\n```cpp\nstd::vector\u003cint\u003e data = {1, 2, 3, 4, 5};\nint a = data[0];  // начальный элемент вектора\nint b = data[4];  // последний элемент вектора (в нём пять элементов)\ndata[2] = -3;  // меняем элемент 3 на -3\n```\n\nЧтобы узнать общее количество элементов в векторе, можно воспользоваться функцией `size`:\n\n```cpp\nstd::cout \u003c\u003c data.size() \u003c\u003c \"\\n\";\n```\n\nОтрицательные индексы, как в некоторых других языках программирования, не допускаются.\n\nОбратите внимание: когда мы обращаемся по индексу через квадратные скобки, проверки его корректности не происходит.Это ещё одно проявление принципа *«мы не должны платить за то, что не используем»*.\n\nВстроенные валидаторы замедляют программу: предполагается, что программист пишет правильный код и уверен, что индекс `i` в выражении `data[i]` неотрицателен и удовлетворяет условию `i \u003c data.size()`. В этом случае они ему не нужны.\n\nЕсли всё же обратиться к вектору по некорректному индексу, то программа во время выполнения попадёт в неопределённое поведение: фактически она попробует прочитать память, не принадлежащую вектору.\n\nЕсли вам не хочется делать много лишних проверок, а в корректности индекса вы не уверены, то можно использовать функцию [`at`](https://en.cppreference.com/w/cpp/container/vector/at):\n\n```cpp\nstd::vector\u003cint\u003e data = {1, 2, 3, 4, 5};\nstd::cout \u003c\u003c data[42] \u003c\u003c \"\\n\";  // неопределённое поведение: может произойти всё что угодно\nstd::cout \u003c\u003c data.at(0) \u003c\u003c \"\\n\";  // напечатается 1\nstd::cout \u003c\u003c data.at(42) \u003c\u003c \"\\n\";  // произойдёт исключение std::out_of_range — его можно будет перехватить и обработать\n```\n\nПро работу с исключениями мы поговорим отдельно в [параграфе «Обработка исключений»](https://education.yandex.ru/handbook/cpp/article/exceptions).\n\nРассмотрим функции вектора `front` и `back`, которые возвращают его первый и последний элемент без использования индексов:\n\n```cpp\nstd::vector\u003cint\u003e data = {1, 2, 3, 4, 5};\nstd::cout \u003c\u003c data.front() \u003c\u003c \"\\n\";  // то же, что data[0]\nstd::cout \u003c\u003c data.back() \u003c\u003c \"\\n\";  // то же, что data[data.size() - 1]\n```\n\nВажно учитывать, что вызов этих функций на пустом векторе приведёт к неопределённому поведению.\n\nДля проверки вектора на пустоту вместо сравнения `data.size() == 0` принято использовать функцию `empty`, которая возвращает логическое значение:\n\n```cpp\nif (!data.empty()) {\n   // вектор не пуст, с ним можно работать\n}\n```\n\n\n## Итерация по индексам\n\nТак сложилось, что в стандартной библиотеке индексы и размеры контейнеров имеют беззнаковый тип. Вместо `unsigned int` или `unsigned long int` для него используется традиционный псевдоним [`size_t`](https://en.cppreference.com/w/cpp/types/size_t) (а точнее, `std::vector\u003cT\u003e::size_type`). Тип `size_t` на самом деле совпадает с `uint32_t` или `uint64_t` в зависимости от битности платформы. Его использование в программе дополнительно подчёркивает, что мы имеем дело с индексами или с размером.\n\nИтерацию по элементам `data` с помощью индексов можно записать так:\n\n```cpp\nfor (size_t i = 0; i != data.size(); ++i) {\n    std::cout \u003c\u003c data[i] \u003c\u003c \" \";\n}\n```\n\nЭто каноническая форма записи такого цикла: в ней принято использовать сравнение `!=` и префиксный `++i`. Для целых чисел не будет разницы, если написать это как-то иначе (например, через `\u003c` и постфиксный `i++`), но потом, когда вы будете писать аналогичные циклы для итераторов других контейнеров, разница появится. Давайте привыкнем всегда оформлять цикл по индексам так.\n\nБеззнаковость типа возвращаемого значения функции `size` порождает следующую проблему. По правилам, унаследованным ещё от языка C, результат арифметических действий над беззнаковым и знаковым типами приводится к беззнаковому типу. Поэтому выражение `data.size() - 1`, например, тоже будет беззнаковым. Если `data.size()` окажется нулём, то такое выражение будет вовсе не минус единицей, а самым большим беззнаковым целым (для 64-битной платформы это $2^{64} - 1$).\n\nРассмотрим следующий ошибочный код, который проверяет, есть ли в векторе дубликаты, идущие подряд:\n\n```cpp\n// итерация по всем элементам, кроме последнего:\nfor (size_t i = 0; i \u003c data.size() - 1; ++i) {\n    if (data[i] == data[i + 1]) {\n        std::cout \u003c\u003c \"Duplicate value: \" \u003c\u003c data[i] \u003c\u003c \"\\n\";\n    }\n}\n```\n\nЭта программа будет некорректно работать на пустом векторе. Условие `i \u003c data.size() - 1` на первой итерации окажется истинным, и произойдёт обращение к элементам пустого вектора. Правильнее было бы переписать это условие через `i + 1 \u003c data.size()` или воспользоваться внешней функцией [`std::ssize`](https://en.cppreference.com/w/cpp/iterator/size), которая появилась в C++20. Она возвращает знаковый размер вектора:\n\n```cpp\nfor (std::int64_t i = 0; i \u003c std::ssize(data) - 1; ++i) {\n    if (data[i] == data[i + 1]) {\n        std::cout \u003c\u003c \"Duplicate value: \" \u003c\u003c data[i] \u003c\u003c \"\\n\";\n    }\n}\n```\n\n\n## Добавление и удаление элементов\n\nВ вектор можно эффективно добавлять элементы в конец и удалять их с конца. Для этого существуют функции `push_back` и `pop_back`. Рассмотрим программу, считывающую числа с клавиатуры в вектор и затем удаляющую все нули в конце:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    int x;\n    std::vector\u003cint\u003e data;\n    while (std::cin \u003e\u003e x) {  // читаем числа, пока не закончится ввод\n        data.push_back(x);  // добавляем очередное число в вектор\n    }\n\n    while (!data.empty() \u0026\u0026 data.back() == 0) {\n        // Пока вектор не пуст и последний элемент равен нулю\n        data.pop_back();  // удаляем этот нулевой элемент\n    }\n}\n```\n\nДобавление элементов в другие части вектора или их удаление неэффективно, так как требует сдвига соседних элементов. Поэтому отдельных функций, например, для добавления или удаления элементов из начала у вектора нет. Это можно сделать с помощью общих функций `insert`/`erase` и итераторов. Мы рассмотрим такие примеры позже.\n\nУдалить все элементы из вектора можно с помощью функции `clear`.\n\n\n## Резерв памяти\n\nВектор хранит элементы в памяти в виде непрерывной последовательности, друг за другом. При этом в конце последовательности резервируется дополнительное место для быстрого добавления новых элементов. Когда этот резерв заканчивается, при вставке очередного элемента происходит *реаллокация*: элементы вектора копируются в новый, более просторный блок памяти.\n\nРеаллокация — довольно дорогая процедура, но если она происходит достаточно редко, то её влияние незначительно. Можно доказать, что если размер нового блока выбирать в два раза больше предыдущего размера, то [амортизационная сложность](https://en.wikipedia.org/wiki/Amortized_analysis) добавления элемента будет константной.\n\nТекущий резерв вектора можно узнать с помощью функции `capacity` (не путайте её с функцией `size`).\n\n![C_4_4ac318ee9f.svg](https://yastatic.net/s3/education-portal/media/C_4_4ac318ee9f_146cbfc8ee.svg)\n\nРассмотрим программу, в которой в вектор последовательно добавляются элементы и после каждого шага печатается размер и резерв:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e data = {1, 2};\n    std::cout \u003c\u003c data.size() \u003c\u003c \"\\t\" \u003c\u003c data.capacity() \u003c\u003c \"\\n\";\n\n    data.push_back(3);\n    std::cout \u003c\u003c data.size() \u003c\u003c \"\\t\" \u003c\u003c data.capacity() \u003c\u003c \"\\n\";\n\n    data.push_back(4);\n    std::cout \u003c\u003c data.size() \u003c\u003c \"\\t\" \u003c\u003c data.capacity() \u003c\u003c \"\\n\";\n\n    data.push_back(5);\n    std::cout \u003c\u003c data.size() \u003c\u003c \"\\t\" \u003c\u003c data.capacity() \u003c\u003c \"\\n\";\n}\n```\n\nВот вывод этой программы:\n\n\u003cpre\u003e\n2\t2\n3\t4\n4\t4\n5\t8\n\u003c/pre\u003e\n\nВидно, что размер вектора увеличивается на единицу, а резерв удваивается после исчерпания. Так, при добавлении четвёрки используется имеющаяся в резерве память, а при добавлении тройки и пятёрки происходит реаллокация.\n\n![C_5_bea6b5948b.svg](https://yastatic.net/s3/education-portal/media/C_5_bea6b5948b_0684ef4144.svg)\n\nИногда требуется заполнить вектор элементами, причём число элементов известно заранее. В таком случае можно сразу зарезервировать нужный размер памяти с помощью функции `reserve`, чтобы при добавлении элементов не происходили реаллокации. Пусть, например, нам сначала задаётся число слов, а потом сами эти слова, и нам требуется сложить их в вектор:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cstd::string\u003e words;\n\n    size_t words_count;\n    std::cin \u003e\u003e words_count;\n\n    // Размер вектора остаётся нулевым, меняется только резерв:\n    words.reserve(words_count);\n\n    for (size_t i = 0; i != words_count; ++i) {\n        std::string word;\n        std::cin \u003e\u003e word;\n        // Все добавления будут дешёвыми, без реаллокаций:\n        words.push_back(word);\n    }\n}\n```\n\nЕсли передать в `reserve` величину меньше текущего резерва, то ничего не поменяется — резерв останется прежним.\n\nФункцию `reserve` не следует путать с функцией `resize`, которая меняет количество элементов в векторе. Если аргумент функции `resize` меньше текущего размера, то лишние элементы в конце вектора удаляются. Если же он больше текущего размера, то при необходимости происходит реаллокация и в вектор добавляются новые элементы с дефолтным значением данного типа.\n\n```cpp\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e data = {1, 2, 3, 4, 5};\n\n    data.reserve(10);  // поменяли резерв, но размер вектора остался равным пяти\n\n    data.resize(3);  // удалили последние элементы 4 и 5\n    data.resize(6);  // получили вектор 1, 2, 3, 0, 0, 0\n}\n```\n\n## Многомерные векторы\n\nВоспользуемся вектором векторов, чтобы сохранить матрицу (таблицу) целых чисел. Пусть на вход программы сначала поступают число строк и число столбцов матрицы, а потом — сами элементы построчно:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    size_t m, n;\n    std::cin \u003e\u003e m \u003e\u003e n;  // число строк и столбцов\n\n    // создаём матрицу matrix из m строк, каждая из которых — вектор из n нулей\n    std::vector\u003cstd::vector\u003cint\u003e\u003e matrix(m, std::vector\u003cint\u003e(n));\n\n    for (size_t i = 0; i != m; ++i) {\n        for (size_t j = 0; j != n; ++j) {\n            std::cin \u003e\u003e matrix[i][j];\n        }\n    }\n\n    // напечатаем матрицу, выводя элементы через табуляцию\n    for (size_t i = 0; i != m; ++i) {\n        for (size_t j = 0; j != n; ++j) {\n            std::cout \u003c\u003c matrix[i][j] \u003c\u003c \"\\t\";\n        }\n        std::cout \u003c\u003c \"\\n\";\n    }\n}\n```\n\nВ этом примере мы заранее создали матрицу из нулей, а потом просто меняли её элементы.\n\n\n## Сортировка вектора\n\nРассмотрим типичную задачу — отсортировать вектор по возрастанию. Для этого в стандартной библиотеке в заголовочном файле `algorithm` есть готовая функция [`sort`](https://en.cppreference.com/w/cpp/algorithm/sort). Гарантируется, что сложность её работы в худшем случае составляет $O(n \\log n)$, где $n$ — число элементов в векторе. Типичные реализации используют алгоритм сортировки [Introsort](https://en.wikipedia.org/wiki/Introsort).\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e data = {3, 1, 4, 1, 5, 9, 2, 6};\n\n    // Сортировка диапазона вектора от начала до конца\n    std::sort(data.begin(), data.end());\n\n    // получим вектор 1, 1, 2, 3, 4, 5, 6, 9\n}\n```\n\nВ функцию `sort` передаются так называемые *итераторы*, ограничивающие рассматриваемый диапазон. В нашем случае мы передаём диапазон, совпадающий со всем вектором, от начала до конца. Соответствующие итераторы возвращают функции `begin` и `end` (не путать с `front` и `back`!). Итераторы можно считать обобщёнными индексами (но они могут быть и у контейнеров, не допускающих обычную индексацию). Подробнее про итераторы мы поговорим в отдельном параграфе.\n\nДля сортировки по убыванию можно передать на вход *обратные итераторы* `rbegin()` и `rend()`, представляющие элементы вектора в перевёрнутом порядке:\n\n```cpp\nstd::sort(data.rbegin(), data.rend());  // 9, 6, 5, 4, 3, 2, 1, 1\n```\n\nВ C++20 доступен более элегантный способ сортировки через `std::ranges::sort`:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e data = {3, 1, 4, 1, 5, 9, 2, 6};\n\n    std::ranges::sort(data);  // можно передать сам вектор, а не его диапазоны\n}\n```\n\nДля сортировки по умолчанию используется сравнение элементов с помощью оператора `\u003c`. Этот оператор работает и для самих векторов: они сравниваются [лексикографически](https://en.wikipedia.org/wiki/Lexicographic_order). Поэтому можно без проблем отсортировать, например, строки в матрице (векторе векторов целых чисел).\n\n\n## Строки\n\nКонтейнер `std::string` можно рассматривать как особый случай вектора символов `std::vector\u003cchar\u003e`, имеющий [набор дополнительных функций](https://en.cppreference.com/w/cpp/string/basic_string). В частности, у строки есть все те же рассмотренные нами функции, что и у вектора (например, `pop_back` или `resize`). Рассмотрим некоторые специфические функции строки:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string s = \"Some string\";\n\n    // приписывание символов и строк\n    s += ' ';  // добавляем отдельный символ в конец, это аналог push_back\n    s += \"functions\";  // добавляем строку в конец\n    std::cout \u003c\u003c s \u003c\u003c \"\\n\";  // Some string functions\n\n    // выделение подстроки\n    // подстрока \"string\" из 6 символов начиная с 5-й позиции\n    std::string sub1 = s.substr(5, 6);\n    // подстрока \"functions\" с 12-й позиции и до конца\n    std::string sub2 = s.substr(12);\n\n    // поиск символа или подстроки\n    size_t pos1 = s.find(' ');  // позиция первого пробела, в данном случае 4\n    size_t pos2 = s.find(' ', pos1 + 1);  // позиция следующего пробела (11)\n    size_t pos3 = s.find(\"str\");  // вернётся 5\n    size_t pos4 = s.find(\"#\");  // вернётся std::string::npos\n}\n```\n\nВставку, замену и удаление подстрок можно сделать через указание индекса начала и длины подстроки:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string s = \"Some string functions\";\n\n    // вставка подстроки\n    s.insert(5, \"std::\");\n    std::cout \u003c\u003c s \u003c\u003c \"\\n\";  // Some std::string functions\n\n    // замена указанного диапазона на новую подстроку\n    s.replace(0, 4, \"Special\");\n    std::cout \u003c\u003c s \u003c\u003c \"\\n\";  // Special std::string functions\n\n    // удаление подстроки\n    s.erase(8, 5);  // Special string functions\n}\n```\n\nАналогичные действия для других контейнеров (например, для того же вектора) можно сделать через итераторы. Мы рассмотрим такие примеры в одном из следующих параграфов.\n\nВ C++20 появились удобные функции `starts_with` и `ends_with` для проверки префикса или суффикса строк:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string phrase;\n    std::getline(std::cin, phrase);\n\n    if (phrase.starts_with(\"hello\")) {\n        std::cout \u003c\u003c \"Greeting\\n\";\n    }\n\n    if (phrase.ends_with(\"bye\")) {\n        std::cout \u003c\u003c \"Farewell\\n\";\n    }\n}\n```\n"])</script><script nonce="">self.__next_f.push([1,"5f:T2699,"])</script><script nonce="">self.__next_f.push([1,"C++ позволяет конструировать новые типы данных на основе базовых типов. В этом параграфе мы познакомимся с перечислениями и структурами, а также рассмотрим конструкции `std::pair` и `std::tuple` из стандартной библиотеки.\n\n\n## Перечисления\n\nПредположим, что мы пишем программу для обработки изображений и хотим работать с цветами. Для каждого цвета заводить отдельную константу не очень удобно. Воспользуемся [перечислением](https://en.cppreference.com/w/cpp/language/enum#Scoped_enumerations) — специальным типом данных, который состоит из конечного набора именованных констант:\n\n```cpp\nenum class Color {\n    White,\n    Red,\n    Orange,\n    Blue,\n};\n```\n\nМы описали новый тип данных `Color` с четырьмя допустимыми значениями. Теперь к каждому цвету можно обращаться через префикс `Color::`:\n\n```cpp\nint main() {\n    Color color1 = Color::Red;\n    Color color2 = Color::Blue;\n}\n```\n\nФактически перечисления — это удобный способ описывать однотипные именованные константы. По умолчанию перечисления хранятся как тип `int`, а их значения последовательно нумеруются с нуля. И тип, и конкретное значение [можно поменять](https://en.cppreference.com/w/cpp/language/enum#Scoped_enumerations).\n\nПреобразовать перечисление в число и обратно можно с помощью оператора `static_cast`:\n\n```cpp\nint value = static_cast\u003cint\u003e(color2);  // 3\nColor color3 = static_cast\u003cColor\u003e(2);  // Color::Orange\n```\n\n{% cut \"Немного истории.\" %}\n\nРаньше в C\\+\\+ перечисления объявлялись [вот так](https://en.cppreference.com/w/cpp/language/enum#Unscoped_enumeration), без слова `class`:\n\n```cpp\nenum Color {\n    White,\n    Red,\n    Orange,\n    Blue,\n};\n\nenum {  // можно даже без названия\n    Apple,\n    Orange,\n    Banana\n};\n```\n\nЭтот способ остался в языке. Но в таком случае все имена внутри перечислений являются глобальными, и могут происходить конфликты имён (`Orange` в примере). Такая программа просто не скомпилируется.\n\n{% endcut %}\n\n\n## Структуры\n\nЧасто хочется собрать «под одной крышей» несколько переменных. В таких случаях можно использовать структуры. Например, давайте опишем структуру точек из трёхмерного пространства:\n\n```cpp\nstruct Point {\n    double x = 0.0;\n    double y = 0.0;\n    double z = 0.0;\n    Color color;  // пусть у нас будет цветная точка\n};\n```\n\nВ данном случае мы описали новый тип данных — `Point`, который содержит в себе четыре переменные.\n\nДавайте поработаем с этой структурой:\n\n```cpp\nint main() {\n    Point point1;  // по умолчанию координаты будут нулевыми, а color никак не будет проинициализирован\n    point1.color = Color::Blue;\n\n    Point point2 = {1.4, -2.2, -3.98, Color::Red};\n    // x = 1.4, y = -2.2, z = -3.98, color = Color::Red\n\n    point2.z = 32;  // обращаться к полям можно через точку\n    point2.x += 2;  // и вообще работать с ними как с обычными переменными\n}\n```\n\nВ С++20 появилась новая форма инициализации структур — [designated initializers](https://en.cppreference.com/w/cpp/language/aggregate_initialization):\n\n```cpp\nint main() {\n    Point point3 = {.x = 1.4, .y = -2.2, .z = -3.98};\n    Point point4 = {.color = Color::Orange};\n}\n```\n\nТакой способ записи понятнее: сразу видно, какое поле структуры каким значением инициализируется. Важно, что поля должны быть перечислены в том же порядке, в каком они указываются при описании структуры (причину этого мы узнаем в [параграфе про конструкторы и жизненный цикл объекта](https://education.yandex.ru/handbook/cpp/article/object-lifetime)). Пропущенные поля будут инициализироваться значением по умолчанию. Так, `point3.color` будет равно `Color::White` — нулевому значению перечисления `Color`.\n\n\n## Выравнивание\n\nТеперь давайте поговорим про размеры перечислений и структур:\n\n```cpp\nint main() {\n    std::cout \u003c\u003c sizeof(double) \u003c\u003c \"\\n\";  // 8\n    std::cout \u003c\u003c sizeof(Color) \u003c\u003c \"\\n\";   // 4 (фактически это int)\n    std::cout \u003c\u003c sizeof(Point) \u003c\u003c \"\\n\";   // 32\n}\n```\n\nПолучается, что размер структуры `Point` (32 байта) не равен сумме размеров её частей (8 + 8 + 8 + 4 = 28). Всё дело в [выравнивании](https://en.cppreference.com/w/cpp/language/object#Alignment): компилятору не очень удобно работать со структурой в 28 байт при условии, что внутри этой структуры есть переменные, размер которых — 8 байт (так как 28 не кратно 8). Поэтому компилятор резервирует за структурой несколько лишних байтов (в нашем случае — 4).\n\n![C_6_ece75de95c.svg](https://yastatic.net/s3/education-portal/media/C_6_ece75de95c_7dfc22890a.svg)\n\nМожно явно попросить компилятор не выделять мнимых байтов, но в таком случае пострадает скорость — потому что если данные в памяти выровнены, то их легче достать и проще обрабатывать.\n\n\n## Кортежи и пары\n\nВ заголовочном файле `utility` есть шаблонная структура [`std::pair`](https://en.cppreference.com/w/cpp/utility/pair) с полями `first` и `second`. Из названия просто догадаться, что она хранит два объекта:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cutility\u003e\n\nint main() {\n    // в угловых скобках нужно указывать два типа:\n    std::pair\u003cint, double\u003e p = {42, 3.14};\n\n    // обращаться к полям можно через .first и .second:\n    std::cout \u003c\u003c p.first \u003c\u003c \"\\n\";  // 42\n    std::cout \u003c\u003c p.second \u003c\u003c \"\\n\";  // 3.14\n}\n```\n\nОднако у `std::pair` есть проблема — её поля обезличены, и не очень ясно, какую смысловую нагрузку несёт `first`, а какую — `second`. Из-за этого мы советуем не злоупотреблять данной структурой, кроме случаев, когда она используется в функциях стандартной библиотеки.\n\nОбобщением пары на несколько переменных является кортеж — [`std::tuple`](https://en.cppreference.com/w/cpp/utility/tuple), объявленный в заголовочном файле `tuple`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003ctuple\u003e\n\nstruct Point;  // определена выше\n\nint main() {\n    std::tuple\u003cint, double, Point\u003e t = {42, 3.14, {.color = Color::Orange}};\n\n    // тут уже нет полей .first и .second,\n    // но есть стандартная функция std::get\u003c\u003e,\n    // которая принимает в угловых скобках индекс элемента (индексация с нуля):\n    std::cout \u003c\u003c std::get\u003c0\u003e(t) \u003c\u003c \"\\n\";  // 42\n    std::cout \u003c\u003c std::get\u003c1\u003e(t) \u003c\u003c \"\\n\";  // 3.14\n    std::cout \u003c\u003c std::get\u003c2\u003e(t).x \u003c\u003c \"\\n\";  // 0.0\n\n    // вызов std::get может появляться и слева от присваивания:\n    std::get\u003c2\u003e(t).color = Color::Red;\n}\n```\n\nВажно понимать, что типы элементов пары или кортежа, а также размер кортежа фиксируются на этапе компиляции.\n\n\nПару, кортеж или структуру можно «распаковать» с помощью [structured binding](https://en.cppreference.com/w/cpp/language/structured_binding).\n\n```cpp\n#include \u003cstring\u003e\n#include \u003cutility\u003e\n\nint main() {\n    std::pair\u003cstd::string, int\u003e p = {\"hello\", 42};\n    auto [word, freq] = p;  // word = \"hello\"; freq = 42;\n}\n```\n\nЗдесь конструкция `auto [word, freq] = p` вводит две новые переменные `word` и `freq` соответствующих типов и присваивает им значения из пары.\n"])</script><script nonce="">self.__next_f.push([1,"60:T446e,"])</script><script nonce="">self.__next_f.push([1,"# Ссылки. Указатели. Константность\n\nСсылки позволяют вводить псевдонимы для переменных. Указатели — это самостоятельные типы данных, которые могут хранить адреса других переменных в памяти. Ключевое слово `const` позволяет подчеркнуть, что переменная используется только для чтения. Часто оно используется совместно с объявлением ссылок и указателей.\n\n\n## Копии переменных\n\nДля начала давайте рассмотрим такой фрагмент кода:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string s1 = \"Elementary, my dear Watson!\";\n    std::string s2 = s1;\n\n    s1.clear();  // s2 никак не изменится\n\n    std::cout \u003c\u003c s1 \u003c\u003c \"\\n\";  // пустая строка\n    std::cout \u003c\u003c s2 \u003c\u003c \"\\n\";  // Elementary, my dear Watson!\n}\n```\n\nВажно понимать, что здесь `s2` будет совершенно новой строкой, которая проинициализирована значением `s1`, но более никак с `s1` не связана. Это отличает С++ от некоторых других языков программирования — например, языка Python. В них после аналогичного присваивания строка осталась бы той же самой.\n\nСоздание новой строки `s2` требует ресурсов: нужно выделить новый блок памяти и скопировать туда старую строку.\n\n\n## Ссылки\n\nВпрочем, в C++ есть возможность обращаться к уже существующему в памяти объекту под другим именем. Рассмотрим это на примере целых чисел:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int x = 42;\n    int\u0026 ref = x;  // ссылка на x\n\n    ++x;\n    std::cout \u003c\u003c ref \u003c\u003c \"\\n\";  // 43\n}\n```\n\nЗдесь `ref` — псевдоним для `x`. Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти. Формально типом `ref` является `int\u0026` — ссылка на `int`.\n\nАналогично для строк:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string s1 = \"Elementary, my dear Watson!\";\n    std::string\u0026 s2 = s1;  // тут ссылка!\n\n    s1.clear();\n\n    std::cout \u003c\u003c s2.size() \u003c\u003c \"\\n\";  // напечатает 0\n}\n```\n\nСсылка должна быть проинициализирована сразу в момент объявления. Например, так написать нельзя:\n\n```cpp\nint main() {\n    int my_variable = 42;\n    int\u0026 ref;  // ошибка!\n    // ...\n    ref = my_variable;\n}\n```\n\nСсылка привязана к одному и тому же объекту со своего рождения. Переназначить её нельзя:\n\n```cpp\nint main() {\n    int x = 42, y = 13;\n    int\u0026 ref = x;  // OK\n    ref = y;  // ссылка останется привязанной к x, значение x поменяется\n}\n```\n\nСсылки удобны там, где исходное имя слишком громоздко (например, является вложенным полем какой-либо структуры).\n\n\n## Указатели\n\nДругой (более базовый) способ сослаться на что-то уже существующее в памяти — указатели. Это специальные типы данных, которые могут хранить адрес какой-либо другой переменной в памяти. Здесь мы можем представлять себе память как длинную ленту с пронумерованными ячейками (байтами). Сам адрес переменной можно получить с помощью унарного оператора `\u0026`:\n\n```cpp\nint main() {\n    int x = 42;\n    int* ptr = \u0026x;  // сохраняем адрес в памяти переменной x в указатель ptr\n\n    ++x;  // увеличим x на единицу\n    std::cout \u003c\u003c *ptr \u003c\u003c \"\\n\";  // 43\n}\n```\n\n![C_7_75695e51d4.svg](https://yastatic.net/s3/education-portal/media/C_7_75695e51d4_20eea84108.svg)\n\nФормально указатель — это не номер ячейки памяти, а отдельный тип. Но обычно он может быть преобразован к целому числу. Вот такой код напечатает адреса переменных в шестнадцатеричном виде:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int x = 1, y = 2, z = 3;\n    std::cout \u003c\u003c \u0026x \u003c\u003c \"\\n\";\n    std::cout \u003c\u003c \u0026y \u003c\u003c \"\\n\";\n    std::cout \u003c\u003c \u0026z \u003c\u003c \"\\n\";\n}\n```\n\nПример вывода:\n\n\u003cpre\u003e\n0x7ffdfee3188c\n0x7ffdfee31888\n0x7ffdfee31884\n\u003c/pre\u003e\n\nМожно заметить, что адреса будут идти «рядом» с шагом `sizeof(int)` по возрастанию или убыванию — это зависит от платформы и компилятора. Но при повторном запуске программы они могут отличаться, так как программе может быть назначен совсем другой сегмент памяти.\n\nКроме адреса ячейки памяти переменная-указатель обладает ещё и типом данных, значение которого в этой ячейке лежит. Это позволяет компилятору правильно интерпретировать обращение к памяти по этому адресу. Поэтому мы используем не какой-либо абстрактный тип «указатель», а именно «указатель на `int`».\n\nОператор разыменования (унарная звёздочка) противоположен оператору взятия адреса (унарному амперсанду). Сравните: `\u0026x` — это адрес `x` в памяти, а `*ptr` — это значение, живущее по адресу, записанному в `ptr`.\n\nУказатели, в отличие от ссылок, можно переназначать. Кроме того, есть выделенное значение никуда не ссылающегося указателя — `nullptr` («нулевой» указатель):\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int x = 42, y = 13;\n    int* ptr;  // по умолчанию не инициализируется, тут лежит «случайный» адрес\n    ptr = nullptr;  // «нулевой» указатель\n    ptr = \u0026x;  // теперь в ptr лежит адрес переменной x\n    std::cout \u003c\u003c *ptr \u003c\u003c \"\\n\";  // 42\n    ptr = \u0026y;  // можно поменять адрес, записанный в ptr\n    std::cout \u003c\u003c *ptr \u003c\u003c \"\\n\";  // 13\n}\n```\n\nУказатель `nullptr` нельзя разыменовывать: это приведёт к неопределённому поведению.\n\nЧасто указатели используются вместе с динамическим выделением памяти (`malloc`/`new`). Мы познакомимся с динамической памятью в [параграфе «Жизненный цикл объекта»](https://education.yandex.ru/handbook/cpp/article/object-lifetime). А сейчас лишь стоит заметить, что указатель сам по себе совершенно не означает, что память, на которую он ссылается, была выделена динамически. Например, во всех примерах выше указатель ссылался на обычную переменную на стеке.\n\nОтдельно рассмотрим указатели на структуру. Для обращения к полям структуры через указатель есть отдельный оператор `-\u003e`:\n\n```cpp\n#include \u003ciostream\u003e\n\nstruct Point {\n    double x, y, z;\n};\n\nint main() {\n    Point p = {3.0, 4.0, 5.0};\n\n    Point* ptr = \u0026p;\n\n    std::cout \u003c\u003c (*ptr).x \u003c\u003c \"\\n\";  // обращение через * и . требует скобок\n    std::cout \u003c\u003c ptr-\u003ex \u003c\u003c \"\\n\";  // то же самое, но чуть короче\n}\n```\n\n\n## Константность\n\nКонстанта — это переменная, предназначенная только для чтения. Её значение должно быть зафиксировано в момент присваивания. При этом оно не обязательно должно быть известно в момент компиляции:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    const int c1 = 42;  // эта константа известна в compile time\n\n    int x;\n    std::cin \u003e\u003e x;\n    const int c2 = 2 * x;  // значение становится известным только в runtime\n\n    с2 = 0;  // ошибка компиляции: константе нельзя присвоить новое значение\n}\n```\n\nУ константного вектора или строки нельзя будет вызвать функции, которые их будут изменять:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    const std::vector\u003cint\u003e v = {1, 3, 5};\n    std::cout \u003c\u003c v.size() \u003c\u003c \"\\n\";  // OK, напечатает 3\n    v.clear();  // ошибка компиляции: константный вектор нельзя изменять\n    v[0] = 0;  // тоже ошибка компиляции\n}\n```\n\nСсылки и указатели можно комбинировать с константностью:\n\n```cpp\nint main() {\n    int x = 42;\n\n    int\u0026 ref = x;  // обычная ссылка\n    const int\u0026 cref = x;  // константная ссылка\n    ++x;  // OK\n    ++ref;  // OK\n    ++cref;  // ошибка компиляции: псевдоним cref предназначен только для чтения\n\n    int* ptr = \u0026x;  // обычный указатель\n    const int* cptr = \u0026x;  // указатель на константу\n    ++*ptr;  // OK\n    ++*cptr;  // ошибка компиляции: разыменованный cptr — константа!\n}\n```\n\nЕсли исходная переменная уже была константной, то взять обычную ссылку или указатель на неё не получится. Другими словами, константность нельзя просто так отменить, её можно только добавить:\n\n```cpp\nint main() {\n    const int cx = 42;\n\n    int\u0026 ref = cx;  // ошибка компиляции: константность нельзя убрать\n    const int\u0026 cref = cx;  // OK\n\n    int* ptr = \u0026cx;  // тоже ошибка компиляции\n    const int* cptr = \u0026cx;  // OK\n}\n```\n\nБазовый тип и слово `const` можно менять местами. Так что `const T` и `T const` — это одно и то же. Но следует различать указатель на константу (`const T*`) и константу типа «указатель» (`T* const`):\n\n```cpp\nint main() {\n    int x = 42;\n    const int cx = 13;\n\n    int* ptr = \u0026x;  // обычный указатель\n    ptr = \u0026cx;  // ошибка компиляции\n\n    const int* cptr = \u0026x;  // OK: через *cptr нельзя будет изменить x\n    cptr = \u0026cx;  // OK\n\n    int* const ptrc = \u0026x;  // OK: *ptrc можно менять, но сам ptrc менять нельзя\n    ptrc = nullptr;  // ошибка компиляции\n\n    const int* const cptrc = \u0026x;  // OK, для \u0026cx тоже бы сработало\n}\n```\n\nПример в последней строке похож на константную ссылку: указатель `cptrc` не позволяет менять содержимое ячейки `\u0026x` (первый `const`) и в него нельзя записать адрес другой переменной (второй `const`).\n\n\n## Ссылки в цикле `range-for`\n\nРассмотрим итерацию по элементам вектора строк. Намеренно положим в вектор много длинных строк и в цикле попробуем подсчитать их длину (которую, конечно, можно было бы сразу вычислить):\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    // создаём вектор из m строк длины n\n    // и искусственно заполняем его:\n    const size_t m = 1000000;\n    const size_t n = 10000;\n    std::vector\u003cstd::string\u003e v(m);\n    for (size_t i = 0; i != m; ++i) {\n        v[i].resize(n, '@');  // кладём в вектор строку из n символов @\n    }\n\n    // нам интересен этот цикл:\n    size_t sum = 0;\n    for (auto row : v) {\n        sum += row.size();\n    }\n    std::cout \u003c\u003c sum \u003c\u003c \"\\n\";\n}\n```\n\nСкомпилируем программу с умеренным уровнем оптимизаций (ключ `-O2`) и измерим время её работы с помощью консольной утилиты [time](https://en.wikipedia.org/wiki/Time_(Unix)):\n\n\u003cpre\u003e\n$ clang++ -O2 -o runnable test.cpp\n$ time ./runnable\n\nreal   0m4,255s\nuser   0m1,948s\nsys    0m2,307s\n\u003c/pre\u003e\n\nПрограмма работала 4,255 секунды. Давайте её ускорим. Заметим, что в цикле мы пишем\n\n```cpp\nfor (auto row : v) {\n    // ...\n}\n```\n\nНа самом деле это эквивалентно такому:\n\n```cpp\nfor (size_t i = 0; i != v.size(); ++i) {\n    std::string row = v[i];  // здесь создаётся копия!\n    // ...\n}\n```\n\nПонятно, что вместо копирования очередной строки можно воспользоваться константной ссылкой:\n\n```cpp\nfor (const auto\u0026 row : v) {\n    // ...\n}\n```\n\nВремя работы такой программы уже будет меньше:\n\n\u003cpre\u003e\n$ time ./runnable\n\nreal   0m3,462s\nuser   0m1,157s\nsys    0m2,305s\n\u003c/pre\u003e\n\nДавайте запомним: чтобы избегать лишнего копирования, в `range-for` используйте константную ссылку при итерации по набору «тяжёлых» объектов — строк, векторов, структур. Если вы хотите в цикле менять элементы контейнера — используйте обычную ссылку. Нашу программу можно было бы переписать так:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    const size_t m = 1000000;\n    const size_t n = 10000;\n    std::vector\u003cstd::string\u003e v(m);\n    for (auto\u0026 row : v) {  // обычная ссылка\n        row.resize(n, '@');\n    }\n\n    size_t sum = 0;\n    for (const auto\u0026 row : v) {  // константная ссылка\n        sum += row.size();\n    }\n    std::cout \u003c\u003c sum \u003c\u003c \"\\n\";\n}\n```\n\n\n## «Висячие» ссылки и указатели\n\nМожет так оказаться, что переменная, на адрес которой ссылается указатель, уже вышла из своей области видимости. Похожая ситуация может произойти и со ссылками. В таком случае обращаться к памяти через ссылку или указатель нельзя — это приведёт к неопределённому поведению.\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int* ptr = nullptr;\n\n    {\n        int x = 42;\n        ptr = \u0026x;\n    }\n\n    // обращаться к памяти, в которой жила переменная x, уже нельзя:\n    std::cout \u003c\u003c *ptr \u003c\u003c \"\\n\";  // неопределённое поведение!\n}\n```\n\nАналогичная ситуация произойдёт при обращении к уже не существующему элементу вектора:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cstd::string\u003e words = {\"one\", \"two\", \"three\"};\n\n    std::string\u0026 ref = words[0];  // псевдоним для начального элемента вектора\n\n    words.clear();\n\n    // обращаться к ссылке ref уже нельзя!\n    std::cout \u003c\u003c ref \u003c\u003c \"\\n\";  // неопределённое поведение!\n}\n```\n\nВажно не допускать в программах таких ситуаций.\n"])</script><script nonce="">self.__next_f.push([1,"61:T3b3a,"])</script><script nonce="">self.__next_f.push([1,"Функции позволяют отделить часто используемый код и переиспользовать его с разными значениями аргументов. С примером функции мы уже знакомы: в каждой программе вы пишете функцию `main`, которая не принимает аргументов и возвращает `int`.\n\n\n## Примеры функций\n\nНапишем простейшую функцию, вычисляющую сумму двух целых чисел:\n\n```cpp\nint Sum(int a, int b) {  // в заголовке функции указывается тип возвращаемого значения и типы аргументов\n    return a + b;\n}\n```\n\nЕсли функция ничего не должна возвращать, её можно объявить как `void`:\n\n```cpp\nvoid DoSomething(double d, char c) {\n    // ...\n    // писать return в конце такой функции не обязательно,\n    //     но если требуется завершить функцию, можно написать просто return;\n}\n\nint main() {\n    int x = 17, y = 42;\n    int z = Sum(x, y);\n    DoSomething(3.14, '@');\n}\n```\n\nВот пример рекурсивной функции, вычисляющей факториал:\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003ciostream\u003e\n\nstd::uint64_t Factorial(std::uint64_t n) {\n    if (n == 0) {\n        return 1;\n    }\n    return n * Factorial(n - 1);  // рекурсивный вызов\n}\n\nint main() {\n    std::cout \u003c\u003c Factorial(5) \u003c\u003c \"\\n\";  // 120\n}\n```\n\nПомните, что если делать очень много рекурсивных вызовов, то рано или поздно переполнится стек — область памяти, в которой хранятся аргументы и локальные переменные текущей функции.\n\n\n## Аргументы функций\n\nПараметры в функции по умолчанию передаются «по значению». Другими словами, функция работает с копиями аргументов. Чтобы лучше представить это, давайте посмотрим, что бы получилось, если бы компилятор заменил вызов функции на непосредственное исполнение кода.\n\nВозьмём такой фрагмент кода:\n\n```cpp\nvoid f(int x, int y) {\n    // работаем с аргументами x и y\n}\n\nint main() {\n    int a, b;\n    // какая-то инициализация a и b\n\n    f(a, b);\n}\n```\n\nЗаменим его на такой код:\n\n```cpp\nint main() {\n    int a, b;\n    // какая-то инициализация a и b\n\n    {   // этот блок просто ограничивает время жизни\n        // находящихся внутри переменных\n        int x = a;\n        int y = b;\n        // работаем с аргументами x и y\n    }\n}\n```\nТеперь видно, что любое изменение `x` или `y` внутри функции никак не затронет `a` и `b`.\n\nМожем ли мы изменить переданный аргумент внутри функции, чтобы это повлияло на аргументы в месте вызова? Да, для этого надо передать аргументы через ссылку или указатель. Вот классический пример функции, меняющей два аргумента местами:\n\n```cpp\nvoid Swap(int\u0026 x, int\u0026 y) {  // передаём аргументы по ссылке\n    int z = x;\n    x = y;\n    y = z;\n}\n\nint main() {\n    int a = 1, b = 2;\n    Swap(a, b);\n    std::cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c \"\\n\";  // 2 1\n}\n```\n\nЧтобы понять, как это работает, раскроем снова код функции в месте вызова:\n\n```cpp\nint main() {\n    int a = 1, b = 2;\n\n    {\n        int\u0026 x = a;\n        int\u0026 y = b;\n        int z = x;\n        x = y;\n        y = z;\n    }\n\n    std::cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c \"\\n\";  // 2 1\n}\n```\n\nВидно, что `x` и `y` — это просто псевдонимы для `a` и `b`.\n\nЗаметьте, что вызов `Swap(1, 2)`, в отличие от `Swap(a, b)`, не скомпилируется, потому что обычная ссылка должна быть привязана к изменяемому объекту.\n\nПримером функции из стандартной библиотеки, которая принимает аргумент по ссылке и изменяет его, является `std::getline`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string line;\n\n    // Второй аргумент передаётся по ссылке и изменяется внутри функции:\n    std::getline(std::cin, line);\n}\n```\n\nИногда копирование объекта может быть очень дорогим (и ненужным). Например, копирование вектора приведёт к копированию всех его элементов. Поэтому вот так передавать вектор в функцию неэффективно:\n\n```cpp\nvoid f(std::vector\u003cint\u003e v) {\n    // плохо: при вызове функции создаётся копия вектора\n}\n```\n\nКопии можно было бы избежать, если бы вектор передавался по ссылке:\n\n```cpp\nvoid f(std::vector\u003cint\u003e\u0026 v) {\n    // Но теперь есть другие недостатки:\n    // 1. В такую функцию нельзя передать константный вектор.\n    // 2. Функция не защищена от случайного изменения вектора:\n    v.clear();  // тут компилятор нас не схватит за руку\n}\n```\n\nПоэтому самое правильное — передавать такой параметр по константной ссылке:\n\n```cpp\nvoid f(const std::vector\u003cint\u003e\u0026 v) {\n    // Такой аргумент не требует дорогого копирования,\n    // его нельзя случайно изменить внутри,\n    // и такую функцию можно вызывать от констант!\n}\n```\n\n**Давайте запомним**: аргументы сложных типов (векторы, строки, любые контейнеры, большие структуры) всегда лучше передавать в функцию по константной ссылке, если функция использует их только для чтения. Из этого правила бывают исключения, но о них мы поговорим отдельно.\n\nВпрочем, это правило не стоит распространять на обычные встроенные типы:\n\n```cpp\nvoid g(const int\u0026 a, const char\u0026 c) {  // так делать не надо, это уже перебор!\n    // передавайте такие параметры просто по значению, как int или char\n}\n```\n\n\n## Возвращаемые значения функций\n\nВ отличие от аргументов, значения сложных типов можно без проблем возвращать из функций. Здесь от ненужного копирования (по крайней мере, для стандартных контейнеров) спасает [copy elision](https://en.cppreference.com/w/cpp/language/copy_elision).\n\nРассмотрим, например, функцию, которая возвращает конкатенацию всех строк из вектора:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nstd::string Concatenate(const std::vector\u003cstd::string\u003e\u0026 parts) {\n    std::string result;\n    for (const auto\u0026 part : parts) {\n        result += part;\n    }\n    return result;\n}\n\nint main() {\n    std::vector\u003cstd::string\u003e parts = {\"abra\", \"ca\", \"dabra\"};\n    std::cout \u003c\u003c Concatenate(parts) \u003c\u003c \"\\n\";  // abracadabra\n}\n```\n\nОпасно возвращать из функции ссылку на локальную переменную, так как эта ссылка сразу же станет [«висячей»](https://education.yandex.ru/handbook/cpp/article/references-pointers-const#«visyachie»-ssylki-i-ukazateli):\n\n```cpp\n#include \u003ciostream\u003e\n\nint\u0026 Sum(int a, int b) {  // ошибка!\n    int result = a + b;\n    return result;\n}\n\nint main() {\n    std::cout \u003c\u003c Sum(2, 3) \u003c\u003c \"\\n\";  // неопределённое поведение!\n}\n```\n\nКомпиляторы в таких случаях генерируют предупреждения.\n\nВозвращать значение по ссылке можно только в случае, если оно заведомо будет доступно после завершения функции. Например, так можно вернуть глобальную переменную или аргумент, также переданный по ссылке.\n\n\n## Функции-компараторы\n\nПусть имеется структура `Date`, описывающая день, месяц и год какой-то даты. Создадим вектор дат:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nstruct Date {\n    int year = 1970;\n    int month = 1;\n    int day = 1;\n};\n\nint main() {\n    std::vector\u003cDate\u003e dates = {\n        {2020, 3, 15},\n        {2019, 1, 21},\n        {2021, 1, 30}\n    };\n\n    // напечатаем содержимое:\n    for (const auto\u0026 [year, month, day] : dates) {\n        std::cout \u003c\u003c year \u003c\u003c \".\" \u003c\u003c month \u003c\u003c \".\" \u003c\u003c day \u003c\u003c \"\\n\";\n    }\n}\n```\n\nПредположим, нам требуется отсортировать даты. Для сортировки нам поможет уже знакомая функция `std::sort`, но есть нюанс: вызов `std::sort(dates.begin(), dates.end())` не скомпилируется, так как компилятор не умеет сравнивать даты между собой. Функция `std::sort` пытается найти оператор `\u003c` для сравнения дат, но, увы, для нашей даты такого нет. Мы можем его определить. Он выглядит как функция с особым именем `operator \u003c`, возвращающая `true`, если первый аргумент меньше второго:\n\n```cpp\nbool operator \u003c (const Date\u0026 lhs, const Date\u0026 rhs) {\n    if (lhs.year != rhs.year) {\n        return lhs.year \u003c rhs.year;\n    }\n    if (lhs.month != rhs.month) {\n        return lhs.month \u003c rhs.month;\n    }\n    return lhs.day \u003c rhs.day;\n}\n```\n\nЗдесь `lhs` и `rhs` — сокращения от left-hand side и right-hand side. Это левый и правый аргументы оператора `\u003c`. Этот громоздкий код можно записать лаконичнее с использованием функции [`std::tie`](https://en.cppreference.com/w/cpp/utility/tuple/tie), возвращающей кортеж из ссылок, для которого уже определено лексикографическое (покомпонентное) сравнение:\n\n```cpp\nbool operator \u003c (const Date\u0026 lhs, const Date\u0026 rhs) {\n    return std::tie(lhs.year, lhs.month, lhs.day) \u003c std::tie(rhs.year, rhs.month, rhs.day);\n}\n```\n\nПосле определения `operator \u003c` сортировка заработает. Но что, если нам в разных случаях нужно по-разному сортировать даты — например, где-то в хронологическом порядке, а где-то — без учёта года? Можно передать в `std::sort` третьим аргументом свою функцию сравнения, которая будет использована вместо `operator \u003c`:\n\n```cpp\nbool CompareWithoutYear(const Date\u0026 lhs, const Date\u0026 rhs) {\n    return std::tie(lhs.month, lhs.day) \u003c std::tie(rhs.month, rhs.day);\n}\n\nint main() {\n    // ...\n    std::sort(dates.begin(), dates.end(), CompareWithoutYear);\n}\n```\n\nОбратите внимание, что третьим аргументом в `std::sort` мы передаём саму функцию (без круглых скобок), а не результат её вызова от каких-то аргументов.\n\n\n## Лямбда-функции\n\nИногда бывает неудобно определять отдельную именованную функцию для сравнения. Тогда можно определить анонимную [лямбда-функцию](https://en.cppreference.com/w/cpp/language/lambda) прямо в месте её использования:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\nstruct Date {\n    int year, month, day;\n};\n\nint main() {\n    std::vector\u003cDate\u003e dates;\n    std::sort(dates.begin(), dates.end(), [](const Date\u0026 lhs, const Date\u0026 rhs) {\n        return std::tie(lhs.month, lhs.day) \u003c std::tie(rhs.month, rhs.day);\n    });\n}\n```\n\nТип возвращаемого значения тут не указывается, компилятор умеет его угадывать по `return` (его можно указать после круглых скобок на «питоновский» манер через `-\u003e`, но не обязательно).\n\nРазберём синтаксис лямбда-функций. Тут видны три блока.\n* Квадратные скобки отвечают за контекст. В них мы можем передать переменные, которые объявлены вне лямбда-функции через запятую, и они будут доступны в самой лямбда-функции.\n* Круглые скобки отвечают за аргументы функции.\n* Фигурные скобки отвечают за тело лямбда-функции.\n\nКогда лямбды добавлялись в стандарт C++11, разработчики очень не хотели вводить для них новое ключевое слово (как `lambda` в Python) и обошлись комбинацией скобок. Есть шутка про то, что вот такая программа является вполне корректной:\n\n```cpp\nint main() {[](){}();}\n```\n\nПопробуйте разобраться, что тут происходит.\n"])</script><script nonce="">self.__next_f.push([1,"62:T37eb,"])</script><script nonce="">self.__next_f.push([1,"[Шаблоны](https://en.cppreference.com/w/cpp/language/templates) — это фрагменты обобщённого кода, в котором некоторые типы или константы вынесены в параметры. Шаблонными могут быть функции, структуры (классы) и даже переменные. Компилятор превращает использование шаблона в конкретный код, подставляя в него нужные параметры на этапе компиляции. Шаблоны позволяют писать общий код, пригодный для использования с разными типами данных.\n\nСтандартная библиотека C++ построена на шаблонах. Раньше её даже называли Standard Template Library (STL, стандартная библиотека шаблонов). Её контейнеры и итераторы являются шаблонными классами, а алгоритмы — шаблонными функциями. Примеры шаблонных конструкций из стандартной библиотеки нам уже встречались: это, например, контейнер `std::vector` и функция `std::sort`. В следующем параграфе мы рассмотрим контейнер `std::array`, размер которого задаётся шаблонной константой времени компиляции. В этом параграфе мы рассмотрим шаблоны функций и структур, параметры которых являются типами. Но прежде чем говорить про шаблоны, рассмотрим перегрузку функций.\n\n\n## Перегрузка функций\n\nКоличество и типы аргументов функции должны быть известны заранее, на этапе компиляции. Но в языке C++ можно создавать функции с одним и тем же именем, но разным набором или типами аргументов и с разными телами. Такие функции называются [перегруженными](https://en.wikipedia.org/wiki/Function_overloading). Рассмотрим, например, семейство перегруженных функций для печати переменной на экран:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nvoid Print(int value) {\n    std::cout \u003c\u003c value \u003c\u003c \"\\n\";\n}\n\nvoid Print(const std::string\u0026 name, int value) {\n    std::cout \u003c\u003c name \u003c\u003c \": \" \u003c\u003c value \u003c\u003c \"\\n\";  // печатаем название и саму величину\n}\n\nvoid Print(const std::string\u0026 str) {\n    std::cout \u003c\u003c str \u003c\u003c \"\\n\";\n}\n\nint main() {\n    Print(42);  // версия 1\n    Print(\"x\", 42);  // версия 2\n    Print(\"good bye\");  // версия 3\n}\n```\n\nКомпилятор, сравнивая разные версии функции друг с другом, смотрит на их имена и набор типов аргументов. При этом имена аргументов ни на что не влияют. Также нельзя перегружать функции по типу возвращаемого значения. Действительно, возвращаемое значение может просто игнорироваться в месте вызова, и компилятор не сможет определить, какая версия функции имеется в виду.\n\n```cpp\nint f(int x) {\n    return x;\n}\n\nint f(int y) {  // ошибка компиляции: функция с таким именем и типом параметра уже была\n    return 2 * y;\n}\n\ndouble f(int x) {  // ошибка компиляции: перегружать по возвращаемому значению нельзя\n    return 3 * x;\n}\n```\n\n\n## Шаблонные функции\n\nРассмотрим классический пример. Предположим, у нас есть функция, вычисляющая максимум целых чисел:\n\n```cpp\nint Max(int x, int y) {\n    if (x \u003e y) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```\n\nОна определена для аргументов типа `int`. Однако, если применить её к аргументам типа `double`, результат получится неожиданным. А её применение к строкам или векторам вообще не скомпилируется:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::cout \u003c\u003c Max(1, 2) \u003c\u003c \"\\n\";  // 2\n    std::cout \u003c\u003c Max(3.14159, 2.71828) \u003c\u003c \"\\n\";  // внезапно 3\n\n    std::string word1 = \"hello\", word2 = \"world\";\n    std::cout \u003c\u003c Max(word1, word2);  // ошибка компиляции\n}\n```\n\nВ вызове `Max(3.14159, 2.71828)` аргументы будут преобразованы к типу `int`, то есть получится `Max(3, 2)`. Вызов `Max(word1, word2)` не скомпилируется, так как строки нельзя привести к типу `int`. Чтобы эти вызовы корректно заработали, надо определить перегруженные версии функции `Max`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint Max(int x, int y) {\n    if (x \u003e y) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\ndouble Max(double x, double y) {\n    if (x \u003e y) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\nstd::string Max(const std::string\u0026 x, const std::string\u0026 y) {\n    if (x \u003e y) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\nint main() {\n    std::cout \u003c\u003c Max(1, 2) \u003c\u003c \"\\n\";  // 2\n    std::cout \u003c\u003c Max(3.14159, 2.71828) \u003c\u003c \"\\n\";  // 3.14159\n\n    std::string word1 = \"hello\", word2 = \"world\";\n    std::cout \u003c\u003c Max(word1, word2);  // world\n}\n```\n\nВыписывать похожие друг на друга версии функций утомительно. Кроме того, такие функции не смогут работать с новыми, неизвестными нам заранее типами. Шаблоны позволяют описать такую функцию один раз, вынеся тип в параметры:\n\n```cpp\ntemplate \u003ctypename T\u003e\nT Max(const T\u0026 x, const T\u0026 y) {\n    if (x \u003e y) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```\n\nШаблон начинается с шапки `template`. Далее в угловых скобках перечисляются формальные имена параметров. В нашем случае параметр один — это тип `T` (от слова type). Вместо ключевого слова `typename` в этом месте допускается использовать слово `class` (вы можете встретить такие описания шаблонов на [cppreference.com](https://cppreference.com/)). А вместо имени `T` можно было бы использовать любой другой идентификатор.\n\nТак как мы не знаем, будет ли тип `T` встроенным или сложным, то на всякий случай передаём аргументы в функцию по константной ссылке, чтобы избежать лишнего копирования.\n\nВ нашей шаблонной функции `Max` используется оператор `\u003e`. Он определён для обычных чисел, строк и векторов (если, конечно, для элементов вектора тоже определён этот оператор). Но если попробовать применить наш шаблон к типу, не поддерживающему оператор `\u003e`, то произойдёт ошибка компиляции:\n\n```cpp\nstruct Point {\n    double x = 0.0;\n    double y = 0.0;\n    double z = 0.0;\n};\n\nint main() {\n    Point p1, p2;\n    Point p = Max(p1, p2);  // ошибка компиляции\n}\n```\n\n\n## Вывод шаблонных параметров\n\nКонкретные версии шаблонной функции `Max` для нужных типов получаются подстановкой шаблонных аргументов в угловые скобки. Так, `Max\u003cint\u003e` — это версия нашей функции для типа `int`, а `Max\u003cstd::string\u003e` — версия для строк. Важно понимать, что, несмотря на общий шаблон, это *разные* функции, которые просто порождаются компилятором по образцу.\n\nВызвать шаблонную функцию можно было бы так:\n\n```cpp\nMax\u003cdouble\u003e(3.14159, 2.71828);  // 3.14159\nMax\u003cint\u003e(3.14159, 2.71828);  // вызывается int-версия, вернётся 3\n```\n\nОднако параметры шаблона в угловых скобках можно не писать: компилятор попытается сам угадать эти параметры по типу аргументов:\n\n```cpp\nint main() {\n    std::cout \u003c\u003c Max(1, 2) \u003c\u003c \"\\n\";  // 2, вызывается Max\u003cint\u003e\n    std::cout \u003c\u003c Max(3.14159, 2.71828) \u003c\u003c \"\\n\";  // 3.14159, вызывается Max\u003cdouble\u003e\n\n    std::string word1 = \"hello\", word2 = \"world\";\n    std::cout \u003c\u003c Max(word1, word2);  // world, вызывается Max\u003cstd::string\u003e\n}\n```\n\nВ случае неоднозначностей, например в вызове `Max(3.14159, 2)`, компилятор не сможет автоматически вывести параметр, и ему придётся подсказать тип: `Max\u003cdouble\u003e(3.14159, 2)`.\n\n\n## Перегрузка шаблонных функций\n\nШаблонные функции тоже можно [перегружать](https://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading). Пусть, например, мы хотим вычислять максимум двух векторов, но при этом сравнивать векторы сначала по размеру, а затем уже лексикографически. Стандартное сравнение векторов через оператор `\u003e` не будет учитывать размер. Поэтому напишем отдельную перегрузку для векторов:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\n// общая версия\ntemplate \u003ctypename T\u003e\nT Max(const T\u0026 x, const T\u0026 y) {\n    if (x \u003e y) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\n// перегрузка для векторов\ntemplate \u003ctypename T\u003e\nconst std::vector\u003cT\u003e\u0026 Max(const std::vector\u003cT\u003e\u0026 v1, const std::vector\u003cT\u003e\u0026 v2) {\n    if (v1.size() \u003e v2.size()) {\n        return v1;\n    } else if (v1.size() \u003c v2.size()) {\n        return v2;\n    } else if (v1 \u003e v2) {\n        return v1;\n    } else {\n        return v2;\n    }\n}\n\nint main() {\n    std::cout \u003c\u003c Max(1, 2) \u003c\u003c \"\\n\";  // вызов общей версии\n\n    std::vector\u003cint\u003e v1 = {1, 2, 3};\n    std::vector\u003cint\u003e v2 = {4, 5};\n    for (int x : Max(v1, v2)) {  // вызов перегруженной версии\n        std::cout \u003c\u003c x \u003c\u003c \" \";  // 1 2 3\n    }\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\n\n## Разрешение неоднозначностей\n\nКогда компилятор видит вызов функции, ему нужно правильно определить, в каком пространстве имён её искать, какую из перегруженных версий выбрать, а в случае шаблонной функции — как вывести параметры шаблона. Для шаблонных функций после выбора перегруженной версии возможен ещё выбор из вариантов [полной специализации шаблона](https://en.cppreference.com/w/cpp/language/template_specialization). Общие правила поиска нужной функции [достаточно сложны](https://en.cppreference.com/w/cpp/language/overload_resolution), и мы не будем их здесь приводить полностью. Однако в случаях, которые мы будем рассматривать в этом учебнике, выбор нужной функции будет интуитивно понятен.\n\n\n## Шаблонные структуры\n\nСтруктуры и классы также могут быть описаны в общем виде и параметризованы типами или константами времени компиляции. Типичный пример шаблонной структуры — `std::pair`. Определим по аналогии свою структуру `Triple` с тремя шаблонными типами:\n\n```cpp\n#include \u003cstring\u003e\n\ntemplate \u003ctypename T1, typename T2, typename T3\u003e\nstruct Triple {\n    T1 first;\n    T2 second;\n    T3 third;\n};\n\nint main() {\n    Triple\u003cint, int, int\u003e point = {-1, 3, 2};\n    Triple\u003cstd::string, std::string, int\u003e wordPairsFreq = {\"hello\", \"world\", 42};\n}\n```\n\nЗдесь так же, как и в случае функций, компилятор генерирует по образцу две никак не связанные друг с другом структуры `Triple\u003cint, int, int\u003e` и `Triple\u003cstd::string, std::string, int\u003e`.\n\nВ следующих параграфах мы будем подробно рассматривать [шаблонные классы](https://en.cppreference.com/w/cpp/language/class_template), в которых могут быть шаблонные функции-члены.\n"])</script><script nonce="">self.__next_f.push([1,"63:T1013f,"])</script><script nonce="">self.__next_f.push([1,"## Параграф «Первые шаги»\n\n### [Задача «Печать текста»](https://new.contest.yandex.ru/42153/problem?id=2109007/2022_10_30/mPrLrWmV0Y)\n\n{% cut \"Условие\" %}\n\nНапишите программу, печатающую на экране первые строчки со [страницы Бьярне Страуструпа про C\\+\\+](https://www.stroustrup.com/C++.html):\n\n```\nC++ is a general-purpose programming language with a bias towards systems programming that\n  - is a better C\n  - supports data abstraction\n  - supports object-oriented programming\n  - supports generic programming.\n```\n\nНе потеряйте парные пробелы в начале строк и переносы в конце строк.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nЗадача очень похожа на программу `Hello world`. Отличие в том, что здесь надо напечатать несколько строк текста. Сам символ перевода строки не может содержаться в обычных строковых литералах, поэтому в программе его придётся заменить на `\\n`. Можно просто вывести каждую строчку отдельно:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    std::cout \u003c\u003c \"C++ is a general-purpose programming language with a bias towards systems programming that\\n\";\n    std::cout \u003c\u003c \"  - is a better C\\n\";\n    std::cout \u003c\u003c \"  - supports data abstraction\\n\";\n    std::cout \u003c\u003c \"  - supports object-oriented programming\\n\";\n    std::cout \u003c\u003c \"  - supports generic programming.\\n\";\n}\n```\n\nОднако писать каждый раз `std::cout` утомительно. В конструкции `std::cout` поддерживается вывод нескольких величин сразу. Можно оставить только самый первый `std::cout`, а остальные строки вывести через `\u003c\u003c`:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    std::cout \u003c\u003c \"C++ is a general-purpose programming language with a bias towards systems programming that\\n\"\n              \u003c\u003c \"  - is a better C\\n\"\n              \u003c\u003c \"  - supports data abstraction\\n\"\n              \u003c\u003c \"  - supports object-oriented programming\\n\"\n              \u003c\u003c \"  - supports generic programming.\\n\";\n}\n```\n\nЗдесь мы нарочно для лучшей читаемости отформатировали программу так, чтобы символы `\u003c\u003c` стояли друг под другом.\n\nРассмотрим ещё два способа решить задачу. Строковые константы, расположенные просто друг за другом, автоматически конкатенируются при компиляции программы. Так `\"Hello,\"  \" world!\"` даст `\"Hello, world!`. Поэтому можно написать так:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    std::cout \u003c\u003c \"C++ is a general-purpose programming language with a bias towards systems programming that\\n\"\n                 \"  - is a better C\\n\"\n                 \"  - supports data abstraction\\n\"\n                 \"  - supports object-oriented programming\\n\"\n                 \"  - supports generic programming.\\n\";\n}\n```\n\nМожно ли избавиться от необходимости писать `\\n` в конце каждой строки? Да, для этого можно воспользоваться raw-литералами. Они могут содержать внутри без экранирования любые символы, в том числе перевод строки, лишь бы они были отличны от выбранных ограничителей. Такие литералы предваряются символом `R`, а в начале и в конце должна стоять произвольно выбранная одинаковая последовательность символов и круглые скобки. Например, `raw(...)raw`, или `~~~(...)~~~`:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    std::cout \u003c\u003c\nR\"~~~(C++ is a general-purpose programming language with a bias towards systems programming that\n  - is a better C\n  - supports data abstraction\n  - supports object-oriented programming\n  - supports generic programming.\n)~~~\";\n}\n```\n\nПодробнее про строковые литералы читайте [здесь](https://en.cppreference.com/w/cpp/language/string_literal).\n\n{% endcut %}\n\n### [Задача «Сумма чисел»](https://new.contest.yandex.ru/42153/problem?id=2109007/2022_10_30/JauJjtpRce)\n\n{% cut \"Условие\" %}\n\nВам даны два целых числа. Напечатайте их сумму.\n\n#### Формат ввода\n\nВводятся два числа, по модулю не превосходящие миллиарда.\n\n#### Формат вывода\n\nНапечатайте сумму этих чисел. В конце поставьте перевод строки.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\u003cbr/\u003e2\n\n|\n\n3\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int a, b;\n    std::cin \u003e\u003e a \u003e\u003e b;\n    std::cout \u003c\u003c a + b \u003c\u003c \"\\n\";\n}\n```\n\nПроверять корректность условия (то, что числа по модулю не превосходят миллиарда) в программе не нужно.\n\nИз условия следует, что сумма этих чисел по модулю не будет превосходить двух миллиардов. Забегая немного вперёд, скажем, что это гарантирует, что сумма поместится в тип `int`. Такие условия позволяют выбрать правильный тип данных для решения задачи.\n\n{% endcut %}\n\n---\n\n## Параграф «Типы данных»\n\n### [Задача «Дюймы»](https://new.contest.yandex.ru/42154/problem?id=2109007/2022_10_30/LuqDYUa7Rs)\n\n{% cut \"Условие\" %}\n\nНапишите программу для перевода сантиметров в дюймы. В одном дюйме $2.54$ сантиметра.\n\n#### Формат ввода\n\nНа вход поступает длина в сантиметрах. Значение может быть дробным. Используйте тип `double` для его хранения.\n\n#### Формат вывода\n\nНапечатайте эту длину в дюймах. Округление не требуется. Достаточно использовать стандартную точность вывода до 6 знаков после запятой, которая установлена по умолчанию.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\\.1\n\n|\n\n0\\.433071\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nЕсли в одном дюйме $2.54$ сантиметра, то в одном сантиметре $1/2.54$ дюйма:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    double centimeters;\n    std::cin \u003e\u003e centimeters;\n\n    double inches = centimeters / 2.54;\n\n    std::cout \u003c\u003c inches \u003c\u003c \"\\n\";\n}\n```\n\n{% endcut %}\n\n### [Задача «Арифметическая прогрессия»](https://new.contest.yandex.ru/42154/problem?id=2109007/2022_10_30/qBcsAH1OyR)\n\n{% cut \"Условие\" %}\n\nПеред вами программа, которая считает сумму первых $n$ натуральных чисел по формуле суммы арифметической прогрессии:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int n;\n    std::cin \u003e\u003e n;\n    std::cout \u003c\u003c n * (n + 1) / 2 \u003c\u003c \"\\n\";\n}\n```\n\nПрограмма должна работать для всех $n \\le 4000000000$, но оказывается, что для некоторых $n$ она работает неправильно. Найдите причину проблемы и исправьте программу.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nНикакой ошибки в формуле нет. Всё дело в используемом типе данных. При $n = 46341$ происходит переполнение типа `int32_t`, а при `n = 3037000500` происходит переполнение типа `int64_t`. При выборе беззнакового типа `uint64_t` переполнения на $n = 4000000000$ не случится. Поэтому просто заменим тип данных на `uint64_t`.\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003ciostream\u003e\n\nint main() {\n    std::uint64_t n = 0;\n    std::cin \u003e\u003e n;\n    std::cout \u003c\u003c n * (n + 1) / 2 \u003c\u003c \"\\n\";\n}\n```\n\nМожно было бы сначала выяснить, является ли `n` чётным, чтобы сначала произвести деление, а потом умножить:\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003ciostream\u003e\n\nint main() {\n    std::uint64_t number = 0;\n    std::cin \u003e\u003e number;\n\n    if (number % 2 == 0) {\n        std::cout \u003c\u003c (number / 2) * (number + 1);\n    } else {\n        std::cout \u003c\u003c ((number + 1) / 2) * number;\n    }\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\nТогда лимиты выросли бы ещё больше. Но в решении этого не потребовалось.\n\n{% endcut %}\n\n---\n\n## Параграф «Ветвления и циклы»\n\n### [Задача «Ход ферзя»](https://new.contest.yandex.ru/42155/problem?id=40119/2022_10_30/k3YWR8AJdQ)\n\n{% cut \"Условие\" %}\n\nШахматный ферзь ходит на любое количество клеток по диагонали, горизонтали или вертикали. Даны две различные клетки на шахматной доске без фигур. Определите, может ли ферзь попасть с первой клетки на вторую одним ходом.\n\n#### Формат ввода\n\nПрограмма получает на вход четыре целых числа от 1 до 8. Первая пара чисел задаёт номер столбца и номер строки для первой клетки. Вторая пара чисел аналогично задаёт вторую клетку.\n\n#### Формат вывода\n\nПрограмма должна вывести `YES`, если из первой клетки ходом ферзя можно попасть во вторую, или `NO` в противном случае.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\u003cbr/\u003e1\u003cbr/\u003e2\u003cbr/\u003e2\n\n|\n\nYES\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\u003cbr/\u003e1\u003cbr/\u003e2\u003cbr/\u003e3\n\n|\n\nNO\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5\u003cbr/\u003e6\u003cbr/\u003e3\u003cbr/\u003e3\n\n|\n\nNO\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nФерзь может ходить по вертикали, горизонтали и диагонали. Для того чтобы проверить, является ли ход вертикальным или горизонтальным, достаточно сравнить координаты $x_1$ $x_2$ или $y_1$ $y_2$. Для проверки является ли ход диагональным достаточно сравнить модуль разности координат $|x1 - x2| и |y1 - y2|$. Если ни одно из условий не выполняется — ход не может быть совершён ферзём. Для нахождения модуля удобно использовать стандартную функцию `std::abs`.\n\n```cpp\n#include \u003ccmath\u003e\n#include \u003ciostream\u003e\n\nint main() {\n    int x1, y1, x2, y2;\n    std::cin \u003e\u003e x1 \u003e\u003e y1;\n    std::cin \u003e\u003e x2 \u003e\u003e y2;\n\n    if (x1 == x2 || y1 == y2 || std::abs(x1 - x2) == std::abs(y1 - y2)) {\n        std::cout \u003c\u003c \"YES\\n\";\n    } else {\n        std::cout \u003c\u003c \"NO\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Прямоугольный треугольник»](https://new.contest.yandex.ru/42155/problem?id=2109007/2022_10_30/szNyt7s1s2)\n\n{% cut \"Условие\" %}\n\nНапишите программу, которая проверяет является ли треугольник прямоугольным.\n\n#### Формат ввода\n\nНа стандартный поток ввода подаётся три целых положительных числа — стороны треугольника. Числа не превосходят 30000.\n\n#### Формат вывода\n\nЕсли полученный треугольник является прямоугольным, напечатайте `YES`. Если треугольник не является прямоугольным, напечатайте `NO`. Если с заданными сторонами невозможно построить треугольник, напечатайте `UNDEFINED`.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr/\u003e4\u003cbr/\u003e5\n\n|\n\nYES\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr/\u003e4\u003cbr/\u003e10\n\n|\n\nUNDEFINED\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВо-первых, нам необходимо проверить существует ли такой треугольник. Для этого достаточно воспользоваться неравенством треугольника: $a + b \u003e c, a + c \u003e b, c + b \u003e a$. Если хотя бы одно из этих условий не выполняется, программа должна выводить `UNDEFINED`.\n\nДалее необходимо проверить является ли треугольник прямоугольным. Есть несколько способов это сделать. Самый простой — воспользоваться теоремой Пифагора. Если одно из равенств $a^2 + b^2 = c^2, a^2 + c^2 = b^2, b^2 + c^2 = a^2$ выполняется, программа должна вывести `YES`. В противном случае надо вывести `NO`.\n\nПо условию задачи стороны треугольника не превосходят $2^{15}$, а значит выражение $a^2 + b^2$ не будет превосходить $2^{30} + 2^{30} = 2^{31}$ и поместится в тип `int`.\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int a, b, c;\n    std::cin \u003e\u003e a \u003e\u003e b \u003e\u003e c;\n\n    if (a + b \u003c= c || a + c \u003c= b || b + c \u003c= a) {\n        std::cout \u003c\u003c \"UNDEFINED\\n\";\n    } else if (a * a + b * b == c * c || a * a + c * c == b * b || b * b + c * c == a * a) {\n        std::cout \u003c\u003c \"YES\\n\";\n    } else {\n        std::cout \u003c\u003c \"NO\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Високосный год»](https://new.contest.yandex.ru/42155/problem?id=2109007/2022_10_30/ZKdJeXjzAA)\n\n{% cut \"Условие\" %}\n\nОпределите, является ли год високосным по [григорианскому календарю](https://en.wikipedia.org/wiki/Gregorian_calendar).\n\nНапоминание:\n\n* год, номер которого кратен 400, — високосный;\n* остальные годы, номер которых кратен 100, — невисокосные (например, годы 1700, 1800, 1900, 2100, 2200, 2300);\n* остальные годы, номер которых кратен 4, — високосные.\n* все остальные годы — невисокосные.\n\n#### Формат ввода\n\nВводится целое положительное четырёхзначное число — номер года.\n\n#### Формат вывода\n\nПрограмма выводит `YES` если год високосный и `NO` в противном случае.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2003\n\n|\n\nNO\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2004\n\n|\n\nYES\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3000\n\n|\n\nNO\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nГрамотно перепишем определения из условия через `if`/`else` и проверку остатка от деления:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int year;\n    std::cin \u003e\u003e year;\n\n    if (year % 400 == 0) {\n        std::cout \u003c\u003c \"YES\\n\";\n    } else if (year % 100 == 0) {\n        std::cout \u003c\u003c \"NO\\n\";\n    } else if (year % 4 == 0) {\n        std::cout \u003c\u003c \"YES\\n\";\n    } else {\n        std::cout \u003c\u003c \"NO\\n\";\n    }\n}\n```\n\nЗаметим, что в получившимся коде дублируются ветви условий. Попробуем его упростить. Для этого достаточно заметить, что високосным является любой год, который делится на 400 или делится на 4, но не делится на 100. После этого упрощения получим следующий код:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int year;\n    std::cin \u003e\u003e year;\n\n    if ((year % 400 == 0 || year % 100 != 0) \u0026\u0026 year % 4 == 0) {\n        std::cout \u003c\u003c \"YES\\n\";\n    } else {\n        std::cout \u003c\u003c \"NO\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Количество дней в месяце»](https://new.contest.yandex.ru/42155/problem?id=2109007/2022_10_30/wmsyWBMEcT)\n\n{% cut \"Условие\" %}\n\nНапишите программу, выводящую количество дней в месяце по заданному номеру месяца и году.\n\n#### Формат ввода\n\nНа вход программе подается два целых положительных числа: номер месяца (от 1 до 12) и четырёхзначный год.\n\n#### Формат вывода\n\nНеобходимо вывести одно число — количество дней в заданном месяце.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\u003cbr/\u003e2001\n\n|\n\n31\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n6\u003cbr/\u003e3000\n\n|\n\n30\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\u003cbr/\u003e2012\n\n|\n\n29\n\n||\n|#\n\n#### Примечание\n\nРекомендуется сначала решить задачу «Високосный год» и использовать её решение для вывода количества дней в феврале.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nЭту задачу можно решать либо через `if`/`else`, либо через `switch`/`case`. Мы воспользуемся вторым вариантом, потому что в таком случае удобно описывать ветви, у которых много разных возможных условий.\n\nПеречислим все возможные месяцы, для которых ответ будет `31`: это январь (1), март (3), май (5), июль (7), август (8), октябрь (10), декабрь (12). Для февраля (2) ответ будет зависеть от года. Воспользуемся кодом из задачи «Високосный год», заменив вывод с `YES`/`NO` на `29`/`28`. Для остальных месяцев воспользуемся инструкцией `default` и выведем `30`.\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int month, year;\n    std::cin \u003e\u003e month \u003e\u003e year;\n\n    switch (month) {\n        case 1:\n        case 3:\n        case 5:\n        case 7:\n        case 8:\n        case 10:\n        case 12:\n            std::cout \u003c\u003c \"31\\n\";\n            break;\n        case 2:\n            if ((year % 400 == 0 || year % 100 != 0) \u0026\u0026 year % 4 == 0) {\n                std::cout \u003c\u003c \"29\\n\";\n            } else {\n                std::cout \u003c\u003c \"28\\n\";\n            }\n            break;\n        default:\n            std::cout \u003c\u003c \"30\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Печать календаря»](https://new.contest.yandex.ru/42155/problem?id=2109007/2022_10_30/cIe068GbKM)\n\n{% cut \"Условие\" %}\n\nНапечатайте месяц из календаря по заданному начальному дню и количеству дней. Ваш ответ должен выглядеть примерно так:\n\n```\n                   1\n 2  3  4  5  6  7  8\n 9 10 11 12 13 14 15\n16 17 18 19 20 21 22\n23 24 25 26 27 28 29\n30 31\n```\n\n#### Формат ввода\n\nВводится два числа: `n` — номер дня недели первого числа месяца (целое число от 1 до 7) и `k` — количество дней в этом месяце (целое число от 1 до 99). $n \\leq k$. Обратите внимание, что число дней в месяце не обязательно должно быть таким же, как в привычном календаре.\n\n#### Формат вывода\n\nНеобходимо напечатать календарь как в примере. Пустые позиции в первой строке заполняйте пробелами. Соседние числа также разделяйте пробелами. Под одно число всегда выделяется два символа. В конце строчек до перевода строки пробелов быть не должно. Вывод должен завершаться ровно одним подряд идущим переводом строки.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДля начала выведем отступ перед первым днём. Номер одного дня записывается в два символа, все дни разделены пробелом. Соответственно, необходимо вывести `n - 1` раз строку из трёх пробелов.\n\nДалее введём счётчик `dayOfWeek` и выставим ему начальное значение, равное `n`. Будем использовать его для отсчета текущего столбца. Воспользуемся циклом `for` от 1 до `k` включительно. Будем выводить текущее число и прибавлять к счётчику 1. Каждый раз, когда счётчик достигает семи, сбрасываем его в единицу и печатаем символ переноса строки `\\n`. Также нужно не забыть, что числа от 1 до 9 занимают всего один символ в нашем календаре. Чтобы это исправить добавим дополнительный `if`, который ставит пробел перед числом.\n\nВ самом конце проверим, в какой день недели закончился месяц. Если он закончился не в воскресенье, то необходимо допечатать перевод строки.\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int n, k;\n    std::cin \u003e\u003e n \u003e\u003e k;\n\n    int dayOfWeek = n;\n\n    for (int i = 1; i \u003c n; ++i) {\n        std::cout \u003c\u003c \"   \";\n    }\n\n    for (int day = 1; day \u003c= k; ++day) {\n        if (day \u003c 10) {\n            std::cout \u003c\u003c \" \";\n        }\n\n        std::cout \u003c\u003c day;\n\n        if (dayOfWeek == 7) {\n            std::cout \u003c\u003c \"\\n\";\n            dayOfWeek = 1;\n        } else {\n            std::cout \u003c\u003c \" \";\n            dayOfWeek += 1;\n        }\n    }\n\n    if (dayOfWeek != 1) {\n        std::cout \u003c\u003c \"\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Сумма цифр»](https://new.contest.yandex.ru/42155/problem?id=40119/2022_10_30/edRMniLUpb)\n\n{% cut \"Условие\" %}\n\nВычислите сумму цифр неотрицательного целого числа.\n\n#### Формат ввода\n\nНа вход подаётся одно неотрицательное целое число, не превосходящее $10^9$.\n\n#### Формат вывода\n\nВыведите сумму цифр этого числа.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n59\n\n|\n\n14\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nПо условию задачи число помещается в тип `int`. Поэтому можно написать цикл, который будет прибавлять к ответу последнюю цифру этого числа (остаток при делении на 10) и делить число на 10 без учёта остатка.\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int x;\n    std::cin \u003e\u003e x;\n\n    int s = 0;\n    while (x != 0) {\n        s += x % 10;\n        x /= 10;\n    }\n\n    std::cout \u003c\u003c s \u003c\u003c \"\\n\";\n}\n```\n\nЕсть более общее решение, которое подойдёт для чисел любого размера, не обязательно влезающих в `int`. Можно считать цифры числа в строку и обработать их посимвольно. Правда, для очень больших строк уже сама сумма цифр может не поместиться в `int`.\n\nЧтобы превратить очередной символ в цифру, воспользуемся тем, что символы цифр в таблице ASCII идут подряд. Поэтому разность кодов символов `c - '0'` будет как раз давать числовое представление очередной цифры.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string digits;\n    std::cin \u003e\u003e digits;\n\n    int s = 0;\n    for (char digit : digits) {\n        s += digit - '0';\n    }\n\n    std::cout \u003c\u003c s \u003c\u003c \"\\n\";\n}\n```\n\n{% endcut %}\n\n### [Задача «ln 2»](https://new.contest.yandex.ru/42155/problem?id=40119/2022_10_30/M8utWQIm0e)\n\n{% cut \"Условие\" %}\n\nЗначение натурального логарифма $\\ln{2}$ [представляется](https://en.wikipedia.org/wiki/Natural_logarithm_of_2) в виде суммы $1 - \\dfrac{1}{2} + \\dfrac{1}{3} - \\dfrac{1}{4} + ... + \\dfrac{(-1)^{n + 1}}{n}$ с точностью до $O(n)$. Напишите программу, выводящую сумму первых $n$ членов этого ряда. Попробуйте также обойтись без использования инструкции `if`.\n\nУказание: используйте тип `double` для работы с числами с плавающей точкой. Используйте стандартную точность вывода.\n\n#### Формат ввода\n\nВводится целое положительное число $n$, помещающееся в тип `int`.\n\n#### Формат вывода\n\nПрограмма выводит ответ на задачу.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\n\n|\n\n0\\.833333\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\n\n|\n\n0\\.5\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\n\n|\n\n1\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nОбъявим две переменные `sign` и `result`. В `result` будем складывать итоговое значение, а в `sign` будем хранить 1 или -1. Знак переменной `sign` будет каждый раз меняться.\n\nВажно привести один из аргументов дроби `sign / i` к типу `double`, чтобы не получилось целочисленного деления.Проще всего это сделать, выбрав для переменной `sign` тип `double`.\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int n;\n    std::cin \u003e\u003e n;\n\n    double sign = 1;\n    double result = 0.0;\n\n    for (int i = 1; i \u003c= n; ++i) {\n        result += sign / i;\n        sign = -sign;\n    }\n    std::cout \u003c\u003c result \u003c\u003c \"\\n\";\n}\n```\n\n{% endcut %}\n\n---\n\n## Параграф «Векторы и строки»\n\n### [Задача «Пароли»](https://new.contest.yandex.ru/42156/problem?id=40119/2022_10_30/bPwYbKLsp1)\n\n{% cut \"Условие\" %}\n\nПароль от некоторого сервиса должен удовлетворять таким ограничениям:\n\n* состоять из символов таблицы ASCII с кодами от 33 до 126;\n* быть не короче 8 символов и не длиннее 14;\n* из 4 классов символов — большие буквы, маленькие буквы, цифры, прочие символы — в пароле должны присутствовать не менее трёх любых.\n\nНапишите программу, которая проверит, что введённый пароль подходит под эти ограничения.\n\n#### Формат ввода\n\nНа входе дана одна строка с паролем.\n\n#### Формат вывода\n\nВыведите `YES`, если пароль удовлетворяет требованиям, и `NO` в противном случае.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nVasya123\n\n|\n\nYES\n\n||\n|#\n\n#### Примечания\n\nВы можете воспользоваться функциями из заголовочного файла [`cctype`](http://en.cppreference.com/w/cpp/header/cctype) или реализовать самостоятельно их аналоги.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nРешение можно целиком записать внутри функции `main`, но нам будет удобнее оформить проверку пароля в виде отдельной функции `IsGood`, которая возвращает логическое значение. Из такой функции всегда можно удобно выйти с помощью `return`, если ответ уже известен.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nbool IsGood(const std::string\u0026 password) {\n    if (password.size() \u003c 8 || password.size() \u003e 14) {\n        return false;\n    }\n    int upper = 0;\n    int lower = 0;\n    int digit = 0;\n    int other = 0;\n\n    for (char c : password) {\n        if (c \u003c 33 || c \u003e 126) {\n            return false;\n        }\n        if ('A' \u003c= c \u0026\u0026 c \u003c= 'Z') {\n            upper = 1;\n        } else if ('a' \u003c= c \u0026\u0026 c \u003c= 'z') {\n            lower = 1;\n        } else if ('0' \u003c= c \u0026\u0026 c \u003c= '9') {\n            digit = 1;\n        } else {\n            other = 1;\n        }\n    }\n\n    return upper + lower + digit + other \u003e= 3;\n}\n\nint main() {\n    std::string password;\n    std::getline(std::cin, password);\n    if (IsGood(password)) {\n        std::cout \u003c\u003c \"YES\\n\";\n    } else {\n        std::cout \u003c\u003c \"NO\\n\";\n    }\n}\n```\n\nЗдесь мы используем явные сравнения с другими символами вида `'0' \u003c= c \u0026\u0026 c \u003c= '9'`. Можно было бы использовать функции [`std::isupper`](https://en.cppreference.com/w/cpp/string/byte/isupper), [`std::islower`](https://en.cppreference.com/w/cpp/string/byte/islower) и [`std::isdigit`](https://en.cppreference.com/w/cpp/string/byte/isdigit) из заголовочного файла [`cctype`](https://en.cppreference.com/w/cpp/header/cctype).\n\n{% endcut %}\n\n### [Задача «Soundex»](https://new.contest.yandex.ru/42156/problem?id=40119/2022_10_30/ElxQrPqrV4)\n\n{% cut \"Условие\" %}\n\nИзвестный алгоритм Soundex определяет, похожи ли два английских слова по звучанию. На вход он принимает слово и заменяет его на некоторый четырёхсимвольный код. Если коды двух слов совпадают, то слова, как правило, звучат похоже.\n\nВам требуется реализовать этот алгоритм. Он работает так:\n\n1. Первая буква слова сохраняется.\n2. В остальной части слова буквы `a`, `e`, `h`, `i`, `o`, `u`, `w` и `y` удаляются;\n3. Оставшиеся буквы заменяются на цифры от 1 до 6, причём похожим по звучанию буквам соответствуют одинаковые цифры:\n\n* `b`, `f`, `p`, `v`: **1**\n* `c`, `g`, `j`, `k`, `q`, `s`, `x`, `z`: **2**\n* `d`, `t`: **3**\n* `l`: **4**\n* `m`, `n`: **5**\n* `r`: **6**\n\n4. Любая последовательность идущих подряд одинаковых цифр сокращается до одной такой цифры.\n5. Итоговая строка обрезается до первых четырёх символов.\n6. Если длина строки получилась меньше четырёх символов, в конце добавляются нули.\n\nПримеры:\n\n`аmmonium` → `ammnm` → `a5555` → `a5` → `a500`.\n\n`implementation` → `implmnttn` → `i51455335` → `i514535` → `i514`.\n\n#### Формат ввода\n\nНа вход подаётся одно непустое слово из строчных латинских букв. Длина слова не превосходит 20 символов.\n\n#### Формат вывода\n\nНапечатайте четырёхбуквенный код, соответствующий слову.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nammonium\n\n|\n\na500\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nimplementation\n\n|\n\ni514\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nХотя задачу можно решить и без функций, нам будет удобно оформить её решение в виде отдельной функции `Soundex`. Шаги 3 и 4 можно оформить в виде оператора `switch`.\n\nНапишем также вспомогательную функцию `Append`, добавляющую символ к ответу в случае, если он не дублируется. В эту функцию удобно передать параметр `res` по ссылке, чтобы его можно было изменять.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nvoid Append(std::string\u0026 res, char c) {\n    if (res.back() != c) {\n        res.push_back(c);\n    }\n}\n\nstd::string Soundex(const std::string\u0026 word) {\n    std::string res;\n    res.push_back(word[0]);\n    for (size_t i = 1; i != word.size(); ++i) {\n        char c = word[i];\n        switch (c) {\n            case 'b':\n            case 'f':\n            case 'p':\n            case 'v':\n                Append(res, '1');\n                break;\n            case 'c':\n            case 'g':\n            case 'j':\n            case 'k':\n            case 'q':\n            case 's':\n            case 'x':\n            case 'z':\n                Append(res, '2');\n                break;\n            case 'd':\n            case 't':\n                Append(res, '3');\n                break;\n            case 'l':\n                Append(res, '4');\n                break;\n            case 'm':\n            case 'n':\n                Append(res, '5');\n                break;\n            case 'r':\n                Append(res, '6');\n                break;\n        }\n    }\n    while (res.size() \u003c 4) {\n        res.push_back('0');\n    }\n    res.resize(4);\n    return res;\n}\n\nint main() {\n    std::string word;\n    std::cin \u003e\u003e word;\n    std::cout \u003c\u003c Soundex(word) \u003c\u003c \"\\n\";\n}\n```\n\n{% endcut %}\n\n### [Задача «Обратная перестановка»](https://new.contest.yandex.ru/42156/problem?id=40119/2022_10_30/W8nWj6EZ1J)\n\n{% cut \"Условие\" %}\n\nНа мероприятие приглашены $n$ гостей. Им предлагают занять места с номерами от 1 до $n$ в зале. Гости занимают эти места в произвольном порядке. Известно, на каком месте сел очередной гость.\n\nВыпишите для каждого очередного места номер гостя, который на него сел.\n\n#### Формат ввода\n\nДано число $n$, а затем $n$ различных чисел $a_1, a_2, ..., a_n$ от 1 до $n$. Число $a_k$ — это номер места, на которое сел $k$-й гость.\n\nЧисло $n$ не превосходит 20000.\n\n#### Формат вывода\n\nВыведите $n$ чисел $b_1, b_2, ..., b_n$ от 1 до $n$. Число $b_k$ должно обозначать номер гостя, который сел на $k$-е место.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n4\u003cbr\u003e3 1 2 4\n\n|\n\n2 3 1 4\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n11\u003cbr\u003e11 6 8 2 10 9 4 7 3 1 5\n\n|\n\n10 4 9 7 11 2 8 3 6 5 1\n\n||\n|#\n\n#### Примечания\n\nЕсли говорить математическим языком, то вам дана [перестановка](https://en.wikipedia.org/wiki/Permutation) и для неё требуется вычислить обратную перестановку.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nБудем заполнять вектор `seats`, в котором для каждого номера места будет указан номер гостя. Не забудьте: элементы вектора индексируются с нуля, а номера мест и гостей в задаче начинаются с единицы.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    int n;\n    std::cin \u003e\u003e n;\n\n    std::vector\u003cint\u003e seats(n);\n    for (int guest = 1; guest \u003c= n; ++guest) {\n        int seat;\n        std::cin \u003e\u003e seat;\n        seats[seat - 1] = guest;\n    }\n\n    for (int guest : seats) {\n        std::cout \u003c\u003c guest \u003c\u003c \" \";\n    }\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\n{% endcut %}\n\n### [Задача «Сортировка по убыванию»](https://new.contest.yandex.ru/42156/problem?id=10033/2022_10_30/q6mp7RT5b6)\n\n{% cut \"Условие\" %}\n\nВам даны строки текстового файла. Отсортируйте набор этих строк по убыванию.\n\n#### Формат ввода\n\nКоличество строк не превосходит 1000. Каждая строка состоит из символов ASCII с кодами от 32 до 126, длина строки не превосходит 100.\n\n#### Формат вывода\n\nНапечатайте строки в отсортированном по убыванию порядке. Для сравнения строк друг с другом достаточно использовать стандартные операторы сравнения, определённые для `std::string`.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\none\u003cbr\u003etwo\u003cbr\u003ethree\n\n|\n\ntwo\u003cbr\u003ethree\u003cbr\u003eone\n\n||\n|#\n\n#### Примечания\n\nКомпилятор не поддерживает `std::ranges`.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nСтроки необходимо прочитать и сложить в вектор, а затем отсортировать и вывести. По умолчанию они будут сортироваться по возрастанию. Есть несколько способов сделать сортировку и вывод в нужном порядке:\n\n1. строки можно напечатать в обратном порядке;\n2. можно передать в `std::sort` обратные итераторы;\n3. можно передать в `std::sort` свою функцию сравнения;\n4. можно передать в `std::sort` уже готовый компаратор `std::greater\u003cstd::string\u003e()`.\n\nВоспользуемся, например, вторым способом:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cstd::string\u003e lines;\n\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        lines.push_back(line);\n    }\n\n    std::sort(lines.rbegin(), lines.rend());\n\n    for (size_t i = 0; i != lines.size(); ++i) {\n        std::cout \u003c\u003c lines[i] \u003c\u003c \"\\n\";\n    }\n}\n```\n\nТипичная ошибка в решении этой задачи — считывать строки через `std::cin \u003e\u003e line` вместо `std::getline`. Такой код прочитает строку не целиком, а до ближайшего пробельного разделителя.\n\n{% endcut %}\n\n### [Задача «Палиндромы»](https://new.contest.yandex.ru/42156/problem?id=40119/2022_10_30/SPhWiKLbHE)\n\n{% cut \"Условие\" %}\n\nДана строка из строчных латинских букв и пробелов. Проверьте, является ли она [палиндромом](https://en.wikipedia.org/wiki/Palindrome) без учета пробелов.\n\n#### Формат ввода\n\nНа вход подается одна строка. В строке могут быть пробелы. Подряд может идти произвольное число пробелов. Длина строки не превосходит 100.\n\n#### Формат вывода\n\nПредставьте, что из строки удалили все пробелы. Необходимо вывести `YES`, если полученная строка — палиндром, и `NO` в противном случае.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nhello world\n\n|\n\nNO\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nnever odd or even\n\n|\n\nYES\n\n||\n|#\n\n#### Примечание\n\nПустая строка считается палиндромом.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nБудем поддерживать два индекса `i` и `j`, которые будут идти с разных сторон строки навстречу друг другу. Будем повторять цикл до тех пор, пока первый индекс меньше второго. В цикле будем игнорировать пробелы. Если будет найдено несоответствие символов, цикл можно досрочно закончить.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::string s;\n    std::getline(std::cin, s);\n\n    int i = 0;\n    int j = static_cast\u003cint\u003e(s.size()) - 1;\n    bool isPalindrome = true;\n\n     while (i \u003c j) {\n        if (s[i] == ' ') {\n            ++i;\n        } else if (s[j] == ' ') {\n            --j;\n        } else if (s[i] != s[j]) {\n            isPalindrome = false;\n            break;\n        } else {\n            ++i;\n            --j;\n        }\n    }\n\n    if (isPalindrome) {\n        std::cout \u003c\u003c \"YES\\n\";\n    } else {\n        std::cout \u003c\u003c \"NO\\n\";\n    }\n}\n```\n\nВот изящное решение этой задачи для тех, кто прочитал [параграф про алгоритмы стандартной библиотеки](https://education.yandex.ru/handbook/cpp/article/algorithms):\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string s;\n    std::getline(std::cin, s);\n\n    std::erase(s, ' ');  // С++20\n\n    // В С++17 пришлось бы написать\n    // s.erase(std::remove(s.begin(), s.end(), ' '), s.end());\n\n    if (std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin())) {\n        std::cout \u003c\u003c \"YES\\n\";\n    } else {\n        std::cout \u003c\u003c \"NO\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Сапёр»](https://new.contest.yandex.ru/42156/problem?id=40119/2022_10_30/DO3GU4vSHD)\n\n{% cut \"Условие\" %}\n\nВам необходимо построить поле для игры [«Сапёр»](https://en.wikipedia.org/wiki/Minesweeper_(video_game)) по его конфигурации — высоте, ширине и координатам расставленных на нем мин.\n\nВкратце напомним правила построения поля для игры «Сапёр»:\n\n* поле состоит из клеток с минами и пустых клеток;\n* клетки с миной обозначаются символом `*`;\n* пустые клетки содержат число от 0 до 8 — количество мин на соседних клетках.\n\n#### Формат ввода\n\nВ первой строке содержатся три числа:\n\n* число $m$ от 1 до 100 — количество строк на поле;\n* число $n$ от 1 до 100 — количество столбцов на поле;\n* число $k$ от 0 до $mn$ — количество мин на поле.\n\nВ следующих $k$ строках содержатся пары чисел с координатами мин (номерами строки и столбца). Нумерация ведётся с единицы.\n\n#### Формат вывода\n\nВыведите построенное поле, разделяя строки поля символом `\\n`, а столбцы — пробелом.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3 2 2\u003cbr\u003e1 1\u003cbr\u003e2 2\n\n|\n\n`* 2`\u003cbr\u003e`2 *`\u003cbr\u003e`1 1`\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nЗаведём двумерный вектор и будем записывать в него мины и количество мин в соседних клетках. Мины будет удобно обозначать минус единицей.\n\nБудем по очереди добавлять мины на игровое поле и для каждой мины сразу обновлять числа в соседних клетках.\n\nЧтобы не выписывать восемь однотипных проверок на соседние клетки, удобно будет создать вектор «сдвигов» и перебирать эти сдвиги в цикле.\n\nМожно также добавить к нашему игровому полю дополнительные клетки по краям, чтобы не делать проверки на корректность при обращении к соседней клетке. Поэтому размер поля в нашей программе на 2 больше указанного.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nstruct Shift {\n    int x = 0;\n    int y = 0;\n};\n\nconst std::vector\u003cShift\u003e SHIFTS = {\n    {-1, -1},\n    {-1,  0},\n    {-1,  1},\n    { 0,  1},\n    { 1,  1},\n    { 1,  0},\n    { 1, -1},\n    { 0, -1},\n};\n\nint main() {\n    size_t rows;\n    size_t columns;\n    size_t mines;\n    std::cin \u003e\u003e rows \u003e\u003e columns \u003e\u003e mines;\n\n    const int mineLabel = -1;\n\n    std::vector\u003cstd::vector\u003cint\u003e\u003e field(rows + 2, std::vector\u003cint\u003e(columns + 2));\n\n    for (size_t index = 0; index != mines; ++index) {\n        int row, column;\n        std::cin \u003e\u003e row \u003e\u003e column;\n\n        field[row][column] = mineLabel;\n\n        for (auto shift : SHIFTS) {\n            auto\u0026 cell = field[row + shift.x][column + shift.y];\n            if (cell != mineLabel) {\n                ++cell;\n            }\n        }\n    }\n\n    for (size_t row = 1; row \u003c= rows; ++row) {\n        for (size_t column = 1; column \u003c= columns; ++column) {\n            if (column \u003e 1) {\n                std::cout \u003c\u003c \" \";\n            }\n            if (field[row][column] == mineLabel) {\n                std::cout \u003c\u003c \"*\";\n            } else {\n                std::cout \u003c\u003c field[row][column];\n            }\n        }\n        std::cout \u003c\u003c \"\\n\";\n    }\n}\n```\n\nОбратите внимание на инициализацию ссылки `cell`. Мы специально объявили `cell` как ссылку, чтобы по этому краткому имени можно было изменить значение.\n\n{% endcut %}\n\n---\n\n## Параграф «Функции»\n\n### [Задача «ArgMax в матрице»](https://new.contest.yandex.ru/42071/problem?id=175943/2022_10_29/wyruyxgW1X)\n\n{% cut \"Условие\" %}\n\nВам требуется написать на C\\+\\+ функцию со следующим заголовком:\n\n```cpp\nstd::pair\u003csize_t, size_t\u003e MatrixArgMax(const std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 matrix);\n```\n\nФункция должна вернуть пару из индексов максимального элемента в матрице. Если максимальных элементов несколько, то нужно вернуть наименьшую такую пару.\n\n#### Примечания\n\nСчитайте, что матрица задана корректно: все строки одинаковой длины, пустых строк нет. В матрице всегда есть хотя бы один элемент.\n\nПодключите необходимые заголовочные файлы и напишите только код функции `MatrixArgMax`. Мы скомпилируем решение с нашей функцией `main`.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nСохраним в переменной `argMax` позицию начального элемента матрицы, а в переменной `max` — значение этого элемента. Обойдём все элементы матрицы с помощью вложенного цикла. Если обнаружим новый максиммум, то обновим эти переменные.\n\n```cpp\n#include \u003cutility\u003e\n#include \u003cvector\u003e\n\nstd::pair\u003csize_t, size_t\u003e MatrixArgMax(const std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 matrix) {\n    std::pair\u003csize_t, size_t\u003e argMax = {0, 0};\n    int max = matrix[0][0];\n    for (size_t i = 0; i != matrix.size(); ++i) {\n        for (size_t j = 0; j != matrix[i].size(); ++j) {\n            if (matrix[i][j] \u003e max) {\n                max = matrix[i][j];\n                argMax = {i, j};\n            }\n        }\n    }\n    return argMax;\n}\n```\n\n{% endcut %}\n\n### [Задача «Общий префикс»](https://new.contest.yandex.ru/42071/problem?id=10033/2022_10_29/x4MIcHV5eg)\n\n{% cut \"Условие\" %}\n\nНапишите функцию для вычисления наибольшего общего префикса строк, переданных в векторе `words`:\n\n```cpp\nstd::string CommonPrefix(const std::vector\u003cstd::string\u003e\u0026 words);\n```\n\nНапример, для пустого вектора функция должна вернуть пустую строку, а для вектора из строк `\"apple\"`, `\"apricot\"` и `\"application\"` — строку `\"ap\"`.\n\n#### Примечание\n\nВ решении не должно быть функции `main`: она будет в нашей тестирующей программе. Подключите необходимые библиотеки и напишите код функции `CommonPrefix`.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДавайте напишем вспомогательную функцию для вычисления общего префикса *двух* строк. Для этого будем идти по символам строк и проверять, равны ли они. Важно не выйти за пределы строки.\n\n```cpp\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nstd::string CommonPrefix(const std::string\u0026 a, const std::string\u0026 b) {\n    size_t i = 0;\n    while (i != a.size() \u0026\u0026 i != b.size() \u0026\u0026 a[i] == b[i]) {\n        ++i;\n    }\n    return a.substr(0, i);\n}\n```\n\nТеперь можно просто перебрать поданные на вход строки и вычислять на каждом шаге общий префикс у текущей строки и старого префикса:\n\n```cpp\nstd::string CommonPrefix(const std::vector\u003cstd::string\u003e\u0026 words) {\n    if (words.empty()) {\n        return {};\n    }\n    std::string prefix = words[0];\n    for (size_t i = 1; i != words.size() \u0026\u0026 !prefix.empty(); ++i) {\n        prefix = CommonPrefix(prefix, words[i]);\n    }\n    return prefix;\n}\n```\n\nЗдесь мы вызываем в цикле первую функцию `CommonPrefix`. Компилятор понимает какую из функций надо вызвать по типам аргументов (здесь передаётся не вектор строк, а две строки).\n\nНедостаток этого решения в том, что мы много раз создаём новые строки (префиксы), хотя на самом деле все они являются подстроками первой строки. Поэтому давайте перепишем первую функцию, чтобы она использовала `std::string_view` — конструкцию, о которой мы поговорим в [параграфе «Адаптеры и представления»](https://education.yandex.ru/handbook/cpp/article/adapters-and-views). Во второй функции объявим `prefix` с явным типом `std::string_view`, а в конце вернём `std::string(prefix)`: преобразование из `string_view` обратно в `string` надо описывать явно.\n\n```cpp\n#include \u003cstring\u003e\n#include \u003cstring_view\u003e\n#include \u003cvector\u003e\n\nstd::string_view CommonPrefix(const std::string_view a, const std::string_view b) {\n    size_t i = 0;\n    while (i != a.size() \u0026\u0026 i != b.size() \u0026\u0026 a[i] == b[i]) {\n        ++i;\n    }\n    return a.substr(0, i);\n}\n\nstd::string CommonPrefix(const std::vector\u003cstd::string\u003e\u0026 words) {\n    if (words.empty()) {\n        return {};\n    }\n    std::string_view prefix = words[0];\n    for (size_t i = 1; i != words.size() \u0026\u0026 !prefix.empty(); ++i) {\n        prefix = CommonPrefix(prefix, words[i]);\n    }\n    return std::string(prefix);\n}\n```\n\nРассмотрим альтернативное решение с синхронным проходом. Будем одновременно идти по всем словам. Для этого удобно сначала вычислить их минимальную длину, чтобы было проще проверять, когда пора остановиться.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nstd::string CommonPrefix(const std::vector\u003cstd::string\u003e\u0026 words) {\n    if (words.empty()) {\n        return {};\n    }\n\n    size_t minLen = words[0].size();\n    for (const auto\u0026 word : words) {\n        minLen = std::min(minLen, word.size());\n    }\n\n    for (size_t i = 0; i \u003c minLen; ++i) {\n        const char c = words[0][i];\n        for (const auto\u0026 word : words) {\n            if (word[i] != c) {\n                return word.substr(0, i);\n            }\n        }\n    }\n\n    return words[0].substr(0, minLen);\n}\n```\n\n{% endcut %}\n\n### [Задача «Функция Split»](https://new.contest.yandex.ru/42071/problem?id=10033/2022_10_29/VbASdGbvPn)\n\n{% cut \"Условие\" %}\n\nВам требуется написать функцию со следующим заголовком:\n\n```cpp\nstd::vector\u003cstd::string\u003e Split(const std::string\u0026 str, char delimiter);\n```\n\nФункция должна вернуть вектор строк, полученный разбиением строки `str` на части по указанному символу-разделителю `delimiter`. Если разделитель встретился в начале или в конце строки `str`, то в начале (соответственно, в конце) вектора с результатом должна быть пустая строка. Если два разделителя встретились рядом, то пустая строка между ними тоже должна попасть в ответ. Для пустой строки надо вернуть вектор, содержащий одну пустую строку.\n\nНапример, `Split(\"What_is_your_name?\", '_')` должна вернуть вектор из строк `What`, `is`, `your` и`name?`.\n\n#### Примечание\n\nПодключите необходимые заголовочные файлы и напишите только код функции `Split`. Мы скомпилируем решение с нашей функцией `main`.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nЗаметим, что количество элементов в ответе должно оказаться на единицу больше количества символов-разделителей в строке.\n\nБудем поддерживать два индекса: начало и конец очередного фрагмента строки. Будем сдвигать конец вправо. Если нам встретится разделитель, добавим этот фрагмент к ответу и переназначим начало будущего фрагмента на следующий индекс.\n\nВ конце надо будет отдельно добавить к ответу последний фрагмент.\n\n```cpp\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nstd::vector\u003cstd::string\u003e Split(const std::string\u0026 str, char delimiter) {\n    std::vector\u003cstd::string\u003e result;\n    size_t i = 0;\n    for (size_t j = 0; j != str.size(); ++j) {\n        if (str[j] == delimiter) {\n            result.push_back(str.substr(i, j - i));\n            i = j + 1;\n        }\n    }\n    result.push_back(str.substr(i));\n    return result;\n}\n```\n\nЗаметим, что если исходная строка будет существовать после вызова функции, то может оказаться эффективнее разбивать строку на `std::string_view` (мы поговорим об этой конструкции в [параграфе «Адаптеры и представления»](https://education.yandex.ru/handbook/cpp/article/adapters-and-views)).\n\n```cpp\n#include \u003cstring\u003e\n#include \u003cstring_view\u003e\n#include \u003cvector\u003e\n\nstd::vector\u003cstd::string_view\u003e Split(const std::string\u0026 s, char delimiter) {\n    std::string_view str = s;\n    std::vector\u003cstd::string_view\u003e result;\n    size_t i = 0;\n    for (size_t j = 0; j != str.size(); ++j) {\n        if (str[j] == delimiter) {\n            result.push_back(str.substr(i, j - i));\n            i = j + 1;\n        }\n    }\n    result.push_back(str.substr(i));\n    return result;\n}\n```\n\n{% endcut %}\n\n### [Задача «Функция Join»](https://new.contest.yandex.ru/42071/problem?id=10033/2022_10_29/7s4ZyIwYbB)\n\n{% cut \"Условие\" %}\n\nВам требуется написать функцию `Join` со следующим заголовком:\n\n```cpp\nstd::string Join(const std::vector\u003cstd::string\u003e\u0026 tokens, char delimiter);\n```\n\nФункция должна вернуть строку, полученную склейкой элементов вектора через указанный разделитель. Например, `Join({\"What\", \"is\", \"your\", \"name?\"}, '_')` должна вернуть строку `\"What_is_your_name?\"`.\n\n#### Примечание\n\nЕсли вектор `tokens` пустой, то функция должна вернуть пустую строку. Если в векторе `tokens` ровно один элемент, то он и должен вернуться в ответе.\n\nПодключите необходимые заголовочные файлы и напишите только код функции `Join`. Мы скомпилируем решение с нашей функцией `main`.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nБудем идти по вектору и добавлять в ответ разделитель и очередной токен. Важно, чтобы разделители не оказались по краям — они должны быть только между токенами.\n\n```cpp\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nstd::string Join(std::vector\u003cstd::string\u003e\u0026 tokens, char delim) {\n    std::string result;\n    for (size_t i = 0; i != tokens.size(); ++i) {\n        if (i \u003e 0) {\n            result += delim;\n        }\n        result += tokens[i];\n    }\n    return result;\n}\n```\n\n{% endcut %}\n\n### [Задача «Транспонировать матрицу»](https://new.contest.yandex.ru/42071/problem?id=40119/2022_10_29/pfYck43HSF)\n\n{% cut \"Условие\" %}\n\nДана прямоугольная матрица $A$ из $m$ строк и $n$ столбцов. Транспонированной матрицей $A^T$ называется матрица из $n$ строк и $m$ столбцов, в которой строки и столбцы поменялись ролями: элемент $A^T_{ij}$ равен элементу $A_{ji}$.\n\nНапишите функцию, которая возвращает транспонированную матрицу:\n\n```cpp\nstd::vector\u003cstd::vector\u003cint\u003e\u003e Transpose(const std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 matrix);\n```\n\n#### Примечание\n\nГарантируется, что вектор `matrix` непуст и все его элементы имеют равную ненулевую длину.\n\nПодключите необходимые заголовочные файлы и напишите только код функции `Transpose`. Мы скомпилируем решение с нашей функцией `main`.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\n```cpp\n#include \u003cvector\u003e\n\nstd::vector\u003cstd::vector\u003cint\u003e\u003e Transpose(const std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 matrix) {\n    const size_t m = matrix.size();\n    const size_t n = matrix[0].size();\n\n    std::vector\u003cstd::vector\u003cint\u003e\u003e result(n);\n    for (size_t j = 0; j != n; ++j) {\n        result[j].resize(m);\n        for (size_t i = 0; i != m; ++i) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n    return result;\n}\n```\n\n{% endcut %}\n\n### [Задача «Сортировка точек»](https://new.contest.yandex.ru/42071/problem?id=40119/2022_10_29/SHJhqzp0rA)\n\n{% cut \"Условие\" %}\n\nВам даны координаты точек на плоскости. Выведите эти точки в порядке возрастания расстояний до начала координат.\n\n#### Формат ввода\n\nСначала задано количество точек $n$. Затем идет последовательность из $n$ строк, каждая из которых содержит два целых числа — координаты точки. Величина $n$ не превосходит 100. Координаты точек по модулю не превосходят 1000.\n\n#### Формат вывода\n\nВыведите через пробел кординаты точек в порядке возрастания расстояний до начала координат. После каждой пары координат печатайте перевод строки.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\u003cbr\u003e2 3\u003cbr\u003e1 2\n\n|\n\n1 2\u003cbr\u003e2 3\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nСоздадим структуру `Point` для хранения точки. Заполним вектор этих структур. Напишем лямбда-функцию для сравнения двух точек. Заметим, что вычислять квадратный корень не обязательно: достаточно сравнить целочисленную сумму квадратов.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    size_t n;\n    std::cin \u003e\u003e n;\n\n    std::vector\u003cPoint\u003e points(n);\n\n    for (size_t i = 0; i != n; ++i) {\n        std::cin \u003e\u003e points[i].x \u003e\u003e points[i].y;\n    }\n\n    std::sort(\n        points.begin(),\n        points.end(),\n        [](const Point\u0026 p1, const Point\u0026 p2) {\n            return p1.x * p1.x + p1.y * p1.y \u003c p2.x * p2.x + p2.y * p2.y;\n        }\n    );\n\n    for (const auto\u0026 point : points) {\n        std::cout \u003c\u003c point.x \u003c\u003c \" \" \u003c\u003c point.y \u003c\u003c \"\\n\";\n    }\n}\n```\n\nНедостаток этого решения в том, что для каждого сравнения пары точек приходится вычислять сумму квадратов заново. Можно было бы предрассчитать расстояния от каждой точки до начала координат отдельно и отсортировать уже по готовым значениям.\n\n{% endcut %}\n\n---"])</script><script nonce="">self.__next_f.push([1,"64:T483b,"])</script><script nonce="">self.__next_f.push([1,"Стандартная библиотека C++ содержит набор [шаблонных контейнеров](https://en.cppreference.com/w/cpp/container). С некоторыми из них мы уже знакомы: это `std::vector` и `std::string`. Эти два контейнера гарантируют, что элементы (в случае `string` — символы строки) будут храниться в непрерывном фрагменте памяти. Эти контейнеры умеют эффективно добавлять элементы в конец, делая реаллокацию при необходимости, но не могут обеспечить эффективную вставку или удаление элементов в других позициях.\n\nВ этом параграфе мы рассмотрим другие последовательные контейнеры. Они не обязательно хранят элементы в непрерывном куске памяти, но позволяют обойти элементы в последовательном порядке.\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://yastatic.net/s3/education-portal/media/C_8_12936ea861_e8ab57f0b8.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\"\u003e\n  \u003cfigcaption\u003e\n    Стрелки показывают направления, в которых контейнер может эффективно расти.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\nКак правило, контейнеры определены в одноимённом заголовочном файле стандартной библиотеки.\n\n## Контейнер `std::array`\n\nЕсли вам нужен массив фиксированного, известного в момент компиляции размера, то используйте [`std::array`](https://en.cppreference.com/w/cpp/container/array). Вот так можно объявить `array` из трёх элементов:\n\n```cpp\n#include \u003carray\u003e\n\nint main() {\n    std::array\u003cint, 3\u003e point = {1, 2, -3};\n}\n```\n\nВнутри `array\u003cT, N\u003e` является обёрткой над [низкоуровневым массивом](https://en.cppreference.com/w/cpp/language/array) `T[N]`, но предоставляет интерфейс стандартного контейнера: знает свой размер, умеет присваиваться, предоставляет итераторы и т. д. Как и у вектора, элементы `array` располагаются в памяти непрерывно, но хранятся не в динамической памяти, а на стеке (мы разберём подробности в [параграфе «Жизненный цикл объекта»](https://education.yandex.ru/handbook/cpp/article/object-lifetime)).\n\nВажно подчеркнуть, что размер `array` должен быть задан в момент компиляции и не может изменяться во время работы программы.\n\n\n## Контейнер `std::deque`\n\n[Deque](https://en.wikipedia.org/wiki/Double-ended_queue) расшифровывается как double-ended queue (двусторонняя очередь).\n\nЕсли вектор располагает элементы в памяти непрерывно, то [`std::deque`](https://en.cppreference.com/w/cpp/container/deque) располагает их кусочно-непрерывно, в отдельных *страницах* (непрерывных блоках) памяти фиксированного размера. Но даже для хранения одного элемента в деке будет выделена целая страница. Сами страницы не обязательно расположены в памяти подряд. Отдельно поддерживается перечень указателей на начала страниц. Размеры страниц зависят от `sizeof(T)` и от конкретной реализации дека. Например, для `std::deque\u003cint\u003e` они могут занимать 4 килобайта.\n\n![C_9_f116fec83a.svg](https://yastatic.net/s3/education-portal/media/C_9_f116fec83a_58d61c5bac.svg)\n\nДек умеет эффективно добавлять и удалять элементы в начале и в конце: это приводит к выделению новой страницы при необходимости. Вставка по краям в деке эффективнее, чем в векторе, так как реаллокаций нет и старые элементы никогда не приходится копировать. В отличие от вектора, дек гарантирует, что при вставке или удалении по краям элементы останутся в тех же самых ячейках памяти, что и были. Вставка в середину дека и удаление из неё уже требуют сдвига элементов.\n\nКак и вектор, дек поддерживает обращение к элементу по индексу за $O(1)$: так как размер страниц фиксирован и начальная позиция в первой странице известна, то можно легко вычислить нужную страницу и позицию в ней. Однако для обращения к элементу деку приходится делать два разыменования указателей, а вектору — только одно.\n\n```cpp\n#include \u003cdeque\u003e\n#include \u003ciostream\u003e\n\nint main() {\n    std::deque\u003cint\u003e d = {1, 2, 3, 4};\n\n    d.push_back(5);  // добавление в конец, как у вектора\n    d.push_back(6);\n    d.pop_back();  // удаление из конца, как у вектора\n\n    d.push_front(0);  // добавление в начало\n    d.push_front(-1);\n    d.pop_front();  // удаление из начала\n\n    // элементы дека: 0, 1, 2, 3, 4, 5\n\n    // обращение по индексам:\n    for (size_t i = 0; i != d.size(); ++i) {\n        std::cout \u003c\u003c d[i] \u003c\u003c \"\\n\";\n    }\n\n    // range-based for:\n    for (int x : d) {\n        std::cout \u003c\u003c x \u003c\u003c \"\\n\";\n    }\n}\n```\n\n\n## Контейнер `std::list`\n\nДвусвязный список [`std::list`](https://en.cppreference.com/w/cpp/container/list) хранит элементы в отдельных узлах. Узлы могут располагаться в разных местах памяти, никакого требования непрерывности нет. В узле рядом с самим элементом хранится указатель на предыдущий и следующий узлы. Можно представить себе отдельный узел двусвязного списка для элементов типа `T` примерно так:\n\n```cpp\ntemplate \u003ctypename T\u003e\nstruct Node {\n    T value;\n    Node* prev;\n    Node* next;\n};\n```\n\nСам список хранит указатели на начальный и конечный узлы. К узлу нельзя эффективно обратиться по номеру (для этого пришлось бы идти в цикле по списку начиная от головы). Поэтому пройтись по списку можно только с помощью range-based for или итераторов:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n\nint main() {\n    std::list\u003cint\u003e l = {10, 15, 20};\n    l.push_front(5);\n    l.push_front(0);\n\n    l.push_back(25);\n    l.push_back(30);\n\n    l.pop_front();\n    l.pop_back();\n\n    for (int x : l) {\n        std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // 5 10 15 20 25\n    }\n}\n```\n\n\n## Итераторы списка\n\n[Итераторы](https://en.wikipedia.org/wiki/Iterator) — это специальные объекты, предназначенные для навигации по контейнеру. Итераторы позволяют обращаться к текущему элементу контейнера и сдвигаться к соседним элементам. Итератор, указывающий на начальный элемент контейнера, возвращает функция `begin`.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n\nint main() {\n    std::list\u003cint\u003e l = {10, 15, 20};\n\n    // Используем auto, чтобы не писать громоздкий тип std::list\u003cint\u003e::iterator\n    auto iter = l.begin();\n    std::cout \u003c\u003c *iter \u003c\u003c \"\\n\";  // печатаем начальный элемент\n    ++iter;  // сдвигаемся к следующему элементу\n    --iter;  // возвращаемся назад\n}\n```\n\nИтераторы в C++ создавались по подобию указателей: их можно разыменовывать (`*`) и сдвигать (`++` и `--`). Однако операторы `++` и `--` для обычных указателей сдвигаются на соседние ячейки памяти, а двусвязный список хранит свои элементы разрозненно. Поэтому указатели могут подойти на роль итераторов лишь для контейнеров с непрерывным хранением (`array`, `vector` и `string`).\n\nФункция `end` у контейнера возвращает особый итератор, который указывает *за* последний элемент контейнера. Этот итератор нельзя разыменовывать. С ним можно только сравниваться:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n\nint main() {\n    std::list\u003cint\u003e l = {10, 15, 20};\n    for (auto iter = l.begin(); iter != l.end(); ++iter) {\n        std::cout \u003c\u003c *iter \u003c\u003c \"\\n\";  // печатаем элементы списка через итератор\n    }\n\n    for (auto iter = l.rbegin(); iter != l.rend(); ++iter) {\n        std::cout \u003c\u003c *iter \u003c\u003c \"\\n\";  // проход по списку в обратном порядке\n    }\n}\n```\n\nС помощью итераторов можно вставлять ([`insert`](https://en.cppreference.com/w/cpp/container/list/insert)) или удалять ([`erase`](https://en.cppreference.com/w/cpp/container/list/erase)) элементы или целые цепочки элементов в любом месте списка:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n\nint main() {\n    std::list\u003cint\u003e l = {0, 10, 15, 20};\n\n    auto iter = l.begin();\n    ++iter;\n    l.insert(iter, 5);  // вставляем на эту позицию элемент\n\n    // Удаляем из списка чётные числа\n    for (auto iter = l.begin(); iter != l.end(); ) {\n        if (*iter % 2 == 0) {\n            iter = l.erase(iter);  // возвращается итератор на элемент, следующий за удалённым\n        } else {\n            ++iter;\n        }\n    }\n\n}\n```\n\nС итераторами стандартных контейнеров мы познакомимся подробнее в других параграфах. Заметим пока, что к итераторам списка (в отличие от итераторов вектора) нельзя прибавлять произвольные целые числа, чтобы сдвинуть их на несколько позиций вперёд: эта операция не может быть реализована эффективно за константное время. Стандартная функция [`std::advance`](https://en.cppreference.com/w/cpp/iterator/advance) из заголовочного файла `iterator` умеет делать это за константное время для итераторов контейнеров с индексацией и за линейное время для итераторов списка. А функции [`std::next`](https://en.cppreference.com/w/cpp/iterator/next) и [`std::prev`](https://en.cppreference.com/w/cpp/iterator/prev) возвращают следующее и предыдущее значения итератора соответственно.\n\n```cpp\n#include \u003citerator\u003e\n#include \u003clist\u003e\n\nint main() {\n    std::list\u003cint\u003e l = {0, 10, 15, 20};\n\n    // вместо этого удобнее воспользоваться функцией std::next:\n    // auto iter = l.begin();\n    // ++iter;\n\n    auto iter = std::next(l.begin());  // итератор указывает на второй элемент списка\n\n    std::advance(iter, 2);  // итератор указывает на последний элемент\n}\n```\n\n\n## Контейнер `std::forward_list`\n\nОдносвязный список [std::forward_list](https://en.cppreference.com/w/cpp/container/forward_list) нужен там, где требуется сэкономить память на хранении ссылок на предыдущий узел. По такому контейнеру можно пройтись только вперёд, а вставка разрешена только в начало (или после указанного итератора). Этот контейнер встречается в некоторых реализациях хеш-таблицы `unordered_map` для хранения элементов с одинаковыми хешами.\n\n```cpp\n#include \u003cforward_list\u003e\n#include \u003ciostream\u003e\n#include \u003citerator\u003e\n\nint main() {\n    std::forward_list\u003cint\u003e fl = {3, 42, 5};\n    fl.push_front(2);\n    // fl.push_back(10);  // ошибка компиляции!\n\n    auto iter = std::next(fl.begin());\n    iter = fl.erase_after(iter);\n    fl.insert_after(iter, 4);\n\n    for (int x : fl) {\n        std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // 2 3 5 4\n    }\n}\n```\n\nФункции [`insert_after`](https://en.cppreference.com/w/cpp/container/forward_list/insert_after) и [`erase_after`](https://en.cppreference.com/w/cpp/container/forward_list/erase_after) своими названиями подчёркивают своё отличие от `insert` и `erase` у других контейнеров, работающих с текущей позицией. В односвязном списке не получится вставить элемент на текущую позицию, как это делает `insert` в `std::list`, поскольку к предыдущему элементу невозможно обратиться, а его ссылку на следующий элемент надо поправить.\n\n**Упражнение**: сравните интерфейсы (набор функций) контейнеров `list` и `forward_list` и объясните различия.\n\n\n## Инвалидация итераторов и ссылок\n\nЕсли контейнер изменяется, то в некоторых случаях итераторы и ссылки (указатели) на элементы могут стать [невалидными](https://en.cppreference.com/w/cpp/container#Iterator_invalidation).\nРассмотрим пример:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e v = {1, 2, 3, 4};\n\n    auto iter = v.begin();  // итератор\n    int* ptr = \u0026v.front();  // указатель\n    int\u0026 ref = v.front();  // ссылка\n\n    std::cout \u003c\u003c *iter \u003c\u003c \" \" \u003c\u003c *ptr \u003c\u003c \" \" \u003c\u003c ref \u003c\u003c \"\\n\";  // 1 1 1\n\n    v.push_back(5);  // происходит реаллокация\n\n    // обращаться к старым итераторам, указателям и ссылкам больше нельзя:\n    std::cout \u003c\u003c *iter \u003c\u003c \" \" \u003c\u003c *ptr \u003c\u003c \" \" \u003c\u003c ref \u003c\u003c \"\\n\";  // неопределённое поведение!\n}\n```\n\nВ этом примере показано, что итераторы, указатели или ссылки могут оказаться невалидными, если у вектора произошла реаллокация. Рассмотрим, как ведут себя итераторы других последовательных контейнеров при добавлении элементов в конец. Указатели и ссылки тут либо вместе инвалидируются, либо вместе остаются валидными, так как они в конечном итоге смотрят на память, которую занимал элемент.\n\n1. Строка `std::string` ведёт себя так же, как и вектор: все итераторы и ссылки инвалидируются.\n2. В `std::array` ничего вставить нельзя, его размер фиксирован.\n3. В `std::deque` инвалидируются итераторы, но не инвалидируются ссылки и указатели! Сами элементы дека остаются в тех же местах памяти, но во внутреннем векторе страниц, про который должен знать итератор дека, вообще говоря, может произойти реаллокация.\n4. В `std::list` и `std::forward_list` ни итераторы, ни ссылки не инвалидируются. Так что если в приведённом примере заменить `vector` на `list`, то он будет корректно работать.\n\n\nВалидность итераторов и ссылок после вызова той или иной функции контейнера описывается в документации (вот [пример](https://en.cppreference.com/w/cpp/container/vector/push_back) для `push_back` у вектора). Также можно обратиться к [этой таблице](https://en.cppreference.com/w/cpp/container#Iterator_invalidation).\n"])</script><script nonce="">self.__next_f.push([1,"65:T7686,"])</script><script nonce="">self.__next_f.push([1,"[Ассоциативные контейнеры](https://en.wikipedia.org/wiki/Associative_array) сопоставляют *ключам* некоторые *значения*.\n\nВ стандартной библиотеке есть ассоциативные контейнеры, основанные на сбалансированных деревьях поиска (`map`, `set`) и контейнеры, основанные на хеш-таблицах (`unordered_map`, `unordered_set`). В этих контейнерах ключи уникальны, то есть, не могут повторяться. Также существуют и `multi`-версии этих контейнеров, в которых допускаются повторы ключей.\n\nТак как C++ — статически типизированный язык, типы ключей и значений должны быть строго зафиксированы на этапе компиляции.\n\n\n## Контейнер `std::map`\n\nНачнём с контейнера [`std::map`](https://en.cppreference.com/w/cpp/container/map). Он определен в заголовочном файле `map`. Аналогично вектору, `std::map` является шаблонным: в угловых скобках нужно указать типы ключей и значений.\n\nРассмотрим пример:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmap\u003e\n#include \u003cstring\u003e\n\nint main() {\n    // инициализируем map набором пар {ключ, значение}\n    std::map\u003cstd::string, int\u003e years = {\n        {\"Moscow\", 1147},\n        {\"Rome\", -753},\n        {\"London\", 47},\n    };\n\n    for (const auto\u0026 [city, year] : years) {\n        std::cout \u003c\u003c city \u003c\u003c \": \" \u003c\u003c year \u003c\u003c \"\\n\";\n    }\n}\n```\n\nВывод программы:\n\n\u003cpre\u003e\nLondon: 47\nMoscow: 1147\nRome: -753\n\u003c/pre\u003e\n\nПри итерации с помощью `ranged-based for` возвращаются пары `std::pair` из константного ключа и значения. Для итерации по элементам мы использовали [structured binding](https://en.cppreference.com/w/cpp/language/structured_binding), прикрепив ссылки `city` и `year` к элементам возвращаемой пары, а также `auto` для автоматического вывода типа. Согласитесь, это удобнее, чем такая форма записи:\n\n```cpp\nfor (const std::pair\u003cconst std::string, int\u003e\u0026 item : years) {\n    std::cout \u003c\u003c item.first \u003c\u003c \": \" \u003c\u003c item.second \u003c\u003c \"\\n\";\n}\n```\n\nКонтейнер `map` реализован как [красно-чёрное дерево](https://en.wikipedia.org/wiki/Red–black_tree) — сбалансированное дерево поиска с особыми свойствами. Поэтому его элементы при итерации обходятся в порядке возрастания ключей, а на самих ключах должен быть определён оператор `\u003c` для сравнения.\n\n![C_10_a36059fc04.svg](https://yastatic.net/s3/education-portal/media/C_10_a36059fc04_c9a3aa95da.svg)\n\nВнутренне устройство красно-чёрных деревьев мы оставим за рамками этого учебника: для нас важнее научиться пользоваться таким контейнером и знать, что три основных операции — поиск, вставка и удаление элемента — выполняются за *логарифмическое время* ($O(\\log n)$) от числа элементов в контейнере. Покажем, как воспользоваться этими операциями.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmap\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::map\u003cstd::string, int\u003e data;\n    std::string key;\n    int value;\n\n    while (std::cin \u003e\u003e key \u003e\u003e value) {\n        data[key] = value;  // вставка\n    }\n\n    data.erase(\"hello\");  // удаление\n\n    // поиск\n    if (auto iter = data.find(\"test\"); iter != data.end()) {\n        std::cout \u003c\u003c \"Found the key \" \u003c\u003c iter-\u003efirst \u003c\u003c \" with the value \" \u003c\u003c iter-\u003esecond \u003c\u003c \"\\n\";\n    } else {\n        std::cout \u003c\u003c \"Not found\\n\";\n    }\n}\n```\n\nРассмотрим эту программу подробнее.\n\nДля вставки мы использовали обращение по ключу в квадратных скобках: `data[key] = value`. В отличие от вектора или дека, ключ теперь не обязательно является индексом: в нашем случае это строка. Альтернативные способы вставки — [`data.insert({key, value})`](https://en.cppreference.com/w/cpp/container/map/insert) или [`data.insert_or_assign(key, value)`](https://en.cppreference.com/w/cpp/container/map/insert_or_assign).\n\nЭти функции принимают пару из ключа и значения, поэтому нам пришлось обрамить в фигурные скобки `key` и `value`, чтобы экземпляр `std::pair` сконструировался на лету. Если ключ `key` уже существует в контейнере, то `data[key] = value` и функция `insert_or_assign` его перезапишут, а `insert` — нет (но вернет информацию о старом значении).\n\nУдаляя элемент по ключу, можно не заботиться о его наличии в контейнере: если ключа нет, то функция [`erase`](https://en.cppreference.com/w/cpp/container/map/erase) просто ничего не поменяет.\n\nДля поиска элемента мы вызываем функцию [`find`](https://en.cppreference.com/w/cpp/container/map/find), которая возвращает итератор. Мы пользуемся [версией `if` с инициализатором](https://en.cppreference.com/w/cpp/language/if#If_Statements_with_Initializer), чтобы сразу сохранить этот итератор в переменную `iter` и потом проверить его значение. Такая переменная будет видна только внутри условного оператора: таким образом мы подчеркнём, что `iter` нам нужен только здесь. Итератор будет либо указывать на пару из найденного ключа и его значения, либо окажется равен значению `data.end()`, если ключ не найден. Обратиться к найденной паре можно через унарную звёздочку или стрелочку (`iter-\u003efirst` означает `(*iter).first`). Это похоже на указатели, но важно понимать, что итератор ассоциативного контейнера — это не указатель, а самостоятельный объект.\n\nВернёмся ещё раз к конструкции `data[key]`. Она возвращает ссылку на значение, которому можно что-то присвоить. Сначала она проверяет, есть ли уже такой ключ в контейнере. Если ключа нет, он тут же вставляется в контейнер со значением по умолчанию (0 для `int`). Затем возвращается ссылка на значение в контейнере.\n\nТакое поведение оператора `[]` требует, чтобы контейнер `data` был изменяемым. Поэтому выражение `data[key]` не скомпилируется, если `data` — константа:\n\n```cpp\nvoid Check(const std::map\u003cstd::string, int\u003e\u0026 data) {\n    if (data[\"total\"] \u003e 0) {  // ошибка компиляции!\n        // ...\n    }\n}\n```\n\nЕсли мы уверены, что ключ в контейнере есть, то можно воспользоваться функцией `at`:\n\n```cpp\nvoid Check(const std::map\u003cstd::string, int\u003e\u0026 data) {\n    if (data.at(\"total\") \u003e 0) {  // OK, это скомпилируется\n        // ...\n    }\n}\n```\n\nЕсли же ключа всё же не окажется, то `at` во время работы программы сгенерирует исключение — «цивилизованную» ошибку, которую можно перехватить и обработать. Исключения мы обсудим в [параграфе «Обработка исключений»](https://education.yandex.ru/handbook/cpp/article/exceptions).\n\n\n## Задача о подсчёте частот слов\n\nРассмотрим классическую задачу: построить частотный словарь из текстового файла. Возьмём для тестирования файл [`text8`](http://mattmahoney.net/dc/text8.zip) с сайта [mattmahoney.net](https://www.mattmahoney.net/dc/textdata.html). Это архив со словами статей из английской «Википедии» общим объёмом 100 мегабайт. Его часто используют для оценки эффективности алгоритмов сжатия и для машинного обучения систем обработки текстов.\n\nНапишем программу, которая подсчитывает количество повторов для каждого слова. Слова будем читать со стандартного ввода просто до ближайшего пробельного разделителя.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmap\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::map\u003cstd::string, int\u003e freqs;\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        ++freqs[word];\n    }\n    for (const auto\u0026 [word, freq] : freqs) {\n        std::cout \u003c\u003c word \u003c\u003c \"\\t\" \u003c\u003c freq \u003c\u003c \"\\n\";\n    }\n}\n```\n\nПосмотрите, как мы элегантно добавляем очередное слово в ассоциативный массив через `++freqs[word]`! Если слово уже встречалось, то мы просто увеличиваем его частоту. Если такого слова не было, то во `freqs` автоматически вставится такой ключ со значением 0, и мы тут же увеличим это значение на 1.\n\nЗапустим программу, передав ей на вход файл `text8`, и посмотрим на первые 10 строк её вывода:\n\n\u003cpre\u003e\n$ clang++ --std=c++20 -o count_freqs count_freqs.cpp\n$ ./count_freqs \u0026lt; text8 | head\na\t325873\naa\t276\naaa\t57\naaaa\t7\naaaaaacceglllnorst\t1\naaaaaaccegllnorrst\t1\naaaaaah\t1\naaaaaalmrsstt\t1\naaaaaannrstyy\t1\naaaaabbcdrr\t1\n\u003c/pre\u003e\n\nМы уже знаем, что итерация по контейнеру `map` обходит узлы в порядке возрастания ключей. Поэтому мы увидели первые «слова» по алфавиту. Позже мы попробуем сделать так, чтобы слова были отсортированы по убыванию частоты. А сейчас давайте попробуем замерить время работы нашей программы. Скомпилируем её с максимальным уровнем оптимизаций (ключ `-O3`) и направим её вывод в `/dev/null` (он нам не нужен). Замеряем время с помощью консольной утилиты [time](https://en.wikipedia.org/wiki/Time_(Unix)).\n\n\u003cpre\u003e\n$ clang++ --std=c++20 -O3 -o count_freqs count_freqs.cpp\n$ time ./count_freqs \u0026lt; text8 \u0026gt; /dev/null\nreal    0m5,541s\nuser    0m5,500s\nsys     0m0,040s\n\u003c/pre\u003e\n\nКонечно, реальное время работы зависит от процессора и других факторов. Но нельзя ли обработать файл быстрее, чем за пять с половиной секунд? В этом нам поможет контейнер `std::unordered_map`.\n\n\n## Контейнер `std::unordered_map`\n\nВоспользуемся другой реализацией ассоциативного массива из стандартной библиотеки C++ — хеш-таблицей [`unordered_map`](https://en.cppreference.com/w/cpp/container/unordered_map). Само название этого класса подчёркивает, что данные будут храниться не упорядоченными по ключу. Предполагается, что для каждого ключа определена хеш-функция (по умолчанию [`std::hash\u003cKey\u003e()`](https://en.cppreference.com/w/cpp/utility/hash)), а по ней вычисляется номер *корзины* (bucket), в которую должен попасть ключ.\n\nСлучай, когда два разных ключа оказываются в одной корзине, называется *коллизией*. В С++ для разрешения коллизий используется [*метод цепочек*](https://en.wikipedia.org/wiki/Hash_table#Collision_resolution), то есть, внутри одной корзины все элементы выстраиваются в односвязный список.\n\n![C_11_471cf1f1e4.svg](https://yastatic.net/s3/education-portal/media/C_11_471cf1f1e4_43e9c2699e.svg)\n\nЕсли хеш-функция достаточно равномерна и корзин достаточно много, то в среднем время поиска, добавления и удаления элементов для `unordered_map` будет *константным* ($O(1)$).\n\nИнтерфейс `unordered_map` специально сделан похожим на интерфейс `map`. Нам будет достаточно заменить только заголовочный файл и имя контейнера:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cunordered_map\u003e\n\nint main() {\n    std::unordered_map\u003cstd::string, int\u003e freqs;\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        ++freqs[word];\n    }\n    for (const auto\u0026 [word, freq] : freqs) {\n        std::cout \u003c\u003c word \u003c\u003c \"\\t\" \u003c\u003c freq \u003c\u003c \"\\n\";\n    }\n}\n```\n\nПорядок обхода теперь выглядит произвольным (но на самом деле он диктуется хеш-функцией):\n\n\u003cpre\u003e\n$ clang++ --std=c++20 -o count_freqs count_freqs.cpp\n$ ./count_freqs \u0026lt; text8 | head\nstorerooms\t2\nfretensis\t1\nmetzada\t1\nworkmans\t1\nmikhailgorbachev\t1\nnaevus\t3\nbuildups\t1\nclandenstine\t1\ndemocratised\t1\nwilgoren\t2\n\u003c/pre\u003e\n\nВремя работы сократилось с 5,5 до 3,1 секунды:\n\n\u003cpre\u003e\n$ clang++ --std=c++20 -O3 -o count_freqs count_freqs.cpp\n$ time ./count_freqs \u0026lt; text8 \u0026gt; /dev/null\nreal    0m3,117s\nuser    0m3,080s\nsys     0m0,036s\n\u003c/pre\u003e\n\nУ контейнера `unordered_map` есть функция [`max_load_factor`](https://en.cppreference.com/w/cpp/container/unordered_map/max_load_factor), которая задаёт максимально допустимое соотношение между числом элементов и количеством корзин. По умолчанию эта величина равна единице, так что `unordered_map` пытается *в среднем* вообще избежать коллизий. Но это не означает отсутствия коллизий в отдельных корзинах.\n\nЕсли при вставке очередного элемента среднее число элементов в корзинах превышает этот порог, число корзин автоматически увеличивается и происходит *рехеширование*. Чем-то это напоминает реаллокацию у вектора.\n\nЕсли нам заранее известно финальное количество ключей, то можно вызвать заранее функцию [`reserve`](https://en.cppreference.com/w/cpp/container/unordered_map/reserve) и избежать лишних рехеширований при вставках. Тем самым можно отыграть дополнительное время:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cunordered_map\u003e\n\nint main() {\n    std::unordered_map\u003cstd::string, int\u003e freqs;\n    freqs.reserve(300'000);  // можно использовать апостроф для выделения разрядов\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        ++freqs[word];\n    }\n    for (const auto\u0026 [word, freq] : freqs) {\n        std::cout \u003c\u003c word \u003c\u003c \"\\t\" \u003c\u003c freq \u003c\u003c \"\\n\";\n    }\n}\n```\n\n\u003cpre\u003e\n$ clang++ --std=c++20 -O3 -o count_freqs count_freqs.cpp\n$ time ./count_freqs \u0026lt; text8 \u0026gt; /dev/null\nreal   0m3,067s\nuser   0m3,035s\nsys    0m0,032s\n\u003c/pre\u003e\n\n\n## Из контейнера в контейнер\n\nВернёмся к сортировке слов по убыванию частоты. Для этого проще всего будет переложить слова с частотами в вектор пар и отсортировать его, используя свою функцию сравнения:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003ctuple\u003e\n#include \u003cunordered_map\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::unordered_map\u003cstd::string, int\u003e freqs;\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        ++freqs[word];\n    }\n\n    // копируем пары в вектор, используя шаблонный конструктор от двух итераторов:\n    std::vector\u003cstd::pair\u003cstd::string, int\u003e\u003e sortedByFreq(\n        freqs.begin(),\n        freqs.end()\n    );\n\n    // сортируем с помощью своей лямбда-функции:\n    std::sort(\n        sortedByFreq.begin(),\n        sortedByFreq.end(),\n        [](const auto\u0026 p1, const auto\u0026 p2) {\n            // сначала сравниваем частоты по убыванию, потом — слова по возрастанию\n            return std::tie(p2.second, p1.first) \u003c std::tie(p1.second, p2.first);\n        }\n    );\n\n    for (const auto\u0026 [word, freq] : sortedByFreq) {\n        std::cout \u003c\u003c word \u003c\u003c \"\\t\" \u003c\u003c freq \u003c\u003c \"\\n\";\n    }\n}\n```\n\nЗдесь мы элегантно копируем данные из `unordered_map` в вектор, указывая при инициализации переменной `sortedByFreq` пару итераторов другого контейнера. Цикл, копирующий элементы из этого диапазона, скрыт в конструкторе вектора.\n\nПосмотрим на первые 10 результатов с помощью консольной утилиты head. Теперь мы в самом деле получили наиболее частотные слова из файла:\n\n\u003cpre\u003e\n$ clang++ --std=c++20 -o count_freqs count_freqs.cpp\n$ ./count_freqs \u0026lt; text8 | head\nthe\t1061396\nof\t593677\nand\t416629\none\t411764\nin\t372201\na\t325873\nto\t316376\nzero\t264975\nnine\t250430\ntwo\t192644\n\u003c/pre\u003e\n\n\n## Контейнеры `std::set` и `std::unordered_set`\n\nКонтейнеры [`std::set`](https://en.cppreference.com/w/cpp/container/set) и [`std::unordered_set`](https://en.cppreference.com/w/cpp/container/unordered_set) похожи на `map` и `unordered_map` по внутреннему устройству, но они хранят только ключи, без ассоциированных значений. Вот как можно выписать повторяющиеся слова текста в алфавитном порядке (по одному разу каждое):\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cset\u003e\n#include \u003cstring\u003e\n#include \u003cunordered_set\u003e\n\nint main() {\n    // здесь будем хранить все слова (каждое по одному разу)\n    std::unordered_set\u003cstd::string\u003e words;\n\n    // здесь будем хранить повторяющиеся слова\n    // используем set, а не unordered_set, чтобы потом напечатать их по алфавиту\n    std::set\u003cstd::string\u003e duplicate_words;\n\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        if (words.contains(word)) {\n            duplicate_words.insert(word);\n        } else {\n            words.insert(word);\n        }\n    }\n\n    for (const auto\u0026 word : duplicate_words) {\n        std::cout \u003c\u003c word \u003c\u003c \"\\n\";\n    }\n}\n```\n\nЗдесь мы применили функцию `contains`, которая появилась только в C++20. При использовании более старого стандарта нужно написать `if (words.find(word) != words.end())`.\n\nЗаметим, что при попадании в `else` мы ищем слово в `words` дважды: один раз для проверки в `contains`, а другой раз — в `insert`. Можно было бы обойтись только одним поиском, воспользовавшись тем, что `insert` [возвращает пару](https://en.cppreference.com/w/cpp/container/set/insert) из итератора на элемент и флажка с результатом поиска:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cset\u003e\n#include \u003cstring\u003e\n#include \u003cunordered_set\u003e\n\nint main() {\n    std::unordered_set\u003cstd::string\u003e words;\n    std::set\u003cstd::string\u003e duplicate_words;\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        auto [iter, has_been_inserted] = words.insert(word);\n        if (!has_been_inserted) {\n            duplicate_words.insert(word);\n        }\n    }\n    for (const auto\u0026 word : duplicate_words) {\n        std::cout \u003c\u003c word \u003c\u003c \"\\n\";\n    }\n}\n```\n\nНазвание `set` происходит от математического понятия множества, где элементы хранятся только по одному разу. Однако никаких теоретико-множественных операций (объединения, пересечения, разности) у `set` и `unordered_set` не предусмотрено. В [параграфе «Алгоритмы»](https://education.yandex.ru/handbook/cpp/article/algorithms#teoretiko-mnozhestvennye-algoritmy) мы рассмотрим алгоритмы для выполнения таких операций над отсортированными последовательностями.\n\n\n## Мультиконтейнеры\n\nВ стандартной библиотеке C++ есть четыре мультиконтейнера:\n- [`std::multimap`](https://en.cppreference.com/w/cpp/container/multimap) (в заголовочном файле `map`);\n- [`std::multiset`](https://en.cppreference.com/w/cpp/container/multiset) (в заголовочном файле `set`);\n- [`std::unordered_multimap`](https://en.cppreference.com/w/cpp/container/unordered_multimap) (в заголовочном файле `unordered_map`);\n- [`std::unordered_multiset`](https://en.cppreference.com/w/cpp/container/unordered_multiset) (в заголовочном файле `unordered_set`).\n\nОни аналогичны обычным ассоциативным контейнерам, которые мы рассматривали выше, но в мультиконтейнерах один и тот же ключ может встретиться несколько раз.\n\nПусть, например, мы хотим сохранять для каждого слова в текстовом файле его порядковый номер. Слова в тексте могут повторяться, поэтому воспользуемся контейнером `multimap`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmap\u003e\n\nint main() {\n    std::multimap\u003cstd::string, int\u003e positions;\n\n    std::string word;\n    int position = 0;\n    while (std::cin \u003e\u003e word) {\n        positions.insert({word, position});\n        ++position;\n    }\n}\n```\n\nВ этом случае мы могли бы применить вместо `std::multimap\u003cstd::string, int\u003e` контейнер `std::map\u003cstd::string, std::vector\u003cint\u003e\u003e`. Разница будет в использовании и в накладных расходах.\n\nДля обхода `multimap` потребуется один цикл, а для `map` с вектором — два вложенных цикла (по ключам и по элементам вектора для данного ключа). Вектор имеет накладные расходы на хранение метаинформации и резерва, а в `multimap` все данные будут храниться в одном сбалансированном дереве.\n\nНаконец, итераторы `multimap` стабильны, а у вектора могут инвалидироваться. Применять `multimap` имеет смысл там, где повторы ключей сравнительно редки.\n\n\n## Итераторы ассоциативных контейнеров\n\nКонтейнеры `map`, `set` и их мультиверсии предоставляют двусторонние итераторы, которые можно сдвигать на соседние позиции вперёд и назад. Как и в случае последовательных контейнеров, запрещено выходить за пределы диапазона, ограниченного `begin()` и `end()`, и разыменовывать итератор, равный `end()`. Итераторы таких контейнеров и ссылки (указатели) на элементы никогда не инвалидируются.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003citerator\u003e\n#include \u003cmap\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::map\u003cint, std::string\u003e numbers = {\n        {100, \"hundred\"},\n        {3, \"three\"},\n        {42, \"forty two\"},\n        {11, \"eleven\"},\n    };\n\n    auto iter = numbers.find(11);\n\n    if (iter != numbers.end()) {\n        // печатаем найденный элемент\n        const auto\u0026 [key, value] = *iter;\n        std::cout \u003c\u003c \"Found: \" \u003c\u003c key \u003c\u003c \": \" \u003c\u003c value \u003c\u003c \"\\n\";  // Found: 11: eleven\n\n        // печатаем предыдущий элемент\n        if (iter != numbers.begin()) {\n            const auto\u0026 [key, value] = *std::prev(iter);\n            std::cout \u003c\u003c \"Previous: \" \u003c\u003c key \u003c\u003c \": \" \u003c\u003c value \u003c\u003c \"\\n\";  // Previous: 3: three\n        } else {\n            std::cout \u003c\u003c \"No previous element\\n\";\n        }\n\n        // печатаем следующий элемент\n        if (auto nextIter = std::next(iter); nextIter != numbers.end()) {\n            const auto\u0026 [key, value] = *nextIter;\n            std::cout \u003c\u003c \"Next: \" \u003c\u003c key \u003c\u003c \": \" \u003c\u003c value \u003c\u003c \"\\n\";  // Next: 42: forty two\n        } else {\n            std::cout \u003c\u003c \"No next element\\n\";\n        }\n    } else {\n        std::cout \u003c\u003c \"Not found\\n\";\n    }\n}\n```\n\nМожет показаться, что в строке `const auto\u0026 [key, value] = *std::prev(iter)` мы строим висячие ссылки, так как возвращаемое значение функции `prev` после вычисления всего выражения сразу станет невалидным. Однако константные ссылки продлевают жизнь объекта до конца текущего блока.\n\nИтераторы unordered-контейнеров однонаправленные: их можно сдвигать только вперёд. Это связано с тем, что коллизии в хеш-таблице обычно разрешаются с помощью односвязного списка элементов, а по односвязному списку нельзя двигаться назад. Итераторы unordered-контейнеров могут инвалидироваться только если произошло рехеширование при вставке. Ссылки и указатели никогда не инвалидируются.\n\nОтдельно отметим функцию `erase` у ассоциативных контейнеров. У неё есть несколько перегруженных версий. Одна версия принимает ключ, другая — итератор удаляемого элемента, третья — диапазон итераторов. Разница будет для мультиконтейнеров: если какой-то ключ повторяется, то первая версия `erase` удалит все вхождения таких ключей, а вторая — только конкретные:\n\n```cpp\n#include \u003cunordered_map\u003e\n\nint main() {\n    std::unordered_multimap\u003cstd::string, int\u003e data = {\n        {\"a\", 1},\n        {\"a\", 2},\n        {\"a\", 3},\n        {\"b\", 4},\n    };\n\n    auto iter = data.find(\"a\");\n    if (iter != data.end()) {\n        data.erase(iter);  // удаляем первое найденное вхождение с ключом \"a\"\n    }\n\n    data.erase(\"a\");  // удаляем все остальные вхождения с ключом \"a\"\n}\n```\n"])</script><script nonce="">self.__next_f.push([1,"66:T93d0,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе мы обсудим *алгоритмы стандартной библиотеки*. Они представляют из себя шаблонные функции для обработки последовательностей: подсчёта, поиска, сортировки и т. д. Такие функции, как правило, принимают на вход два итератора, которые ограничивают рассматриваемый диапазон.\n\nМы уже знакомы с одной из таких функций: это `std::sort`. В этом параграфе мы познакомимся с некоторыми другими важными примерами алгоритмов, а полный их перечень можно найти на [cppreference.com](https://en.cppreference.com/w/cpp/algorithm).\n\n\n## Пары итераторов\n\nВ функции стандартной библиотеки часто требуется передать два итератора, которые ограничивают диапазон элементов. К ним предъявляются такие требования:\n- это должны быть итераторы одного и того же контейнера;\n- от первого итератора ко второму можно перейти, применяя оператор `++`.\n\nПредполагается, что второй итератор при этом ссылается *за* последний элемент диапазона. Его нельзя разыменовывать оператором `*`, даже если он ссылается на валидный элемент.\n\nМожно рассматривать пару итераторов как математический полуинтервал, где левый конец включается в диапазон, а правый — нет.\n\nВсе контейнеры имеют функции `begin` и `end`. Они возвращают итераторы, указывающие на начальный и *за* последний элемент всей последовательности элементов контейнера.\n\n![C_12_fcbb311560.svg](https://yastatic.net/s3/education-portal/media/C_12_fcbb311560_0a54f1b304.svg)\n\nКонтейнеры, которые допускают обход в обратном порядке (все кроме `forward_list` и `unordered`-контейнеров), имеют также функции `rbegin` и `rend`. Они возвращают *обратные итераторы*. С их помощью можно проходить по элементам из конца в начало.\n\n![C_13_94b1b9742b.svg](https://yastatic.net/s3/education-portal/media/C_13_94b1b9742b_708d9a5ffa.svg)\n\nОднако можно строить и другие диапазоны. Например, вот так можно отсортировать по возрастанию «середину» вектора кроме первого и последнего элемента:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e data = {100, 42, 17, 80, 20, 0};\n    std::sort(data.begin() + 1, data.end() - 1);  // 100, 17, 20, 42, 80, 0\n}\n```\n\nВпрочем, так можно делать только если мы уверены, что в векторе есть хотя бы два элемента. В противном случае диапазон получится некорректным и поведение программы будет неопределённым.\n\n\nЗаметим, что с помощью итераторов реализован цикл range-based for. В самом деле, конструкция\n\n```cpp\nfor (const auto\u0026 element : container) {\n    // делаем что-то с element\n}\n```\n\nпросто превращается компилятором в примерно такой код:\n\n```cpp\nfor (auto iter = container.begin(); iter != container.end(); ++iter) {\n    const auto\u0026 element = *iter;\n    // делаем что-то с element\n}\n```\n\nВ C++20 для каждого алгоритма были добавлены так называемые [constrained-версии](https://en.cppreference.com/w/cpp/algorithm/ranges). Эти версии вместо пары итераторов принимают диапазон (range), оформленный в виде отдельного объекта. В частности, в роли такого объекта может выступать сам контейнер. Это позволяет вызывать сортировку, например, так:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e data = {100, 42, 17, 80, 20, 0};\n    std::ranges::sort(data);  // 0, 17, 20, 42, 80, 100\n}\n```\n\nМы пока ограничимся классическими версиями алгоритмов.\n\n\n## Подсчёт\n\nРассмотрим, пожалуй, самый простой пример — алгоритм [`std::count`](https://en.cppreference.com/w/cpp/algorithm/count). Эта функция подсчитывает, сколько элементов последовательности равны заданному. Конечно, такую задачу можно решить с помощью банального цикла:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e v = {2, 7, 1, 8, 2, 8};\n\n    // сколько в последовательности восьмёрок?\n    int counter = 0;\n    for (int elem : v) {\n        if (elem == 8) {\n            ++counter;\n        }\n    }\n    std::cout \u003c\u003c counter \u003c\u003c \"\\n\";  // 2\n}\n```\n\nОднако использование готового стандартного алгоритма всегда предпочтительнее:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e v = {2, 7, 1, 8, 2, 8};\n    std::cout \u003c\u003c std::count(v.begin(), v.end(), 8) \u003c\u003c \"\\n\";  // 2\n}\n```\n\nФункцию `std::count` можно применять к итераторам любого последовательного контейнера. Применим её, например, к списку:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n\nint main() {\n    std::list\u003cint\u003e v = {2, 7, 1, 8, 2, 8};\n    std::cout \u003c\u003c std::count(v.begin(), v.end(), 8) \u003c\u003c \"\\n\";\n}\n```\n\nТакие функции как `std::count` позволяют упростить код и сделать его более лаконичным и выразительным. Важно понимать, что это самые обыкновенные шаблонные функции, написанные на C++. Вы даже можете посмотреть их реализацию, если откроете заголовочный файл `algorithm`. Давайте попробуем в качестве упражнения написать такую функцию самостоятельно.\n\n```cpp\ntemplate \u003ctypename Iter, typename Value\u003e  // два шаблонных параметра: тип итератора и тип эталонного элемента\nint count(Iter first, Iter last, const Value\u0026 value) {\n    int counter = 0;\n    for (Iter iter = first; iter != last; ++iter) {\n        if (*iter == value) {\n            ++counter;\n        }\n    }\n    return counter;\n}\n```\n\nОбратите внимание, что параметры `first` и `last` передаются в функцию по значению. Это стандартное соглашение: считается, что итераторы — лёгкие элементы, которые можно дёшево копировать. А вот про тип `Value` мы заранее ничего не знаем, поэтому передаём параметр `value` по константной ссылке. Так как `first` передаётся по значению, то этот параметр можно менять внутри функции. Поэтому часто можно встретить такую реализацию:\n\n```cpp\ntemplate \u003ctypename Iter, typename Value\u003e\nint count(Iter first, Iter last, const Value\u0026 value) {\n    int counter = 0;\n    // Смело меняем first, это всё равно копия переданного аргумента:\n    while (first != last) {\n        if (*first == value) {\n            ++counter;\n        }\n        ++first;\n    }\n    return counter;\n}\n```\n\nНа самом деле тип возвращаемого значения этой функции не в точности `int`, а `typename iterator_traits\u003cIter\u003e::difference_type`, построенный по типу итератора.\n\n\n## Поиск\n\nАлгоритм [`std::find`](https://en.cppreference.com/w/cpp/algorithm/find) ищет последовательным перебором первое вхождение элемента, равного заданному. Результатом является итератор, который указывает на найденный элемент. Если же ничего не найдено, то возвращается правый конец переданного полуинтервала.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cdeque\u003e\n#include \u003ciostream\u003e\n\nint main() {\n    std::deque\u003cint\u003e d = {3, 14, 15, 92, 6};\n\n    // Такой элемент есть, мы его точно найдём\n    auto iter1 = std::find(d.begin(), d.end(), 15);\n    // Итераторы дека можно вычитать, напечатается индекс найденного элемента\n    std::cout \u003c\u003c (iter1 - d.begin()) \u003c\u003c \"\\n\";\n\n    auto start = d.begin();\n    // К итераторам дека и вектора можно прибавлять целые числа\n    auto end = start + 3;\n    // Полуинтервал [start; end) теперь ограничивает подпоследовательность 3, 14, 15\n\n    auto iter2 = std::find(start, end, 19);\n    if (iter2 == end) {\n        std::cout \u003c\u003c \"No such element!\\n\";\n    } else {\n        std::cout \u003c\u003c *iter2 \u003c\u003c \"\\n\";\n    }\n    // Напечатает No such element\n}\n```\n\nВот его возможная реализация:\n\n```cpp\ntemplate \u003ctypename Iter, typename Value\u003e\nIter find(Iter first, Iter last, const Value\u0026 value) {\n    while (first != last) {\n        if (*first == value) {\n            return first;\n        }\n        ++first;\n    }\n    return last;\n}\n```\n\nИмеется также алгоритм [`std::search`](https://en.cppreference.com/w/cpp/algorithm/search), который ищет не отдельный элемент, а подпоследовательность элементов.\n\n\n## Алгоритмы и встроенные функции\n\nУ [ассоциативных контейнеров](https://education.yandex.ru/handbook/cpp/article/associative-containers) есть встроенная функция `find`, которая возвращает похожий по смыслу итератор. Разберёмся, в чём различие между общим алгоритмом `find` и встроенной функцией. Алгоритм `std::find` написан в общем виде. Он работает только с итераторами и ничего не знает о физическом устройстве контейнера. Поэтому он ищет элемент последовательным перебором с линейной сложностью $O(n)$. Но в ассоциативных контейнерах можно найти элемент быстрее: за $O(\\log n)$ в `set` и `map` и в среднем за $O(1)$ в `unordered_set` и `unordered_map`.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cset\u003e\n\nint main() {\n    std::set\u003cint\u003e numbers = {2, 3, 5, 7, 11, 13, 17, 19};\n\n    // Предпочтительный способ:\n    auto iter1 = numbers.find(15);\n\n    // Допустимо, но неэффективно!\n    auto iter2 = std::find(numbers.begin(), numbers.end(), 15);\n}\n```\n\nТут мы встречаемся с общей идеей, заложенной в дизайн стандартной библиотеки C++: если некоторый алгоритм имеет более эффективную реализацию для конкретного контейнера, то он будет реализован у этого контейнера в виде встроенной функции. Наоборот, если возможна лишь общая реализация, то специальной встроенной функции не будет. Поэтому, например, у вектора и дека нет своей встроенной функции `find`.\n\nЗаметим, что найти элемент по ключу в контейнерах `map` и `unordered_map` с помощью алгоритма `std::find` вообще не получится. Дело в том, что итераторы таких контейнеров ссылаются на пару из константного ключа и значения, а не просто на ключ. А значение как правило нам заранее неизвестно: его как раз обычно и требуется получить по ключу.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cmap\u003e\n#include \u003cutility\u003e\n\nint main() {\n    std::map\u003cint, int\u003e m = {\n        {1, 30},\n        {2, 28},\n        {3, 31},\n        // ...\n    };\n\n    auto it1 = m.find(12);   // правильный способ поиска по ключу\n    auto it2 = std::find(m.begin(), m.end(), 12);  // не скомпилируется!\n\n    std::pair\u003cconst int, int\u003e value = {12, 31};\n    // Скомпилируется, но неэффективно и бессмысленно:\n    auto it3 = std::find(m.begin(), m.end(), value);\n}\n```\n\n\n## Алгоритмы, принимающие предикат\n\nВ алгоритмах `count` и `find` мы передавали третьим аргументом конкретное значение, которое требовалось найти в последовательности. Но иногда бывает нужно найти любое значение, удовлетворяющее некоторому условию. Такое условие можно оформить в виде функции, получающей на вход элемент последовательности и возвращающей логический ответ (`true`, если элемент подходит и `false`, если не подходит). Такие функции называют *предикатами*. Для работы с ними имеются алгоритмы, в названии которых добавляется суффикс `_if`.\n\nНапример, подсчитаем, сколько заглавных латинских букв в строке. Передадим в функцию `count_if` предикат, оформленный в виде лямбда-функции:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string s = \"iPhone SE\";\n\n    std::cout \u003c\u003c std::count_if(\n        s.begin(),\n        s.end(),\n        [](char c) {\n            return 'A' \u003c= c \u0026\u0026 c \u003c= 'Z';\n        }\n    ) \u003c\u003c \"\\n\";  // 3\n}\n```\n\n{% cut \"Подробности\" %}\n\nМожно было бы внутри лямбда-функции вместо двойного неравенства воспользоваться функцией [`std::isupper`](https://en.cppreference.com/w/cpp/string/byte/isupper). К сожалению, просто передать `std::isupper` в `std::count_if` не получится: компилятор не сможет без конкретных аргументов отличить эту функцию от [другой перегруженной версии](https://en.cppreference.com/w/cpp/locale/isupper).\n\n{% endcut %}\n\nНапишем для примера собственную реализацию алгоритма `find_if`. Тип предиката сделаем просто шаблонным параметром.\n\n```cpp\ntemplate \u003ctypename Iter, typename Predicate\u003e\nIter find_if(Iter first, Iter last, Predicate p) {\n    while (first != last) {\n        if (p(*first)) {  // применяем предикат\n            return first;\n        }\n        ++first;\n    }\n    return last;\n}\n```\n\nОтметим [семейство алгоритмов](https://en.cppreference.com/w/cpp/algorithm/all_any_none_of) `std::all_of`, `std::any_of` и `std::none_of`, также принимающих предикаты. Их смысл понятен из названия. Например, `any_of` проверяет, что какой-то элемент последовательности удовлетворяет предикату. Типичная реализация `any_of` сводится к вызову `find_if` и сравнению результата с итератором `last`.\n\n\n## Алгоритмы, модифицирующие последовательность\n\nРассмотрим алгоритм [`std::reverse`](https://en.cppreference.com/w/cpp/algorithm/reverse). Он переставляет элементы последовательности в обратном порядке:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string s = \"No lemon, no melon!\";\n    std::reverse(s.begin(), s.end());\n    std::cout \u003c\u003c s \u003c\u003c \"\\n\";  // !nolem on ,nomel oN\n}\n```\n\nЕго возможная реализация выглядит так:\n\n```cpp\ntemplate \u003ctypename Iter\u003e\nvoid reverse(Iter first, Iter last) {\n    while (first != last) {\n        --last;\n        if (first == last) {\n            break;\n        }\n        std::swap(*first, *last);\n        ++first;\n    }\n}\n```\n\nСложность тут в том, что `last` указывает за последний элемент, и этот итератор надо аккуратно подвинуть назад, прежде чем переставлять элементы. Здесь вызывается функция [`std::swap`](https://en.cppreference.com/w/cpp/algorithm/swap), реализацию которой мы уже писали в [параграфе «Функции»](https://education.yandex.ru/handbook/cpp/article/functions).\n\n\nВажно понимать, что алгоритмы работают с итераторами, и поэтому они ничего не знают о физическом способе хранения элементов в контейнерах. Алгоритмы знают лишь о логическом порядке перебора элементов. Поэтому алгоритмы не могут физически что-либо удалить из контейнера или добавить в него. Лучшее, что они могут сделать, — это переупорядочить элементы в последовательности.\n\nРассмотрим алгоритм [`std::unique`](https://en.cppreference.com/w/cpp/algorithm/unique). Этот алгоритм переставляет элементы так, чтобы в последовательности не было подряд идущих дубликатов. Уменьшить размер последовательности алгоритм не может. Поэтому в конце последовательности остаётся некоторый набор ненужных элементов. Их можно потом явно удалить, вызвав функцию `erase` у контейнера:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e v = {5, 5, 3, 2, 2, 5, 9, 1};\n    auto iter = std::unique(v.begin(), v.end());\n    // В векторе окажется 5, 3, 2, 5, 9, 1, 9, 1\n    //                                      ^ iter будет указывать сюда\n    v.erase(iter, v.end());  // удаляем хвост из ненужных элементов\n}\n```\n\nОбратите внимание, что третья пятёрка не удалилась, потому что она не расположена рядом с другими пятёрками. Обычно `std::unique` применяют вместе с `std::sort`, чтобы одинаковые элементы оказались рядом:\n\n```cpp\nstd::sort(v.begin(), v.end());\nv.erase(std::unique(v.begin(), v.end()), v.end());\n```\n\nСреди других алгоритмов, модифицирующих последовательность, имеются\n- [`std::fill`](https://en.cppreference.com/w/cpp/algorithm/fill) и [`std::generate`](https://en.cppreference.com/w/cpp/algorithm/generate) (заполнение заданными значениями),\n- [`std::rotate`](https://en.cppreference.com/w/cpp/algorithm/rotate) (циклический сдвиг),\n- [`std::replace`](https://en.cppreference.com/w/cpp/algorithm/replace) (замена элементов),\n- [`std::remove`](https://en.cppreference.com/w/cpp/algorithm/remove) (переупорядочивание элементов, чтобы указанный элемент не встречался в начале),\n- [`std::shuffle`](https://en.cppreference.com/w/cpp/algorithm/shuffle) (случайная перестановка элементов).\n\n\n## Запись в другую последовательность\n\nАлгоритм [`std::copy`](https://en.cppreference.com/w/cpp/algorithm/copy) копирует содержимое одной последовательности в другую последовательность. Он принимает три аргумента: обычную пару итераторов, задающих входной диапазон, и итератор, обозначающий начало выходного диапазона. Четвёртый аргумент не нужен: никаких проверок корректности всё равно не делается.\n\nВ этом примере мы копируем диапазон элементов в обратном порядке из вектора в список:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e v = {3, 14, 15, 92, 6};\n    std::list\u003cint\u003e l;\n    l.resize(v.size());  // теперь в списке l 5 нулей\n\n    std::copy(v.rbegin(), v.rend(), l.begin());\n\n    for (int x : l) {\n        std::cout \u003c\u003c x \u003c\u003c \" \";\n    }\n    std::cout \u003c\u003c \"\\n\";  // 6 92 15 14 3\n}\n```\n\nВ контейнере, в который мы копируем элементы, должно быть достаточно места, чтобы они поместились. Если бы мы не вызвали `resize` для списка `l`, то программа попала бы в неопределенное поведение!\n\n```cpp\nВот возможная реализация алгоритма copy:\ntemplate \u003ctypename InputIter, typename OutputIter\u003e\nOutputIter copy(InputIter first, InputIter last, OutputIter out) {\n    while (first != last) {\n        *out = *first;\n        ++first;\n        ++out;\n    }\n    return out;\n}\n```\n\nОбратите внимание, что шаблонные типы входных и выходных итераторов, вообще говоря, разные. Функция возвращает выходной итератор, указывающий *за* последний записанный элемент. Этот итератор позволяет потом физически удалить лишние элементы выходной последовательности, которые больше не нужны:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003clist\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e v = {3, 14, 15, 92, 6};\n    std::list\u003cint\u003e l(10);  // 10 нулей\n\n    auto iter = std::copy(v.begin(), v.end(), l.begin());\n    // 3 14 15 92 6 0 0 0 0 0, iter указывает на первый ноль\n\n    l.erase(iter, l.end());  // 3 14 15 92 6\n}\n```\n\nВ стандартной библиотеке для модифицирующих алгоритмов есть версии с суффиксом `_copy` в имени, которые ведут себя похожим образом. Вместо модификации исходной последовательности они записывают результат в отдельную выходную последовательность. В ней должно быть достаточно места, чтобы результат поместился. Вот пример использования функции [`std::replace_copy`](https://en.cppreference.com/w/cpp/algorithm/ranges/replace_copy):\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cstd::string\u003e words1 = {\"a\", \"cat\", \"and\", \"a\", \"dog\"};\n    std::vector\u003cstd::string\u003e words2(words1.size());  // 5 пустых строк\n\n    const std::string from = \"a\";\n    const std::string to = \"the\";\n    std::replace_copy(words1.begin(), words1.end(), words2.begin(), from, to);\n\n    for (const auto\u0026 word : words1) {\n        std::cout \u003c\u003c word \u003c\u003c \" \";  // a cat and a dog\n    }\n    std::cout \u003c\u003c \"\\n\";\n\n    for (const auto\u0026 word : words2) {\n        std::cout \u003c\u003c word \u003c\u003c \" \";  // the cat and the dog\n    }\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\n\n## Адаптеры для вставки\n\nВ стандартной библиотеке есть конструкции, которые притворяются обычными итераторами, но на самом деле не являются таковыми. Например, шаблонная функция [`std::back_inserter`](https://en.cppreference.com/w/cpp/iterator/back_inserter) принимает последовательный контейнер и возвращает *адаптер*, который ведёт себя как итератор, но при попытке записи в него добавляет элемент в контейнер через `push_back`. Такие адаптеры удобно использовать с модифицирующими алгоритмами.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003citerator\u003e\n#include \u003clist\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e v = {3, 14, 15, 92, 6};\n    std::list\u003cint\u003e l;  // список пустой!\n    std::copy(v.begin(), v.end(), std::back_inserter(l));  // 3 14 15 92 6\n}\n```\n\nТакже есть функции [`std::front_inserter`](https://en.cppreference.com/w/cpp/iterator/front_inserter) и [`std::inserter`](https://en.cppreference.com/w/cpp/iterator/inserter). Последняя кроме контейнера принимает ещё и итератор, перед которым должна производиться вставка. Разумеется, этот итератор не должен инвалидироваться в процессе работы алгоритма.\n\n\n## Сортировка\n\nМы уже знакомы с `std::sort`. Заметим, что этот алгоритм [нестабильный](https://en.wikipedia.org/wiki/Sorting_algorithm#Stability): после сортировки порядок одинаковых элементов может измениться. Это может быть заметно, например, во время сортировки вектора структур при сравнении по какому-то ключевому полю. В стандартной библиотеке имеется чуть менее эффективная функция [`stable_sort`](https://en.cppreference.com/w/cpp/algorithm/stable_sort) с асимптотической сложностью $O(n (\\log n)^2)$, сохраняющая порядок эквивалентных элементов.\n\nВажно заметить, что алгоритмы сортировки требуют, чтобы на входе были *итераторы произвольного доступа*. Такие итераторы предоставляют контейнеры с индексами — `vector`, `string`, `array`, `deque`. К итераторам этих контейнеров можно прибавлять целые числа и их можно вычитать друг из друга. В сортировке это используется для быстрого обращения к элементу в середине последовательности.\n\nВызов общего алгоритма сортировки с итераторами списка просто не скомпилируется. Однако, как и с функцией `find` у ассоциативных контейнеров, у списков есть [встроенная](https://en.cppreference.com/w/cpp/container/list/sort) функция `sort`. Она использует сортировку слиянием, которая чуть менее эффективна на практике, но имеет ту же асимптотическую сложность $O(n \\log n)$, что и `std::sort`.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003clist\u003e\n\nint main() {\n    std::list\u003cint\u003e data = {3, 14, 15, 92, 6};\n    std::sort(data.begin(), data.end());  // не скомпилируется!\n    data.sort();  // OK, встроенная функция сортировки списка\n}\n```\n\nПроверить, отсортирована ли последовательность, можно с помощью функции [`std::is_sorted`](https://en.cppreference.com/w/cpp/algorithm/is_sorted). А с помощью функции [`std::partial_sort`](https://en.cppreference.com/w/cpp/algorithm/partial_sort) можно построить только начало отсортированного массива, не сортируя хвост:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e data = {3, 14, 15, 92, 6};\n    std::partial_sort(data.begin(), data.begin() + 3, data.end());\n    // первыми тремя элементами в векторе будут 3, 6, 14\n}\n```\n\n\n## Алгоритмы бинарного поиска\n\nК отсортированным последовательностям в контейнерах можно применять особый набор алгоритмов. Рассмотрим алгоритмы для [бинарного поиска](https://en.wikipedia.org/wiki/Binary_search_algorithm):\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    // Отсортирован по возрастанию:\n    std::vector\u003cint\u003e data = {1, 4, 5, 9, 9, 13, 47};\n\n    // Элемент будет найден:\n    if (std::binary_search(data.begin(), data.end(), 5)) {\n        std::cout \u003c\u003c \"Found\\n\";\n    } else {\n        std::cout \u003c\u003c \"Not found\\n\";\n    }\n}\n```\n\nЕсли [`binary_search`](https://en.cppreference.com/w/cpp/algorithm/binary_search) возвращает `true` или `false`, то алгоритмы [`lower_bound`](https://en.cppreference.com/w/cpp/algorithm/lower_bound) и [`upper_bound`](https://en.cppreference.com/w/cpp/algorithm/upper_bound) возвращают итераторы. Алгоритм `lower_bound` возвращает итератор на *первый элемент, не меньший заданного*. Алгоритм `upper_bound` возвращает итератор на *первый элемент, больший заданного*:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nint main() {\n    // Числа идут по возрастанию:\n    std::vector\u003cint\u003e data = {1, 4, 5, 9, 9, 13, 47};\n\n    auto iter1 = std::lower_bound(\n        data.begin(), data.end(),\n        8\n    );  // *iter1 == 9\n\n    auto iter2 = std::upper_bound(\n        data.begin(), data.end(),\n        47\n    );  // iter2 == data.end()\n\n    // все элементы исходной последовательности, такие, что 8 \u003c= x \u003c= 47,\n    // попадут в полуинтервал [iter1, iter2)\n    for (auto iter = iter1; iter != iter2; ++iter) {\n        std::cout \u003c\u003c *iter \u003c\u003c \" \";  // 9 9 13 47\n    }\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\nВ частности, пара `std::lower_bound(first, last, x)` и `std::upper_bound(first, last, x)` ограничивает диапазон элементов, эквивалентных `x`. Пару таких итераторов можно получить за один вызов из функции [`std::equal_range`](https://en.cppreference.com/w/cpp/algorithm/equal_range).\n\n![C_14_e2dbcd6369.svg](https://yastatic.net/s3/education-portal/media/C_14_e2dbcd6369_b7b3bf7131.svg)\n\nКак и в случае с `find`, у ассоциативных контейнеров есть собственные встроенные реализации функций [`lower_bound`](https://en.cppreference.com/w/cpp/container/map/lower_bound), [`upper_bound`](https://en.cppreference.com/w/cpp/container/map/upper_bound) и [`equal_range`](https://en.cppreference.com/w/cpp/container/map/equal_range).\n\nЕсли последовательность не будет упорядочена, то результат работы всех этих функций может быть некорректным.\n\nФормально эти функции можно применять и к итераторам списка, не имеющим произвольного доступа. В этом случае время работы будет не логарифмическим, а линейным.\n\n\n## Теоретико-множественные алгоритмы\n\nНад отсортированными последовательностями можно выполнять операции\n- слияния ([`std::merge`](https://en.cppreference.com/w/cpp/algorithm/merge)),\n- объединения ([`std::set_union`](https://en.cppreference.com/w/cpp/algorithm/set_union))\n- пересечения ([`std::set_intersection`](https://en.cppreference.com/w/cpp/algorithm/set_intersection)),\n- разности ([`std::set_difference`](https://en.cppreference.com/w/cpp/algorithm/set_difference)),\n- [симметрической разности](https://en.wikipedia.org/wiki/Symmetric_difference) ([`std::set_symmetric_difference`](https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference)).\n\nТакже можно проверять вложения ([`std::includes`](https://en.cppreference.com/w/cpp/algorithm/includes)).\n\nЭти алгоритмы работают за линейное время от суммарной длины последовательностей. Перечисленные операции соответствуют математическим [мультимножествам](https://en.wikipedia.org/wiki/Multiset), а не множествам, потому что элементы в последовательностях могут повторяться. Каждый элемент учитывается со своей кратностью.\n\nВсе эти операции (кроме `includes`) принимают пять аргументов:\n- два итератора первого диапазона,\n- два итератора второго диапазона,\n- итератор выходной последовательности для записи ответа.\n\nЭлементы выходной последовательности также будут отсортированы.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cdeque\u003e\n#include \u003citerator\u003e\n#include \u003clist\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cint\u003e in1 = {1, 3, 5, 5, 7};\n    std::list\u003cint\u003e in2 = {1, 1, 2, 3};\n    std::deque\u003cint\u003e out;\n\n    std::merge(\n        in1.begin(), in1.end(),\n        in2.begin(), in2.end(),\n        std::back_inserter(out)\n    );  // 1, 1, 1, 2, 3, 3, 5, 5, 7\n\n    out.clear();\n    std::set_union(\n        in1.begin(), in1.end(),\n        in2.begin(), in2.end(),\n        std::back_inserter(out)\n    );  // 1, 1, 2, 3, 5, 5, 7\n\n    out.clear();\n    std::set_intersection(\n        in1.begin(), in1.end(),\n        in2.begin(), in2.end(),\n        std::back_inserter(out)\n    );  // 1, 3\n\n    out.clear();\n    std::set_difference(\n        in1.begin(), in1.end(),\n        in2.begin(), in2.end(),\n        std::back_inserter(out)\n    );  // 5, 5, 7\n\n    out.clear();\n    std::set_symmetric_difference(\n        in1.begin(), in1.end(),\n        in2.begin(), in2.end(),\n        std::back_inserter(out)\n    );  // 1, 2, 5, 5, 7\n\n    std::includes(\n        in2.begin(), in2.end(),\n        in1.begin(), in1.end()\n    );  // false\n}\n```\n"])</script><script nonce="">self.__next_f.push([1,"67:T39e2,"])</script><script nonce="">self.__next_f.push([1,"*Адаптеры* над стандартными контейнерами — это не самостоятельные контейнеры. Они используют какой-нибудь другой контейнер (например, дек или вектор) для хранения своих элементов, но при этом предоставляют свой набор функций для работы с ними. В стандартной библиотеке есть адаптеры `std::stack`, `std::queue` и `std::priority_queue`.\n\n*Представления* (views) не владеют памятью, а лишь ссылаются на диапазон значений другого контейнера. Представлением можно считать пару итераторов. В С++20 появилась обширная библиотека [`ranges`](https://en.cppreference.com/w/cpp/ranges) для работы с представлениями. В этом параграфе мы рассмотрим конструкцию `string_view`, представляющую фрагмент строки.\n\n\n## Адаптер `std::stack`\n\n[Стек](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) — это последовательность элементов, в которую разрешается добавлять и извлекать элементы только с одной стороны. Обращение к промежуточным элементам не допускается. Говорят, что структура данных «стек» реализует идею LIFO (last in — first out).\n\nПонятно, что эти действия можно сделать с помощью вектора или дека и операций `push_back` и `pop_back`. Адаптер [`std::stack`](https://en.cppreference.com/w/cpp/container/stack) является обёрткой над такими контейнерами с особым интерфейсом — функциями `push`, `pop` и `top`. Это позволяет более выразительно подчеркнуть, что используется не просто какой-то контейнер, а именно стек как структура данных.\n\n![C_15_5b267237b1.svg](https://yastatic.net/s3/education-portal/media/C_15_5b267237b1_8330b1abed.svg)\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstack\u003e\n\nint main() {\n    std::stack\u003cint\u003e s;\n    s.push(1);\n    s.push(13);\n    s.pop();  // удалить элемент с вершины стека (в стеке останется 1)\n\n    std::cout \u003c\u003c s.top() \u003c\u003c \"\\n\";  // получить элемент на вершине стека, не удаляя его\n\n    if (s.empty()) {  // проверка на пустоту\n       std::cout \u003c\u003c \"Stack is empty\\n\";\n    }\n}\n```\n\nФункция `pop` ничего не возвращает. Напротив, функция `top` возвращает элемент, но никак не меняет состояние стека. Так было сделано для [гарантий безопасности исключений](https://en.cppreference.com/w/cpp/language/exceptions#Exception_safety). Мы поговорим об этом в [параграфе «Обработка исключений»](https://education.yandex.ru/handbook/cpp/article/exceptions).\n\nПо умолчанию стек использует контейнер `std::deque` для хранения элементов. При желании мы можем указать другой тип этого контейнера. Всё, что требуется от этого контейнера, — это поддержка операций `push_back`, `pop_back`, `back` и `empty`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n#include \u003cstack\u003e\n\nint main() {\n    std::stack\u003cint, std::list\u003cint\u003e\u003e s;  // используем std::list для хранения элементов в стеке\n    // ...\n}\n```\n\nВ C++ есть ещё понятие [*стека*](https://en.wikipedia.org/wiki/Stack-based_memory_allocation) как области памяти для локальных переменных и аргументов функций. Оно так называется потому, что переменные автоматически помещаются туда при создании и автоматически удаляются при выходе из области видимости. То есть, последняя созданная переменная удалится первой, как в обычном стеке. Не следует путать это понятие с адаптером `std::stack`. Подробнее про жизненный цикл объектов мы поговорим в [параграфе «Жизненный цикл объекта»](https://education.yandex.ru/handbook/cpp/article/object-lifetime).\n\n\n## Адаптер `std::queue`\n\nДругой похожий адаптер — очередь ([`std::queue`](https://en.cppreference.com/w/cpp/container/queue)). Очередь реализует идею [FIFO](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)) (first in — first out). Можно считать, что элементы встают в очередь с одного конца, а извлекаются с другого. Очередь предоставляет функции `push`, `pop`, `front` и `back`.\n\n![C_16_01269a1fc5.svg](https://yastatic.net/s3/education-portal/media/C_16_01269a1fc5_1c00eaf442.svg)\n\nНе следует путать адаптер `queue` с контейнером `deque`.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cqueue\u003e\n\nint main() {\n    std::queue\u003cint\u003e s;\n    s.push(1);\n    s.push(13);\n\n    std::cout \u003c\u003c s.front() \u003c\u003c \"\\n\";  // 1\n    std::cout \u003c\u003c s.back() \u003c\u003c \"\\n\";  // 13\n\n    s.pop();  // в очереди останется 13\n\n    if (s.empty()) {\n       std::cout \u003c\u003c \"Queue is empty\\n\";\n    }\n}\n```\n\nТак же как и в `std::stack`, в очереди по умолчанию используется `std::deque` для хранения элементов. Этот контейнер точно так же можно заменить. Для этого нужно указать тип нового контейнера во втором шаблонном параметре. Однако в отличие от стека здесь не получится использовать `std::vector`, так как у него нет функций `push_front` и `pop_front`.\n\n\n## Адаптер `std::priority_queue`\n\nРассмотрим адаптер [`std::priority_queue`](https://en.cppreference.com/w/cpp/container/priority_queue) — [очередь с приоритетами](https://en.wikipedia.org/wiki/Priority_queue). Эта структура данных позволяет за логарифмическое время добавлять и удалять элементы и за константное время получать максимальный элемент. Типичная реализация очереди с приоритетами основана на структуре данных [«куча»](https://en.wikipedia.org/wiki/Heap_(data_structure)). Для хранения элементов используется контейнер с индексами и с возможностью добавления в конец. На эту роль подходят `std::vector` и `std::deque`, но не подходит `std::list`. По умолчанию используется `std::vector`.\n\n![C_17_fdf5eb654e.svg](https://yastatic.net/s3/education-portal/media/C_17_fdf5eb654e_4840663bf5.svg)\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cqueue\u003e  // именно queue, а не priority_queue\n\nint main() {\n    std::priority_queue\u003cint\u003e pq;\n    for (int x : {3, 14, 15, 92, 6, 0, 1, 10}) {\n        pq.push(x);\n    }\n    while (!pq.empty()) {\n        std::cout \u003c\u003c pq.top() \u003c\u003c \"\\n\";\n        pq.pop();\n    }\n    // Будет напечатано 92, 15, 14, 10, 6, 3, 1, 0\n}\n```\n\nДля сравнения элементов по умолчанию используется оператор `\u003c`. Чтобы воспользоваться оператором `\u003e` и, соответственно, извлекать из очереди минимальные элементы вместо максимальных, можно передать в третьем шаблонном параметре специальную обёртку `std::greater\u003cint\u003e`.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cfunctional\u003e\n#include \u003cqueue\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::priority_queue\u003c\n        int,\n        std::vector\u003cint\u003e,  // тип внутреннего контейнера; его приходится указывать, если нам нужен третий параметр\n        std::greater\u003cint\u003e  // вспомогательная обёртка над оператором \u003e (а не \u003c)\n    \u003e pq;\n\n    for (int x : {3, 14, 15, 92, 6}) {\n        pq.push(x);\n    }\n\n    while (!pq.empty()) {\n        std::cout \u003c\u003c pq.top() \u003c\u003c \"\\n\";\n        pq.pop();\n    }\n    // Будет напечатано 3 6 14 15 92\n}\n```\n\n\n## Представление `std::string_view`\n\nКонструкция [`std::string_view`](https://en.cppreference.com/w/cpp/string/basic_string_view) не является адаптером. Это не самостоятельная строка, а отсылка к подстроке какой-то другой строки. Объекты такого класса не выделяют память для размещения символов строки и не копируют подстроки. Упрощённо их можно представлять себе просто как такие структуры:\n\n```cpp\nstruct string_view {\n    const char* start;  // указатель на начало подстроки в чужой памяти\n    size_t len;   // длина этой подстроки\n};\n```\n\n![C_18_8928234899.svg](https://yastatic.net/s3/education-portal/media/C_18_8928234899_95168071ce.svg)\n\nДавайте взглянем на следующий код:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string s = \"Hello, world! How do you do?\";\n    auto sub = s.substr(7, 5);  // тип sub — std::string\n    sub[0] = 'W';\n    std::cout \u003c\u003c sub \u003c\u003c \"\\n\";  // World\n    // В исходной строке всё осталось по-прежнему:\n    std::cout \u003c\u003c s \u003c\u003c \"\\n\";  // Hello, world! How do you do?\n}\n```\n\nЗдесь имеется исходная строка `s`, у которой мы выделяем подстрочку `sub`. Эта подстрока является самостоятельной копией фрагмента исходной строки. С одной стороны, это позволяет её независимо изменять. С другой стороны, если такие изменения не требуются, на такое копирование тратится время и память.\n\nПерепишем теперь это через `string_view`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cstring_view\u003e\n\nint main() {\n    std::string s = \"Hello, world! How do you do?\";\n    std::string_view sv = s;  // смотрим через string_view на строку s\n    auto sub = sv.substr(7, 5);  // теперь тип sub — std::string_view\n    // sub[0] = 'W';  // изменять через string_view символы строки нельзя\n    std::cout \u003c\u003c sub \u003c\u003c \"\\n\";  // world\n    std::cout \u003c\u003c s \u003c\u003c \"\\n\";  // Hello, world! How do you do?\n}\n```\n\nОбёртка `string_view` рассматривает исходную строчку как константную: она не позволяет её изменять. В то же время через `string_view` можно читать символы фрагмента исходной строки, а также можно брать новые подстроки и сужать длину подстроки:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cstring_view\u003e\n\nint main() {\n    std::string s = \"Hello, world! How do you do?\";\n    std::string_view sv = s;\n    sv.remove_prefix(7);  // убрали из sv первые 7 символов\n    sv.remove_suffix(16);  // убрали последние 16 символов\n    std::cout \u003c\u003c sv \u003c\u003c \"\\n\";  // world\n    std::cout \u003c\u003c s \u003c\u003c \"\\n\";  // строка s при этом никак не изменилась\n}\n```\n\nОбёртка `string_view` позволяет избежать ненужных копирований и ускорить программу там, где ведётся работа с подстроками одной большой строки. Например, это могут быть фрагменты JSON- или XML-файлов. Однако важно помнить, что `string_view` валиден только при условии, что объемлющая строка жива. Например, следующая программа некорректна и приведёт к неопределённому поведению:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cstring_view\u003e\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cstd::string_view\u003e lines;\n    for (int i = 0; i \u003c 5; ++i) {\n        std::string line;\n        std::getline(std::cin, line);\n        lines.push_back(line);  // string_view в векторе ссылается на память строки line\n    }\n    for (auto item : lines) {\n        std::cout \u003c\u003c item \u003c\u003c \"\\n\";  // Ошибка! Все эти строки уже невалидны!\n    }\n}\n```\n\nПрограмма компилируется, но при запуске попадает в неопределённое поведение, так как исходные строки `line` выходят из своей области видимости после каждой итерации цикла, и обращаться к их памяти больше нельзя.\n\nПо аналогии со `string_view`, [`std::span`](https://en.cppreference.com/w/cpp/container/span) является оберткой над произвольной непрерывной последовательностью элементов в памяти. Можно сказать, что `span` — это аналог `string_view` для массивов или векторов.\n"])</script><script nonce="">self.__next_f.push([1,"68:T14e03,"])</script><script nonce="">self.__next_f.push([1,"## Параграф «Последовательные контейнеры»\n\n### [Задача «Шаблонный Print»](https://new.contest.yandex.ru/42157/problem?id=10033/2022_10_23/InNsEHFsyx)\n\n{% cut \"Условие\" %}\n\nВам надо написать функцию `Print`, которая умеет печатать в поток `std::cout` элементы переданного контейнера через указанную строку-разделитель. Первый аргумент функции — контейнер. Гарантируется, что по этому контейнеру можно проитерироваться с помощью стандартного цикла range-based for, и что элементы контейнера можно напечатать в поток `std::cout` с помощью стандартного оператора `\u003c\u003c`. Второй аргумент функции — строка-разделитель, которую надо печатать между элементами. В конце необходимо напечатать перевод строки `\\n`.\n\nПример вызова:\n\n```cpp\nint main() {\n    std::vector\u003cint\u003e data = {1, 2, 3};\n    Print(data, \", \");  // 1, 2, 3\n}\n```\n\n#### Примечание\n\nВ вашем решении должен быть только код функции `Print` без функции `main`. Подключите все необходимые для реализации библиотеки. Используйте константные ссылки для получения параметров и при итерации в цикле, чтобы избежать лишних копирований: если этого не сделать, то программа не скомпилируется.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nПрежде всего определимся с заголовком функции `Print`. Она должна работать с любым контейнером. Проще всего будет сделать тип контейнера шаблонным параметров функции (да и название задачи на это намекает):\n\n```cpp\ntemplate \u003ctypename Container\u003e\nvoid Print(const Container\u0026 data, const std::string\u0026 delimiter);\n```\n\nСам контейнер и строку-разделитель мы будем принимать по константной ссылке, чтобы избежать лишних и ненужных копирований. Про необходимость передачи по константной ссылке даже написано в примечании к условию (это специально проверяется в тестах).\n\nПостараемся решить задачу, не предполагая ничего дополнительного о контейнере, кроме того, что сказано в условии. Гарантируется, что по контейнеру можно пройтись с помощью range-based for:\n\n```cpp\nfor (const auto\u0026 elem : data) {\n    // ...\n}\n```\n\nСтроку-разделитель следует печатать только *между* элементами. Для этого нам нужно понимать, последний ли элемент сейчас печатается. Но гораздо проще проверять, первый ли это элемент. Заведём для этого логическую переменную, изначально установленную в `true`, и сбросим её на первой итерации цикла.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\ntemplate \u003ctypename Container\u003e\nvoid Print(const Container\u0026 data, const std::string\u0026 delimiter) {\n    bool first = true;\n\n    for (const auto\u0026 elem : data) {\n        if (!first) {\n            std::cout \u003c\u003c delimiter;\n        } else {\n            first = false;\n        }\n\n        std::cout \u003c\u003c elem;\n    }\n\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\nРешения, использующие итераторы, тоже допустимы, так как range-based for на самом деле под капотом обращается к функциям `begin` и `end`:\n\n```cpp\nfor (auto iter = std::begin(data); iter != std::end(data); ++it) {\n    // ...\n}\n```\n\nОднако не следуют проверять, является ли элемент последним, с помощью такого сравнения:\n\n```cpp\n    if (iter == std::prev(std::end(data))) {\n        // ...\n    }\n```\n\nУ однонаправленных итераторов (например, у односвязного списка `forward_list`) взятие `prev` приведёт к неопределенному поведению. По аналогичной причине это не будет работать с некоторыми реализациями `unordered_set`.\n\nВместо этого можно либо написать `next(iter) == end(data)`, либо, как в решении выше, проверять не на конец, а на начало (сравнивать `iter` с `begin(data)`):\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003citerator\u003e\n#include \u003cstring\u003e\n\ntemplate \u003ctypename Container\u003e\nvoid Print(const Container\u0026 data, const std::string\u0026 delimiter) {\n    for (auto iter = std::begin(data); iter != std::end(data); ++iter) {\n        std::cout \u003c\u003c *iter;\n        if (std::next(iter) != std::end(data)) {\n            std::cout \u003c\u003c delimiter;\n        }\n    }\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\nОтметим также, что первое решение скорее всего покажет большую производительность, так как компилятору будет проще оптимизировать инструкцию `if` над логической переменной, а процессору будет проще предугадать правильную ветку исполнения. Однако реальная разность в производительности на такой примитивной задаче вряд ли будет заметна на уровне погрешности.\n\n{% endcut %}\n\n### [Задача «Проверка работ»](https://new.contest.yandex.ru/42157/problem?id=40119/2022_10_30/DP6KMkViPy)\n\n{% cut \"Условие\" %}\n\nВ университете проводится письменная контрольная работа. $N$ студентов сдают свои работы в общую стопку, причем некоторые кладут свою работу сверху, а другие (считая, что чем позже их работу проверят, тем лучше) — снизу. Проверяются работы в том порядке, в котором лежат, начиная с верхней. Определите, чья работа будет проверена $k$-й по счёту.\n\n#### Формат ввода\n\nПервая строка содержит одно натуральное число $N$, не превосходящее 10000, — число студентов.\n\nКаждая из последующих $N$ строк содержит фамилию студента — строку из латинских букв длиной от 2 до 10 символов, и через пробел слово `top` или `bottom` — положил этот студент свою работу сверху или снизу.\n\nСледующая строка содержит одно целое число $M$ от 0 до 10000 — для какого числа работ нужно определить их автора.\n\nСледующие $M$ строк содержат по одному числу $x_i$ от 1 до $N$ — номер в стопке очередной интересующей нас работы.\n\n#### Формат вывода\n\nВыведите $M$ строк. В $i$-й строке выведите фамилию студента, чья работа будет проверена $x_i$-й по счёту.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr/\u003eIvanov top\u003cbr/\u003ePetrov top\u003cbr/\u003eSidorov bottom\u003cbr/\u003e2\u003cbr/\u003e1\u003cbr/\u003e3\n\n|\n\nPetrov\u003cbr/\u003eSidorov\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr/\u003eIvanov top\u003cbr/\u003eIvanov bottom\u003cbr/\u003eIvanov top\u003cbr/\u003e4\u003cbr/\u003e1\u003cbr/\u003e2\u003cbr/\u003e3\u003cbr/\u003e1\n\n|\n\nIvanov\u003cbr/\u003eIvanov\u003cbr/\u003eIvanov\u003cbr/\u003eIvanov\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nСамая подходящая для нашей задачи структура данных — `std::deque`. В этот контейнер можно эффективно вставлять новые элементы по краям и обращаться к элементам по индексам. Будем хранить в деке имена студентов в том порядке, в котором их работы попадают в стопку. Для этого при считывании позиции `top` будем использовать функцию `push_front`, а в случае позиции `bottom` — функцию `push_back`. Обе функции в среднем работают за константное время.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cdeque\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::deque\u003cstd::string\u003e works;\n\n    int n = 0;\n    std::cin \u003e\u003e n;\n\n    for (int i = 0; i \u003c n; ++i) {\n        std::string name, position;\n        std::cin \u003e\u003e name \u003e\u003e position;\n\n        if (position == \"top\") {\n            works.push_front(name);\n        } else {\n            works.push_back(name);\n        }\n    }\n\n    int k = 0;\n    std::cin \u003e\u003e k;\n    for (int i = 0; i \u003c k; ++i) {\n        int x = 0;\n        std::cin \u003e\u003e x;\n        std::cout \u003c\u003c works[x - 1] \u003c\u003c \"\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Вагоны»](https://new.contest.yandex.ru/42157/problem?id=10033/2022_10_30/HiYeWqkVZH)\n\n{% cut \"Условие\" %}\n\nВы — машинист. Вам поручено реализовать функцию `void MakeTrain()`, чтобы сформировать поезд из набора вагонов.\n\nУ каждого вагона есть номер (помещается в `int`). Номера вагонов внутри состава могут повторяться. Изначально путь, на котором формируется состав, пустой. Вы должны уметь выполнять следующие команды, которые поступают в отдельных строках на входе:\n\n* `+left W` — добавить вагон с номером $W$ слева\n* `+right W` — добавить вагон с номером $W$ справа\n* `-left N` — отцепить и убрать $N$ вагонов слева\n* `-right N` — отцепить и убрать $N$ вагонов справа\n\nВ последних двух командах $N$ может быть больше текущей длины состава — в этом случае надо убрать весь состав целиком. Отцеплять вагоны по одному может быть долго: постарайтесь сразу отцеплять по $N$ штук. Напечатайте через пробел номера вагонов получившегося состава, если смотреть на них слева направо. В самом конце напечатайте перевод строки.\n\nНа вход подаются строки с командами в указанном формате. Всего будет не более 1 млн команд. Оформите ваше решение в функции `void MakeTrain()`. Эта функция должна читать данные со стандартного потока ввода и печатать их в стандартный поток вывода. Подключите все необходимые библиотеки. В вашем решении не должно быть функции `main`.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДля хранения последовательности вагонов нам нужен контейнер, позволяющий эффективно добавлять и удалять элементы с обоих концов. Мы знаем два таких контейнера в стандартной библиотеке - `std::list` и `std::deque`.\n\nВ условии есть совет отцеплять вагоны сразу по N штук. Это намекает на то, что `deque` будет более подходящим контейнером: его итераторы являются итераторами произвольного доступа, а значит, можно будет быстро найти место расцепки.\n\nК тому же в задании есть нестандартные ограничения по времени. Контейнер `std::list` может оказаться медленнее дека, потому что он аллоцирует отдельные ячейки памяти под каждый элемент. Напротив, `std::deque` аллоцирует сразу большие страницы памяти.\n\nИтак, выбираем `std::deque\u003cint\u003e`:\n\n```cpp\n#include \u003cdeque\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nvoid MakeTrain() {\n    using Wagon = int;\n    std::deque\u003cWagon\u003e train;\n\n    std::string command;\n    Wagon wagon;\n    size_t k;\n    while (std::cin \u003e\u003e command) {\n        if (command == \"+left\") {\n            std::cin \u003e\u003e wagon;\n            train.push_front(wagon);\n        } else if (command == \"+right\") {\n            std::cin \u003e\u003e wagon;\n            train.push_back(wagon);\n        } else if (command == \"-left\") {\n            std::cin \u003e\u003e k;\n            k = std::min(k, train.size());\n            train.erase(train.begin(), train.begin() + k);\n        } else if (command == \"-right\") {\n            std::cin \u003e\u003e k;\n            k = std::min(k, train.size());\n            train.erase(train.end() - k, train.end());\n        }\n    }\n\n    for (const auto\u0026 wagon : train) {\n        std::cout \u003c\u003c wagon \u003c\u003c \" \";\n    }\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\nЗдесь мы используем псевдоним `Wagon` вместо `int`, чтобы в будущем можно было легко поменять тип. (В конце при выводе вагонов по-хорошему не надо было бы печатать последний пробел, но в тестах ответ проверяется с точность до пробельных символов в конце, и такое решение проходит.)\n\nМы специально просим в этой задаче написать код в отдельной функции, чтобы в своей функции `main` позвать [`std::ios_base::sync_with_stdio(false)`](https://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio) и ускорить ввод-вывод, так что накладные расходы на ввод-вывод данных будут минимальными.\n\nМожно сгенерировать искусственный тест, где будут случайные добавления вагонов с разных сторон, а потом — серия мелких удалений (и так несколько раз). Попробуем сравнить скорость работы этой программы для `deque` и для `list` на таком тесте с опцией компилятора `-O3` (то есть, с полностью включенными оптимизациями). Оказывается, что `list` медленнее на 20%.\n\nЗаметим, что в решении с `deque` отцепка вагонов по одному через `pop_back` или `pop_front` на самом деле оказывается не медленнее вызова `erase` с парой итераторов.\n\n#### Неверные решения\n\nРазберём два неправильных решения этой задачи. Первое — пытаться считывать данные через `getline` в строку, а потом отдельно разбирать её через `stringstream`:\n\n```cpp\n    std::string line;\n    std::string command;\n    Wagon wagon;\n    while (std::getline(std::cin, line)) {\n        std::istringstream ss(line);\n        ss \u003e\u003e command \u003e\u003e wagon;\n        // ...\n    }\n```\n\nЭто удобно, но в данном случае сильно замедляет программу. Поток `istringstream` внутри хранит копию исходной строки, а на это требуются накладные расходы.\n\nВторое ошибочное решение — такое:\n\n```cpp\n    if (command == \"+left\") {\n        std::cin \u003e\u003e wagon;\n        train.push_front(wagon);\n    } else if (command == \"+right\") {\n        std::cin \u003e\u003e wagon;\n        train.push_back(wagon);\n    } else if (command == \"-left\") {\n        std::cin \u003e\u003e k;\n        for (size_t i = 0; i \u003c std::min(k, train.size()); ++i) {\n            train.pop_front();\n        }\n    } else if (command == \"-right\") {\n        std::cin \u003e\u003e k;\n        for (size_t i = 0; i \u003c std::min(k, train.size()); ++i) {\n            train.pop_back();\n        }\n    }\n```\n\nТут просто будет неверный ответ. Найдите ошибку самостоятельно.\n\n{% endcut %}\n\n### [Задача «Ctrl\\+X, Ctrl\\+V»](https://new.contest.yandex.ru/42157/problem?id=2109007/2022_10_20/pQSs6ZAOvH)\n\n{% cut \"Условие\" %}\n\nПетя решил написать свой собственный текстовый редактор и просит вас помочь протестировать его прототип. На текущей стадии разработки в редакторе есть только возможность загрузить файл и выполнять с ним такие действия:\n\n* переместить курсор на строчку вниз (`Down`)\n* переместить курсор на строчку вверх (`Up`)\n* вырезать текущую строку в буфер обмена (`Ctrl+X`)\n* вставить строку из буфера перед текущей строкой (`Ctrl+V`)\n\nИзначально курсор находится на первой (начальной) строке.\n\nОперации `Down` с курсором на последней строке и `Up` с курсором на первой строке должны игнорироваться.\n\nЛюбой текстовый файл в системе заканчивается переводом строки. Поэтому последняя строка любого файла является пустой. Операция `Ctrl+X` на пустой строке ничего не делает.\n\nИзначально буфер редактора пустой. Операция `Ctrl+X` перезаписывает буфер, если в нём уже было какое-то значение. Операция `Ctrl+V` не очищает буфер и может быть использована несколько раз подряд. Операция `Ctrl+V` при пустом буфере ничего не делает.\n\nПомогите Пете протестировать его текстовый редактор. Напишите программу, которая по заданному файлу и набору команд выводит получившийся файл.\n\n#### Формат ввода\n\nПрограмме на вход подаётся набор строк, разделённых переносом строки. Длина каждой строки не превышает 3000 символов. Последняя строка в файле является пустой. Она означает завершение ввода файла. Других пустых строк в файле быть не может.\n\nПосле этого и до окончания ввода программе подаются команды `Down`, `Up`, `Ctrl+X`, `Ctrl+V`.\n\n#### Формат вывода\n\nВыведите получившийся файл построчно.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nprogram\u003cbr/\u003eis awesome\u003cbr/\u003eMy\u003cbr/\u003eis awful\u003cbr/\u003e\u003cbr/\u003eDown\u003cbr/\u003eDown\u003cbr/\u003eDown\u003cbr/\u003eCtrl\\+X\u003cbr/\u003eUp\u003cbr/\u003eCtrl\\+X\u003cbr/\u003eUp\u003cbr/\u003eUp\u003cbr/\u003eCtrl\\+V\n\n|\n\nMy\u003cbr/\u003eprogram\u003cbr/\u003eis awesome\u003cbr/\u003e\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\ncopy\u003cbr/\u003epaste\u003cbr/\u003e\u003cbr/\u003eCtrl\\+X\u003cbr/\u003eCtrl\\+V\u003cbr/\u003eCtrl\\+V\u003cbr/\u003eCtrl\\+V\u003cbr/\u003eCtrl\\+X\u003cbr/\u003eCtrl\\+V\u003cbr/\u003eCtrl\\+V\u003cbr/\u003eCtrl\\+V\n\n|\n\ncopy\u003cbr/\u003ecopy\u003cbr/\u003ecopy\u003cbr/\u003epaste\u003cbr/\u003epaste\u003cbr/\u003epaste\n\n||\n|#\n\n#### Примечание\n\nЕсли условие кажется вам запутанным, попробуйте воспользоваться настоящим текстовым редактором, например [Sublime](https://www.sublimetext.com/). Создайте пустой файл, вставьте любой пример из условия и исполняйте заданные команды. В итоге вы должны получить точно такой же файл, как в ответе. Таким образом описанное в условии поведение в точности соответствует поведению множества настоящих текстовых редакторов.\n\nИспользуйте `std::getline` для считывания строчек файла.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДля работы со строками нам нужен контейнер для хранения данных, в котором вставка в середину возможна за константное время. При этом нам не нужно иметь произвольный доступ по индексу, так как курсор в файле перемещается последовательно. Подходящим контейнером является двусвязный список `std::list`.\n\nЗапишем все строки (кроме последней пустой) в список. В роли курсора будет выступать итератор списка. Вспомним, что операции над списком не инвалидируют существующие итераторы.\n\nДалее будем последовательно обрабатывать команды.\n\n1. **Команда `Up`**.\n   Необходимо передвинуть итератор на одну позицию назад. Для этого можно воспользоваться конструкцией `--cursor`. Необходимо не забыть про случай, когда курсор уже находится на первой строке.\n\n2. **Команда `Down`**.\n   Необходимо передвинуть итератор на одну позицию вперёд, воспользовавшись конструкцией `++cursor`. Перед этим надо проверить, не находится ли курсор на последний строке.\n\n3. **Команда `Ctrl+X`**.\n   Копируем текущее значение итератора в буфер. После этого перезаписываем курсор с помощью `cursor = file.erase(cursor)`. Напомним, что `erase` возвращает итератор на следующий элемент в списке, что соответствует требуемому поведению.\n\n4. **Команда `Ctrl+V`**.\n   Проверяем, что буфер не пуст, и используем функцию `insert`.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n#include \u003cstring\u003e\n#include \u003cutility\u003e\n\nint main() {\n    std::list\u003cstd::string\u003e file;\n\n    while (true) {\n        std::string line;\n        std::getline(std::cin, line);\n\n        if (line.empty()) {\n            break;\n        }\n\n        file.push_back(line);\n    }\n\n    auto cursor = file.begin();\n    std::string buffer;\n\n    std::string command;\n    while (std::cin \u003e\u003e command) {\n        if (command == \"Up\") {\n            if (cursor == file.begin()) {\n                continue;\n            }\n            --cursor;\n        } else if (command == \"Down\") {\n            if (cursor == file.end()) {\n                continue;\n            }\n            ++cursor;\n        } else if (command == \"Ctrl+X\") {\n            if (cursor == file.end()) {\n                continue;\n            }\n            buffer = std::move(*cursor);\n            cursor = file.erase(cursor);\n        } else if (command == \"Ctrl+V\") {\n            if (buffer.empty()) {\n                continue;\n            }\n            file.insert(cursor, buffer);\n        }\n    }\n\n    for (const auto \u0026x: file) {\n        std::cout \u003c\u003c x \u003c\u003c \"\\n\";\n    }\n}\n```\n\nОбратите внимание, что при вырезании строки в буфер мы используем функцию `std::move`. Она позволяет забрать владение строкой, которая вот-вот будет удалена из списка, и сэкономить на её копировании. Подробнее про move-семантику рассказано в [параграфе «Жизненный цикл объекта»](https://education.yandex.ru/handbook/cpp/article/object-lifetime).\n\n{% endcut %}\n\n### [Задача «Ctrl\\+X, Ctrl\\+V - 2»](https://new.contest.yandex.ru/42157/problem?id=2109007/2022_10_20/VvDR4vqAfy)\n\n{% cut \"Условие\" %}\n\nЭта задача — продолжение предыдущей задачи `Ctrl+X, Ctrl+V`. В качестве основы вы можете взять код оттуда.\n\nПетя продолжает разработку своего текстового редактора. На этот раз добавилось еще одна операция — зажать клавишу Shift (`Shift`).\n\nОперации `Up` и `Down` при зажатой клавише Shift выделяют строки в текстовом редакторе. Если курсор находится на строке $n$, то после операций `Shift`, `Down`, `Down` выделенными окажутся строки $n$ и $n+1$.\n\nОперация `Ctrl+X` вырезает выделенные строки из файла в буфер. Операция `Ctrl+V` копирует строки из буфера, заменяя выделенные строки в файле.\n\nОперации `Ctrl+X` и `Ctrl+V` сбрасывают выделение после исполнения и отпускают клавишу `Shift`. Если при исполнении этих операций в файле не выделена ни одна строка, поведение должно соответствовать предыдущей задаче `Ctrl+X, Ctrl+V`.\n\n#### Формат ввода\n\nПрограмме на вход подаётся набор строк, разделённых переносом строки. Длина каждой строки не превышает 3000 символов. Последняя строка в файле является пустой. Она означает завершение ввода файла. Других пустых строк в файле быть не может.\n\nПосле этого и до окончания ввода программе подаются команды `Down`, `Up`, `Ctrl+X`, `Ctrl+V`, `Shift`.\n\n#### Формат вывода\n\nВыведите получившийся файл построчно.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nMy\u003cbr/\u003eprogram\u003cbr/\u003eis\u003cbr/\u003eawful\u003cbr/\u003ebad\u003cbr/\u003epoor\u003cbr/\u003ewrong\u003cbr/\u003eawesome\u003cbr/\u003e\u003cbr/\u003eDown\u003cbr/\u003eDown\u003cbr/\u003eDown\u003cbr/\u003eShift\u003cbr/\u003eDown\u003cbr/\u003eDown\u003cbr/\u003eDown\u003cbr/\u003eDown\u003cbr/\u003eCtrl\\+X\n\n|\n\nMy\u003cbr/\u003eprogram\u003cbr/\u003eis\u003cbr/\u003eawesome\u003cbr/\u003e\n\n||\n|#\n\n#### Примечание\n\nДля вырезания строк из файла в буфер удобно использовать функцию [splice](https://en.cppreference.com/w/cpp/container/list/splice). Разберитесь самостоятельно по документации, как она устроена.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nКак и рекомендуется в условии, возьмём за основу код из предыдущей задачи. Однако теперь в качестве буфера у нас будет не одна строка, а лист строк.\n\nТакже нам понадобятся дополнительные переменные для обработки нажатия клавиши `Shift`:\n\n* В логической переменной `shiftPressed` будем поддерживать текущее состояние клавиши: `true` если клавиша нажата\n  и `false` если нет.\n* В переменной `shift` будем хранить указатель на строчку, на которой произошло нажатие клавиши `Shift`.\n* В переменной `shiftOffset` будем поддерживать разность номера строки где сейчас находится курсор и номера\n  строки на которой была нажата клавиша `Shift`.\n\nДалее будем последовательно обрабатывать команды.\n\n1. **Команда `Up`**.\n   Добавим проверку нажата ли сейчас клавиша `Shift`. Если нажата – уменьшим `shiftOffset` на единицу. Иначе передвинем указатель `shift` вместе с курсором.\n\n2. **Команда `Down`**.\n   Аналогично команде `Up`, только здесь мы будем увеличивать `shiftOffset` на единицу.\n\n3. **Команда `Shift`**.\n   Единственное, что мы должны сделать при вызове этой команды – поставить переменной `shiftPressed` значение `true`.\n\n4. **Команда `Ctrl+X`**.\n   Воспользуемся функцией `.splice`, которая позволит нам эффективно и без копирования «вырезать» элементы из одного листа и вставить их в другой. Достаточно лишь передать этой функции два итератора `cursor` и `shift`. Воспользуемся переменной `shiftOffset` чтобы понять, какой из этих двух итераторов должен идти первым. Также нужно корректно обработать операцию `Ctrl+X` без зажатой клавиши `Shift` (`cursor == shift`). В таком случае необходимо заранее сделать копию курсора, иначе после операции `.splice` старый курсор будет ссылаться на элемент в буфере, а не в файле. В конце не забудем «обнулить» все переменные, связанные с клавишей `Shift`.\n\n5. **Команда `Ctrl+V`**.\n   Сначала сделаем операцию `.erase`, аналогично определяя порядок итераторов с помощью `shiftOffset`. После сделаем `.insert`, передав ему итераторы на наш буфер. В конце также не забудем обнулить `Shift` переменные.\n\nИтоговое решение:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::list\u003cstd::string\u003e file;\n\n    while (true) {\n        std::string line;\n        std::getline(std::cin, line);\n\n        if (line.empty()) {\n            break;\n        }\n\n        file.push_back(line);\n    }\n\n    auto cursor = file.begin();\n\n    std::list\u003cstd::string\u003e buffer;\n\n    bool shiftPressed = false;\n    int shiftOffset = 0;\n    auto shift = file.begin();\n\n    std::string command;\n    while (std::cin \u003e\u003e command) {\n        if (command == \"Up\") {\n            if (cursor == file.begin()) {\n                continue;\n            }\n\n            --cursor;\n            if (!shiftPressed) {\n                shift = cursor;\n            } else {\n                --shiftOffset;\n            }\n        } else if (command == \"Down\") {\n            if (cursor == file.end()) {\n                continue;\n            }\n\n            ++cursor;\n            if (!shiftPressed) {\n                shift = cursor;\n            } else {\n                ++shiftOffset;\n            }\n        } else if (command == \"Ctrl+X\") {\n            if (shift == cursor \u0026\u0026 cursor == file.end()) {\n                continue;\n            }\n\n            buffer.clear();\n\n            if (shift == cursor) {\n                auto toSplice = cursor;\n                cursor = std::next(cursor);\n                buffer.splice(buffer.begin(), file, toSplice);\n            } else if (shiftOffset \u003c 0) {\n                buffer.splice(buffer.begin(), file, cursor, shift);\n                cursor = shift;\n            } else {\n                buffer.splice(buffer.begin(), file, shift, cursor);\n            }\n\n            shiftPressed = false;\n            shift = cursor;\n            shiftOffset = 0;\n        } else if (command == \"Ctrl+V\") {\n            if (buffer.empty()) {\n                continue;\n            }\n\n            if (shiftOffset \u003c 0) {\n                cursor = file.erase(cursor, shift);\n            } else if (shiftOffset \u003e 0) {\n                cursor = file.erase(shift, cursor);\n            }\n\n            file.insert(cursor, buffer.begin(), buffer.end());\n\n            shiftPressed = false;\n            shift = cursor;\n            shiftOffset = 0;\n        } else if (command == \"Shift\") {\n            shiftPressed = true;\n        }\n    }\n\n    for (const auto \u0026x: file) {\n        std::cout \u003c\u003c x \u003c\u003c \"\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n----------\n\n## Параграф «Ассоциативные контейнеры»\n\n### [Задача «Встречалось ли число раньше?»](https://new.contest.yandex.ru/42072/problem?id=40119/2022_10_29/g5xZUGXJmv)\n\n{% cut \"Условие\" %}\n\nНа вход подаётся последовательность целых чисел. Для каждого числа выведите в отдельной строке слово `YES`, если это число ранее встречалось в последовательности, и `NO`, если не встречалось.\n\n#### Формат ввода\n\nВводится список чисел. Все числа списка находятся на одной строке и разделены пробелом. Каждое число представимо типом `int`.\n\n#### Формат вывода\n\nВыведите ответ на задачу.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1 2 1 2 2 1 6\n\n|\n\nNO\u003cbr\u003eNO\u003cbr\u003eYES\u003cbr\u003eYES\u003cbr\u003eYES\u003cbr\u003eYES\u003cbr\u003eNO\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nЭту задачу удобно решить через `std::set`, но так как нам не важен порядок элементов, то лучше будет использовать `std::unordered_set`. Будем сохранять прочитанные числа и выводить каждый раз `YES`, если это число уже есть в нашем множестве, и `NO` в противном случае. Не забудем сохранить само число во множестве.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cunordered_set\u003e\n\nint main() {\n    std::unordered_set\u003cint\u003e numbers;\n    int number;\n    while (std::cin \u003e\u003e number) {\n        if (numbers.contains(number)) {\n            std::cout \u003c\u003c \"YES\\n\";\n        } else {\n            std::cout \u003c\u003c \"NO\\n\";\n            numbers.insert(number);\n        }\n    }\n}\n```\n\nМожно было бы вместо вызова `contains` воспользоваться тем, что функция `insert` возвращает пару из итератора и успешности вставки:\n\n```cpp\n       if (numbers.insert(number).second) {\n           std::cout \u003c\u003c \"NO\\n\";\n       } else {\n           std::cout \u003c\u003c \"YES\\n\";\n       }\n```\n\n{% endcut %}\n\n### [Задача «Общие буквы»](https://new.contest.yandex.ru/42072/problem?id=40119/2022_10_29/sbcHkBgD9R)\n\n{% cut \"Условие\" %}\n\nВам даны слова. Выведите в алфавитном порядке список общих букв всех слов.\n\n#### Формат ввода\n\nНа вход поступают слова (по одному в строке), состоящие из маленьких латинских букв алфавита. Длина слов не превосходит 100 символов, а количество слов не превосходит 1000.\n\n#### Формат вывода\n\nВыведите в алфавитном порядке без пробелов список букв, которые присутствуют в каждом слове.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\napple\u003cbr\u003epeach\n\n|\n\naep\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nalpha\u003cbr\u003ebeta\u003cbr\u003egamma\u003cbr\u003edelta\u003cbr\u003eepsilon\n\n|\n\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВоспользуемся контейнером `std::map\u003cchar, int\u003e`. Будем для каждой буквы подсчитывать число слов, в которых эта буква встретилась. Затем напечатаем все буквы, которые встретились во всех словах.\n\nЕсли какая-то буква повторяется в слове, то важно не посчитать её дважды. Для этого сначала буквы всех слов сложим в `set` или `unordered_set`.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmap\u003e\n#include \u003cset\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::map\u003cchar, int\u003e counter;\n    std::string word;\n    int wordsCount = 0;\n    while (std::cin \u003e\u003e word) {\n        ++wordsCount;\n        std::set\u003cchar\u003e letters(word.begin(), word.end());\n        for (char c : letters) {\n            ++counter[c];\n        }\n    }\n    for (auto [c, freq] : counter) {\n        if (freq == wordsCount) {\n            std::cout \u003c\u003c c;\n        }\n    }\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\n{% endcut %}\n\n### [Задача «Файловая система»](https://new.contest.yandex.ru/42072/problem?id=40119/2022_10_29/KrgTpE5yIH)\n\n{% cut \"Условие\" %}\n\nДан список всех файлов в некоторой файловой системе. Необходимо вывести все непустые директории этой файловой системы в лексикографическом порядке.\n\nГарантируется, что все пути начинаются от корня файловой системы. Все пути состоят из слешей (`/`), латинских символов, цифр и точек. Два слеша никогда не стоят подряд.\n\n#### Формат ввода\n\nНа вход подаются строки, описывающие пути ко всем файлам в системе. Каждый путь содержится в отдельной строке. Число строк не превосходит 10000.\n\n#### Формат вывода\n\nВыведите все непустые директории в этой файловой системе в лексикографическом порядке. Каждый путь должен начинаться со слеша и заканчиваться слешом.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n/docs/README.txt\u003cbr\u003e/docs/LICENSE.txt\u003cbr\u003e/boot/grub\u003cbr\u003e/init\n\n|\n\n/\u003cbr\u003e/boot/\u003cbr\u003e/docs/\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n/root/test.cpp\u003cbr\u003e/root/tests/01\u003cbr\u003e/root/tests/01.a\u003cbr\u003e/bin/bash\u003cbr\u003e\n\n|\n\n/\u003cbr\u003e/bin/\u003cbr\u003e/root/\u003cbr\u003e/root/tests/\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВоспользуемся контейнером `set`. Если нам дан путь к некоторому файлу, то все его родительские директории заведомо непустые. Надо будет аккуратно вырезать из этого пути все подстроки, которые заканчиваются на `/`, и сложить их в `set`.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cset\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::set\u003cstd::string\u003e dirs;\n    std::string path;\n    while (std::getline(std::cin, path)) {\n        for (size_t i = 0; i != path.size(); ++i) {\n            if (path[i] == '/') {\n                dirs.insert(path.substr(0, i + 1));\n            }\n        }\n    }\n    for (const auto\u0026 dir : dirs) {\n        std::cout \u003c\u003c dir \u003c\u003c \"\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Предметный указатель»](https://new.contest.yandex.ru/42072/problem?id=40119/2022_10_29/UPyDVMd6im)\n\n{% cut \"Условие\" %}\n\nПрофессор написал научную книгу и составил для неё предметный указатель. Это список ключевых слов, для каждого из которых указана страница, на которой это слово встречается. Теперь профессор хочет для каждой страницы выписать в алфавитном порядке все ключевые слова, которые на эту страницу попали (если такие вообще есть). Помогите профессору решить эту задачу.\n\n#### Формат ввода\n\nСначала задано натуральное число `n`, не превосходящее 1000 — количество слов, которое требуется обработать. Далее идут `n` строк. В каждой строке сначала записано ключевое слово. Затем идёт натуральное число, также не превосходящее 1000, — номер страницы. Ключевые слова состоят из латинских букв, не бывают пустыми и по длине не превосходят 16 символов. Слова в списке, конечно, могут повторяться.\n\n#### Формат вывода\n\nВыпишите в порядке возрастания все страницы, на которых присутствуют ключевые слова. После каждого номера страницы через пробел выпишите в алфавитном порядке сами эти слова. Если на какой-то странице слово встретилось несколько раз, то повторять его не нужно. Завершающего пробела в конце строк быть не должно.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5\u003cbr\u003ederivative 10\u003cbr\u003efunction 2\u003cbr\u003efunction 10\u003cbr\u003efunction 10\u003cbr\u003elimit 7\n\n|\n\n2 function\u003cbr\u003e7 limit\u003cbr\u003e10 derivative function\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВоспользуемся ассоциативным контейнером, который будет номерам страниц сопоставлять множества слов на этой странице. Так как в ответе надо вывести страницы по возрастанию, а слова — по алфавиту, то нам подойдут упорядоченные контейнеры `std::map` и `std::set`.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmap\u003e\n#include \u003cset\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::map\u003cint, std::set\u003cstd::string\u003e\u003e index;\n\n    int n;\n    std::cin \u003e\u003e n;\n    for (int i = 0; i \u003c n; ++i) {\n        std::string word;\n        int page;\n        std::cin \u003e\u003e word \u003e\u003e page;\n        index[page].insert(word);\n    }\n\n    for (const auto\u0026 [page, words] : index) {\n        std::cout \u003c\u003c page;\n        for (const auto\u0026 word : words) {\n            std::cout \u003c\u003c \" \" \u003c\u003c word;\n        }\n        std::cout \u003c\u003c \"\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Символьные n-граммы»](https://new.contest.yandex.ru/42072/problem?id=19924/2022_10_29/apwfymagGA)\n\n{% cut \"Условие\" %}\n\nБудем называть символьной $n$-граммой последовательность из $n$ последовательно идущих символов в одном слове в тексте. Для данного числа $n$ подсчитайте суммарное количество каждой $n$-граммы в тексте.\n\n#### Формат ввода\n\nВ первой строке заданы два числа: `m` — число слов в тексте (от 1 до 100000) и `n` — длина $n$-граммы (от 1 до 5). Далее идет $m$ слов. Можно считать, что слова отделены пробелами или переносами строк. Обработку пунктуации и регистра реализовывать не нужно. Читайте слова просто через `std::cin \u003e\u003e word`.\n\n#### Формат вывода\n\nВыведите все $n$-граммы, отсортированные по убыванию частоты, а в случае равных частот — лексикографически (по алфавиту). Для каждой $n$-граммы напечатайте также её частоту (смотрите формат в примере).\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n6 2\u003cbr\u003eto be or not to be\n\n|\n\nbe - 2\u003cbr\u003eto - 2\u003cbr\u003eno - 1\u003cbr\u003eor - 1\u003cbr\u003eot - 1\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nЗадача похожа на классическую задачу про подсчёт частоты слов в тексте, только вместо слов надо будет подсчитывать подстроки слов длины N.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003ctuple\u003e\n#include \u003cunordered_map\u003e\n#include \u003cutility\u003e\n#include \u003cvector\u003e\n\nint main() {\n    size_t m, n;\n    std::cin \u003e\u003e m \u003e\u003e n;\n\n    std::unordered_map\u003cstd::string, int\u003e freqs;\n\n    for (size_t i = 0; i != m; ++i) {\n        std::string word;\n        std::cin \u003e\u003e word;\n        for (size_t j = n; j \u003c= word.size(); ++j) {\n            ++freqs[word.substr(j - n, n)];\n        }\n    }\n\n    std::vector\u003cstd::pair\u003cstd::string, int\u003e\u003e sorted(freqs.begin(), freqs.end());\n    std::sort(\n        sorted.begin(),\n        sorted.end(),\n        [](const auto\u0026 p1, const auto\u0026 p2) {\n            return std::tie(p2.second, p1.first) \u003c std::tie(p1.second, p2.first);\n        }\n    );\n\n    for (const auto\u0026 [word, freq] : sorted) {\n        std::cout \u003c\u003c word \u003c\u003c \" - \" \u003c\u003c freq \u003c\u003c \"\\n\";\n    }\n}\n```\n\nПожалуй, самый нетривиальный фрагмент здесь — выделение подстрок:\n\n```cpp\nfor (size_t j = n; j \u003c= word.size(); ++j) {\n    ++freqs[word.substr(j - n, n)];\n}\n```\n\nЗдесь `j` пробегает все позиции *за* последним символом подстроки. Соотвественно, `j - n` — всевозможные начальные позиции подстрок длины `n`. Так организованный цикл защищён от случайных переполнений и вычитаний большего числа из меньшего в беззнаковом типе `size_t`. В таких конструкциях всегда полезно проверять себя на \"крайних\" случаях (например, когда `n` совпадает с `word.size()`).\n\nЕсли известно, что `n` мало по сравнению со средним размером слова, то более выгодным по скорости может оказаться другое решение: сначала сохраняем в `std::unordered_map` все слова, а сами $n$-граммы строим как `std::unordered_map\u003cstd::string_view, int\u003e`:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cstring_view\u003e\n#include \u003ctuple\u003e\n#include \u003cunordered_map\u003e\n#include \u003cutility\u003e\n#include \u003cvector\u003e\n\nint main() {\n    size_t m, n;\n    std::cin \u003e\u003e m \u003e\u003e n;\n\n    std::unordered_map\u003cstd::string, int\u003e words;\n    words.reserve(m);\n    for (size_t i = 0; i != m; ++i) {\n        std::string word;\n        std::cin \u003e\u003e word;\n        ++words[word];\n    }\n\n    std::unordered_map\u003cstd::string_view, int\u003e freqs;\n\n    for (const auto\u0026 [word, freq] : words) {\n        std::string_view sv = word;\n        for (size_t j = n; j \u003c= sv.size(); ++j) {\n            freqs[sv.substr(j - n, n)] += freq;\n        }\n    }\n\n    std::vector\u003cstd::pair\u003cstd::string_view, int\u003e\u003e sorted(freqs.begin(), freqs.end());\n    std::sort(\n        sorted.begin(),\n        sorted.end(),\n        [](const auto\u0026 p1, const auto\u0026 p2) {\n            return std::tie(p2.second, p1.first) \u003c std::tie(p1.second, p2.first);\n        }\n    );\n\n    for (const auto\u0026 [word, freq] : sorted) {\n        std::cout \u003c\u003c word \u003c\u003c \" - \" \u003c\u003c freq \u003c\u003c \"\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n----------\n\n## Параграф «Алгоритмы»\n\n### [Задача «Удвоить вектор»](https://new.contest.yandex.ru/42073/problem?id=10033/2022_10_29/YH1WWgN87I)\n\n{% cut \"Условие\" %}\n\nТребуется написать шаблонную функцию `Duplicate`, которая получает на вход вектор и дублирует все его элементы в конце вектора. Например, из вектора с элементами `1, 2, 3` должен получиться вектор с элементами `1, 2, 3, 1, 2, 3`. Вася написал вот такую реализацию, которая почему-то не работает:\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nvoid Duplicate(std::vector\u003cT\u003e\u0026 v) {\n    for (auto it = v.begin(); it != v.end(); ++it) {\n        v.push_back(*it);\n    }\n}\n```\n\nВам надо исправить код Васи.\n\n#### Примечания\n\nСдайте в систему только исправленный код функции `Duplicate` без функции `main`. Подключите все необходимые для вашей реализации библиотеки. Заголовок функции Вася написал правильно, в этом можете не сомневаться.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nРешение Васи не работает, так как в процессе вставки итераторы вектора инвалидируются и программа попадает в неопределённое поведение. Самый простой способ исправить проблему — переписать цикл через индексы. При этом исходный размер вектора надо запомнить в начале цикла. Это можно сделать прямо в секции инициализации цикла `for`:\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nvoid Duplicate(std::vector\u003cT\u003e\u0026 v) {\n    for (size_t n = v.size(), i = 0; i \u003c n; ++i) {\n        v.push_back(v[i]);\n    }\n}\n```\n\nДругой способ — зарезервировать в векторе заранее удвоенное число элементов. Тогда при вставке не будет происходить реаллокаций, и итераторы не будут инвалидироваться. Исходное решение заработает. Но его всё же удобнее переписать через алгоритм `copy`:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nvoid Duplicate(std::vector\u003cT\u003e\u0026 v) {\n    v.reserve(v.size() * 2);\n    std::copy(v.begin(), v.end(), std::back_inserter(v));\n}\n```\n\n{% endcut %}\n\n### [Задача «Алгоритм unique»](https://new.contest.yandex.ru/42073/problem?id=40119/2022_10_29/vp6XqmeWQ3)\n\n{% cut \"Условие\" %}\n\nВам надо написать свою реализацию стандартного алгоритма `unique`. Заголовок функции должен быть таким:\n\n```cpp\ntemplate \u003ctypename Iter\u003e\nIter Unique(Iter first, Iter last);\n```\n\nФункция должна переупорядочить элементы диапазона \\[`first`; `last`) так, чтобы подряд идущие одинаковые элементы в ней не встречались. Функция возвращает итератор за последний элемент итоговой последовательности. Что останется в пределах от этого вернувшегося итератора до старого `last` — не важно. Время работы функции должно линейно зависеть от длины диапазона.\n\n#### Примечания\n\nВ вашем решении должен быть только код этой шаблонной функции и не должно быть функции `main`. Использовать вызов `std::unique` нельзя.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nБудем идти по диапазону от начала до конца двумя итераторами. Первый итератор будет сдвигаться всегда на одну позицию вправо. А второй итератор будет проматывать повторы, сдвигаясь на ближайший правый элемент, отличный от текущего. Будем записывать значение из второго итератора в ячейку, на которую указывает первый итератор. В конце цикла первый итератор как раз будет указывать за последний записанный элемент.\n\n```cpp\ntemplate \u003ctypename Iter\u003e\nIter Unique(Iter first, Iter last) {\n    auto it1 = first;\n    auto it2 = first;\n    while (it2 != last) {\n        if (it1 != it2) {\n            *it1 = *it2;\n        }\n        ++it1;\n        const auto\u0026 value = *it2;\n        while (it2 != last \u0026\u0026 *it2 == value) {\n            ++it2;\n        }\n    }\n    return it1;\n}\n```\n\nЗаметим, что вместо `*it1 = *it2` правильнее было бы написать `*it1 = std::move(*it2)`, так как нам больше не потребуется значение в ячейке `*it2`, и у него можно отобрать владение. Это имеет смысл, если значения — сложные типы с нетривиальным копированием (например, контейнеры). Подробнее про move-семантику рассказано в [параграфе «Жизненный цикл объекта»](https://education.yandex.ru/handbook/cpp/article/object-lifetime).\n\n{% endcut %}\n\n### [Задача «Алгоритм set_difference»](https://new.contest.yandex.ru/42073/problem?id=40119/2022_10_29/4cf1Uxb6S8)\n\n{% cut \"Условие\" %}\n\nНапишите свою реализацию стандартного алгоритма `set_difference`. Заголовок функции должен быть таким:\n\n```cpp\ntemplate \u003ctypename InIter1, typename InIter2, typename OutIter\u003e\nOutIter SetDifference(InIter1 first1, InIter1 last1,\n                      InIter2 first2, InIter2 last2,\n                      OutIter out);\n```\n\nФункция должна сформировать элементы разности диапазонов \\[`first1`, `last1`) и \\[`first2`, `last2`) и записать их в последовательность, начинающуюся с `out`. Исходные диапазоны предполагаются отсортированными. Каждый элемент считается со своей кратностью. Функция должна вернуть итератор, который указывает за последний записанный элемент.\n\n#### Примечания\n\nВ вашем решении должен быть только код этой шаблонной функции и не должно быть функции `main`. Программа должна использовать константную память и быть линейной по сложности. Допускается сравнивать итераторы с помощью `==` и `!=`, а также сравнивать элементы с помощью `\u003c`. Использовать вызов `std::set_difference` нельзя.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nБудем идти двумя итераторами `it1` и `it2` по первому и второму диапазонам. Если текущий элемент во втором диапазоне меньше элемента в первом, то промотаем второй итератор вперёд. Если текущие элементы в диапазонах оказались разными, то элемент первого диапазона не встречается во втором и должен попасть в ответ. Если же элементы оказались равными, то нужно продвинуть оба итератора на одну позицию вперёд.\n\nВ реализации необходимо следить за тем, чтобы итераторы не вышли за допустимые границы. К тому же, сравнивать сами элементы можно только с помощью оператора `\u003c`.\n\n```cpp\ntemplate \u003ctypename InIter1, typename InIter2, typename OutIter\u003e\nOutIter SetDifference(InIter1 first1, InIter1 last1, InIter2 first2, InIter2 last2, OutIter out) {\n    auto it1 = first1;\n    auto it2 = first2;\n\n    while (it1 != last1) {\n        while (it2 != last2 \u0026\u0026 *it2 \u003c *it1) {\n            ++it2;\n        }\n        if (it2 == last2 || *it1 \u003c *it2) {\n            *out = *it1;\n            ++out;\n        } else if (it2 != last2) {\n            ++it2;\n        }\n        ++it1;\n    }\n    return out;\n}\n```\n\n{% endcut %}\n\n### [Задача «Приближённый двоичный поиск»](https://new.contest.yandex.ru/42073/problem?id=40119/2022_10_29/PZPR4i6N8p)\n\n{% cut \"Условие\" %}\n\nВ этой задаче нужно применить функцию `std::lower_bound` и итераторы для быстрого поиска ближайшего элемента в отсортированном массиве.\n\n#### Формат ввода\n\nВ первой строке входных данных содержатся натуральные числа `n` и `k`, не превосходящие 100000. Во второй строке задаются целых `n` чисел первого массива, отсортированного по неубыванию, а в третьей строке – `k` целых чисел второго массива. Каждое число в обоих массивах по модулю не превосходит $2 \\cdot 10^9$. Второй массив, в отличие от первого, не отсортирован.\n\n#### Формат вывода\n\nДля каждого из `k` чисел выведите в отдельной строке число из первого массива, наиболее близкое к данному. Если таких несколько, выведите меньшее из них.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nСложим числа первого массива в вектор. Второй массив складывать в вектор не нужно: мы сможем подбирать ближайший элемент из первого массива на лету. Оформим этот подбор в функции `Approx`. Она получает на вход первый массив и число `x` из второго массива. Так как первый массив отсортирован, то мы можем применить алгоритм `std::lower_bound`, чтобы бинарным поиском найти итератор первого элемента, большего или равного `x`. Дальше возможны такие взаимоисключающие случаи:\n\n1. Все числа в массиве меньше `x`. Тогда вернётся итератор `end()`. Достаточно вернуть последнее число из массива.\n2. Все числа в массиве больше `x`. Тогда вернётся итератор `begin()`. Возвращаем первое число из массива.\n3. В массиве есть число `x`. Его и возвращаем.\n4. В массиве есть числа как меньшие `x`, так и большие `x`, но нет самого `x`. Тогда надо сравнить с `x` два элемента: `*std::prev(iter) и *iter`.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003citerator\u003e\n#include \u003cvector\u003e\n\nint Approx(const std::vector\u003cint\u003e\u0026 v, int x) {\n    auto iter = std::lower_bound(v.begin(), v.end(), x);\n    if (iter == v.end()) {\n        return *std::prev(iter);\n    } else if (iter == v.begin()) {\n        return *iter;\n    } else if (*iter == x) {\n        return *iter;\n    } else {\n        int x1 = *std::prev(iter);\n        int x2 = *iter;\n        if (std::abs(x1 - x) \u003c= std::abs(x2 - x)) {\n            return x1;\n        } else {\n            return x2;\n        }\n    }\n}\n\nint main() {\n    int n, k;\n    std::cin \u003e\u003e n \u003e\u003e k;\n\n    std::vector\u003cint\u003e v(n);\n    for (int i = 0; i != n; ++i) {\n        std::cin \u003e\u003e v[i];\n    }\n\n    for (int i = 0; i != k; ++i) {\n        int x;\n        std::cin \u003e\u003e x;\n        std::cout \u003c\u003c Approx(v, x) \u003c\u003c \"\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Функция Process»](https://new.contest.yandex.ru/42073/problem?id=40119/2022_10_29/54CFSrAxvL)\n\n{% cut \"Условие\" %}\n\nАндрею надо написать шаблонную функцию `Process`, которая обрабатывает вектор с числами некоторого типа `T`. Его функция должна вызвать другую функцию `PrintResults`, чтобы напечатать с определенным форматированием положительные числа из вектора. Функция `PrintResults` принимает на вход пару итераторов, как и многие алгоритмы стандартной библиотеки. Поэтому Андрей решил сначала скопировать нужные элементы исходного вектора в другой массив, чтобы передать его начало и конец в эту функцию.\nВот код Андрея:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nvoid Process(const std::vector\u003cT\u003e\u0026 data) {\n    std::vector\u003cT\u003e filtered;\n\n    auto filteredLast = std::copy_if(\n        data.begin(),\n        data.end(),\n        filtered.begin(),\n        [](const T\u0026 x) { return x \u003e 0; }\n    );\n\n    PrintResults(filtered.begin(), filteredLast);\n}\n```\n\nЭтот код почему-то не работает. Найдите ошибку и сдайте исправленное решение.\n\n#### Примечания\n\nВам нужно сдать только исправленный код Андрея. В вашей программе не должно быть функции `main`.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nПроблема в том, что в решении Андрея применяется алгоритм `std::copy_if` к пустой выходной последовательности. Правильнее всего будет воспользоваться функций `std::back_inserter`. Теперь можно не запоминать результат работы `copy_if`: он всё равно будет равен `filtered.end()`.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003citerator\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nvoid Process(const std::vector\u003cT\u003e\u0026 data) {\n    std::vector\u003cT\u003e filtered;\n\n    std::copy_if(\n        data.begin(),\n        data.end(),\n        std::back_inserter(filtered),\n        [](const T\u0026 x) { return x \u003e 0; }\n    );\n\n    PrintResults(filtered.begin(), filtered.end());\n}\n```\n\n{% endcut %}\n\n----------\n\n## Параграф «Адаптеры и представления»\n\n### [Задача «Скобочная последовательность»](https://new.contest.yandex.ru/42077/problem?id=1172064/2022_10_29/UIG8ykjc3J)\n\n{% cut \"Условие\" %}\n\nНа вход подаётся скобочная последовательность — строка, которая состоит из скобок `()[]{}`. Вам нужно определить, является ли она *[правильной](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BA%D0%BE%D0%B1%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C)*. В правильной скобочной последовательности каждой открывающей скобке соответствует закрывающая и пары скобок корректно вложены друг в друга.\n\n#### Формат ввода\n\nСтрока, состоящая из символов `()[]{}`.\n\n#### Формат вывода\n\nНапечатайте `YES`, если скобочная последовательность является правильной, и `NO` в противном случае.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n(\\{\\{\\{\\[\\]\\})\n\n|\n\nNO\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n\\}()\\[\\]\\{\n\n|\n\nNO\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n\\{(())()\\}\\[\\]\n\n|\n\nYES\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВоспользуемся адаптером `std::stack`. Будем помещать в стек открывающие скобки. Если нам встретилась закрывающая скобка, то убедимся, что она соответствует открывающей скобке на вершине стека и уберём из стека эту вершину. Скобочная последовательность будет правильной, если в конце стек окажется пустым. Удобно оформить этот алгоритм в виде функции `IsCorrect`, которая принимает строку.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstack\u003e\n#include \u003cstring\u003e\n\nbool IsCorrect(const std::string\u0026 sequence) {\n    std::stack\u003cchar\u003e brackets;\n\n    for (char bracket : sequence) {\n        if (bracket == '(' || bracket == '{' || bracket == '[') {\n            brackets.push(bracket);\n        } else {\n            if (brackets.empty()) {\n                return false;\n            }\n            char top = brackets.top();\n            if ((top == '(' \u0026\u0026 bracket == ')') || (top == '{' \u0026\u0026 bracket == '}') || (top == '[' \u0026\u0026 bracket == ']')) {\n                brackets.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n\n    return brackets.empty();\n}\n\nint main() {\n    std::string sequence;\n    std::getline(std::cin, sequence);\n    if (IsCorrect(sequence)) {\n        std::cout \u003c\u003c \"YES\\n\";\n    } else {\n        std::cout \u003c\u003c \"NO\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Минимум на отрезке»](https://new.contest.yandex.ru/42077/problem?id=40119/2022_10_29/CdMPDqJ9uc)\n\n{% cut \"Условие\" %}\n\nРассмотрим последовательность целых чисел длины $n$. По ней с шагом 1 двигается «окно» длины $k$. Другими словами, сначала в «окне» видны первые $k$ чисел, на следующем шаге в «окне» уже будут находиться $k$ чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить в нём минимальное число.\n\n#### Формат ввода\n\nВ первой строке входных данных содержатся два натуральных числа $n$ и $k$ — длины последовательности и «окна». При этом $n \\leqslant 150000$, $k \\leqslant 10000$, $k \\leqslant n$. На следующей строке находятся $n$ чисел — сама последовательность.\n\n#### Формат вывода\n\nВыходые данные должны содержать $n - k + 1$ строк — минимумы для каждого положения «окна».\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7 3\u003cbr\u003e1 3 2 4 5 3 1\n\n|\n\n1\u003cbr\u003e2\u003cbr\u003e2\u003cbr\u003e3\u003cbr\u003e1\n\n||\n|#\n\n#### Примечание\n\nДля решения задачи рекомендуется использовать `std::multiset` для хранения окна. Решение с непосредственным подсчётом минимума для каждого положения окна будет неэффективным.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nС одной стороны, нам потребуется хранить последовательность чисел в окне, чтобы знать, в каком порядке они будут выходить из окна. Можно было бы сложить все числа в `std::vector`, но это слишком расточительно. Достаточно хранить только элементы из окна. На эту роль отлично подходит адаптер `std::queue`.\n\nС другой стороны, нам надо уметь быстро находить минимальный элемент в окне. Для этого можно воспользоваться контейнером `std::multiset` (числа могут повторяться, поэтому `std::set` не подойдёт).\n\nИтак, алгоритм таков:\n\n1. Добавляем в окно новый элемент.\n2. Если окно заполнено, то печатаем минимальный элемент окна и удаляем из него крайний элемент.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cqueue\u003e\n#include \u003cset\u003e\n\nint main() {\n    int n, k;\n    std::cin \u003e\u003e n \u003e\u003e k;\n\n    std::queue\u003cint\u003e numbers;\n    std::multiset\u003cint\u003e window;\n\n    for (int i = 1; i \u003c= n; ++i) {\n        int x;\n        std::cin \u003e\u003e x;\n        numbers.push(x);\n        window.insert(x);\n        if (i \u003e= k) {\n            std::cout \u003c\u003c *window.begin() \u003c\u003c \"\\n\";\n            auto iter = window.find(numbers.front());\n            window.erase(iter);\n            numbers.pop();\n        }\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Очередь с приоритетами»](https://new.contest.yandex.ru/42077/problem?id=40119/2022_10_29/e5HA34aJZA)\n\n{% cut \"Условие\" %}\n\nНапишите программу, которая будет обрабатывать последовательность запросов таких видов:\n\n1. `CLEAR` — сделать очередь с приоритетами пустой (если в очереди уже были какие-то элементы, то удалить все).\n\n2. `ADD n` — добавить в очередь с приоритетами число `n` (вмещается в стандартный тип `int`).\n\n3. `EXTRACT` — вынуть из очереди с приоритетами максимальное значение. Следует изменить данные в памяти и вывести на экран найденное максимальное значение, или, если очередь была пустой, слово `CANNOT`.\n\n#### Формат ввода\n\nВо входных данных записана произвольная последовательность запросов `CLEAR`, `ADD` и `EXTRACT` — каждый в отдельной строке. Суммарное количество всех запросов не превышает 200000.\n\n#### Формат вывода\n\nДля каждого запроса типа `EXTRACT` выведите его результат в отдельной строке.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nADD 192168812\u003cbr\u003eADD 125\u003cbr\u003eADD 321\u003cbr\u003eEXTRACT\u003cbr\u003eEXTRACT\u003cbr\u003eCLEAR\u003cbr\u003eADD 7\u003cbr\u003eADD 555\u003cbr\u003eEXTRACT\u003cbr\u003eEXTRACT\u003cbr\u003eEXTRACT\n\n|\n\n192168812\u003cbr\u003e321\u003cbr\u003e555\u003cbr\u003e7\u003cbr\u003eCANNOT\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nНазвание задачи подсказывает, что нужно использовать контейнер `std::priority_queue`. Фактически, нужно реализовать обработчик команд. Так как отдельной функции `clear` у адаптеров нет, то придётся очищать очередь поэлементно.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cqueue\u003e\n\nint main() {\n    std::priority_queue\u003cint\u003e pq;\n\n    std::string command;\n    while (std::cin \u003e\u003e command) {\n        if (command == \"CLEAR\") {\n            while (!pq.empty()) {\n                pq.pop();\n            }\n        } else if (command == \"ADD\") {\n            int x;\n            std::cin \u003e\u003e x;\n            pq.push(x);\n        } else if (command == \"EXTRACT\") {\n            if (pq.empty()) {\n                std::cout \u003c\u003c \"CANNOT\\n\";\n            } else {\n                std::cout \u003c\u003c pq.top() \u003c\u003c \"\\n\";\n                pq.pop();\n            }\n        }\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Next token»](https://new.contest.yandex.ru/42077/problem?id=40119/2022_10_29/l4jzh9nNId)\n\n{% cut \"Условие\" %}\n\nВам надо написать функцию `NextToken` для выделения очередного токена в строке. Токеном считается последовательность символов до указанного символа-разделителя (или до конца строки).\n\nИспользоваться функция будет примерно так:\n\n```cpp\nint main() {\n    std::string_view sv = \"Hello world and good bye\";\n\n    const char delimiter = ' ';\n    std::string_view token;\n\n    // Делим строку на токены по разделителю и перебираем эти токены:\n    while (NextToken(sv, delimiter, token)) {\n        // обрабатываем очередной token\n        // например, печатаем его на экране:\n        std::cout \u003c\u003c token \u003c\u003c \"\\n\";\n    }\n}\n```\n\nРезультатом выполнения такой программы будет\n\n```\nHello\nworld\nand\ngood\nbye\n```\n\nСдайте только код функции `NextToken` и подключите необходимые библиотеки. Ваша функция будет скомпилирована с нашей функцией `main`. Гарантируется, что входная строка не заканчивается на разделитель. Догадайтесь сами, какие аргументы должна принимать функция `NextToken`. Эта функция может менять первый аргумент (`sv`).\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nПервый аргумент функции имеет тип `std::string_view`: это не самостоятельная строка, а отсылка к подстроке какой-то другой строки. По условию задачи её можно изменять. Будем при каждом вызове функции сдвигать её к началу следующего токена. Для этого будем этот аргумент будем принимать по ссылке. Аналогично, последний аргумент функции тоже изменяется (в него должен быть записан токен), поэтому он тоже должен быть принят по ссылке.\n\nЗаметим, что функция возвращает `false`, если токенов больше нет.\n\n```cpp\n#include \u003cstring_view\u003e\n\nbool NextToken(std::string_view\u0026 sv, char delim, std::string_view\u0026 tok) {\n    if (sv.empty()) {\n        return false;\n    }\n\n    auto pos = sv.find(delim);\n    if (pos != sv.npos) {  // разделитель найден\n        tok = sv.substr(0, pos);  // вырезаем очередной токен\n        sv.remove_prefix(pos + 1);  // сдвигаем sv за разделитель\n    } else {\n        tok = sv;\n        sv.remove_prefix(sv.size());  // формально тут получится пустая строка\n    }\n    return true;\n}\n```\n\nТакая функция не может отличить случай изначально пустой строки от случая последнего пустого токена в строке, которая заканчивается на разделитель. Однако по условию задачи это не важно.\n\n{% endcut %}\n\n### [Задача «Самые частотные слова»](https://new.contest.yandex.ru/42077/problem?id=1172064/2022_10_29/yGjwgu39bc)\n\n{% cut \"Условие\" %}\n\nВыведите `k` самых частотных слов текста и их частоты.\n\n#### Формат ввода\n\nВ первой строке указано натуральное число `k`, не превосходящее 1000. Далее идут строки текста объёмом до 1 Mб. Слова в тексте разделены пробелами или переводами строк. Различать регистр и обрабатывать пунктуацию не нужно.\n\n#### Формат вывода\n\nВ выводе должно быть не более `k` самых частотных слов текста. Через табуляцию после слова напечатайте его частоту. Слова должны быть упрядочены по убыванию частоты, а при равенстве частот — по алфавиту.\n\n#### Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\u003cbr\u003eto be or not to be\u003cbr\u003ethat is the question\n\n|\n\nbe\u0026tab;2\u003cbr\u003eto\u0026tab;2\u003cbr\u003eis\u0026tab;1\n\n||\n|#\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВ [параграфе про ассоциативные контейнеры](https://education.yandex.ru/handbook/cpp/article/associative-containers) мы рассматривали задачу про частотный словарь. Там мы печатали весь словарь целиком. В этой задаче требуется вывести только `k` самых частотных слов, где `k` мало по сравнению с размером словаря. Для этого можно было бы переложить слова в вектор и воспользоваться алгоритмом`partial_sort`:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003ctuple\u003e\n#include \u003cunordered_map\u003e\n#include \u003cutility\u003e\n#include \u003cvector\u003e\n\nint main() {\n    size_t k;\n    std::cin \u003e\u003e k;\n\n    // Подсчитываем частоты слов\n    std::unordered_map\u003cstd::string, int\u003e words;\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        ++words[word];\n    }\n\n    // Переносим слова и их частоты в вектор\n    std::vector\u003cstd::pair\u003cstd::string, int\u003e\u003e v(words.begin(), words.end());\n\n    // Находим максимальные k элементов\n    std::partial_sort(\n        v.begin(),\n        v.begin() + std::min(v.size(), k),  // k может оказаться больше размера вектора\n        v.end(),\n        [](const auto\u0026 p1, const auto\u0026 p2) { return std::tie(p2.second, p1.first) \u003c std::tie(p1.second, p2.first); }\n    );\n\n    // Печатаем топовые слова\n    for (size_t i = 0; i \u003c k \u0026\u0026 i \u003c v.size(); ++i) {\n        const auto\u0026 [word, freq] = v[i];\n        std::cout \u003c\u003c word \u003c\u003c \"\\t\" \u003c\u003c freq \u003c\u003c \"\\n\";\n    }\n}\n```\n\nРассмотрим аналогичное решение, где вместо `std::partial_sort` используется адаптер `std::priority_queue`. Мы будем поддерживать в очереди с приоритетами не более `k` элементов. В качестве значений положим туда пары из частоты и самого слова, причём частоту умножим на -1, чтобы она стала отрицательной. Этот трюк позволит выкидывать с вершины очереди пару с минимальной по модулю частотой, а в случае равенства частот — с лексикографически максимальным словом.\n\nКогда все слова будут обработаны, в очереди с приоритетами останутся нужные нам слова. Но извлекаться они будут в противоположном порядке. Чтобы получить правильный порядок, проще всего скопировать их в вектор и развернуть этот вектор наоборот.\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cqueue\u003e\n#include \u003cstring\u003e\n#include \u003cunordered_map\u003e\n#include \u003cutility\u003e\n#include \u003cvector\u003e\n\nint main() {\n    size_t k;\n    std::cin \u003e\u003e k;\n\n    std::unordered_map\u003cstd::string, int\u003e words;\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        ++words[word];\n    }\n\n    using TPair = std::pair\u003cint, std::string\u003e;  // удобный псевдоним для типа\n\n    std::priority_queue\u003cTPair\u003e pq;\n    for (const auto\u0026 [word, freq] : words) {\n        pq.push({-freq, word});  // нарочно кладём отрицательную частоту\n        if (pq.size() \u003e k) {\n            pq.pop();  // выкидываем элемент с минимальной (то есть, максимальной отрицательной) частотой\n        }\n    }\n\n    // Копируем элементы в вектор\n    std::vector\u003cTPair\u003e top;\n    top.reserve(k);\n\n    while (!pq.empty()) {\n        const auto\u0026 [freq, word] = pq.top();\n        top.push_back({-freq, word});  // возвращаем настоящую частоту\n        pq.pop();\n    }\n\n    // Переворачиваем вектор\n    std::reverse(top.begin(), top.end());\n\n    for (const auto\u0026 [freq, word] : top) {\n        std::cout \u003c\u003c word \u003c\u003c \"\\t\" \u003c\u003c freq \u003c\u003c \"\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n----------"])</script><script nonce="">self.__next_f.push([1,"69:T7938,"])</script><script nonce="">self.__next_f.push([1,"Классы похожи на структуры: это пользовательские типы данных, в которых хранятся *поля*. Синтаксически даже ключевые слова `struct` и `class` взаимозаменяемы (только объявления внутри `struct` по умолчанию публичны, а внутри `class` — приватны, об этом ниже). Однако мы будем различать семантику структуры и класса:\n\n1. Мы будем использовать `struct` в типах, где не требуется сложная логика по инициализации и обработке значений. Структуры — это просто набор полей, не связанных какими-либо ограничениями. Типичный пример — `struct Point` из [параграфа «Составные типы данных»](https://education.yandex.ru/handbook/cpp/article/complex-data-types#struktury).\n\n2. Мы будем использовать `class` там, где требуются какие-либо действия при инициализации и обработке данных. Класс предполагает некоторый *инвариант*: он не позволяет изменить данные произвольным образом. Хороший пример — `class Time`, который мы рассмотрим ниже. Часы, минуты и секунды не могут быть произвольными числами, и класс должен гарантировать, что они всегда корректны.\n\nКласс, как и структура, задаёт тип данных, но дополнительно определяет его поведение. Переменные этого типа по традиции называются *объектами*.\n\n\n## Объявление класса\n\nРассмотрим сначала простую структуру, которая хранит число время в сутках в виде часов, минут и секунд:\n\n```cpp\nstruct Time {\n    int hours = 0;\n    int minutes = 0;\n    int seconds = 0;\n};\n```\n\nТакая структура очень проста, но она никак не проверяет корректность времени. Предполагается, что `hours` находится в пределах от 0 до 23, а `minutes` и `seconds` — от 0 до 59. Но никто не помешает нам присвоить им другие значения:\n\n```cpp\nint main() {\n    Time t;\n    t.hours = 42;\n    t.minutes = -5;\n    t.seconds = 61;\n}\n```\n\nЧтобы контролировать значения этих полей и гарантировать их корректность, объявим класс `Time`. Три наших поля в классе будут объявлены в [приватной](https://en.cppreference.com/w/cpp/language/access#Private_member_access), или закрытой области. Это значит, что доступ к ним будут иметь только особо указанные [дружественные функции](https://en.cppreference.com/w/cpp/language/friend) и [функции из класса](https://en.cppreference.com/w/cpp/language/member_functions) (member functions). Кстати, в других языках программирования функции из класса именуют *методами*, но в стандарте C++ термина «метод» нет.\n\nВ [публичной](https://en.cppreference.com/w/cpp/language/access#Private_member_access) области объявим *конструктор* для начальной инициализации переменной класса `Time` и три функции для чтения полей:\n\n```cpp\nclass Time {\nprivate:\n    int hours;\n    int minutes;\n    int seconds;\n\npublic:\n    Time(int h, int m, int s);  // объявляем конструктор\n\n    // Объявляем три функции для чтения полей:\n    int GetHours() const;\n    int GetMinutes() const;\n    int GetSeconds() const;\n};\n```\n\nЗдесь мы пока только *объявили* эти функции, но пока не написали их тела. Мы это сделаем чуть позже. А пока обратите внимание, что конструктор — это особая функция, которая вызывается при создании объекта. Имя конструктора совпадает с именем класса, а возвращаемое значение не указывается. Три функции `GetHours`, `GetMinutes` и `GetSeconds` объявлены *константными* — с пометой `const` в конце. Это значит, что эти функции не могут менять состояние объекта (в нашем случае — не изменяют значения полей `hours`, `minutes` и `seconds`).\n\nФактически мы скрыли детали реализации нашего класса и предоставили [публичный интерфейс](https://en.wikipedia.org/wiki/Class_(computer_programming)#The_concept_of_class_interface) — набор функций, через которые можно что-то сделать с объектом.\n\n\n## Определение функций из класса\n\nДавайте теперь *определим* эти функции, — то есть, напишем их тела. Это можно сделать прямо внутри объявления класса (и дальше мы будем для краткости писать их именно так). Но, вообще говоря, определить функцию из класса можно и отдельно. Пишем после объявления класса:\n\n```cpp\nTime::Time(int h, int m, int s) {\n    if (s \u003c 0 || s \u003e 59) {\n        // обрабатываем ошибочные секунды\n    }\n    if (m \u003c 0 || m \u003e 59) {\n        // обрабатываем ошибочные минуты\n    }\n    if (h \u003c 0 || h \u003e 23) {\n        // обрабатываем ошибочные часы\n    }\n    hours = h;\n    minutes = m;\n    seconds = s;\n}\n\nint Time::GetHours() const {\n    return hours;\n}\n\nint Time::GetMinutes() const {\n    return minutes;\n}\n\nint Time::GetSeconds() const {\n    return seconds;\n}\n```\n\nОбратите внимание, что при внешнем определении функции из класса мы предваряем её имя префиксом с именем класса и двумя двоеточиями. Это напоминает пространства имён (вспомните, что мы везде пишем `std::` перед именами из стандартной библиотеки).\n\nКаждая такая функция из класса неявно применяется к текущему объекту. Например, вызов `t.GetHours()` в этом коде будет применён к объекту `t`:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    Time t(13, 30, 0);  // 13:30:00\n    std::cout \u003c\u003c t.GetHours() \u003c\u003c \"\\n\";  // 13\n}\n```\n\nТела функций из класса написаны так, как будто поля этого неявно переданного объекта попали в текущую область видимости. Сам же этот объект доступен в теле функции через указатель `this`. Можно было бы написать\n\n```cpp\nint Time::GetHours() const {\n    return this-\u003ehours;  // то же самое, что (*this).hours\n}\n```\n\nНо так обычно не пишут. То, что `this` — это указатель, а не более удобная ссылка, — историческое недоразумение.\n\n\nОбратите внимание, что теперь из кода любой другой функции, которая не является функцией из класса, нельзя обратиться к полям и изменить их:\n\n```cpp\nint main() {\n    Time t(13, 30, 0);\n    t.hours = 42;  // ошибка компиляции: приватное поле недоступно!\n}\n```\n\n\nСледует отличать функции из класса от обычных функций. Например, вот это — самая обычная функция, которая просто принимает аргумент типа `Time`:\n\n```cpp\nbool IsAfternoonTime(const Time\u0026 time) {\n    return time.GetHours() \u003e= 12;\n}\n\n#include \u003ciostream\u003e\n\nint main() {\n    Time t(13, 30, 0);\n    if (IsAfternoonTime(t)) {  // вызываем обычную функцию\n        std::cout \u003c\u003c t.GetHours() - 12 \u003c\u003c \"PM\\n\";  // вызываем функцию из класса\n    }\n}\n```\n\nОбратите внимание, что у внешней функции `IsAfternoonTime` никакой пометы `const` указывать не нужно: сведения о константности уже заложены в описание типа параметра `time`.\n\n\n## Конструктор и обработка ошибок\n\nВернёмся к нашему конструктору. Мы пока не написали в нём код обработки ошибочных аргументов. Было бы слишком плохо просто выйти из конструктора в случае ошибки:\n\n```cpp\nTime::Time(int h, int m, int s) {\n    if (s \u003c 0 || s \u003e 59) {\n        return;\n    }\n    // ...\n}\n```\n\nВ таком случае как ни в чём не бывало был бы создан объект, причём его поля никак не были бы проинициализированы. Поскольку у полей примитивный тип `int`, то в них, как и в непроинициализированных локальных переменных, содержался бы «мусор»:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    Time t(42, -5, 61);\n\n    // Неопределённое поведение: может быть напечатано всё, что угодно:\n    std::cout \u003c\u003c t.GetHours() \u003c\u003c \"\\n\";\n}\n```\n\nПрограммисту надо решить, как должен вести себя конструктор в этой ситуации. Есть два варианта:\n\n1. Сгенерировать *исключение* — специальное сообщение об ошибке.\nРабота конструктора в этом случае прерывается. Объект не считается созданным. Такое исключение должно быть перехвачено специальным обработчиком `try`/`catch`. Подробнее об исключениях мы будем говорить в [отдельном параграфе](https://education.yandex.ru/handbook/cpp/article/exceptions), а пока просто научимся их генерировать:\n\n    ```cpp\n    #include \u003cstdexcept\u003e\n    \n    Time::Time(int h, int m, int s) {\n        if (s \u003c 0 || s \u003e 59 || m \u003c 0 || m \u003e 59 || h \u003c 0 || h \u003e 23) {\n            throw std::out_of_range(\"Wrong time!\");\n        }\n        // ...\n    }\n    ```\n\n2. Всё же создать объект, выполнив инициализацию его полей какими-то значениями.\nДавайте сейчас поступим именно таким способом. Приведём часы, минуты и секунды к привычной шкале, перекидывая лишнее в другие разряды.\n\n    ```cpp\n    Time::Time(int h, int m, int s) {\n        m += s / 60;\n        s %= 60;\n        // Если s было отрицательным, то остаток тоже будет отрицательным\n        if (s \u003c 0) {\n            // Уменьшим в этом случае минуты и сделаем секунды положительными\n            m -= 1;\n            s += 60;\n        }\n\n        h += m / 60;\n        m %= 60;\n        if (m \u003c 0) {\n            h -= 1;\n            m += 60;\n        }\n\n        h %= 24;\n        if (h \u003c 0) {\n            h += 24;\n        }\n\n        hours = h;\n        minutes = m;\n        seconds = s;\n    }\n    ```\n\n    Теперь все создаваемые объекты класса `Time` будут поддерживать инвариант «время задано корректно в пределах от 00:00:00 до 23:59:59»:\n\n    ```cpp\n    int main() {\n        Time t1(10, 18, -5);  // 10:17:55\n        Time t2(25, 10, 42);  // 01:10:42\n        Time t3(23, 59, 61);  // 00:00:01\n    }\n    ```\n\n\n## Перегрузка конструкторов\n\nЗаметим, что нельзя создать объект, не указав параметры конструктора или указав их неправильно:\n\n```cpp\nint main() {\n    Time t;  // ошибка компиляции: у класса Time нет конструктора без аргументов!\n    Time t2(3600);  // ошибка компиляции: у класса Time нет конструктора от одного аргумента!\n}\n```\n\nОднако в классе может быть несколько конструкторов. Добавим перегруженные версии для конструктора без аргументов (он будет инициализировать время нулями) и для конструктора, получающего число секунд с начала дня. Удобно будет указать нулевые значения наших полей в качестве значений по умолчанию.\n\n```cpp\nclass Time {\nprivate:\n    int hours = 0;\n    int minutes = 0;\n    int seconds = 0;\n\npublic:\n    Time() = default;\n\n    Time(int h, int m, int s);  // этот конструктор уже был написан раньше\n\n    Time(int s): Time(0, 0, s) {\n    }\n};\n```\n\nЗдесь мы объявили конструктор `Time()` с пометой `default`. Это значит, что компилятор сгенерирует его по умолчанию (в данном случае с пустым телом). Такая пометка встретится нам дальше при изучении других специальных функций класса. Конечно, мы могли бы просто написать тут пустое тело, но `default` здесь выразительнее.\n\nКонструктор `Time(int s)` объявлен [делегирующим](https://en.cppreference.com/w/cpp/language/constructor#Delegating_constructor): он ссылается на другой конструктор.\n\nПодробнее про конструкторы мы поговорим в [параграфе о жизненном цикле объектов](https://education.yandex.ru/handbook/cpp/article/object-lifetime).\n\n\n## Константные и неконстантные функции из класса\n\nСейчас мы можем проинициализировать объекты класса `Time` только в момент создания и далее никак не можем их изменить. Они пока ведут себя как константы. Давайте теперь добавим в класс функции для изменения состояния объекта. Напишем функцию `AddSeconds`, которая добавляет ко времени заданное количество секунд. Для краткости определим её тело прямо внутри объявления класса, а тела конструктора и `Get`-функций не будем повторять:\n\n```cpp\nclass Time {\nprivate:\n    int hours, minutes, seconds;\n\npublic:\n    Time(int h, int m, int s);\n\n    int GetHours() const;\n    int GetMinutes() const;\n    int GetSeconds() const;\n\n    void AddSeconds(int s) {\n        seconds += s;\n        // дальше следует выполнить такие же преобразования, как в конструкторе\n    }\n};\n```\n\nФункцию `AddSeconds` мы не объявили константной, так как она изменяет поля объекта. Однако вызвать такую функцию у константного объекта, конечно, не получится:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    Time t(10, 8, 0);  // 10:08:00\n    t.AddSeconds(40);  // 10:08:40\n\n    // Константная ссылка: через псевдоним cref объект нельзя изменять\n    const Time\u0026 cref = t;\n\n    // Константную функцию из класса вызвать можно\n    std::cout \u003c\u003c cref.GetHours() \u003c\u003c \"\\n\";  // OK\n\n    // Неконстантную функцию из класса нельзя вызвать у константной сущности\n    cref.AddSeconds(20);  // ошибка компиляции\n}\n```\n\n{% cut \"Удобно оформить нормализацию в виде отдельной приватной функции `Normalize`.\" %}\n\nЕё потребуется вызывать только в конструкторе и в функции `AddSeconds`, а внешним пользователям класса она не нужна. Фактически, эта функция будет поддерживать [*инвариант класса*](https://en.wikipedia.org/wiki/Class_invariant).\n\n```cpp\nclass Time {\nprivate:\n    int hours, minutes, seconds;\n\n    void Normalize() {\n        minutes += seconds / 60;\n        seconds %= 60;\n        if (seconds \u003c 0) {\n            minutes -= 1;\n            seconds += 60;\n        }\n\n        hours += minutes / 60;\n        minutes %= 60;\n        if (minutes \u003c 0) {\n            hours -= 1;\n            minutes += 60;\n        }\n\n        hours %= 24;\n        if (hours \u003c 0) {\n            hours += 24;\n        }\n    }\n\npublic:\n    Time(int h, int m, int s) {\n        hours = h;\n        minutes = m;\n        seconds = s;\n        Normalize();\n    }\n\n    void AddSeconds(int s) {\n        seconds += s;\n        Normalize();\n    }\n\n    int GetHours() const;\n    int GetMinutes() const;\n    int GetSeconds() const;\n};\n```\n\nКстати, более правильный синтаксис для нашего конструктора такой:\n\n```cpp\nclass Time {\n    // ...\n\npublic:\n    Time(int h, int m, int s):\n        hours(h),  // явно указываем, как инициализировать поля\n        minutes(m),\n        seconds(s)\n    {\n        Normalize();\n    }\n```\n\nМы подробнее поговорим об этом в [параграфе «Жизненный цикл объекта»](https://education.yandex.ru/handbook/cpp/article/object-lifetime).\n\n{% endcut %}\n\n\n\n## Перегрузка операторов\n\nВместо вызова `t.AddSeconds(40)` было бы заманчиво написать просто `t += 40`. Для этого нужно [перегрузить](https://en.cppreference.com/w/cpp/language/operators) соответствующие арифметические операторы для нашего класса. А для этого достаточно переименовать нашу функцию `AddSeconds` в `operator +=`.\n\nСогласно канонам, такой оператор обычно возвращает ссылку на текущий объект `*this`. В выражении `t += 40` это возвращаемое значение игнорируется, однако оно позволяет писать странные цепочки вида `(t += 40) += 20`. Не будем отступать от традиции:\n\n```cpp\nclass Time {\n   // пропустим объявления полей и функций\n\npublic:\n   Time\u0026 operator += (int s) {\n       seconds += s;\n       Normalize();\n       return *this;\n   }\n};\n```\n\nАналогично, объявим `operator +` для сложения объекта `Time` и целого числа секунд. В отличие от оператора `+=` он будет создавать новый объект `Time`, а не модифицировать текущий.\n\n```cpp\nclass Time {\n   // ...\n\npublic:\n   Time operator + (int s) const {\n       return Time(hours, minutes, seconds + s);\n   }\n};\n```\n\nПроверяем:\n\n```cpp\nint main() {\n    Time t(13, 30, 0);\n    t += 40;  // теперь в t записано время 13:30:40\n\n    Time t2 = t + 20;  // объект t не изменился, а в t2 записано 13:31:00\n}\n```\n\nВообще-то этот оператор `+` мы могли бы объявить и как внешнюю функцию. Если интерфейс класса это позволяет сделать, то такой способ более предпочтителен:\n\n```cpp\nTime operator + (const Time\u0026 t, int s) {  // обратите внимание: тут не может быть модификатора const, это внешняя функция\n    return Time(t.GetHours(), t.GetMinutes(), t.GetSeconds() + s);\n}\n```\n\nБолее того, можно воспользоваться готовым оператором `+=`:\n\n```cpp\n// Принимаем t по значению, чтобы эту копию можно было изменить\nTime operator + (Time t, int s) {\n    t += s;\n    return t;\n}\n```\n\nБыло бы большой ошибкой возвращать из `operator +` значение по ссылке, как в `operator +=`. Действительно, в операторе `+` возвращается по значению новый объект, который был сконструирован локально. Ссылка на него сразу бы стала висячей.\n\n\nПерегрузим теперь оператор вычитания. Он позволит вычитать одно время из другого и получать число секунд между этими временными метками. Но сначала добавим в класс полезную функцию `TotalSeconds`, которая вернёт число секунд с начала суток:\n\n```cpp\nclass Time {\n   // ...\n\npublic:\n    int TotalSeconds() const {\n       return hours * 60 * 60 + minutes * 60 + seconds;\n    }\n};\n```\n\nТеперь можно определить `operator -` просто как внешнюю функцию:\n\n```cpp\nint operator - (const Time\u0026 t1, const Time\u0026 t2) {\n    return t1.TotalSeconds() - t2.TotalSeconds();\n}\n```\n\nПерегружать можно большинство операторов. Часто используется перегрузка оператора `()`, чтобы объект мог имитировать вызов функции. Особенно важно правильно перегружать оператор присваивания `=` там, где это нужно (мы встретимся с этим в [параграфe «Жизненный цикл объекта»](https://education.yandex.ru/handbook/cpp/article/object-lifetime)).\n\nПримерами перегрузок операторов у классов стандартной библиотеки являются оператор обращения по индексу в массиве `[]` у контейнеров `std::vector` и `std::map`, или оператор `\u003c\u003c` для вывода в поток. Встречаются и экзотические случаи вроде перегрузки оператора `/` для [формирования пути в файловой системе](https://en.cppreference.com/w/cpp/filesystem/path/operator_slash) или [конструирования дат](https://en.cppreference.com/w/cpp/chrono/operator_slash). Однако в общем случае, если речь не идёт о математическом классе, контейнере или потоковом вводе-выводе, увлекаться перегрузкой операторов не стоит.\n\n\n## Перегрузка операторов ввода-вывода\n\nОператоры `\u003c\u003c` и `\u003e\u003e` на самом деле применяются к целым числам и выполняют [побитовые сдвиги](https://en.cppreference.com/w/cpp/language/operator_arithmetic#Bitwise_shift_operators). Как мы знаем, в стандартной библиотеке они перегружены для форматированного потокового ввода и вывода. Покажем, как сделать это для своего класса.\n\n```cpp\n#include \u003ciostream\u003e\n\nstd::ostream\u0026 operator \u003c\u003c (std::ostream\u0026 out, const Time\u0026 t) {\n    out \u003c\u003c t.GetHours() \u003c\u003c \":\" \u003c\u003c t.GetMinutes() \u003c\u003c \":\" \u003c\u003c t.GetSeconds();\n    return out;\n}\n\nstd::istream\u0026 operator \u003e\u003e (std::istream\u0026 in, Time\u0026 t) {\n    int h, m, s;\n    char dummy;\n    // Считываем число и любой непробельный символ за ним\n    in \u003e\u003e h \u003e\u003e dummy;\n    in \u003e\u003e m \u003e\u003e dummy;\n    in \u003e\u003e s \u003e\u003e dummy;\n\n    // У нас нет другого способа изменить время через публичный интерфейс\n    // кроме присваивания нового значения\n    t = Time(h, m, s);\n    return in;\n}\n```\n\nМы перегрузили два оператора `\u003c\u003c` и `\u003e\u003e`. Первым аргументом они получают по ссылке входной или выходной поток. Второй аргумент — переменная нашего класса. Для оператора `\u003c\u003c` она передаётся по константной ссылке, а для `\u003e\u003e` — просто по ссылке, так как будет изменяться. Оба оператора возвращают ссылку на поток, чтобы можно было создавать цепочки вида `std::cout \u003c\u003c x \u003c\u003c y \u003c\u003c z`.\n\nОбратите внимание, что оба перегруженных оператора работают с абстрактными потоками `in` и `out`, а не с конкретными `std::cin` или `std::cout`. Это позволяет их применять к потокам, связанным с файлами или строками.\n\nТеперь можно читать и печатать время:\n\n```cpp\nint main() {\n    Time t;\n    // Считываем время в формате hh:mm:ss,\n    // где на самом деле вместо двоеточия может быть любой разделитель\n    std::cin \u003e\u003e t;\n\n    t += 40;\n    std::cout \u003c\u003c t \u003c\u003c \"\\n\";  // печатаем время в формате hh:mm:ss\n}\n```\n\n\n## Меняем реализацию, сохраняем интерфейс\n\nИнтерфейсом мы называем объявления из открытой части класса и объявления внешних функций, которые связаны с классом. Это то, что доступно пользователю нашего класса. Напомним, как выглядит интерфейс нашего класса `Time`:\n\n```cpp\nclass Time {\nprivate:\n    // детали реализации\n\npublic:\n    Time(int h, int m, int s);\n\n    int GetHours() const;\n    int GetMinutes() const;\n    int GetSeconds() const;\n\n    int TotalSeconds() const;\n\n    Time\u0026 operator += (int s);\n};\n\nTime operator + (const Time\u0026 t, int s);\n\nint operator - (const Time\u0026 t1, const Time\u0026 t2);\n```\n\nПредположим, что мы включили этот класс в библиотеку, а разные пользователи её используют в своих программах. В какой-то момент мы можем захотеть улучшить библиотеку и сделать новую версию класса. При этом программы пользователей не должны от этого сломаться: наши изменения должны оказаться обратно совместимыми. Разделение на интерфейс и на детали реализации как раз позволяет менять эти детали, сохраняя интерфейс неизменным.\n\nПеределаем класс `Time`, чтобы он хранил не три переменных типа `int` (часы, минуты и секунды), а одну переменную с числом секунд, прошедших с начала суток. Реализация большинства функций от этого упростится, хотя функции вида `GetHours` станут чуть сложнее.\n\n```cpp\nclass Time {\nprivate:\n    int totalSeconds;\n\n    void Normalize() {  // смотрите, как упростилась эта функция!\n        const int secondsInDay = 24 * 60 * 60;\n\n        totalSeconds %= secondsInDay;\n        if (totalSeconds \u003c 0) {\n            totalSeconds += secondsInDay;\n        }\n    }\n\npublic:\n    Time(int h, int m, int s) {\n        totalSeconds = h * 60 * 60 + m * 60 + s;\n        Normalize();\n    }\n\n    int GetHours() const {\n        return totalSeconds / (60 * 60);\n    }\n\n    int GetMinutes() const {\n        return (totalSeconds / 60) % 60;\n    }\n\n    int GetSeconds() const {\n        return totalSeconds % 60;\n    }\n\n    int TotalSeconds() const {\n        return totalSeconds;\n    }\n\n    Time\u0026 operator += (int s) {\n        totalSeconds += s;\n        Normalize();\n        return *this;\n    }\n};\n```\n\nЗаметьте, что реализация внешних функций `operator +` и `operator -` никак не изменится, потому что они написаны в терминах публичного интерфейса класса.\n"])</script><script nonce="">self.__next_f.push([1,"6a:T6c09,"])</script><script nonce="">self.__next_f.push([1,"Классы, как и функции, могут быть параметризованы типами или константами. Такие классы называются шаблонными. Примерами шаблонов классов являются все контейнеры стандартной библиотеки. В этом параграфе мы напишем шаблонный класс «Матрица». Мы также рассмотрим на его примере не связанные с шаблонами вещи: перегрузку по константности и итерацию в цикле range-based for.\n\n[Матрица](https://en.wikipedia.org/wiki/Matrix_(mathematics)) — это таблица чисел, для которой определены математические операции сложения, вычитания и (при подходящих размерах) — умножения. Элементы матрицы могут иметь разную природу: например, это могут быть целые, рациональные, комплексные числа или даже многочлены. Напишем класс-контейнер для хранения матрицы и для выполнения операций над ней.\n\n\n## Выбор шаблонных параметров\n\nНаш класс должен поддерживать работу с разными типами элементов. Поэтому вынесем тип элемента в шаблонные параметры:\n\n```cpp\ntemplate \u003ctypename T\u003e\nclass Matrix;\n```\n\nДальше нам надо решить, будут ли размеры матрицы известны во время компиляции. Если да, их тоже разумно сделать шаблонными параметрами, а хранить матрицу можно в двумерном контейнере `std::array`:\n\n```cpp\n#include \u003carray\u003e\n\ntemplate \u003ctypename T, int Rows, int Columns\u003e\nclass Matrix {\nprivate:\n    // Массив из Rows строк, каждая из которых — массив из Columns элементов типа T\n    std::array\u003cstd::array\u003cT, Columns\u003e, Rows\u003e data;\n};\n\nint main() {\n    Matrix\u003cint, 3, 4\u003e m;  // матрица размера 3 x 4\n}\n```\n\nОднако чаще размеры матрицы становятся известными только во время выполнения программы. Тогда шаблонные размеры не подойдут, так как аргументы шаблона должны быть известны в момент компиляции. В этом случае размеры должны содержаться в данных самой матрицы, а не в её типе. Мы напишем именно такую реализацию. Хранить матрицу будем в двумерном векторе, хотя возможны и другие способы. Сами размеры матрицы явно хранить не обязательно: их можно достать из самого вектора. Но следует написать удобные функции `GetRows` и `GetColumns` для их получения:\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Matrix {\nprivate:\n    std::vector\u003cstd::vector\u003cT\u003e\u003e data;\n\npublic:\n    size_t GetRows() const {\n        return data.size();\n    }\n\n    size_t GetColumns() const {\n        // У пустого вектора data обращаться к нулевому элементу нельзя\n        if (data.empty()) {\n            return 0;\n        }\n        return data[0].size();\n    }\n};\n```\n\nМы будем поддерживать в классе инвариант «в строках матрицы одинаковое количество элементов». Поэтому число столбцов можно будет получить через обращение к нулевой строке.\n\n\n## Конструкторы\n\nНапишем конструктор, соблюдающий этот инвариант.\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Matrix {\nprivate:\n    std::vector\u003cstd::vector\u003cT\u003e\u003e data;\n\n    // Вспомогательная функция, чтобы сделать массив прямоугольным\n    void MakeRectangle() {\n        // Вычисляем максимальную длину строки\n        size_t maxSize = 0;\n        for (const auto\u0026 row : data) {\n            if (row.size() \u003e maxSize) {\n                maxSize = row.size();\n            }\n        }\n\n        for (auto\u0026 row : data) {  // итерация без const позволяет изменять row\n            row.resize(maxSize);  // увеличиваем длины строк при необходимости\n        }\n    }\n\npublic:\n    // Конструктор\n    Matrix(const std::vector\u003cstd::vector\u003cT\u003e\u003e\u0026 d): data(d) {  // инициализируем вектор переданным значением\n        MakeRectangle();  // соблюдаем инвариант\n    }\n\n    // ...\n};\n```\n\nНаша матрица теперь может быть сконструирована примерно так:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    Matrix\u003cint\u003e m({\n        {1, 2, 3},\n        {4, 5, 6},\n    });\n\n    std::cout \u003c\u003c m.GetRows() \u003c\u003c \"\\n\";  // 2\n    std::cout \u003c\u003c m.GetColumns() \u003c\u003c \"\\n\";  // 3\n}\n```\n\nДобавим ещё один конструктор для построения нулевой матрицы заданных размеров. Он нам пригодится в дальнейшем. Будем считать, что нулевое значение элемента матрицы — это значение по умолчанию типа `T`. Для примитивных числовых типов, таких как `int` или `double`, это соблюдается. Для более сложных типов элементов (например, рациональных чисел или многочленов) это будет результат вызова конструктора без аргументов: `T()`. Вызов этого конструктора в приведённом ниже коде спрятан внутри функции `resize` у вектора.\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Matrix {\nprivate:\n    std::vector\u003cstd::vector\u003cT\u003e\u003e data;\n\npublic:\n    Matrix(size_t rows, size_t columns) {\n        data.resize(rows);\n        for (auto\u0026 row : data) {\n            row.resize(columns);\n        }\n    }\n\n    // ...\n};\n\nint main() {\n    Matrix\u003cdouble\u003e m(3, 4);  // создаём нулевую матрицу из 3 строк и 4 столбцов\n}\n```\n\n\n## Обращение к элементам и перегрузка по константности\n\nНаша матрица пока бесполезна: мы можем её создать, но не можем обратиться к её элементам. Хочется делать это так же, как и с двумерным массивом:\n\n```cpp\nint main() {\n    Matrix\u003cint\u003e m(3, 4);\n    int element = m[0][0];\n    m[1][1] = 1;\n    m[2][3] = 5;\n}\n```\n\nБыло бы заманчиво определить в матрице оператор `[]` для обращения по индексу. Он может получать ровно один аргумент (то, что написано в скобках). Каким должно быть его возвращаемое значение? Очевидно, это должно быть нечто, к чему можно снова применить оператор `[]` со вторым индексом. На эту роль может подойти внутренний вектор элементов `std::vector\u003cT\u003e`, который задаёт отдельную строку в матрице. Напишем вот такую версию:\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Matrix {\nprivate:\n    std::vector\u003cstd::vector\u003cT\u003e\u003e data;\n\npublic:\n    const std::vector\u003cT\u003e\u0026 operator [] (size_t i) const {\n        return data[i];\n    }\n};\n```\n\nМы написали константную версию этого оператора. Она возвращает вектор по константной ссылке. Эта версия вполне годится для чтения элемента матрицы, но пока не пригодна для его изменения:\n\n```cpp\nint main() {\n    Matrix\u003cint\u003e m(3, 4);\n    int element = m[0][0];  // OK\n    m[1][1] = 1;  // не скомпилируется: у константного вектора m[1] нельзя изменить элемент\n}\n```\n\nДавайте разберёмся, как соотносятся друг с другом два слова `const` в объявлении этого оператора. Попробуем рассмотреть другие реализации, где одно из этих слов убрано.\n\n1. Уберём первый `const`:\n\n    ```cpp\n    std::vector\u003cT\u003e\u0026 operator [] (size_t i) const {\n        return data[i];  // ошибка компиляции!\n    }\n    ```\n\n    Мы получим ошибку компиляции в теле оператора. В самом деле, константная функция видит поле `data` у текущего объекта как константное. Значит, и `data[i]` будет константой. А к константе нельзя привязать обычную, неконстантную ссылку.\n\n2. Уберём второй `const`:\n\n    ```cpp\n    const std::vector\u003cT\u003e\u0026 operator [] (size_t i) {\n        return data[i];\n    }\n    ```\n\n    Такое тело оператора скомпилируется, но по сравнению с исходной версией этот оператор будет бесполезен. Его нельзя будет применить к константной матрице, так как нет синтаксических гарантий, что он ничего не изменяет. А к неконстантной матрице его применить можно, но результат всё равно будет константным. Поэтому поменять значение в матрице всё равно не получится:\n\n    ```cpp\n    int main() {\n        Matrix\u003cint\u003e m(3, 4);\n        int element = m[0][0];  // OK\n\n        const Matrix\u003cint\u003e\u0026 cm = m;\n        int element2 = cm[0][0];  // не скомпилируется\n\n        m[1][1] = 1;  // не скомпилируется\n    }\n    ```\n\n3. Уберём оба `const`:\n\n    ```cpp\n    std::vector\u003cT\u003e\u0026 operator [] (size_t i) {\n        return data[i];\n    }\n    ```\n\n    Такая версия позволит изменять элемент у неконстантных матриц. Однако к константным матрицам применить её для чтения всё равно не получится. Впрочем, C++ позволяет перегружать функции из класса по константности. Другими словами, в классе можно написать две версии, отличающиеся наличием `const` в конце объявления:\n\n    ```cpp\n    const std::vector\u003cT\u003e\u0026 operator [] (size_t i) const {\n        return data[i];\n    }\n\n    std::vector\u003cT\u003e\u0026 operator [] (size_t i) {  // перегрузка по константности\n        return data[i];\n    }\n    ```\n\n    Теперь первая версия будет применяться к константным матрицам, а вторая — к неконстантным.\n\n{% cut \"Перегрузку функций из класса по константности можно понимать чуть иначе.\" %}\n\nПредположим, что указатель на текущий объект `this` передаётся в наш оператор явно (кстати, такая возможность [появится](https://en.cppreference.com/w/cpp/language/member_functions#Explicit_object_parameter) в C++23). Тогда константность функции означала бы просто константость этого указателя. Наши функции выглядели бы так:\n\n```cpp\n   const std::vector\u003cT\u003e\u0026 operator [] (const Matrix\u003cT\u003e* const this, size_t i) {  // константная версия\n       return data[i];\n   }\n\n   std::vector\u003cT\u003e\u0026 operator [] (Matrix\u003cT\u003e* const this, size_t i) {  // неконстантная версия\n       return data[i];\n   }\n```\n\nТеперь видно, что у функций формально различаются типы первого аргумента, а значит к ним применимы [стандартные правила перегрузки](https://education.yandex.ru/handbook/cpp/article/templates).\n\n{% endcut %}\n\nОднако нас ожидает подвох. Неконстантная версия оператора `[]` может привести к нарушению инварианта класса:\n\n```cpp\nint main() {\n    Matrix\u003cint\u003e m(3, 4);  // матрица 3 x 4\n    m[0].resize(10);  // синтаксически допустимо!\n    // Теперь в матрице есть строка из 10 элементов и ещё две строки из четырёх элементов\n}\n```\n\n![C_19_0c9f30695f.svg](https://yastatic.net/s3/education-portal/media/C_19_0c9f30695f_b1e4ec5e62.svg)\n\nЕсть два способа, чтобы избежать такой ситуации.\n\n1. Можно сделать специальный класс, представляющий строку матрицы.\nУ этого класса не будет опасных функций, таких как `resize` у вектора. Из неконстантной версии оператора `[]` вместо `std::vector\u003cT\u003e\u0026` можно возвращать объект этого класса.\n\n2. Можно сделать обращение к элементу не через оператор `[]`, а иначе.\nНапример, можно перегрузить «оператор вызова функции» `()`. Этот оператор в отличие от `[]` может принимать несколько аргументов.\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Matrix {\nprivate:\n    std::vector\u003cstd::vector\u003cT\u003e\u003e data;\n\npublic:\n    T\u0026 operator () (size_t i, size_t j) {\n        return data[i][j];\n    }\n\n    // ...\n};\n\nint main() {\n    Matrix\u003cint\u003e m(3, 4);\n    m(1, 1) = 1;\n}\n```\n\nДля чтения элементов константных матриц можно оставить как константную версию оператора `[]`, так и добавить перегруженную по константности версию оператора `()`:\n\n```cpp\n    const T\u0026 operator () (size_t i, size_t j) const {\n        return data[i][j];\n    }\n```\n\n\n## Итерация по матрице\n\nЧтобы можно было писать цикл range-based for по строкам матрицы, нужно добавить к классу функции `begin` и `end`, возвращающие итераторы. В нашем случае это могут быть просто итераторы вектора `data`. Можно представить себе более сложный случай, где требуется обходить матрицу не построчно, а поэлементно. Для этого можно было бы написать свои итераторы. Впрочем, это выходит за рамки этого параграфа.\n\nСделаем функции `begin` и `end` константными, чтобы не столкнуться с проблемой из предыдущего пункта (фактически, пожертвуем возможностью изменять строки матрицы через range-based for).\n\nНекоторая сложность тут возникает с типом возвращаемого значения функций `begin` и `end`. Это должен быть такой итератор вектора `std::vector\u003cstd::vector\u003cT\u003e\u003e`, который не позволяет изменять элементы. Такой итератор возвращают константные функции `data.cbegin()` и `data.cend()`. Тип этого итератора — `std::vector\u003cstd::vector\u003cT\u003e\u003e::const_iterator`. Так как это имя зависит от неизвестного заранее шаблонного параметра `T`, то, вообще говоря, компилятору нужно [подсказать](https://en.cppreference.com/w/cpp/language/dependent_name#The_typename_disambiguator_for_dependent_names) с помощью ключевого слова `typename`, что это действительно имя типа:\n\n```cpp\ntypename std::vector\u003cstd::vector\u003cT\u003e\u003e::const_iterator\n```\n\nВпрочем, в C++20 это требование смягчили: в типе возвращаемого значения функции слово `typename` можно не писать.\n\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Matrix {\nprivate:\n    std::vector\u003cstd::vector\u003cT\u003e\u003e data;\n\npublic:\n    // Определим для краткости псевдоним для типа\n    using const_iterator = typename std::vector\u003cstd::vector\u003cT\u003e\u003e::const_iterator;\n\n    // Используем этот псевдоним в объявлении функций\n    const_iterator begin() const {\n        return data.cbegin();\n    }\n\n    const_iterator end() const {\n        return data.cend();\n    }\n};\n\nint main() {\n    Matrix m(3, 4);\n    std::cin \u003e\u003e m;\n\n    for (const auto\u0026 row : m) {  // работает!\n        // обрабатываем строку row\n    }\n}\n```\n\nЗаметим, что этот тип можно вывести проще с помощью конструкции [`decltype`](https://en.cppreference.com/w/cpp/language/decltype), которая определяет на этапе компиляции тип выражения:\n\n```cpp\n    using const_iterator = decltype(data.cbegin());  // определим псевдоним для типа\n\n    const_iterator begin() const {\n        return data.cbegin();\n    }\n\n    const_iterator end() const {\n        return data.cend();\n    }\n```\n\n\n## Потоковый ввод и вывод\n\nПерегрузим для удобства операторы ввода и вывода. Напомним, что они являются внешними функциями. Так как `Matrix` — шаблонный класс, эти функции тоже должны быть шаблонными:\n\n```cpp\n#include \u003ciostream\u003e\n\ntemplate \u003ctypename T\u003e\nstd::ostream\u0026 operator \u003c\u003c (std::ostream\u0026 out, const Matrix\u003cT\u003e\u0026 matrix) {\n    const size_t rows = matrix.GetRows();\n    const size_t columns = matrix.GetColumns();\n    for (size_t i = 0; i != rows; ++i) {\n        for (size_t j = 0; j != columns; ++j) {\n            if (j \u003e 0) {\n                out \u003c\u003c \"\\t\";\n            }\n            out \u003c\u003c matrix[i][j];\n        }\n        out \u003c\u003c \"\\n\";\n    }\n    return out;\n}\n\ntemplate \u003ctypename T\u003e\nstd::istream\u0026 operator \u003e\u003e (std::istream\u0026 in, Matrix\u003cT\u003e\u0026 matrix) {\n    const size_t rows = matrix.GetRows();\n    const size_t columns = matrix.GetColumns();\n    for (size_t i = 0; i != rows; ++i) {\n        for (size_t j = 0; j != columns; ++j) {\n            in \u003e\u003e matrix(i, j);\n        }\n    }\n    return in;\n}\n```\n\nВ операторе `\u003e\u003e` мы считаем, что размеры матрицы уже заданы в самой матрице:\n\n```cpp\nint main() {\n    Matrix\u003cdouble\u003e m(3, 4);  // создаём нулевую матрицу из 3 строк и 4 столбцов\n    std::cin \u003e\u003e m; // заполняем построчно её 12 элементов из потока ввода\n}\n```\n\n\n## Арифметические операции\n\nНапишем для примера перегрузку операторов `+` и `+=`. Здесь важно проверить, что складываются матрицы одинакового размера. Так как размер не является шаблонным параметром, мы не можем проверить это на этапе компиляции. Если размеры не совпадают, необходимо сгенерировать исключение. Про обработку исключений мы будем говорить в [параграфе «Обработка исключений»](https://education.yandex.ru/handbook/cpp/article/exceptions), а пока просто сгенерируем его оператором `throw`.\n\n```cpp\n#include \u003cstdexcept\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Matrix {\nprivate:\n    std::vector\u003cstd::vector\u003cT\u003e\u003e data;\n\npublic:\n    // ...\n\n    Matrix\u003cT\u003e\u0026 operator += (const Matrix\u003cT\u003e\u0026 other) {\n        const size_t rows = GetRows();\n        const size_t columns = GetColumns();\n        if (rows != other.GetRows() || columns != other.GetColumns()) {\n            throw std::invalid_argument(\"Matrices have different size!\");\n        }\n        for (size_t i = 0; i != rows; ++i) {\n            for (size_t j = 0; j != columns; ++j) {\n                data[i][j] += other.data[i][j];\n            }\n        }\n        return *this;\n    }\n};\n\ntemplate \u003ctypename T\u003e\nMatrix\u003cT\u003e operator + (const Matrix\u003cT\u003e\u0026 m1, const Matrix\u003cT\u003e\u0026 m2) {\n    auto tmp = m1;\n    tmp += m2;\n    return tmp;\n}\n```\n\nМы реализовали оператор `+=` как функцию из класса, а оператор `+` — как внешнюю функцию. Мы могли бы в операторе `+=` воспользоваться уже написанным оператором `()` для доступа к элементам матрицы, но в этом нет необходимости, так как встроенная функция имеет доступ к приватным полям. Обратите внимание, что в операторе `+=` мы обращаемся к приватному полю `data` у *другого* объекта (`other`) того же типа `Matrix\u003cT\u003e`. Это вполне допустимо.\n\nНаш оператор `+` вызывает оператор `+=`, и это позволяет избежать дублирования кода. В реализации оператора умножения для матриц удобнее будет сделать наоборот, так как проще выписать формулу для элементов произведения матриц, чем формулу для изменения элементов текущей матрицы после умножения на другую.\n\nПодчеркнём ещё раз, что оператор `+=` возвращает ссылку на текущий объект, а оператор `+` возвращает по значению новую матрицу.\n\n\n## Сравнение матриц\n\nНапишем операторы `==` и `!=` для сравнения двух матриц. Вообще говоря, в таких матрицах элементы могут быть разных типов (например, `int` и `long`). Важно лишь, чтобы сами такие элементы можно было сравнивать. Сделаем поэтому для примера шаблонные параметры матриц разными. Чисто для иллюстрации напишем оператор `==` как функцию из класса, а оператор `!=` — как внешнюю функцию.\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Matrix {\nprivate:\n    std::vector\u003cstd::vector\u003cT\u003e\u003e data;\n\npublic:\n    // Шаблонный оператор внутри шаблонного класса\n    // Параметр T2 никак не связан с параметром T\n    template \u003ctypename T2\u003e\n    bool operator == (const Matrix\u003cT2\u003e\u0026 other) const {\n        const size_t rows = GetRows();\n        const size_t columns = GetColumns();\n        if (rows != other.GetRows() || columns != other.GetColumns()) {\n            return false;\n        }\n        for (size_t i = 0; i != rows; ++i) {\n            for (size_t j = 0; j != columns; ++j) {\n                if (!((*this)(i, j) == other(i, j))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    // ...\n};\n\ntemplate \u003ctypename T1, typename T2\u003e\nbool operator != (const Matrix\u003cT1\u003e\u0026 m1, const Matrix\u003cT2\u003e\u0026 m2) {\n    return !(m1 == m2);\n}\n```\n\nЕсли бы не требовалось сравнивать матрицы разных типов, код оператора `==` мог быть предельно простым:\n\n```cpp\n    bool operator == (const Matrix\u003cT\u003e\u0026 other) const {\n        return data == other.data;  // векторы умеют сравниваться на равенство\n    }\n```\n\nОднако мы решили сделать сам этот оператор шаблонным. Поэтому матрицы `*this` и `other` теперь имеют, вообще говоря, разный тип. В первом случае это `Matrix\u003cT\u003e`, а во втором — `Matrix\u003cT2\u003e`. Поэтому, во-первых, код оператора `==` больше не имеет доступа к приватному полю `data` у объекта `other`, а во-вторых, векторы разных типов сравниваться друг с другом не умеют. Нам остаётся только вручную сравнить элементы матрицы.\n\nОбратите внимание на сравнение внутри вложенного цикла:\n\n```cpp\nif (!((*this)(i, j) == other(i, j))) {\n    return false;\n}\n```\n\nТут мы написали `(*this)(i, j)`, чтобы показать, как вызвать оператор `()` у текущего объекта. И ещё мы намеренно используем отрицание равенства вместо `!=`: так как мы сравниваем матрицы с помощью `==`, то предполагается, что *именно такой* оператор будет применяться и к самим элементам. Вообще говоря, если `T` и `T2` — сложные типы, то перегруженного оператора `!=` у них может вообще не быть.\n\nСравнение матриц с помощью операторов `\u003c` и `\u003e` не имеет смысла, поэтому мы не будем их перегружать.\n"])</script><script nonce="">self.__next_f.push([1,"6b:T91e6,"])</script><script nonce="">self.__next_f.push([1,"В этом параграфе мы узнаем подробнее про конструкторы, деструктор и оператор присваивания, проследим эволюцию объекта от создания до уничтожения, поговорим про временные объекты, а также рассмотрим два разных способа создать объект: на стеке или в динамической памяти. Это потребуется нам в [параграфе «Идиома RAII и умные указатели»](https://education.yandex.ru/handbook/cpp/article/raii-and-smart-pointers) для понимания того, как объекты класса могут владеть ресурсами.\n\nДля знакомства с жизненным циклом объекта мы напишем особый класс, который в своих специальных функциях выводит на экран соответствующие сообщения.\n\n\n## Класс для логгирования сообщений\n\nРаньше мы определяли у классов только конструкторы. Они принимали параметры для инициализации объекта. На самом деле в классе можно определить ещё несколько специальных функций:\n- конструктор копирования: он вызывается при создании копии другого объекта;\n- оператор присваивания: вызывается при присваивании нового значения уже существующему объекту;\n- деструктор: вызывается при уничтожении объекта.\n\nРаньше в наших классах эти функции неявно дописывал за нас компилятор. Их реализация была тривиальной: конструктор просто копировал поля из объекта-образца, оператор присваивания присваивал их значения полям текущего объекта, а деструктор ничего не делал.\n\nНапишем класс `Logger`, в котором мы нарочно переопределим эти специальные функции и будем выводить в них сообщения об их вызове. Дальше мы создадим объекты этого класса и проследим по логу, в каком порядке эти функции вызываются. Начнём с конструктора и деструктора:\n\n```cpp\n#include \u003ciostream\u003e\n\nclass Logger {\npublic:\n    Logger() {  // конструктор без аргументов\n        std::cout \u003c\u003c \"Logger()\\n\";\n    }\n\n    ~Logger() {  // деструктор\n        std::cout \u003c\u003c \"~Logger()\\n\";\n    }\n};\n```\n\nИмя деструктора состоит из тильды и имени класса. Как мы узнаем позже, деструкторы необходимы для освобождения ресурсов, захваченных классом. Но сейчас наш деструктор, как и конструктор, просто печатает сообщение о вызове.\n\n\n## Автоматические объекты\n\nНапишем теперь простую тестовую программу, которая создаёт переменную типа `Logger` и больше ничего не делает.\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    Logger x;\n    std::cout \u003c\u003c \"Hello!\\n\";\n}\n```\n\nЭта программа напечатает такой текст:\n\n\u003cpre\u003e\nLogger()\nHello!\n~Logger()\n\u003c/pre\u003e\n\nПервую строчку печатает конструктор при создании объекта `x`. А последнюю строчку печатает деструктор, когда выполнение программы доходит до конца блока. В нашем примере таким блоком служит тело функции. Мы видим, что для обычных переменных компилятор *автоматически вызывает деструкторы*, когда эти переменные выходят из своей области видимости. Поэтому иногда такие переменные называют автоматическими. Позже мы познакомимся с другими способами создать объект.\n\nДобавим к нашей программе ещё один объект:\n\n```cpp\nint main() {\n    Logger x1;\n    Logger x2;\n}\n```\n\nПрограмма напечатает такой вывод:\n\n\u003cpre\u003e\nLogger()\nLogger()\n~Logger()\n~Logger()\n\u003c/pre\u003e\n\nУ каждого из объектов был вызван конструктор, а затем — деструктор. К сожалению, по этому выводу невозможно понять, в каком порядке вызывались деструкторы. Добавим индивидуальности нашим объектам, чтобы отличать их логи: будем хранить в них различные целые числа.\n\n```cpp\n#include \u003ciostream\u003e\n\nclass Logger {\nprivate:\n    int id = 0;\n\npublic:\n    Logger() {\n        std::cout \u003c\u003c \"Logger(): \" \u003c\u003c id \u003c\u003c \"\\n\";\n    }\n\n    Logger(int x) {  // новый конструктор для инициализации объекта целым числом\n        id = x;\n        std::cout \u003c\u003c \"Logger(int): \" \u003c\u003c id \u003c\u003c \"\\n\";\n    }\n\n    ~Logger() {\n        std::cout \u003c\u003c \"~Logger(): \" \u003c\u003c id \u003c\u003c \"\\n\";\n    }\n};\n```\n\nРассмотрим такой пример:\n\n```cpp\nint main() {\n    Logger x1(1);\n    {\n        Logger x2(2);\n    }\n    Logger x3(3);\n}\n```\n\nЗдесь мы нарочно в функции `main` создали вложенный блок и поместили туда переменную `x2`. Теперь программа напечатает\n\n\u003cpre\u003e\nLogger(int): 1\nLogger(int): 2\n~Logger(): 2\nLogger(int): 3\n~Logger(): 3\n~Logger(): 1\n\u003c/pre\u003e\n\nМы видим, что автоматические объекты удаляются в порядке, который противоположен порядку создания. Объект, созданный последним, выйдет из области видимости первым. Именно таким образом ведёт себя стек. Поэтому часто про автоматические объекты говорят, что они *созданы на стеке*. Память для хранения таких объектов выделяется и освобождается очень быстро: для этого достаточно передвинуть «границу», которая отделяет занятую область от незанятой.\n\n![C_20_3bb78e59bb.svg](https://yastatic.net/s3/education-portal/media/C_20_3bb78e59bb_12050521ba.svg)\n\n\n## Объекты в динамической памяти\n\nМодель стека не всегда подходит для создания объектов. Например, функция `push_back` для добавления нового элемента в `std::list` не может создать новый узел на стеке: он бы автоматически разрушился деструктором при выходе из функции.\n\nВ C++ можно управлять жизнью объекта вручную. Ручные объекты будут расположены уже не на стеке, а в *динамической памяти*. Программист сам должен следить за временем жизни таких объектов и удалять их, когда они не нужны. Создаются такие объекты конструкцией `new`, которая выбирает свободный блок памяти, создаёт там объект и возвращает указатель на эту память. Такие объекты необходимо обязательно удалять конструкцией `delete`, когда они станут не нужны.\n\n```cpp\nint main() {\n    Logger* ptr1 = new Logger(1);\n    Logger* ptr2 = new Logger(2);\n\n    delete ptr1;  // удаляем сначала объект *ptr1\n    delete ptr2;  // потом удаляем *ptr2\n}\n```\n\nВ этой программе мы смогли поменять порядок удаления объектов по сравнению со стеком: `*ptr1`, который был создан раньше `*ptr2`, также удаляется раньше. Вывод такой программы:\n\n\u003cpre\u003e\nLogger(int): 1\nLogger(int): 2\n~Logger(): 1\n~Logger(): 2\n\u003c/pre\u003e\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://yastatic.net/s3/education-portal/media/C_21_6e0cec8465_302d91bbb3.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\"\u003e\n  \u003cfigcaption\u003e\n    Объекты в динамической памяти не обязательно расположены подряд — они могут появляться и уничтожаться в произвольном порядке.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\nСразу заметим, что непосредственные конструкции `new` и `delete` довольно опасны. Очень легко допустить ситуацию, в которой `delete` или будет забыт, или не будет вызван. Это в свою очередь может привести к [*утечке памяти*](https://en.wikipedia.org/wiki/Memory_leak) и, возможно, утечке других ресурсов, которые могли быть захвачены объектом. Подробнее об этом мы поговорим в [параграфе «Идиома RAII и умные указатели»](https://education.yandex.ru/handbook/cpp/article/raii-and-smart-pointers). Там же мы рассмотрим более безопасные способы работы с динамическими объектами.\n\nКонструкции `new` и `delete` следует рассматривать как транзакции. Так, `new` сначала выделяет блок динамической памяти подходящего размера, а потом конструирует в этой памяти элемент. Наоборот, `delete` сначала вызывает деструктор объекта, а потом возвращает динамическую память системе.\n\nКонтейнеры стандартной библиотеки (кроме `std::array`) также размещают свои элементы в динамической памяти. Например, мы могли бы получить тот же эффект, воспользовавшись контейнером `std::list`. Удаление элемента из такого контейнера приводит к вызову деструктора элемента.\n\n\n```cpp\n#include \u003clist\u003e\n\nint main() {\n    std::list\u003cLogger\u003e loggers(2);  // создаём список из двух элементов\n    loggers.pop_front();  // удаляем первый элемент\n    loggers.pop_back();  // удаляем второй элемент\n}   // тут вызывается деструктор самого списка loggers\n```\n\n\n## Копирование и присваивание\n\nЗапустим такую программу:\n\n```cpp\nint main() {\n    Logger x1(1);\n    Logger x2 = x1;  // создаём копию\n}\n```\n\nМы увидим, что как будто бы вызывается один конструктор и два деструктора:\n\n\u003cpre\u003e\nLogger(int): 1\n~Logger(): 1\n~Logger(): 1\n\u003c/pre\u003e\n\nНа самом деле каждому вызову деструктора должен соответствовать вызов конструктора. В этом примере для объекта `x2` вызывается *конструктор копирования*. Мы не переопределили его в классе `Logger`, и компилятор любезно предоставил нам его реализацию по умолчанию.\n\nПохожая странность будет и в таком примере:\n\n```cpp\nint main() {\n    Logger x1(1);\n    Logger x2(2);\n    x2 = x1;  // присваиваем значение уже созданному объекту\n}\n```\n\nИз лога может показаться, что объект `x2` вообще не удаляется, а объект `x1` удаляется дважды:\n\n\u003cpre\u003e\nLogger(int): 1\nLogger(int): 2\n~Logger(): 1\n~Logger(): 1\n\u003c/pre\u003e\n\nЗдесь компилятор нам предоставил по умолчанию *оператор присваивания*, который просто поменял значение поля `id`.\n\nВот как примерно выглядят версии конструктора копирования и оператора присваивания, которые генерирует компилятор:\n\n```cpp\nclass Logger {\nprivate:\n    int id = 0;\n\npublic:\n    // ...\n\n    // Конструктор копирования\n    Logger(const Logger\u0026 other) {\n        id = other.id;  // инициализируем поле id значением из объекта-образца\n    }\n\n    // Оператор присваивания\n    Logger\u0026 operator = (const Logger\u0026 other) {\n        id = other.id;  // пользуемся тем же оператором = для поля id\n        return *this;\n    }\n};\n```\n\nДефолтный конструктор копирования просто вызывает аналогичные конструкторы копирования для всех полей класса. Аналогично, дефолтный оператор присваивания вызывает операторы присваивания для полей. В конструкторе копирования нельзя принимать параметр `const Logger\u0026 other` по значению как `Logger other`: в этом случае параметр должен был бы копироваться, и этот конструктор стал бы рекурсивно вызывать сам себя.\n\nОператор присваивания по оформлению похож на оператор `+=`, который мы писали раньше. Предполагается, что он возвращает ссылку на текущий объект `*this`. Это позволяет писать каскадные присваивания `a = b = c`: они превращаются компилятором в `a = (b = c)`.\n\nВажно понимать разницу между конструктором копирования и оператором присваивания. Конструктор копирования создаёт новый объект, а оператор присваивания модифицирует уже существующий.\n\nКак мы знаем, каждый объект занимает определённую память, в которой расположены его поля. Если у класса есть нетривиальные конструктор или оператор присваивания, то объекты такого класса нельзя копировать или изменять, просто меняя байты в этой памяти, например, функцией [`std::memcpy`](https://en.cppreference.com/w/cpp/string/byte/memcpy). Необходим полноценный вызов этих специальных функций.\n\nДобавим логгирование в конструктор копирования и оператор присваивания. Однако нам по-прежнему хочется различать номера исходного объекта и его копии. Здесь бы нам помог глобальный счётчик объектов. Каждому новому объекту — неважно, копия это или нет, — мы бы присвоили уникальный номер. Такой счётчик можно было бы хранить в глобальной переменной. Но лучше всего спрятать его внутрь класса и сделать *статическим* полем, чтобы не засорять глобальное пространство имён.\n\n\n## Статические поля и функции\n\nКлючевое слово `static` в C++ используется в [нескольких разных смыслах](https://en.cppreference.com/w/cpp/keyword/static).\n\nВ объявлении поля в классе оно обозначает, что значение этого поля [одинаково для всех объектов класса](https://en.cppreference.com/w/cpp/language/static#Static_data_members). Фактически, статическое поле является глобальной переменной, которую просто поместили в класс как в пространство имён. Ниже мы пользуемся словом `static` в сочетании с `inline` — этот синтаксис позволяет инициализировать такие поля прямо в классе:\n\n```cpp\n#include \u003ciostream\u003e\n\nclass C {\npublic:\n    int x = 0;  // обычное поле\n    inline static int sx = 0;  // статическое поле, проинициализированное прямо в классе\n    static const int scx = 100;  // статическая константа\n};\n\nint main() {\n    // Обращаемся со статическим полем просто как с глобальной переменной с особым именем:\n    std::cout \u003c\u003c C::sx \u003c\u003c \" \" \u003c\u003c C::scx \u003c\u003c \"\\n\";  // 0 100\n\n    C::sx = 1;\n    std::cout \u003c\u003c C::sx \u003c\u003c \" \" \u003c\u003c C::scx \u003c\u003c \"\\n\";  // 1 100\n\n    C c1, c2;  // создадим два объекта типа C\n    // Обычное поле value привязано к конкретному объекту класса:\n    c1.x = 42;\n    c2.x = 17;\n    c2.sx = 13;  // к статическому полю можно обратиться как к обычному, но оно поменяется глобально\n\n    std::cout \u003c\u003c c1.x \u003c\u003c \" \" \u003c\u003c c1.sx \u003c\u003c \" \" \u003c\u003c c1.scx \u003c\u003c \"\\n\";  // 42 13 100\n    std::cout \u003c\u003c c2.x \u003c\u003c \" \" \u003c\u003c c2.sx \u003c\u003c \" \" \u003c\u003c c2.scx \u003c\u003c \"\\n\";  // 17 13 100\n}\n```\n\nПримером статической константы в стандартной библиотеке является [`std::string::npos`](https://en.cppreference.com/w/cpp/string/basic_string/npos). Напомним, что это значение возвращает функция `find` у строки, если подстрока не найдена.\n\n{% cut \"Статические функции имеют похожую семантику.\" %}\n\n[Статическая функция](https://en.cppreference.com/w/cpp/language/static#Static_member_functions) — это просто обычная функция, которую поместили в класс как в пространство имён по семантическим соображениям. В отличие от функции из класса она не принимает неявным образом текущий объект, но может обращаться к статическим полям.\n\n```cpp\n#include \u003ciostream\u003e\n\nclass C {\nprivate:\n    int x = 0;\n    inline static int sx = 0;\n\npublic:\n    // обычная функция из класса\n    void f(int y) {\n        x = y;  // есть текущий объект и доступ к его полям\n        sx = y;\n    }\n\n    // статическая функция:\n    static void sf(int y) {\n        // нет текущего объекта, и поэтому нет доступа к полю x\n        // но есть доступ к статическому полю\n        sx = y;\n    }\n};\n\nint main() {\n    C obj;\n    obj.f(1);  // вызываем обычную функцию, в неё неявно передаётся объект obj\n\n    C::sf(2);  // вызываем статическую функцию через имя класса\n    obj.sf(3);  // вызываем статическую функцию через объект, но сам объект obj в неё не передаётся\n}\n```\n\n{% endcut %}\n\n\n## Класс `Logger` с глобальным счётчиком\n\nВоспользуемся статической переменной, чтобы подсчитывать количество когда-либо созданных объектов класса. Изменять этот счётчик объектов будем в конструкторе объектов.\n\n```cpp\n#include \u003ciostream\u003e\n\nclass Logger {\nprivate:\n    inline static int counter = 0;\n\n    const int id;  // константа должна быть проинициализирована в конструкторе\n\npublic:\n    Logger(): id(++counter) {  // инициализируем id текущего объекта\n        std::cout \u003c\u003c \"Logger(): \" \u003c\u003c id \u003c\u003c \"\\n\";\n    }\n\n    Logger(const Logger\u0026 other): id(++counter) {\n        std::cout \u003c\u003c \"Logger(const Logger\u0026): \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n    }\n\n    Logger\u0026 operator = (const Logger\u0026 other) {\n        // Тут никакие счётчики не меняются, ведь объект уже создан\n        std::cout \u003c\u003c \"Logger\u0026 operator = (const Logger\u0026) \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n        return *this;\n    }\n\n    ~Logger() {\n        std::cout \u003c\u003c \"~Logger() \" \u003c\u003c id \u003c\u003c \"\\n\";\n    }\n};\n```\n\nВ конструкторах мы не можем написать инициализацию `id` вот так прямо в теле:\n\n```cpp\n    Logger() {\n        ++counter;\n        id = counter;\n        // ...\n    }\n```\n\nДело в том, что `id` мы теперь сделали константным полем. Единственная возможность его проинициализировать — явно указать его значение с помощью вот такого синтаксиса перед телом конструктора:\n\n```cpp\n    Logger(): id(++counter) {\n        // ...\n    }\n```\n\nОбратите внимание на префиксный оператор `++` перед `counter`. Он сначала увеличивает значение счётчика `counter`, а затем уже обновлённое значение используется для инициализации поля `id`. Поэтому все наши объекты будут нумероваться с единицы.\n\nРассмотрим теперь такую программу:\n\n```cpp\nint main() {\n    Logger x1;\n    Logger x2 = x1;  // это не присваивание, а инициализация нового объекта через конструктор копирования\n    Logger x3;\n    x3 = x1;  // а вот это уже оператор присваивания\n}\n```\n\nНа экране мы увидим такой лог:\n\n\u003cpre\u003e\nLogger(): 1  // создали объект x1\nLogger(const Logger\u0026): 2 1  // создали объект x2 по образцу x1\nLogger() 3  // создали объект x3\nLogger\u0026 operator = (const Logger\u0026) 3 1  // вызвали оператор присваиваниия x3 = x1\n~Logger() 3\n~Logger() 2\n~Logger() 1\n\u003c/pre\u003e\n\n\n## Инициализация подполей\n\nПоместим наш класс `Logger` внутрь другого класса, также логгирующего свои вызовы:\n\n```cpp\nclass OuterLogger {\nprivate:\n    // Делаем два поля типа Logger\n    Logger innerLogger1;\n    Logger innerLogger2;\n\n    inline static int counter = 0;\n    const int id;\n\npublic:\n    OuterLogger(): id(++counter) {\n        std::cout \u003c\u003c \"OuterLogger(): \" \u003c\u003c id \u003c\u003c \"\\n\";\n    }\n\n    OuterLogger(const OuterLogger\u0026 other):\n        innerLogger1(other.innerLogger1),  // инициализируем поля\n        innerLogger2(other.innerLogger2),  // в порядке их объявления\n        id(++counter)\n    {\n        std::cout \u003c\u003c \"OuterLogger(const OuterLogger\u0026): \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n    }\n\n    OuterLogger\u0026 operator = (const OuterLogger\u0026 other) {\n        innerLogger1 = other.innerLogger1;  // вызываем оператор присваивания для полей\n        innerLogger2 = other.innerLogger2;\n        std::cout \u003c\u003c \"OuterLogger\u0026 operator = (const OuterLogger\u0026) \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n        return *this;\n    }\n\n    ~OuterLogger() {\n        std::cout \u003c\u003c \"~OuterLogger() \" \u003c\u003c id \u003c\u003c \"\\n\";\n    }\n};\n\nint main() {\n    OuterLogger outerLogger;\n}\n```\n\nЗаметьте, что у классов `Logger` и `OuterLogger` имеются свои независимые счётчики объектов.\n\nМы получим следующий лог:\n\n\u003cpre\u003e\nLogger(): 1\nLogger(): 2\nOuterLogger(): 1\n~OuterLogger(): 1\n~Logger(): 2\n~Logger(): 1\n\u003c/pre\u003e\n\nМы видим, что перед входом в тело конструктора инициализируются поля создаваемого объекта, если они, конечно, не имеют примитивного типа вроде `int`. Мы можем указать, с какими аргументами их инициализировать: это сделано в конструкторе копирования класса `OuterLogger`. Если инициализация поля пропущена, то для него будет вызван конструктор без аргументов. Только после этого начинает выполняться тело конструктора. Поэтому мы видим лог в таком порядке:\n\n\u003cpre\u003e\nLogger(): 1  // конструирование поля innerLogger1\nLogger(): 2  // конструирование поля innerLogger2\nOuterLogger(): 1  // тело конструктора класса OuterLogger\n\u003c/pre\u003e\n\nВ деструкторе всё происходит наоборот. Сначала выполняется его тело, а затем автоматически вызываются деструкторы для полей, причём в обратном порядке.\n\n\n## Временные объекты\n\nРассмотрим такой код:\n\n```cpp\n#include \u003ciostream\u003e\n\nvoid f(const Logger\u0026 x) {\n    std::cout \u003c\u003c \"void f(const Logger\u0026)\\n\";\n}\n\nint main() {\n    f(Logger());\n    std::cout \u003c\u003c \"Hello!\\n\";\n}\n```\n\nЗдесь мы передаём в функцию `f` *временный объект* `Logger()`. У него нет имени. Он существует лишь пока вычисляется выражение `f(Logger())`. Поэтому сообщение о вызове его деструктора мы увидим до строки `Hello!`:\n\n\u003cpre\u003e\nLogger(): 1\nvoid f(const Logger\u0026)\n~Logger(): 1\nHello!\n\u003c/pre\u003e\n\nВ C++ имеется возможность различать в функциях временные и обычные объекты. Напишем перегруженную версию функции `f`, принимающую на вход так называемую [rvalue-ссылку](https://en.cppreference.com/w/cpp/language/reference#Rvalue_references):\n\n```cpp\n#include \u003ciostream\u003e\n\nvoid f(const Logger\u0026 x) {  // версия для обычных аргументов\n    std::cout \u003c\u003c \"void f(const Logger\u0026)\\n\";\n}\n\nvoid f(Logger\u0026\u0026 x) {  // версия для временных аргументов типа Logger\n    std::cout \u003c\u003c \"void f(Logger\u0026\u0026)\\n\";\n}\n\nint main() {\n    f(Logger());  // вызывается перегруженная версия для временных аргументов\n    std::cout \u003c\u003c \"\\n\";\n\n    Logger x;\n    f(x);  // вызывается обычная версия\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\nВывод будет таким:\n\n\u003cpre\u003e\nLogger(): 1\nvoid f(Logger\u0026\u0026)\n~Logger(): 1\n\nLogger(): 2\nvoid f(const Logger\u0026)\n\n~Logger(): 2\n\u003c/pre\u003e\n\nТермин «временный объект», который мы используем, не совсем корректен. Правильнее было бы говорить об [объектах категории prvalue или xvalue](https://en.cppreference.com/w/cpp/language/value_category), но мы не будем сейчас переусложнять наш рассказ. Добавим только, что обычный объект можно принудительно рассмотреть как временный, применив к нему функцию [`std::move`](https://en.cppreference.com/w/cpp/utility/move) из заголовочного файла `utility`. Это может потребоваться для вызова правильной перегруженной версии какой-либо функции.\n\nПерегрузка функций по rvalue-ссылкам особенно полезна в контейнерах и в классах, владеющих ресурсами. Она позволяет отобрать владение ресурсами у временного объекта и избежать дорогих операций копирования и инициализации. Мы увидим это в [параграфе «Идиома RAII и умные указатели»](https://education.yandex.ru/handbook/cpp/article/raii-and-smart-pointers).\n\n\nДавайте добавим в наш класс `Logger` *конструктор перемещения* и оператор присваивания, которые будут принимать временный объект.\n\n```cpp\nclass Logger {\n    // ...\n\npublic:\n    // ...\n\n    // Конструктор перемещения:\n    Logger(Logger\u0026\u0026 other): id(++counter) {\n        std::cout \u003c\u003c \"Logger(Logger\u0026\u0026): \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n    }\n\n    Logger\u0026 operator = (Logger\u0026\u0026 other) {\n        std::cout \u003c\u003c \"Logger\u0026 operator = (Logger\u0026\u0026) \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n        return *this;\n    }\n};\n```\n\nЗапустим такой код:\n\n```cpp\n#include \u003cutility\u003e\n\nint main() {\n    Logger x1;\n    Logger x2 = x1;  // вызывается обычный конструктор копирования\n    Logger x3 = Logger();  // сработает copy elision: временный объект даже не будет создаваться\n    Logger x4 = std::move(x1);  // вызывается конструктор перемещения\n}\n```\n\nМы увидим на экране\n\n\u003cpre\u003e\nLogger(): 1\nLogger(const Logger\u0026): 2 1\nLogger(): 3\nLogger(Logger\u0026\u0026): 4 1\n~Logger(): 4\n~Logger(): 3\n~Logger(): 2\n~Logger(): 1\n\u003c/pre\u003e\n\nПояснить здесь нужно инициализацию объекта `x3`. Начиная с C++17 компилятор обязан упрощать такое выражение до простого `Logger x3`. Это упрощение называется [*copy elision*](https://en.cppreference.com/w/cpp/language/copy_elision).\n\nАналогично, протестируем оператор присваивания:\n\n```cpp\n#include \u003cutility\u003e\n\nint main() {\n    Logger x1;\n    Logger x2;\n\n    x2 = x1;  // обычный оператор присваивания\n    x2 = Logger();  // присваиваем временный объект с номером 3, который тут же умирает\n    x2 = std::move(x1);  // рассматриваем x1 как временный объект (но он при этом продолжает жить)\n}\n```\n\nВывод:\n\n\u003cpre\u003e\nLogger(): 1\nLogger(): 2\nLogger\u0026 operator = (const Logger\u0026): 2 1\nLogger(): 3\nLogger\u0026 operator = (Logger\u0026\u0026): 2 3\n~Logger(): 3\nLogger\u0026 operator = (Logger\u0026\u0026): 2 1\n~Logger(): 2\n~Logger(): 1\n\u003c/pre\u003e\n\n\n## Объекты в контейнерах\n\nПопробуем сложить элементы нашего типа `Logger` в различные контейнеры. Начнем с `std::list`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n\nint main() {\n   std::list\u003cLogger\u003e container;\n   container.push_back(Logger());\n   std::cout \u003c\u003c \"\\n\";\n\n   Logger x;\n   container.push_back(x);\n   std::cout \u003c\u003c \"\\n\";\n}\n```\n\nВывод на экран зависит от конкретной реализации контейнера `std::list` в стандартной библиотеке. Будет примерно следующее:\n\n\u003cpre\u003e\nLogger(): 1  // создаём временный объект Logger(), который передаётся в push_back\nLogger(Logger\u0026\u0026): 2 1  // в контейнере создаётся новый объект через конструктор перемещения\n~Logger(): 1  // временный объект умирает\n\nLogger(): 3  // создаётся объект x\nLogger(const Logger\u0026): 4 3  // объект x копируется в контейнер\n\n~Logger(): 3  // умирает объект x\n~Logger(): 2  // умирает сам containter: сначала умирает его первый элемент\n~Logger() 4  // умирает второй элемент контейнера\n\u003c/pre\u003e\n\nВ нашем контейнере всего два элемента, но в итоге было создано четыре объекта! Заметим, что вместо `push_back` можно было бы воспользоваться функцией `emplace_back`. Она принимает на вход не сам объект, копию которого надо поместить в контейнер, а аргументы конструктора объекта, и создаёт новый объект сама:\n\n```cpp\nint main() {\n   std::list\u003cLogger\u003e container;\n   container.emplace_back();  // аргументов нет: создаём в контейнере новый объект конструктором без аргументов\n   container.emplace_back();\n}\n```\n\nВывод на экран теперь такой:\n\n\u003cpre\u003e\nLogger(): 1\nLogger(): 2\n~Logger(): 1\n~Logger(): 2\n\u003c/pre\u003e\n\nТеперь положим элементы в вектор:\n\n```cpp\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cLogger\u003e container;\n    container.emplace_back();\n    std::cout \u003c\u003c \"\\n\";\n    container.emplace_back();\n    std::cout \u003c\u003c \"\\n\";\n}\n```\n\nВывод, опять же, зависит от реализации `std::vector` и будет примерно таким:\n\n\u003cpre\u003e\nLogger(): 1  // создаём первый объект в векторе\n\nLogger(): 2  // создаём второй объект в векторе\nLogger(const Logger\u0026): 3 1  // но что это?\n~Logger(): 1\n\n~Logger(): 3\n~Logger(): 2\n\u003c/pre\u003e\n\nОткуда здесь конструктор копирования, создающий третий объект? Это произошла реаллокация. После первого `emplace_back` в векторе была зарезервирована память только под один элемент. Когда выполнился второй `emplace_back`, произошло следующее:\n- выделился новый фрагмент памяти, достаточный для хранения двух элементов;\n- в нём был создан новый (второй) элемент на нужном месте: это строка `Logger(): 2` в логе;\n- в новый фрагмент памяти был скопирован первый элемент из старой памяти: `Logger(const Logger\u0026): 3 1`;\n- элемент в старой части памяти был уничтожен: `~Logger(): 1`.\n\nПорядок удаления элементов в деструкторе вектора стандартом не определён и может различаться в разных реализациях стандартной библиотеки. В нашем примере элементы удалялись в прямом порядке.\n"])</script><script nonce="">self.__next_f.push([1,"6c:T7f62,"])</script><script nonce="">self.__next_f.push([1,"Наследование — это способ организовывать иерархии классов. При этом класс-наследник приобретает поля и функции базового класса, модифицируя их область видимости.\n\nЯзык C\\+\\+ — один из немногих языков с множественным наследованием: у класса может быть несколько базовых классов. Множественное наследование считается сложным (и не всегда оправданным). Мы не будем его здесь рассматривать. В этом параграфе мы познакомимся с *публичным одиночным наследованием*.\n\n## Наследование\n\nСначала приведём синтаксические детали. Пусть есть некоторый класс `A`.\n\n```cpp\nclass A {\nprivate:\n    int x;\n\npublic:\n    void Func1();\n    void Func2();\n};\n```\n\nВ нашем классе `A` для примера объявлено приватное поле `x` и публичные функции `Func1` и `Func2`. Пусть их реализация написана где-то отдельно. Публично унаследуем от этого класса новый класс `B`:\n\n```cpp\nclass B: public A {\nprivate:\n    int y;\n\npublic:\n    void Func2();\n    void Func3();\n};\n```\n\nТехнически класс `B` включает в себя подобъект класса `A`. Класс `B` приобретает поля и функции базового класса `A`, возможно, меняя их уровень доступа.\n\n```cpp\nint main() {\n    B b;\n    b.Func1();  // унаследована от A\n    b.Func2();  // переопределена в классе B\n    b.A::Func2();  // версия Func2 из класса A\n    b.Func3();  // определена в классе B\n}\n```\n\nПриватное поле `x` в функциях класса `B` оказывается недоступным (как и в любом другом месте кода), однако оно хранится внутри объекта типа `B` и может быть изменено функциями из `A`:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    std::cout \u003c\u003c sizeof(A) \u003c\u003c \"\\n\";  // 4 байта (x)\n    std::cout \u003c\u003c sizeof(B) \u003c\u003c \"\\n\";  // 8 байт (x и у)\n}\n```\n\n![C](https://yastatic.net/s3/education-portal/media/C_22_e23ba3c48a_ca0e048973.svg)\n\nСамое заманчивое, что тип `B` может быть приведён к типу `A`. Поэтому объект класса `B` может использоваться везде, где ожидается `A`:\n\n```cpp\nvoid DoSomething(const A\u0026);\n\nint main() {\n    B b;\n    DoSomething(b);  // ok\n}\n```\n\nОтнаследуемся от класса `Logger` из предыдущего параграфа, чтобы посмотреть, как рождается и умирает объект базового класса.\n\n```cpp\n#include \u003ciostream\u003e\n\nclass InheritedLogger: public Logger {\npublic:\n    InheritedLogger() {\n        std::cout \u003c\u003c \"InheritedLogger()\\n\";\n    }\n\n    ~InheritedLogger() {\n        std::cout \u003c\u003c \"~InheritedLogger()\\n\";\n    }\n};\n\nint main() {\n    InheritedLogger x;\n}\n```\n\nВывод программы будет таким:\n\n\u003cpre\u003e\nLogger(): 1\nInheritedLogger()\n~InheritedLogger()\n~Logger(): 1\n\u003c/pre\u003e\n\nЗдесь перед входом в тело конструктора инициализируется неявный объект базового класса, а затем уже выполняется код конструктора класса-наследника. В деструкторе всё происходит наоборот. Это очень похоже на поведение класса `OuterLogger`, в котором объект типа `Logger` хранился как поле. В самом деле, наследование чисто технически можно свести к композиции.\n\n## Наследование и композиция\n\nСравним наследование с композицией — использованием класса в качестве типа поля другого класса. Напишем класс `C`, который будет вместо наследования от `A` использовать композицию.\n\n```cpp\nclass C {\nprivate:\n    A a;  // используем явное поле типа A\n    int y;\n\npublic:\n    void Func1() {  // эмулируем наследование Func1 от A\n        return a.Func1();\n    }\n\n    void Func2();\n\n    void Func3();\n\n    const A\u0026 GetA() const {\n        return a;\n    }\n};\n```\n\nНаш класс хранит фактически те же данные, что и класс `B`, только поле `x` теперь спрятано внутрь поля `a`. Нам пришлось явно написать функцию `Func1`, которая просто вызывает аналогичную функцию у поля `a`. К тому же, больше нет возможности использовать класс `C` вместо класса `A`. Для этого пришлось написать функцию `GetA`, которая возвращает константную ссылку на поле `a`.\n\n```cpp\nint main() {\n    C c;\n    c.Func1();  // вызывает Func1 у поля a\n    c.Func2();  // определена в классе C\n    c.Func3();  // определена в классе C\n    DoSomething(c.GetA());  // нет явного приведения к типу A\n}\n```\n\nМы видим *синтаксические* различия между публичным наследованием и композицией. Публичное наследование автоматически приносит в интерфейс класса-наследника функции из базового класса и позволяет наследнику притворяться объектом базового типа. Напротив, композиция приносит объект исходного класса как именованное поле, а для предоставления доступа к его функциям требуется писать обёртки.\n\nТеперь давайте обсудим *семантические* различия. Считается, что композиция реализует отношение [has-a](https://en.wikipedia.org/wiki/Has-a) между объектами `C` и `A`. Перевести это можно как «`A` — часть `C`», или «`C` реализован с помощью `A`». Наоборот, публичное наследование обозначает отношение [is-a](https://en.wikipedia.org/wiki/Is-a): «`B` является `A`», или «`B` — особый случай `A`».\n\nПусть, например, мы разрабатываем классы для моделирования транспортного средства (`Vehicle`), автомобиля (`Car`) и двигателя (`Engine`). Тогда класс `Car` следовало бы унаследовать от `Vehicle` (автомобиль является транспортным средством), а `Engine` сделать полем внутри `Car` (двигатель — часть автомобиля).\n\n{% cut \"Подробнее\" %}\n\nИногда бывает сложно сделать правильный выбор между композицией и наследованием. Тогда помогает так называемый [принцип подстановки Барбары Лисков](https://en.wikipedia.org/wiki/Liskov_substitution_principle). Надо рассмотреть все возможные сценарии использования базового класса `A` (например, все функции, использующие `A`). Принцип требует, чтобы поведение таких функций не изменялось, если вместо объекта базового класса `A` вдруг будет подставлен объект производного класса `B`. Если это не так, то наследование — неправильный выбор.\n\nПусть, например, мы рассматриваем классы «Квадрат» (`Square`) и «Прямоугольник» (`Rectangle`). Кажется, что квадрат — частный случай прямоугольника. Должен ли `Square` быть наследником `Rectangle`? Ответ зависит от того, какой интерфейс у этих классов. Если `Rectangle` позволяет через публичный интерфейс независимо изменять стороны прямоугольника, то наследование использовать нельзя: такая операция над квадратом нарушит его инвариант.\n\n{% endcut %}\n\nВажная особенность наследования — возможность заменять поведение функций базового класса в классах-наследниках. Она называется *полиморфизмом*.\n\n## Параметрический полиморфизм\n\nОбычно про полиморфизм рассказывают на хрестоматийном примере с иерархией животных. Мы не будем отходить от этой традиции. Пусть нам для разработки некоторой игры требуются классы для кошки и собаки. В классах должно храниться имя животного и должна быть функция `Voice`. Напишем эти классы по отдельности.\n\n```cpp\n#include \u003cstring\u003e\n\nclass Cat {\nprivate:\n    std::string name;\n\npublic:\n    Cat(const std::string\u0026 n): name(n) {\n    }\n\n    const std::string\u0026 GetName() const {\n        return name;\n    }\n\n    std::string Voice() const {\n        return \"Meow!\";\n    }\n};\n\nclass Dog {\nprivate:\n    std::string name;\n\npublic:\n    Dog(const std::string\u0026 n): name(n) {\n    }\n\n    const std::string\u0026 GetName() const {\n        return name;\n    }\n\n    std::string Voice() const {\n        return \"Woof!\";\n    }\n};\n```\n\n{% cut \"Подробнее\" %}\n\nМы возвращаем голос из функции, а не храним его в константном поле. Это более гибкое решение: представьте, например, что голос может зависеть от времени суток.\n\n{% endcut %}\n\nЭти два класса похожи друг на друга, но никак не связаны. Использоваться они будут примерно так:\n\n```cpp\n#include \u003ciostream\u003e\n\nvoid Process(const Cat\u0026 creature) {\n    std::cout \u003c\u003c creature.GetName() \u003c\u003c \": \" \u003c\u003c creature.Voice() \u003c\u003c \"\\n\";\n}\n\nvoid Process(const Dog\u0026 creature) {\n    std::cout \u003c\u003c creature.GetName() \u003c\u003c \": \" \u003c\u003c creature.Voice() \u003c\u003c \"\\n\";\n}\n\nint main() {\n    Cat c(\"Tom\");\n    Dog d(\"Buffa\");\n    Process(c);  // Tom: Meow!\n    Process(d);  // Buffa: Woof!\n}\n```\n\nВ этом коде сразу заметно дублирование. Уберём его с помощью шаблонов:\n\n```cpp\ntemplate \u003ctypename Creature\u003e\nvoid Process(const Creature\u0026 creature) {\n    std::cout \u003c\u003c creature.GetName() \u003c\u003c \": \" \u003c\u003c creature.Voice() \u003c\u003c \"\\n\";\n}\n```\n\nКод функции `main` не изменится. В каком-то смысле это уже полиморфизм: у нас есть разные классы с однотипным интерфейсом, а также набор одноименных перегруженных функций для их обработки. Вызов такой функции синтаксически никак не зависит от того, какой тип животного используется, хотя функции на самом деле разные. Выбор нужной функции происходит во время компиляции. Такой подход называется параметрическим полиморфизмом.\n\nДублирования в самих классах `Cat` и `Dog` можно было бы избежать с помощью дополнительного поля, описывающего тип:\n\n```cpp\n#include \u003cstring\u003e\n\nenum class AnimalType {\n    Cat,\n    Dog,\n};\n\nclass Animal {\nprivate:\n    AnimalType type;\n    std::string name;\n\npublic:\n    Animal(AnimalType t, const std::string\u0026 n):\n        type(t), name(n)\n    {\n    }\n\n    const std::string\u0026 GetName() const {\n        return name;\n    }\n\n    std::string Voice() const {\n        switch (type) {\n            case AnimalType::Cat:\n                return \"Meow!\";\n            case AnimalType::Dog:\n                return \"Woof!\";\n            default:\n                return \"Unknown creature type\";\n        }\n    }\n};\n\nint main() {\n    Animal c(AnimalType::Cat, \"Tom\");\n    Animal d(AnimalType::Dog, \"Buffa\");\n    Process(c);  // Tom: Meow!\n    Process(d);  // Buffa: Woof!\n}\n```\n\nОднако такой подход плохо масштабируется. Представьте, что у нас много типов животных и много функций, подобных `Voice`. В каждой из таких функций пришлось бы писать код, который рассматривает все варианты типов. Для добавления нового типа животного к такой иерархии потребовалось бы расширить перечисление `CreatureType` и изменить код всех таких функций. Если бы такой класс `Creature` поставлялся бы со сторонней библиотекой, в код которой мы не можем вносить изменения, то добавить новый тип в иерархию было бы просто невозможно.\n\n## Полиморфизм через наследование\n\nОрганизуем наши классы в иерархию наследования с базовым классом `Animal`. Это позволит избавиться от дублирования поля `name` и функции `GetName` в коде, а также позволит по-своему определить функцию `Voice`.\n\n![C](https://yastatic.net/s3/education-portal/media/C_23_3c5c7ea1ae_76b74d8dda.svg)\n\nКонструктор у каждого класса-наследника всё-таки придётся написать свой. Он будет просто вызывать конструктор базового класса.\n\n```cpp\n#include \u003cstring\u003e\n\nclass Animal {\nprivate:\n    std::string name;\n\npublic:\n    Animal(const std::string\u0026 n): name(n) {\n    }\n\n    const std::string\u0026 GetName() const {\n        return name;\n    }\n\n    std::string Voice() const {\n        return \"Generic creature voice\";\n    }\n};\n\nclass Cat: public Animal {\npublic:\n    Cat(const std::string\u0026 n): Animal(n) {\n    }\n\n    std::string Voice() const {\n        return \"Meow!\";\n    }\n};\n\nclass Dog: public Animal {\npublic:\n    Dog(const std::string\u0026 n): Animal(n) {\n    }\n\n    std::string Voice() const {\n        return \"Woof!\";\n    }\n};\n```\n\nСо старым кодом функции `Process` всё работает:\n\n```cpp\n#include \u003ciostream\u003e\n\ntemplate \u003ctypename Creature\u003e\nvoid Process(const Creature\u0026 creature) {\n    std::cout \u003c\u003c creature.GetName() \u003c\u003c \": \" \u003c\u003c creature.Voice() \u003c\u003c \"\\n\";\n}\n\nint main() {\n    Cat c(\"Tom\");\n    Dog d(\"Buffa\");\n    Process(c);  // Tom: Meow!\n    Process(d);  // Buffa: Woof!\n}\n```\n\nКак мы помним, классы-наследники могут быть автоматически приведены к типу базового класса. Попробуем убрать шаблон в функции `Process`, чтобы передавать в неё аргумент базового класса `Animal`.\n\n```cpp\n#include \u003ciostream\u003e\n\nvoid Process(const Animal\u0026 creature) {\n    std::cout \u003c\u003c creature.GetName() \u003c\u003c \": \" \u003c\u003c creature.Voice() \u003c\u003c \"\\n\";\n}\n\nint main() {\n    Cat c(\"Tom\");\n    Dog d(\"Buffa\");\n    Process(c);  // Tom: Generic creature voice\n    Process(d);  // Buffa: Generic creature voice\n}\n```\n\nНаша программа компилируется, но животные внезапно теряют свой голос. Вместо переопределённых версий функции `Voice` вызывается версия `Animal::Voice` из базового класса. В самом деле, функция `Process` работает с параметром типа `Animal` и ничего не знает о том, что у этого класса могут быть наследники со своими версиями функций. Решить эту проблему можно, объявив функцию `Voice` в базовом классе `Animal` виртуальной.\n\n## Виртуальные функции\n\nВ предыдущем примере выбор функции `Voice` осуществлялся на этапе компиляции программы. Компилятор выбирал её исходя из формального типа аргумента `creature` — внутри функции это был `const Animal\u0026`. Этот стандартный для C\\+\\+ подход называется *ранним связыванием*. Имеется в виду, что ещё до запуска программы адрес выбранной функции `Animal::Voice` в памяти был заранее привязан к этому месту кода.\n\nВиртуальные функции класса позволяют осуществить [*позднее связывание*](https://en.wikipedia.org/wiki/Late_binding). В этом случае выбор подходящей функции будет происходить уже во время выполнения программы.\n\nФункция должна быть объявлена виртуальной в *базовом* классе:\n\n```cpp\n#include \u003cstring\u003e\n\nclass Animal {\npublic:\n    // ...\n\n    virtual std::string Voice() const {\n        return \"Generic creature voice\";\n    }\n};\n```\n\nВ классах-наследниках её следует переопределять с дополнительной пометкой `override`:\n\n```cpp\nclass Cat: public Animal {\npublic:\n    // ...\n\n    std::string Voice() const override {\n        return \"Meow!\";\n    }\n};\n\nclass Dog: public Animal {\npublic:\n    // ...\n\n    std::string Voice() const override {\n        return \"Woof!\";\n    }\n};\n```\n\n{% cut \"Подробнее\" %}\n\nСлово `override` писать не обязательно, но желательно. При его наличии компилятор сможет проверить, действительно ли в базовом классе есть виртуальная функция с такой сигнатурой. Это позволит заранее найти вот такие ошибки:\n\n```cpp\nclass Dog: public Animal {\npublic:\n    // ...\n\n    std::string Voice() override {  // забыли const!\n        return \"Woof!\";\n    }\n};\n```\n\nЗдесь виртуальная функция базового класса имеет другую сигнатуру. Без слова `override` компилятор бы решил, что мы просто хотим создать новую перегруженную функцию в классе-наследнике.\n\n{% endcut %}\n\nТеперь в функции `Process` выбор нужной функции происходит динамически, во время исполнения программы. Он зависит от реального типа аргумента, который был приведён к базовому классу `Animal`:\n\n```cpp\n#include \u003ciostream\u003e\n\nvoid Process(const Animal\u0026 creature) {\n    std::cout \u003c\u003c creature.GetName() \u003c\u003c \": \" \u003c\u003c creature.Voice() \u003c\u003c \"\\n\";\n}\n\nint main() {\n    Cat c(\"Tom\");\n    Dog d(\"Buffa\");\n    Process(c);  // Tom: Meow!\n    Process(d);  // Buffa: Woof!\n}\n```\n\n{% cut \"Как это работает\" %}\n\nЕсли в базовом классе объявлена хотя бы одна виртуальная функция, то компилятор добавляет к классу ещё одно неявное поле — указатель на [таблицу виртуальных функций](https://en.wikipedia.org/wiki/Virtual_method_table). Конструкторы базового класса и классов-наследников меняют этот указатель, чтобы он указывал на таблицу виртуальных функций именно этого класса. Чем-то это напоминает подход с перечислением `AnimalType` и полем `type` в базовом классе, но только вместо перечисления здесь указатель. Для выбора нужной функции надо сначала перейти по этому указателю на таблицу, а потом уже вызвать функцию. Это медленнее, чем обычный вызов функции. Виртуальные функции имеют свои накладные расходы, и поэтому функции класса не являются виртуальными по умолчанию.\n\n{% endcut %}\n\nЗаметим, что мы нигде явно не создаём объекты базового класса `Animal`. Поэтому функцию `Animal::Voice` можно объявить *чисто виртуальной* вот так:\n\n```cpp\nclass Animal {\npublic:\n    // ...\n\n    virtual std::string Voice() const = 0;  // чисто виртуальная функция\n};\n```\n\nРазработчики C\\+\\+ очень не хотели вводить для чисто виртуальных функций новое ключевое слово, и поэтому придумали такой странный синтаксис.\n\nУ чисто виртуальной функции даже не обязательно должна быть реализация. Если в классе есть такая функция, то класс считается *абстрактным*. Создать объект такого класса (например, написать `Animal a`) не получится, так как класс считается не полностью определенным. Назначение чисто виртуальных функций — потребовать, чтобы классы-наследники переопределили это поведение, иначе они тоже будут считаться абстрактными.\n\nВ примерах ниже мы пока не будем считать функцию `Voice` чисто виртуальной. Но в окончательной версии класса мы сделаем её такой.\n\n## Полиморфизм и контейнеры\n\nДавайте устроим зоопарк и сложим наших животных в контейнер. У стандартных контейнеров должен быть явно указан тип элемента. Попробуем указать в качестве такого типа базовый класс `Animal`:\n\n```cpp\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cAnimal\u003e zoo;\n\n    zoo.push_back(Cat(\"Tom\"));\n    zoo.push_back(Dog(\"Buffa\"));\n\n    // Тут можно было бы написать цикл,\n    // но мы напишем два вызова для наглядности\n    Process(zoo[0]);  // Tom: Generic creature voice!\n    Process(zoo[1]);  // Buffa: Generic creature voice!\n}\n```\n\nВнезапно виртуальное поведение сломалось: мы снова видим результат работы базовой функции `Animal::Voice`. Это произошло потому, что в векторе хранятся *копии* переданных в `push_back` объектов, и эти копии имеют тип `Animal`.То же самое бы случилось, если функция `Process` принимала бы свой параметр по значению, а не по константной ссылке.\n\nЧтобы виртуальные функции заработали, в вектор можно положить указатели на `Animal`:\n\n```cpp\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cAnimal*\u003e zoo;\n\n    // Создадим пока что объекты на стеке\n    Cat c(\"Tom\");\n    Dog d(\"Buffa\");\n\n    // Кладём в вектор адреса этих объектов\n    zoo.push_back(\u0026c);\n    zoo.push_back(\u0026d);\n\n    // Для разыменования нужна звёздочка\n    Process(*zoo[0]);  // Tom: Meow!\n    Process(*zoo[1]);  // Buffa: Woof!\n}\n```\n\nТакой пример работает, однако он не очень интересен. Мы положили в вектор адреса автоматических объектов на стеке. Эти объекты разрушаются при выходе из блока. Поэтому будет плохо возвращать такой вектор из функции — все указатели в нём станут сразу невалидными.\n\nПопробуем создать объекты в динамической памяти:\n\n```cpp\n#include \u003cvector\u003e\n\nint main() {\n    std::vector\u003cAnimal*\u003e zoo;\n\n    zoo.push_back(new Cat(\"Tom\"));\n    zoo.push_back(new Dog(\"Buffa\"));\n\n    Process(*zoo[0]);  // Tom: Meow!\n    Process(*zoo[1]);  // Buffa: Woof!\n}\n```\n\nМы создали объекты в динамической памяти, но не освободили эту память в конце. Это грубая ошибка. Мы должны были вызвать `delete`, когда эта память станет ненужной. Ещё важно, чтобы для животных вызывался правильный деструктор — `~Cat` для кошки, `~Dog` для собаки. Поэтому, если в базовом классе есть виртуальные функции, и с ним предполагается полиморфная работа с созданием объектов в динамической памяти, то *деструктор базового класса необходимо объявить виртуальным*:\n\n```cpp\nclass Animal {\npublic:\n    // ...\n\n    virtual ~Animal() {\n    }\n};\n\n// ...\n\nint main() {\n    // ...\n\n    for (Animal* animal : zoo) {\n        delete animal;  // вызов виртуального деструктора и освобождение памяти\n    }\n}\n```\n\nЗаметим, что такая работа с динамическими объектами очень опасна. Мы можем по какой-то причине не дойти до цикла с уничтожением объектов. Более правильным было бы использовать вектор умных указателей `std::vector\u003cstd::unique_ptr\u003cAnimal\u003e\u003e`. Тогда писать цикл с вызовами `delete` было бы не нужно. Об этом будет рассказано в [параграфе «Идиома RAII и умные указатели»](https://education.yandex.ru/handbook/cpp/article/raii-and-smart-pointers).\n\n{% cut \"Напишем окончательную иерархию классов с учётом всех исправлений.\" %}\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nclass Animal {\nprivate:\n    std::string name;\n\npublic:\n    Animal(const std::string\u0026 n): name(n) {\n    }\n\n    const std::string\u0026 GetName() const {\n        return name;\n    }\n\n    virtual std::string Voice() const = 0;\n\n    virtual ~Animal() {\n    }\n};\n\nclass Cat: public Animal {\npublic:\n    Cat(const std::string\u0026 n): Animal(n) {\n    }\n\n    std::string Voice() const override {\n        return \"Meow!\";\n    }\n};\n\nclass Dog: public Animal {\npublic:\n    Dog(const std::string\u0026 n): Animal(n) {\n    }\n\n    std::string Voice() const override {\n        return \"Woof!\";\n    }\n};\n\nvoid Process(const Animal\u0026 creature) {\n    std::cout \u003c\u003c creature.GetName() \u003c\u003c \": \" \u003c\u003c creature.Voice() \u003c\u003c \"\\n\";\n}\n```\n\nОсновная программа теперь может выглядеть так\n\n```cpp\n#include \u003cmemory\u003e\n#include \u003cvector\u003e\n\nint main() {\n    // Подробности в параграфе 4.6\n    std::vector\u003cstd::unique_ptr\u003cAnimal\u003e\u003e zoo;\n\n    zoo.emplace_back(std::make_unique\u003cCat\u003e(\"Tom\"));\n    zoo.emplace_back(std::make_unique\u003cDog\u003e(\"Buffa\"));\n\n    Process(*zoo[0]);  // Tom: Meow!\n    Process(*zoo[1]);  // Buffa: Woof!\n}\n```\n\n{% endcut %}\n\nМожно ли было сложить животных в контейнер, не используя базовый класс? Да. Для этого подойдут шаблонный класс [`std::variant`](https://en.cppreference.com/w/cpp/utility/variant) и функция [`std::visit`](https://en.cppreference.com/w/cpp/utility/variant/visit) из стандартной библиотеки.\n\n{% cut \"Подробности\" %}\n\nКласс `std::variant` позволяет хранить значение одного из указанных типов. При этом он не использует динамическое выделение памяти. От типов не требуется, чтобы они имели общий базовый класс — они могут быть независимыми, как в разделе про статический полиморфизм. Вот как выглядит эта магия:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvariant\u003e\n#include \u003cvector\u003e\n\n// Как-то определены, не обязательно наследуются от базового класса\nclass Cat;\nclass Dog;\n\ntemplate \u003ctypename Creature\u003e\nvoid Process(const Creature\u0026 creature) {\n    std::cout \u003c\u003c creature.GetName() \u003c\u003c \": \" \u003c\u003c creature.Voice() \u003c\u003c \"\\n\";\n}\n\nint main() {\n    std::vector\u003cstd::variant\u003cCat, Dog\u003e\u003e zoo;  // либо кошки, либо собаки\n\n    zoo.push_back(Cat(\"Tom\"));\n    zoo.push_back(Dog(\"Buffa\"));\n\n    for (const auto\u0026 animal : zoo) {\n        std::visit(\n            [](const auto\u0026 creature) {  // шаблонная лямбда-функция\n                Process(creature);\n            },\n            animal\n        );\n    }\n}\n```\n\nЭто тоже динамический полиморфизм, так как выбор нужной функции происходит во время работы программы. Но он не использует наследование. Недостатком этого подхода является то, что при объявлении вектора надо сразу указать, какие типы могут храниться в `std::variant`. Полиморфизм, который реализован через наследование, лишён этого недостатка.\n\nПодробности можно прочитать [здесь](https://www.cppstories.com/2020/04/variant-virtual-polymorphism.html/).\n\n{% endcut %}"])</script><script nonce="">self.__next_f.push([1,"6d:T726d,"])</script><script nonce="">self.__next_f.push([1,"В C++ различают ошибки времени компиляции и ошибки времени выполнения. Ошибки первого типа обнаруживает компилятор до запуска программы. К ним относятся, например, синтаксические ошибки в коде. Ошибки второго типа проявляются при запуске программы. Примеры ошибок времени выполнения: ввод некорректных данных, некорректная работа с памятью, недостаток места на диске и т. д. Часто такие ошибки могут привести к неопределённому поведению программы.\n\nНекоторые ошибки времени выполнения можно обнаружить заранее с помощью проверок в коде. Например, такими могут быть ошибки, нарушающие инвариант класса в конструкторе. Обычно, если ошибка обнаружена, то дальнейшее выполение функции не имеет смысла, и нужно сообщить об ошибке в то место кода, откуда эта функция была вызвана. Для этого предназначен *механизм исключений*.\n\n\n## Коды возврата и исключения\n\nРассмотрим функцию, которая считывает со стандартного потока возраст и возвращает его вызывающей стороне. Добавим в функцию проверку корректности возраста: он должен находиться в диапазоне от 0 до 128 лет. Предположим, что повторный ввод возраста в случае ошибки не предусмотрен.\n\n```cpp\nint ReadAge() {\n    int age;\n    std::cin \u003e\u003e age;\n    if (age \u003c 0 || age \u003e= 128) {\n        // Что вернуть в этом случае?\n    }\n    return age;\n}\n```\n\nЧто вернуть в случае некорректного возраста? Можно было бы, например, договориться, что в этом случае функция возвращает ноль. Но тогда похожая проверка должна быть и в месте вызова функции:\n\n```cpp\nint main() {\n    if (int age = ReadAge(); age == 0) {\n        // Произошла ошибка\n    } else {\n        // Работаем с возрастом age\n    }\n}\n```\n\nТакая проверка неудобна. Более того, нет никакой гарантии, что в вызывающей функции программист вообще её напишет. Фактически мы тут выбрали некоторое значение функции (ноль), обозначающее ошибку. Это пример подхода к обработке ошибок через *коды возврата*. Другим примером такого подхода является хорошо знакомая нам функция `main`. Только она должна возвращать ноль при успешном завершении и что-либо ненулевое в случае ошибки.\n\nДругим способом сообщить об обнаруженной ошибке являются исключения. С каждым сгенерированным исключением связан некоторый объект, который как-то описывает ошибку. Таким объектом может быть что угодно — даже целое число или строка. Но обычно для описания ошибки заводят специальный класс и генерируют объект этого класса:\n\n```cpp\n#include \u003ciostream\u003e\n\nstruct WrongAgeException {\n    int age;\n};\n\nint ReadAge() {\n    int age;\n    std::cin \u003e\u003e age;\n    if (age \u003c 0 || age \u003e= 128) {\n        throw WrongAgeException(age);\n    }\n    return age;\n}\n```\n\nЗдесь в случае ошибки оператор `throw` генерирует исключение, которое представлено временным объектом типа `WrongAgeException`. В этом объекте сохранён для контекста текущий неправильный возраст `age`. Функция досрочно завершает работу: у неё нет возможности обработать эту ошибку, и она должна сообщить о ней наружу. Поток управления возвращается в то место, откуда функция была вызвана. Там исключение может быть перехвачено и обработано.\n\n\n## Перехват исключения\n\nМы вызывали нашу функцию `ReadAge` из функции `main`. Обработать ошибку в месте вызова можно с помощью блока `try`/`catch`:\n\n```cpp\nint main() {\n    try {\n        age = ReadAge();  // может сгенерировать исключение\n        // Работаем с возрастом age\n    } catch (const WrongAgeException\u0026 ex) {  // ловим объект исключения\n        std::cerr \u003c\u003c \"Age is not correct: \" \u003c\u003c ex.age \u003c\u003c \"\\n\";\n        return 1;  // выходим из функции main с ненулевым кодом возврата\n    }\n    // ...\n}\n```\n\nМы знаем заранее, что функция `ReadAge` может сгенерировать исключение типа `WrongAgeException`. Поэтому мы оборачиваем вызов этой функции в блок `try`. Если происходит исключение, для него подбирается подходящий `catch`-обработчик. Таких обработчиков может быть несколько. Можно смотреть на них как на набор перегруженных функций от одного аргумента — объекта исключения. Выбирается первый подходящий по типу обработчик и выполняется его код. Если же ни один обработчик не подходит по типу, то исключение считается необработанным. В этом случае оно пробрасывается дальше по стеку — туда, откуда была вызвана текущая функция. А если обработчик не найдётся даже в функции `main`, то программа аварийно завершается.\n\nУсложним немного наш пример, чтобы из функции `ReadAge` могли вылетать исключения разных типов. Сейчас мы проверяем только значение возраста, считая, что на вход поступило число. Но предположим, что поток ввода досрочно оборвался, или на входе была строка вместо числа. В таком случае конструкция `std::cin \u003e\u003e age` никак не изменит переменную `age`, а лишь возведёт специальный [флаг ошибки](https://en.cppreference.com/w/cpp/io/ios_base/iostate) в объекте `std::cin`. Наша переменная `age` останется непроинициализированной: в ней будет лежать неопределённый мусор. Можно было бы явно проверить этот флаг в объекте `std::cin`, но мы вместо этого включим режим генерации исключений при таких ошибках ввода:\n\n```cpp\nint ReadAge() {\n    std::cin.exceptions(std::istream::failbit);\n    int age;\n    std::cin \u003e\u003e age;\n    if (age \u003c 0 || age \u003e= 128) {\n        throw WrongAgeException(age);\n    }\n    return age;\n}\n```\n\nТеперь ошибка чтения в операторе `\u003e\u003e` у потока ввода будет приводить к исключению типа [`std::istream::failure`](https://en.cppreference.com/w/cpp/io/ios_base/failure). Функция `ReadAge` его не обрабатывает. Поэтому такое исключение покинет пределы этой функции. Поймаем его в функции `main`:\n\n```cpp\nint main() {\n    try {\n        age = ReadAge();  // может сгенерировать исключения разных типов\n        // Работаем с возрастом age\n    } catch (const WrongAgeException\u0026 ex) {\n        std::cerr \u003c\u003c \"Age is not correct: \" \u003c\u003c ex.age \u003c\u003c \"\\n\";\n        return 1;\n    } catch (const std::istream::failure\u0026 ex) {\n        std::cerr \u003c\u003c \"Failed to read age: \" \u003c\u003c ex.what() \u003c\u003c \"\\n\";\n        return 1;\n    } catch (...) {\n        std::cerr \u003c\u003c \"Some other exception\\n\";\n        return 1;\n    }\n    // ...\n}\n```\n\nПри обработке мы воспользовались функцией `ex.what` у исключения типа `std::istream::failure`. Такие функции есть у всех исключений стандартной библиотеки: они возвращают текстовое описание ошибки.\n\nОбратите внимание на третий `catch` с многоточием. Такой блок, если он присутствует, будет перехватывать любые исключения, не перехваченные ранее.\n\n\n## Исключения стандартной библиотеки\n\nФункции и классы стандартной библиотеки в некоторых ситуациях генерируют исключения особых типов. Все такие типы выстроены в [иерархию наследования](https://en.cppreference.com/w/cpp/error/exception) от базового класса `std::exception`. Иерархия классов позволяет писать обработчик `catch` сразу на группу ошибок, которые представлены базовым классом: `std::logic_error`, `std::runtime_error` и т. д.\n\nВот несколько примеров:\n\n1. Функция `at` у контейнеров `std::array`, `std::vector` и `std::deque` генерирует исключение `std::out_of_range` при некорректном индексе.\n\n2. Аналогично, функция `at` у `std::map`, `std::unordered_map` и у соответствующих мультиконтейнеров генерирует исключение `std::out_of_range` при отсутствующем ключе.\n\n3. Обращение к значению у пустого объекта `std::optional` приводит к исключению `std::bad_optional_access`.\n\n4. Потоки ввода-вывода могут генерировать исключение `std::ios_base::failure`.\n\n\n## Исключения в конструкторах\n\nВ [параграфе «Классы»](https://education.yandex.ru/handbook/cpp/article/classes) мы написали класс `Time`. Этот класс должен был соблюдать инвариант на значение часов, минут и секунд: они должны были быть корректными. Если на вход конструктору класса `Time` передавались некорректные значения, мы приводили их к корректным, используя деление с остатком.\n\nБолее правильным было бы сгенерировать в конструкторе исключение. Таким образом мы бы явно передали сообщение об ошибке во внешнюю функцию, которая пыталась создать объект.\n\n```cpp\nclass Time {\nprivate:\n    int hours, minutes, seconds;\n\npublic:\n    // Заведём класс для исключения и поместим его внутрь класса Time как в пространство имён\n    class IncorrectTimeException {\n    };\n\n    Time::Time(int h, int m, int s) {\n        if (s \u003c 0 || s \u003e 59 || m \u003c 0 || m \u003e 59 || h \u003c 0 || h \u003e 23) {\n            throw IncorrectTimeException();\n        }\n        hours = h;\n        minutes = m;\n        seconds = s;\n    }\n\n    // ...\n};\n```\n\nГенерировать исключения в конструкторах — совершенно нормальная практика. Однако не следует допускать, чтобы исключения покидали пределы деструкторов. Чтобы понять причины, посмотрим подробнее, что происходит при генерации исключения.\n\n\n## Свёртка стека\n\nВспомним класс `Logger` из предыдущего параграфа. Посмотрим, как он ведёт себя при возникновении исключения. Воспользуемся в этом примере стандартным базовым классом `std::exception`, чтобы не писать свой класс исключения.\n\n```cpp\n#include \u003cexception\u003e\n#include \u003ciostream\u003e\n\nvoid f() {\n    std::cout \u003c\u003c \"Welcome to f()!\\n\";\n    Logger x;\n    // ...\n    throw std::exception();  // в какой-то момент происходит исключение\n}\n\nint main() {\n    try {\n        Logger y;\n        f();\n    } catch (const std::exception\u0026) {\n        std::cout \u003c\u003c \"Something happened...\\n\";\n        return 1;\n    }\n}\n```\n\nМы увидим такой вывод:\n\n\u003cpre\u003e\nLogger(): 1\nWelcome to f()!\nLogger(): 2\n~Logger(): 2\n~Logger(): 1\nSomething happened...\n\u003c/pre\u003e\n\nСначала создаётся объект `y` в блоке `try`. Затем мы входим в функцию `f`. В ней создаётся объект `x`. После этого происходит исключение. Мы должны досрочно покинуть функцию. В этот момент начинается *свёртка стека* (stack unwinding): вызываются деструкторы для всех созданных объектов в самой функции и в блоке `try`, как если бы они вышли из своей области видимости. Поэтому перед обработчиком исключения мы видим вызов деструктора объекта `x`, а затем — объекта `y`.\n\nАналогично, свёртка стека происходит и при генерации исключения в конструкторе. Напишем класс с полем `Logger` и сгенерируем нарочно исключение в его конструкторе:\n\n```cpp\n#include \u003cexception\u003e\n#include \u003ciostream\u003e\n\nclass C {\nprivate:\n    Logger x;\n\npublic:\n    C() {\n        std::cout \u003c\u003c \"C()\\n\";\n        Logger y;\n        // ...\n        throw std::exception();\n    }\n\n    ~C() {\n        std::cout \u003c\u003c \"~C()\\n\";\n    }\n};\n\nint main() {\n    try {\n        C c;\n    } catch (const std::exception\u0026) {\n        std::cout \u003c\u003c \"Something happened...\\n\";\n    }\n}\n```\n\nВывод программы:\n\n\u003cpre\u003e\nLogger(): 1  // конструктор поля x\nC()\nLogger(): 2  // конструктор локальной переменной y\n~Logger(): 2  // свёртка стека: деструктор y\n~Logger(): 1  // свёртка стека: деструктор поля x\nSomething happened...\n\u003c/pre\u003e\n\nЗаметим, что деструктор самого класса `C` не вызывается, так как объект в конструкторе не был создан.\n\n\nМеханизм свёртки стека гарантирует, что деструкторы для всех созданных автоматических объектов или полей класса в любом случае будут вызваны. Однако он полагается на важное свойство: *деструкторы самих классов не должны генерировать исключений*. Если исключение в деструкторе произойдёт в момент свёртки стека при обработке другого исключения, то программа аварийно завершится.\n\n\n## Пример с динамической памятью\n\nПодчеркнём, что свёртка стека работает только с автоматическими объектами. В этом нет ничего удивительного: ведь за временем жизни объектов, созданных в динамической памяти, программист должен следить самостоятельно. Исключения вносят дополнительные сложности в ручное управление динамическими объектами:\n\n```cpp\nvoid f() {\n    Logger* ptr = new Logger();  // конструируем объект класса Logger в динамической памяти\n    // ...\n    g();  // вызываем какую-то функцию\n    // ...\n    delete ptr;  // вызываем деструктор и очищаем динамическую память\n}\n```\n\nНа первый взгляд кажется, что в этом коде нет ничего опасного: `delete` вызывается в конце функции. Однако функция `g` может сгенерировать исключение. Мы не перехватываем его в нашей функции `f`. Механизм свёртки уберёт со стека лишь сам указатель `ptr`, который является автоматической переменной примитивного типа. Однако он ничего не сможет сделать с объектом в памяти, на которую ссылается этот указатель. В логе мы увидим только вызов конструктора класса `Logger`, но не увидим вызова деструктора. Нам придётся обработать исключение вручную:\n\n```cpp\nvoid f() {\n    Logger* ptr = new Logger();\n    // ...\n    try {\n        g();\n    } catch (...) {  // ловим любое исключение\n        delete ptr;  // вручную удаляем объект\n        throw;  // перекидываем объект исключения дальше\n    }\n    // ...\n    delete ptr;\n\n}\n```\n\nЗдесь мы перехватываем любое исключение и частично обрабатываем его, удаляя объект в динамической памяти. Затем мы прокидываем текущий объект исключения дальше с помощью оператора `throw` без аргументов.\n\n\nСогласитесь, этот код очень далёк от совершенства. При непосредственной работе с объектами в динамической памяти нам приходится оборачивать в `try`/`catch` любую конструкцию, из которой может вылететь исключение. Понятно, что такой код чреват ошибками. В [параграфе «Идиома RAII и умные указатели»](https://education.yandex.ru/handbook/cpp/article/raii-and-smart-pointers) мы узнаем, как с точки зрения C++ следует работать с такими ресурсами, как память.\n\n\n## Гарантии безопасности исключений\n\nПредположим, что мы пишем свой класс-контейнер, похожий на двусвязный список. Наш контейнер позволяет добавлять элементы в хранилище и отдельно хранит количество элементов в некотором поле `elementsCount`. Один из инвариантов этого класса такой: значение `elementsCount` равно реальному числу элементов в хранилище.\n\nНе вдаваясь в детали, давайте посмотрим, как могла бы выглядеть функция добавления элемента.\n\n```cpp\ntemplate \u003ctypename T\u003e\nclass List {\nprivate:\n    struct Node {  // узел двусвязного списка\n        T element;\n        Node* prev = nullptr;  // предыдущий узел\n        Node* next = nullptr;  // следующий узел\n    };\n\n    Node* first = nullptr;  // первый узел списка\n    Node* last = nullptr;  // последний узел списка\n    int elementsCount = 0;\n\npublic:\n    // ...\n\n    size_t Size() const {\n        return elementsCount;\n    }\n\n    void PushBack(const T\u0026 elem) {\n        ++elementsCount;\n\n        // Конструируем в динамической памяти новой узел списка\n        Node* node = new Node(elem, last, nullptr);\n\n        // Связываем новый узел с остальными узлами\n        if (last != nullptr) {\n            last-\u003enext = node;\n        } else {\n            first = node;\n        }\n        last = node;\n    }\n};\n```\n\nНе будем здесь рассматривать другие функции класса — конструкторы, деструктор, оператор присваивания... Рассмотрим функцию `PushBack`. В ней могут произойти такие исключения:\n\n1. Выражение `new` может сгенерировать исключение [`std::bad_alloc`](https://en.cppreference.com/w/cpp/memory/new/bad_alloc) из-за нехватки памяти.\n\n2. Конструктор копирования класса `T` может сгенерировать произвольное исключение. Этот конструктор вызывается при инициализации поля `element` создаваемого узла в конструкторе класса `Node`. В этом случае `new` ведёт себя как транзакция: выделенная перед этим динамическая память корректно вернётся системе.\n\nЭти исключения не перехватываются в функции `PushBack`. Их может перехватить код, из которого `PushBack` вызывался:\n\n```cpp\n#include \u003ciostream\u003e\n\nclass C;  // какой-то класс\n\nint main() {\n    List\u003cC\u003e data;\n    C element;\n\n    try {\n        data.PushBack(element);\n    } catch (...) {  // не получилось добавить элемент\n        std::cout \u003c\u003c data.Size() \u003c\u003c \"\\n\";  // внезапно 1, а не 0\n    }\n\n    // работаем дальше с data\n}\n```\n\nНаша функция `PushBack` сначала увеличивает счётчик элементов, а затем выполняет опасные операции. Если происходит исключение, то в классе `List` нарушается инвариант: значение счётчика `elementsCount` перестаёт соответствовать реальности. Можно сказать, что функция `PushBack` *не даёт гарантий безопасности*.\n\nВсего выделяют четыре уровня [*гарантий безопасности исключений*](https://en.wikipedia.org/wiki/Exception_safety) (exception safety guarantees):\n\n1. **Гарантия отсутствия сбоев**.\nФункции с такими гарантиями вообще не выбрасывают исключений. Примерами могут служить правильно написанные деструктор и конструктор перемещения, а также константные функции вида `Size`.\n\n2. **Строгая гарантия безопасности**.\nИсключение может возникнуть, но от этого объект нашего класса не поменяет состояние: количество элементов останется прежним, итераторы и ссылки не будут инвалидированы и т. д.\n\n3. **Базовая гарантия безопасности**.\nПри исключении состояние объекта может поменяться, но оно останется внутренне согласованным, то есть, инварианты будут соблюдаться.\n\n4. **Отсутствие гарантий**.\nЭто довольно опасная категория: при возникновении исключений могут нарушаться инварианты.\n\nВсегда стоит разрабатывать классы, обеспечивающие хотя бы базовую гарантию безопасности. При этом не всегда возможно эффективно обеспечить строгую гарантию.\n\nПереместим в нашей функции `PushBack` изменение счётчика в конец:\n\n```cpp\n    void PushBack(const T\u0026 elem) {\n        Node* node = new Node(elem, last, nullptr);\n\n        if (last != nullptr) {\n            last-\u003enext = node;\n        } else {\n            first = node;\n        }\n        last = node;\n\n        ++elementsCount;  // выполнится только если раньше не было исключений\n    }\n```\n\nТеперь такая функция соответствует строгой гарантии безопасности.\n\n\nВ документации функций из классов стандартной библиотеки обычно указано, какой уровень гарантии они обеспечивают. Рассмотрим, например, гарантии безопасности класса `std::vector`.\n\n- Деструктор, функции `empty`, `size`, `capacity`, а также `clear` предоставляют гарантию отсутствия сбоев.\n\n- Функции `push_back` и `resize` предоставляют строгую гарантию.\n\n- Функция `insert` предоставляет лишь базовую гарантию.\n\nМожно было бы сделать так, чтобы она предоставляла строгую гарантию, но за это пришлось бы заплатить её эффективностью: при вставке в середину вектора пришлось бы делать реаллокацию.\n\nФункции класса, которые гарантируют отсутствие сбоев, следует помечать ключевым словом [`noexcept`](https://en.cppreference.com/w/cpp/language/noexcept_spec):\n\n```cpp\nclass C {\npublic:\n    void f() noexcept {\n        // ...\n    }\n};\n```\n\nС одной стороны, эта подсказка позволяет компилятору генерировать более эффективный код. С другой — эффективно обрабатывать объекты таких классов в стандартных контейнерах. Например, `std::vector\u003cC\u003e` при реаллокации будет использовать конструктор перемещения класса `C`, если он помечен как `noexcept`. В противном случае будет использован конструктор копирования, который может быть менее эффективен, но зато позволит обеспечить строгую гарантию безопасности при реаллокации.\n"])</script><script nonce="">self.__next_f.push([1,"6e:T87ce,"])</script><script nonce="">self.__next_f.push([1,"[Идиома RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization) (Resource Acquisition Is Initialization) переводится как «захват ресурса должен быть инициализацией объекта». Пусть программе требуется какой-то ресурс (память, файл), который надо обязательно «вернуть», когда он будет уже не нужен. Идея состоит в том, что лучше всего запрашивать этот ресурс в конструкторе некоторого объекта, а освобождать — в деструкторе. На этой идее построены стандартные контейнеры и так называемые «умные указатели» — классы `unique_ptr` и `shared_ptr` из стандартной библиотеки.\n\nНазвание идиомы, как замечает сам Бьярне Страуструп, выбрано неудачно. Лучше отражают её смысл альтернативные названия:\n - CADR (Constructor Acquires, Destructor Releases) — в конструкторе захватываем ресурс, в деструкторе — освобождаем;\n - SBRM (Scope-Bound Resource Management) — управление ресурсами с привязкой к области видимости.\n\n\n## Файл как ресурс\n\nРассмотрим хрестоматийный пример ресурса: файл. Работу программы с файлами обеспечивает операционная система. Файл вначале нужно «открыть» для чтения или записи, а в конце работы — «закрыть».\n\nДавайте посмотрим, как работали с файлами в языке С, из которого вырос C++. С каждым файлом связывался так называемый файловый дескриптор. Это был просто указатель на объект специальной структуры `std::FILE`.\n\nЭтот способ возможен и в C++. Мы обсудим его недостатки и напишем позже более удобную замену.\n\n```cpp\n#include \u003ccstdio\u003e\n\nint main() {\n    // Открываем файл input.txt для чтения и получаем его дескриптор\n    if (std::FILE* f = std::fopen(\"input.txt\", \"r\"); f != nullptr) {\n        // Если дескриптор не является нулевым указателем, то файл успешно окрыт\n        char buf[100];  // массив символов размера 100\n        std::fscanf(f, \"%99s\", buf);  // считываем из файла максимум 99 символов текста в буфер\n        // ...\n        std::fclose(f);  // закрываем файл\n    } else {\n        std::cout \u003c\u003c \"File open failure!\\n\";\n    }\n}\n```\n\nМы не будем останавливаться на деталях работы функции `fscanf`. Нас сейчас интересует открытие и закрытие файла, а также поведение программы в случае ошибок.\n\nВ приведённом примере обрабатывается случай, когда файл не получается открыть. Такое может произойти если файла с указанным именем, например, не существует. В строках кода, обозначенных многоточием, тоже возможны аварийные ситуации. Например, в файле могут оказаться некорректные данные. В каждой из таких ситуаций важно не забыть закрыть файл. Код с такими проверками становится слишком громоздким.\n\nСогласно идиоме RAII, нам следует «обернуть» файловый дескриптор в объект специального класса. Тогда открытие файла соответствовало бы инициализации объекта в его конструкторе, а закрытие файла — уничтожению объекта в деструкторе. В случае ошибки при открытии файла мы бы сгенерировали исключение, и объект нашего класса не был бы создан.\n\n```cpp\n#include \u003ccstdio\u003e\n#include \u003cexception\u003e\n#include \u003cstring\u003e\n\nclass CannotOpenFileException {\n};\n\nclass File {\nprivate:\n    std::FILE* f;  // тот самый файловый дескриптор, который мы оборачиваем\n\npublic:\n    File(const std::string\u0026 name) {\n        if (f = std::fopen(name.c_str(), \"r\"); f == nullptr) {\n            throw CannotOpenFileException();\n        }\n    }\n\n    ~File() noexcept {\n        std::fclose(f);\n    }\n\n    std::string Read() const {\n        char buf[100];\n        std::fscanf(f, \"%99s\", buf);\n        return buf;\n    }\n};\n```\n\nТеперь можно работать так:\n\n```cpp\nint main() {\n    try {\n        File file(\"input.txt\");\n        auto str = file.Read();\n        // ...\n    } catch (const CannotOpenFileException\u0026) {\n        std::cout \u003c\u003c \"File open failure!\\n\";\n    }\n}\n```\n\nЧто бы ни произошло в строках с многоточием, для объекта `file` всегда будет вызван деструктор, а значит, файл будет корректно закрыт.\n\n\n## Копирование и присваивание\n\nНаша обёртка `File` пока не идеальна: у неё есть проблемы с копированием и присваиванием. Рассмотрим такой пример:\n\n```cpp\nint main() {\n    File f1(\"a.txt\");\n    File f2 = f1;  // конструктор копирования\n    File f3(\"b.txt\");\n    f3 = f1;  // оператор присваивания\n}\n```\n\nВсе эти три объекта хранят внутри на самом деле один и тот же файловый дескриптор. Когда для них вызовутся деструкторы, то один и тот же файл будет закрыт несколько раз, что ошибочно.\n\nОдин из способов решить эту проблему — просто запретить такое копирование и присваивание. Это можно сделать так:\n\n```cpp\nclass File {\npublic:\n    // Запрещаем компилятору автоматически генерировать\n    // конструктор копирования и оператор присваивания:\n    File(const File\u0026) = delete;\n    File\u0026 operator = (const File\u0026) = delete;\n\n    // ...\n};\n```\n\nТеперь код функции `main` как в примере выше просто не скомпилируется. Но всё-таки хочется, чтобы вот такой код был допустимым:\n\n```cpp\n// Вспомогательная функция\nFile GetFile() {\n    File f(\"a.txt\");\n    // ...\n    return f;\n}\n\nint main() {\n     // Сейчас не сработает — конструктор копирования запрещён!\n     File f = GetFile();  // ошибка компиляции!\n     // ...\n}\n```\n\nВ отличие от предыдущего примера с копированием именованных объектов, здесь копируется временный объект — результат функции `GetFile`. Как мы знаем, для таких объектов предусмотрены особые rvalue-ссылки. Можно просто написать конструктор перемещения, который заберет данные из такого объекта:\n\n```cpp\nclass File {\npublic:\n    File(const File\u0026) = delete;\n    File\u0026 operator = (const File\u0026) = delete;\n\n    // Конструктор перемещения\n    File(File\u0026\u0026 other) noexcept {  // File\u0026\u0026 — ссылка на временный объект\n        f = other.f;\n        other.f = nullptr;  // забираем владение дескриптором у временного объекта other!\n    }\n\n    // Оператор присваивания с семантикой перемещения\n    File\u0026 operator = (File\u0026\u0026 other) noexcept {\n        if (f != nullptr \u0026\u0026 f != other.f) {\n            fclose(f);  // закрываем файл у текущего объекта\n        }\n        f = other.f;  // забираем владение у временного объекта other\n        other.f = nullptr;\n        return *this;\n    }\n\n    // Добавим проверку в деструктор:\n    ~File() noexcept {\n        if (f != nullptr) {\n            fclose(f);\n        }\n    }\n\n    // ...\n};\n```\n\nТеперь копирование и присваивание обычных именованных объектов запрещены, но для временных объектов они возможны. Так как временный объект всё равно скоро будет уничтожен деструктором, можно отобрать у него владение ресурсом и оставить его «сиротой», то есть, сделать указатель `f` нулевым. У такого объекта уже нельзя вызывать функцию `Read`, но никто это и не будет делать\n\nВ деструкторе мы добавляем проверку и закрываем файл только если дескриптор `f` ненулевой. Это обеспечивает корректную работу деструктора для «осиротевших» временных объектов.\n\nЗаметим, что оператор перемещающего присваивания можно было бы реализовать чуть иначе с помощью функции `std::swap`. Это позволяет избавиться от неуклюжей проверки и от вызова `fclose` внутри тела оператора:\n\n```cpp\n#include \u003cutility\u003e\n\nclass File {\npublic:\n    File\u0026 operator = (File\u0026\u0026 other) noexcept {\n        std::swap(f, other.f);  // обмениваемся дескрипторами с other\n        return *this;\n    }\n\n    // ...\n};\n```\n\nЗдесь мы просто обмениваемся дескрипторами с временным объектом `other`. Файловый дескриптор текущего объекта будет закрыт в деструкторе объекта `other`, который должен быть вызван вскоре после присваивания.\n\nВ отличие от оператора перемещающего присваивания, в конструкторе перемещения закрывать файловый дескриптор у текущего объекта не нужно, так как текущего объекта пока просто не существует.\n\n\n## RAII в стандартной библиотеке\n\nВ стандартной библиотеке уже есть готовая обёртка над файловыми дескрипторами `std::fstream`, которая позволяет работать с файлами как с потоками ввода-вывода. Она написана в стиле `RAII` и напоминает наш класс `File`. Некоторое отличие заключается в том, что конструктор `std::fstream` не генерирует исключение в случае ошибки.\n\nВот как ей можно воспользоваться:\n\n```cpp\n#include \u003cfstream\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::fstream file(\"input.txt\");\n\n    std::string data;\n    file \u003e\u003e data;\n\n    std::cout \u003c\u003c data \u003c\u003c \"\\n\";\n}   // файл автоматически закроется при вызове деструктора\n```\n\n\nДругим примером ресурса является динамическая память. Все контейнеры стандартной библиотеки (кроме, пожалуй, `std::array`) так или иначе исповедуют идиому RAII: в их конструкторах выделяется память, которой они владеют, а в деструкторах эта память освобождается. Таким образом, эти контейнеры надёжно защищают программиста от ошибок из-за утечек памяти.\n\n{% cut \"Ещё примеры\" %}\n\nДругим примером использования RAII в стандартной библиотеке является класс [`std::lock_guard`](https://en.cppreference.com/w/cpp/thread/lock_guard). Он предназначен для синхронизации [мьютексов](https://en.wikipedia.org/wiki/Lock_(computer_science)) в многопоточном приложении. Многопоточность выходит за рамки этого пособия. Но тем не менее приведём такой пример для иллюстрации.\n\n```cpp\n#include \u003cmutex\u003e\n\nstd::mutex m;\n\nvoid f();  // какая-то функция\n\nvoid Bad() {\n    m.lock();  // захватываем мьютекс\n    f();  // если произойдёт исключение, то мьютекс никогда не освободится\n    m.unlock();  // освобождаем мьютекс\n}\n\nvoid Good() {\n    std::lock_guard\u003cstd::mutex\u003e lock(m);  // класс-обёртка в стиле RAII\n    f();  // если произойдёт исключение, то мьютекс будет освобождён!\n}   // вызов m.unlock() не требуется — это сделает деструктор объекта lock\n```\n\n{% endcut %}\n\n\n## Владение несколькими ресурсами\n\nРешим задачу, которую часто предлагают на собеседованиях. Пусть дан некоторый класс `A`. Нужно написать конструкторы и деструктор класса `C`, который владеет переменной типа `A` и хранит её в динамической памяти.\n\nНапишем сначала наивный вариант решения.\n\n```cpp\ntemplate \u003ctypename A\u003e\nclass C {\nprivate:\n    A* x;\n\npublic:\n    C() {\n        x = new A();\n    }\n\n    // ...\n\n    ~C() {\n        delete x;\n    }\n};\n```\n\nТут есть такая же проблема, как и с классом `File`: конструктор копирования и оператор присваивания по умолчанию просто скопируют указатель на ту же память:\n\n```cpp\nint main() {\n    C\u003cint\u003e c1;\n    C\u003cint\u003e c2(c1);  // указатели c1.x и c2.x равны!\n}  // проблема: в деструкторе c1 память будет освобождена повторно!\n```\n\nДопишем конструктор копирования и оператор присваивания. В отличие от класса `File` мы не будем их запрещать, а сделаем «глубокое» копирование:\n\n```cpp\ntemplate \u003ctypename A\u003e\nclass C {\nprivate:\n    A* x;\n\npublic:\n    C() {\n        x = new A();\n    }\n\n    // Создаём новый объект с помощью конструктора копирования класса A\n    C(const C\u0026 other) {\n        x = new A(*other.x);\n    }\n\n    // Вызываем оператор присваивания не для указателей, а для объектов класса A\n    C\u0026 operator = (const C\u0026 other) {\n        *x = *other.x;\n        return *this;\n    }\n\n    ~C() {\n        delete x;\n    }\n};\n```\n\nНаш класс владеет динамической памятью в стиле RAII: в конструкторах память выделяется, в деструкторе — освобождается. Теперь усложним задачу. Пусть даны два класса `A` и `B`. В нашем классе `D` должны быть два указателя: и на объект класса `A`, и на объект класса `B`. Наш класс `D` должен владеть и той, и другой динамической памятью.\n\n```cpp\ntemplate \u003ctypename A, typename B\u003e\nclass D {\nprivate:\n    A* x;\n    B* y;\n\npublic:\n    D() {\n        x = new A();\n        y = new B();\n    }\n\n    D(const D\u0026 other) {\n        x = new A(*other.x);\n        y = new B(*other.y);\n    }\n\n    D\u0026 operator = (const D\u0026 other) {\n        *x = *other.x;\n        *y = *other.y;\n        return *this;\n    }\n\n    ~D() {\n        delete x;\n        delete y;\n    }\n};\n```\n\nКазалось бы, здесь нет никакого подвоха. Однако такой класс по сравнению с предыдущей версией является опасным. Дело в том, что в конструкторе при инициализации поля `y` может произойти ошибка. Во-первых, может просто не хватить динамической памяти. Во-вторых, может произойти исключение в конструкторе класса `B`. Сама ошибка не является чем-то опасным. Однако давайте посмотрим, что произойдёт при этом с полем `x`. При исключении будет сворачиваться стек. В частности, будет вызван деструктор для уже проинициализированной переменной `x`. Но деструктор указателя тривиален. Этот деструктор не сделает ничего. Поэтому объект `*x` не будет корректно уничтожен и память в `x` «утечёт». Напомним, что деструктор `~D` не будет вызван, так как конструктор завершится с ошибкой.\n\nПервое приходящее в голову решение проблемы: обернуть инициализацию в конструкторе в `try`/`catch`:\n\n```cpp\ntemplate \u003ctypename A, typename B\u003e\nclass D {\nprivate:\n    A* x;\n    B* y;\n\npublic:\n    D() {\n       x = new A();  // тут тоже может произойти ошибка, но она не приведёт к утечкам!\n       try {\n           y = new B();\n       } catch (...) {\n           delete x;  // если что-то пошло не так, то освобождаем уже созданный x\n           throw;  // и прокидываем исключение дальше\n       }\n    }\n\n    // Примерно такой же код придётся написать\n    // в конструкторе копирования и в операторе присваивания\n    // ...\n\n    ~D() {\n        delete x;\n        delete y;\n    }\n};\n```\n\nМы решили проблему, но это выглядит коряво. Если ли лучшее решение? Следуя идиоме RAII нам следовало бы *каждую* переменную — и `x`, и `y` — хранить вместо обычного указателя в какой-нибудь умной «обёртке». В конструкторе такой обёртки выделялась бы память, а в деструкторе она бы освобождалась. В чём-то такая обёртка была бы похожа на класс `C` с одним указателем. Тогда в самом классе `D` нам не пришлось бы ни обрабатывать исключения, ни писать деструктор. Более того, не надо было бы вообще определять свои методы: сгодились бы все те, что компилятор предоставляет по умолчанию.\n\n```cpp\ntemplate \u003ctypename A, typename B\u003e\nclass D {\nprivate:\n    C\u003cA\u003e x;\n    C\u003cB\u003e y;\n};\n```\n\nЗаметьте, никаких конструкторов, операторов присваивания и деструктора в классе `D` теперь вообще писать не нужно! Что, например, произойдёт, если в конструкторе по умолчанию при инициализации поля `y` будет выброшено исключение? В этом случае будет сворачиваться стек. Для уже проинициализированного поля `x` будет вызван деструктор. Но теперь тип поля `x` — это не «голый» указатель `A*`, а наша обёртка `C\u003cA\u003e`. В её деструкторе и будет освобождена память. Утечки не произойдёт.\n\n{% cut \"Зачем может понадобиться хранить в классе не обычные поля, а указатели?\" %}\n\nРассмотрим, например, вот такую альтернативу классу `D`:\n\n```cpp\ntemplate \u003ctypename A, typename B\u003e\nclass E {\nprivate:\n    A a;\n    B b;\n};\n```\n\nЗдесь поля `a` и `b` являются автоматическими. Если такой вариант решения возможен, то он является более предпочтительным. Однако указатели могут понадобиться по следующим причинам:\n\n1. Объекты типа `A` и `B` могут быть «тяжёлыми», то есть, иметь большой `sizeof`. Поэтому их может быть выгоднее создавать не на стеке, который ограничен, а в динамической памяти.\n\n2. Может потребоваться [отложенная инициализация](https://en.wikipedia.org/wiki/Lazy_initialization) для полей `a` и `b`. Класс `E` требует, чтобы эти поля были проинициализированы сразу в его конструкторе. Но инициализация `a` или `b` может быть долгой или дорогой, или у нас пока может не быть для неё достаточного набора данных. Если там будет указатель (изначально — нулевой), то создать объекты типов `A` и `B` можно будет и позже. Впрочем, для этого можно использовать и обёртку [`std::optional`](https://en.cppreference.com/w/cpp/utility/optional).\n\n3. Мы пишем класс-контейнер, который хранит свои данные в динамической памяти. Обычно двумя указателями тут не обойтись, но аналогия распространяется и на более сложные случаи. Например, можно реализовать матрицу через низкоуровневое выделение памяти для двумерного массива. А можно вместо этого воспользоваться готовой RAII-обёрткой — стандартным вектором векторов, что мы и сделали в [параграфе «Шаблоны классов»](https://education.yandex.ru/handbook/cpp/article/template-classes).\n\n{% endcut %}\n\n## Умный указатель `std::unique_ptr`\n\nУмные обёртки над отдельным указателем, следующие идиоме RAII, есть в стандартной библиотеке. Это так называемые [*умные указатели*](https://en.wikipedia.org/wiki/Smart_pointer) (smart pointers).\n\nРассмотрим умный указатель [`std::unique_ptr`](https://en.cppreference.com/w/cpp/memory/unique_ptr).\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmemory\u003e  // все умные указатели объявлены здесь\n\nint main() {\n    int* ptr = new int(17);  // обычный указатель\n    std::cout \u003c\u003c *ptr \u003c\u003c \"\\n\";  // 17\n    delete ptr;  // важно не забыть!\n\n    // А это — умный указатель\n    std::unique_ptr\u003cint\u003e smart = std::make_unique\u003cint\u003e(17);  // вместо new int(17)\n\n    // Он притворяется обычным указателем — у него перегружены соответствующие операторы:\n    std::cout \u003c\u003c *smart \u003c\u003c \"\\n\";  // 17\n\n}   // вызывать delete не надо, выделенная память освободится при выходе из блока\n```\n\nУмный указатель «владеет» ресурсом: память будет освобождена в его деструкторе. Слово `unique` в его названии подчёркивает, что это единственный владелец ресурса. Такой указатель, как и наш класс `File`, нельзя скопировать. Иначе будет непонятно, кто должен владеть ресурсом и кто должен удалять его: исходный объект или копия?\n\n```cpp\n    auto smart2 = smart;  // не скомпилируется!\n```\n\nЗаметим, что `std::unique_ptr` отличается от класса `C`, который мы написали ранее. Класс `C` выполнял глубокое копирование хранимого объекта, в то время как `std::unique_ptr` копирование запрещает. В этом смысле `std::unique_ptr` больше похож на наш класс `File`. Как и у `File`, у `std::unique_ptr` есть конструктор перемещения и оператор перемещающего присваивания. Поэтому, хотя объекты `std::unique_ptr` нельзя копировать, их можно возвращать из функции:\n\n```cpp\n#include \u003cmemory\u003e\n#include \u003cutility\u003e\n\n// Странная функция: она неявно требует, чтобы вызывающая сторона взяла на себя владение ресурсом\nint* f() {\n    // ...\n    return new int(123);\n}\n\n// Эта функция возвращает умный указатель:\nstd::unique_ptr\u003cint\u003e g() {\n    // ...\n    return std::make_unique\u003cint\u003e(123);  // OK\n}\n\nint main() {\n    f();  // возвращаемое значение проигнорировано, память утекла!\n    g();  // а тут ничего страшного: деструктор временного объекта очистил память\n}\n```\n\nМожет показаться, что `std::unique_ptr` фактически не отличается от автоматической переменной. Это не так. Объект, созданный в динамической памяти и обёрнутый в `std::unique_ptr`, всегда имеет одного чётко определённого владельца. Невозможно случайно создать копию такого объекта. Владение можно передавать в функции и возвращать из них.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmemory\u003e\n#include \u003cutility\u003e\n\nvoid PutIn(std::unique_ptr\u003cLogger\u003e x) {\n    // Получаем x по значению\n    // что-то делаем с x\n}\n\nint main() {\n    auto smart = std::make_unique\u003cLogger\u003e();\n    // ...\n\n    // Притворяемся, что smart — временный объект.\n    // Фактически, передаём владение в функцию.\n    PutIn(std::move(smart));\n\n    // Объект smart теперь всё ещё живой, но он больше ничем не владеет\n    if (smart.get() == nullptr) {\n        std::cout \u003c\u003c \"Empty!\\n\";  // Empty!\n    }\n}\n```\n\nРассмотрим элегантную реализацию односвязного списка через `std::unique_ptr`.\n\n```cpp\n#include \u003cmemory\u003e\n\ntemplate \u003ctypename T\u003e\nclass ForwardList {\nprivate:\n    struct Node {\n        T data;\n        std::unique_ptr\u003cNode\u003e next;  // узел владеет следующим узлом\n    };\n\n    std::unique_ptr\u003cNode\u003e head;  // сам список владеет начальным узлом\n\npublic:\n    void PushFront(const T\u0026 elem) {\n        head = std::make_unique\u003cNode\u003e(elem, std::move(head));\n    }\n\n    void PopFront() {\n        head = std::move(head-\u003enext);\n    }\n\n    const T\u0026 Front() const {\n        return head-\u003edata;\n    }\n\n    bool Empty() const {\n        return head == nullptr;\n    }\n\n    ~ForwardList() {\n        // Можно было бы оставить деструктор пустым — всё корректно бы удалилось,\n        // но на больших списках мог бы переполниться стек вызовов из-за рекурсии в деструкторе Node.\n        while (!Empty()) {\n            PopFront();\n        }\n    }\n\n};\n```\n\nСравните это с реализацией класса `List` из [предыдущего параграфа](https://education.yandex.ru/handbook/cpp/article/exceptions)!\n\n\n## Умный указатель `std::shared_ptr`\n\nДругая разновидность умного указателя — умный указатель с подсчётом ссылок на объект. Это [`std::shared_ptr`](https://en.cppreference.com/w/cpp/memory/shared_ptr). Такой указатель уже можно копировать. При копировании увеличивается счётчик созданных копий. В деструкторе этот счётчик уменьшается. Объект удаляется последним владельцем, когда счётчик дойдёт до нуля. Этот счётчик хранится в отдельной ячейке динамической памяти. На неё ссылаются все объекты `shared_ptr`, которые разделяют владение одним и тем же объектом в динамической памяти. Текущее значение счётчика можно узнать с помощью функции `use_count`.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmemory\u003e\n\nint main() {\n    std::shared_ptr\u003cint\u003e ptr1 = std::make_shared\u003cint\u003e(17);\n    std::cout \u003c\u003c *ptr1 \u003c\u003c \"\\n\";  // 17\n    std::cout \u003c\u003c ptr1.use_count() \u003c\u003c \"\\n\";  // 1\n\n    auto ptr2 = ptr1;  // копирование разрешено!\n    std::cout \u003c\u003c *ptr1 \u003c\u003c \"\\n\";  // 17\n    std::cout \u003c\u003c *ptr2 \u003c\u003c \"\\n\";  // 17 — это всё тот же объект\n    std::cout \u003c\u003c ptr1.use_count() \u003c\u003c \"\\n\";  // 2\n    std::cout \u003c\u003c ptr2.use_count() \u003c\u003c \"\\n\";  // 2\n\n    std::shared_ptr\u003cint\u003e ptr3;\n    std::cout \u003c\u003c ptr3.use_count() \u003c\u003c \"\\n\";  // 0\n\n    ptr3 = ptr1;  // присваивание тоже разрешено!\n    std::cout \u003c\u003c *ptr3 \u003c\u003c \"\\n\";  // 17\n    std::cout \u003c\u003c ptr1.use_count() \u003c\u003c \"\\n\";  // 3\n    std::cout \u003c\u003c ptr2.use_count() \u003c\u003c \"\\n\";  // 3\n    std::cout \u003c\u003c ptr3.use_count() \u003c\u003c \"\\n\";  // 3\n}\n```\n\nКлассический случай применения `std::shared_ptr` — реализация [направленного ациклического графа](https://stackoverflow.com/questions/27348396/smart-pointers-for-graph-representation-vertex-neighbors-in-c11). В этой реализации каждая вершина хранит вектор умных указателей на соседние вершины, в которые ведут рёбра. Умные указатели на начальные вершины хранятся отдельно.\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://yastatic.net/s3/education-portal/media/C_24_4d837aca9a_e374744778.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\"\u003e\n  \u003cfigcaption\u003e\n    Пример направленного ациклического графа.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\n{% cut \"Подробнее\" %}\n\nТребование ацикличности графа важно: если допустить циклы в таком графе, то может оказаться, что вершина `A` ссылается через `std::shared_ptr` на вершину `B`, а та, в свою очередь, ссылается через `std::shared_ptr` на вершину `A`. Такой цикл никогда не сможет быть разрушен с помощью счётчика ссылок. Это приведёт к утечке памяти. Решением может быть замена одной из ссылок на [`std::weak_ptr`](https://en.cppreference.com/w/cpp/memory/weak_ptr), но это выходит за рамки этого пособия.\n\n{% endcut %}\n\nСледует помнить, что счётчик ссылок и выделение динамической памяти — это дополнительные накладные расходы. Поэтому предпочитайте класс `std::unique_ptr` классу `std::shared_ptr`, а обычный объект на стеке — умному указателю `std::unique_ptr` там, где это возможно.\n"])</script><script nonce="">self.__next_f.push([1,"6f:T2fde7,"])</script><script nonce="">self.__next_f.push([1,"## Параграф «Классы»\n\n### [Задача «Дата»](https://new.contest.yandex.ru/42158/problem?id=40119/2022_10_30/P3uS0Pifjg)\n\n{% cut \"Условие\" %}\n\nВам надо написать класс `Date` для хранения даты григорианского календаря. Используйте три переменных типа `int` для хранения дня, месяца и года. В вашем классе должен быть следующий публичный интерфейс:\n\n1. Конструктор, принимающий на вход три числа: день, месяц и год. В случае некорректной даты должна создаваться дата $1$ января $1970$ года.\n\n2. Константные функции `GetDay`, `GetMonth` и `GetYear`.\n\n3. Бинарные операторы `+` и `-`, где вторым аргументом является целое число — количество дней. Эти операторы должны вернуть новую дату, отстоящую от заданной на указанное число дней.\n\n4. Бинарный оператор `-`, вычисляющий разность между двумя датами и возвращающий `int` – количество дней.\n\nСчитайте, что все обрабатываемые даты будут лежать в пределах от $1$ января $1970$ года до $31$ декабря $2099$ года.\n\n#### Примечания\n\nСдайте в систему только код класса `Date` без функции main.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДля начала запишем главное условие — «Используйте три переменных типа `int` для хранения дня, месяца и года», также определим константы.\n\n```cpp\nconst int DEFAULT_DATE_DAY = 1;\nconst int DEFAULT_DATE_MONTH = 1;\nconst int DEFAULT_DATE_YEAR = 1970;\nconst int DAYS_IN_YEAR_WITHOUT_FEB = 337;\n\nclass Date {\nprivate:\n    int d = DEFAULT_DATE_DAY, m = DEFAULT_DATE_MONTH, y = DEFAULT_DATE_YEAR;\n\n    // Дальше реализуем вспомогательные функции-члены.\n    // Нам нужно будет понимать високосный ли перед нами год, корректную ли дату ввели:\n    int GetDaysInFeb(int year) const {\n        if ((!(year % 4) \u0026\u0026 (year % 100)) || !(year % 400)) {\n            return 29;\n        }\n        return 28;\n    }\n\n    int GetDaysInMonth(int month, int year) const {\n        switch (month) {\n            case 2:\n                return GetDaysInFeb(year);\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n            case 8:\n            case 10:\n            case 12:\n                return 31;\n            default:\n                return 30;\n        }\n    }\n\n    int GetDaysInYear(int year) const {\n        return DAYS_IN_YEAR_WITHOUT_FEB + GetDaysInFeb(year);\n    }\n\n    bool IsCorrectDate() const {\n        return GetMonth() \u003c= 12 \u0026\u0026 GetMonth() \u003e= 1 \u0026\u0026 GetDay() \u003c= GetDaysInMonth(GetMonth(), GetYear()) \u0026\u0026 GetDay() \u003e 0;\n    }\n\n    // Помимо прочего будет полезно уметь переводить текущую дату в число — количество дней от 01.01.1970 и обратно.\n    int DaysPassedToMonth(int month, int year) const {\n        int days = 0;\n        for (int i = 1; i \u003c month; ++i) {\n            days += GetDaysInMonth(i, year);\n        }\n        return days;\n    }\n\n    int GetDays() const {\n        int days = 0;\n        for (int i = DEFAULT_DATE_YEAR; i \u003c GetYear(); ++i) {\n            days += GetDaysInYear(i);\n        }\n        return days + DaysPassedToMonth(GetMonth(), GetYear()) + GetDay();\n    }\n\n    void SetFromDays(int inp_days) {\n        m = DEFAULT_DATE_MONTH;\n        y = DEFAULT_DATE_YEAR;\n\n        while (inp_days \u003e GetDaysInYear(GetYear())) {  // сначала определяем год\n            inp_days -= GetDaysInYear(GetYear());\n            ++y;\n        }\n\n        while (inp_days \u003e DaysPassedToMonth(GetMonth() + 1, GetYear())) {  // определяем месяц\n            ++m;\n        }\n\n        d = inp_days - DaysPassedToMonth(GetMonth(), GetYear());  // остаток в дни\n    }\n\n// Когда подготовительная часть закончена, реализуем публичный интерфейс:\npublic:\n    Date(int day, int month, int year)\n            : d{day}, m{month}, y{year} {\n        if (!IsCorrectDate()) {\n            d = DEFAULT_DATE_DAY;\n            m = DEFAULT_DATE_MONTH;\n            y = DEFAULT_DATE_YEAR;\n        }\n    }\n\n    int GetDay() const {\n        return d;\n    }\n\n    int GetMonth() const {\n        return m;\n    }\n\n    int GetYear() const {\n        return y;\n    }\n\n    Date operator + (int k) const {\n        Date result(*this);\n        result.SetFromDays(result.GetDays() + k);\n        return result;\n    }\n\n    Date operator - (int k) const {\n        Date result(*this);\n        result.SetFromDays(result.GetDays() - k);\n        return result;\n    }\n\n    int operator - (const Date\u0026 other) const {\n        return GetDays() - other.GetDays();\n    }\n};\n```\n\n{% endcut %}\n\n### [Задача «Дата - 2»](https://new.contest.yandex.ru/42158/problem?id=40119/2022_10_30/DMKpiJs31G)\n\n{% cut \"Условие\" %}\n\nВам надо переделать реализацию класса `Date` из предыдущей задачи, сохранив публичный интерфейс неизменным. Теперь для хранения даты используйте одну переменную типа `int` — количество дней, прошедших с некоторого начала отсчёта.\n\nСчитайте, что все обрабатываемые даты будут лежать в пределах от $1$ января $1970$ года до $31$ декабря $2099$ года.\n\n#### Примечания\n\nСдайте в систему только код класса `Date` без функции main.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nИзменим нашу реализацию из предыдущей задачи. Часть вспомогательных функций-членов не меняется:\n\n```cpp\n#include \u003ctuple\u003e\n\nconst int DEFAULT_DATE_DAY = 1;\nconst int DEFAULT_DATE_MONTH = 1;\nconst int DEFAULT_DATE_YEAR = 1970;\nconst int DAYS_IN_YEAR_WITHOUT_FEB = 337;\n\nclass Date {\nprivate:\n    int days{0};\n\n    int GetDaysInFeb(int year) const {\n        if ((!(year % 4) \u0026\u0026 (year % 100)) || !(year % 400)) {\n            return 29;\n        }\n        return 28;\n    }\n\n    int GetDaysInMonth(int month, int year) const {\n        switch (month) {\n            case 2:\n                return GetDaysInFeb(year);\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n            case 8:\n            case 10:\n            case 12:\n                return 31;\n            default:\n                return 30;\n        }\n    }\n\n    int GetDaysInYear(int year) const {\n        return DAYS_IN_YEAR_WITHOUT_FEB + GetDaysInFeb(year);\n    }\n\n    int DaysPassedToMonth(int month, int year) const {\n        int result = 0;\n        for (int i = 1; i \u003c month; ++i) {\n            result += GetDaysInMonth(i, year);\n        }\n        return result;\n    }\n\n    // Отредактируем перевод из даты в дни и обратно:\n    void SetDays(int day, int month, int year) {\n        days = 0;\n        for (int i = DEFAULT_DATE_YEAR; i \u003c year; ++i) {\n            days += GetDaysInYear(i);\n        }\n        days = days + DaysPassedToMonth(month, year) + day;\n    }\n\n    std::tuple\u003cint, int, int\u003e ToDate() const {\n        int inp_days = days;\n        int month = DEFAULT_DATE_MONTH;\n        int year = DEFAULT_DATE_YEAR;\n\n        while (inp_days \u003e GetDaysInYear(year)) {  // сначала определяем год\n            inp_days -= GetDaysInYear(year);\n            ++year;\n        }\n\n        while (inp_days \u003e DaysPassedToMonth(month + 1, year)) {  // определяем месяц\n            ++month;\n        }\n\n        int day = inp_days - DaysPassedToMonth(month, year);  // остаток в дни\n        return {day, month, year};\n    }\n\n    void SetFromDays(int inp_days) {\n        days = inp_days;\n    }\n\n    int GetDays() const {\n        return days;\n    }\n\n// Осталось поменять публичные интерфейсы.\n// Так как в них мы почти не завязывались на тип хранения,\n//     правки будут только в функциях-членах чтения и конструкторе:\npublic:\n    Date(int day, int month, int year) {\n        if (month \u003e 12 || month \u003c 1 || day \u003e GetDaysInMonth(month, year) || day \u003c 1) {\n            days = 0;\n        } else {\n            SetDays(day, month, year);\n        }\n    }\n\n    int GetDay() const {\n        return std::get\u003c0\u003e(ToDate());\n    }\n\n    int GetMonth() const {\n        return std::get\u003c1\u003e(ToDate());\n    }\n\n    int GetYear() const {\n        return std::get\u003c2\u003e(ToDate());\n    }\n\n    Date operator + (int k) const {\n        Date result(*this);\n        result.SetFromDays(result.GetDays() + k);\n        return result;\n    }\n\n    Date operator - (int k) const {\n        Date result(*this);\n        result.SetFromDays(result.GetDays() - k);\n        return result;\n    }\n\n    int operator - (const Date\u0026 other) const {\n        return GetDays() - other.GetDays();\n    }\n};\n```\n\n{% endcut %}\n\n### [Задача «Rational»](https://new.contest.yandex.ru/42158/problem?id=40119/2022_10_30/LJjNoDCHJX)\n\n{% cut \"Условие\" %}\n\nНапишите класс `Rational` (рациональное число). Конструктор класса должен получать на вход два числа типа `int` (числитель и знаменатель). Считайте, что по умолчанию числитель равен 0, а знаменатель — 1.\n\nПереопределите бинарные операторы сложения, вычитания, умножения и деления (работающие в том числе и с аргументами типа `int`), унарные плюс и минус. Предусмотрите функции-члены `Numerator` и `Denominator` для получения числителя и знаменателя несократимого представления этой дроби (знаменатель должен быть положительным). Переопределите также операторы `+=`, `-=`, `*=` и `/=`. Не забудьте определить операторы `==` и `!=`.\n\n#### Примечания\n\nИспользуйте функцию [std::gcd](https://en.cppreference.com/w/cpp/numeric/gcd) стандартной библиотеки.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nОдно и то же число может быть задано разными парами числитель/знаменатель (1/2, 2/4, 3/6, ...). Мы же будем хранить рацинальное число в виде несократимой дроби. Для этого нам потребуется функция `std::gcd`, которая появилась в [C\\+\\+17](https://en.cppreference.com/w/cpp/numeric/gcd). Впрочем, можно написать самостоятельно её реализацию с помощью [алгоритма Евклида](https://en.wikipedia.org/wiki/Euclidean_algorithm):\n\n```cpp\nint gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n```\n\nМы введём вспомогательную приватную функцию `Reduce`, которая будет сокращать дробь и гарантировать, что знаменатель неотрицателен. Эту функцию мы будем вызывать всякий раз, когда при вычислениях дробь могла стать сократимой.\n\n```cpp\n#include \u003cnumeric\u003e\n\nclass Rational {\nprivate:\n    int num;\n    int denom;\n\n    void Reduce() {\n        int d = std::gcd(num, denom);\n        num /= d;\n        denom /= d;\n        if (denom \u003c 0) {\n            num *= -1;\n            denom *= -1;\n        }\n    }\n\npublic:\n    Rational(int num_ = 0, int denom_ = 1) : num(num_), denom(denom_) {\n        Reduce();\n    }\n\n    int Numerator() const {\n        return num;\n    }\n\n    int Denominator() const {\n        return denom;\n    }\n\n    // унарный плюс (формально ничего не меняет)\n    Rational operator + () const {\n        return {num, denom};\n    }\n\n    // унарный минус\n    Rational operator - () const {\n        return Rational(-num, denom);\n    }\n\n    // rhs - сокращение от right hand side (правый аргумент бинарного оператора)\n    Rational\u0026 operator += (const Rational\u0026 rhs) {\n        num = num * rhs.denom + rhs.num * denom;\n        denom *= rhs.denom;\n        Reduce();\n        return *this;\n    }\n\n    Rational\u0026 operator -= (const Rational\u0026 rhs) {\n        num = num * rhs.denom - rhs.num * denom;\n        denom *= rhs.denom;\n        Reduce();\n        return *this;\n    }\n\n    Rational\u0026 operator *= (const Rational\u0026 rhs) {\n        num *= rhs.num;\n        denom *= rhs.denom;\n        Reduce();\n        return *this;\n    }\n\n    Rational\u0026 operator /= (const Rational\u0026 rhs) {\n        // сохраняем старый числитель, чтобы корректно работало выражение q /= q.\n        int tmp = rhs.num;\n        num *= rhs.denom;\n        denom *= tmp;\n        Reduce();\n        return *this;\n    }\n};\n\nRational operator + (const Rational\u0026 lhs, const Rational\u0026 rhs) {\n    Rational result = lhs;\n    result += rhs;\n    return result;\n}\n\nRational operator - (const Rational\u0026 lhs, const Rational\u0026 rhs) {\n    Rational result = lhs;\n    result -= rhs;\n    return result;\n}\n\nRational operator * (const Rational\u0026 lhs, const Rational\u0026 rhs) {\n    Rational result = lhs;\n    result *= rhs;\n    return result;\n}\n\nRational operator / (const Rational\u0026 lhs, const Rational\u0026 rhs) {\n    Rational result = lhs;\n    result /= rhs;\n    return result;\n}\n\nbool operator == (const Rational\u0026 lhs, const Rational\u0026 rhs) {\n    return lhs.Numerator() == rhs.Numerator() \u0026\u0026 lhs.Denominator() == rhs.Denominator();\n}\n\nbool operator != (const Rational\u0026 lhs, const Rational\u0026 rhs) {\n    return !(lhs == rhs);\n}\n```\n\n{% endcut %}\n\n### [Задача «Tree»](https://new.contest.yandex.ru/42158/problem?id=40119/2022_10_30/WVfsCBVPIW)\n\n{% cut \"Условие\" %}\n\nВася пишет новую структуру данных — дерево. В узлах и листьях дерева хранятся строковые ключи. Каждый путь от корня до какого-нибудь узла можно записать, перечисляя последовательные ключи узлов. Типичный пример — иерархия папок в файловой системе. Вася уже выбрал способ хранения дерева:\n\n```cpp\n#include \u003cmap\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nstruct Node {\n    std::map\u003cstd::string, Node\u003e children;\n};\n\nclass Tree {\nprivate:\n    Node root;\n\npublic:\n    bool Has(const std::vector\u003cstd::string\u003e\u0026 node) const;\n    void Insert(const std::vector\u003cstd::string\u003e\u0026 node);\n    void Delete(const std::vector\u003cstd::string\u003e\u0026 node);\n};\n\n// Ваш код будет вставлен сюда\n#include \"your_code\"\n```\n\nНе будем обсуждать, насколько это эффективно.\n\nВаша задача — написать реализации функций `Has`, `Insert` и `Delete` для этого класса. В примере с папками в файловой системе функция `Has` должна проверить, существует ли такая папка, функция `Insert` должна создать папку (возможно, с промежуточными родительскими папками), а `Delete` — удалить папку со всеми вложенными подпапками, если такая папка существует.\n\nМожно считать, что вектор, передаваемый на вход этих функций, всегда непустой.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nРассмотрим для начала функцию `Has`. Её структура должна выглядеть так:\n\n```cpp\nbool Tree::Has(const std::vector\u003cstd::string\u003e\u0026 node) const {\n    // заводим переменную current, «смотрящую» на корень дерева\n    for (const auto\u0026 item : node) {\n        if (/* среди потомков current есть item */) {\n            // заменить current на этого потомка\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\nКакого типа может быть `current`? Правильный ответ: это должен быть указатель на `Node`. При спуске по дереву его можно будет переназначать на вложенный узел:\n\n```cpp\nbool Tree::Has(const std::vector\u003cstd::string\u003e\u0026 node) const {\n    const Node* current = \u0026root;\n    for (const auto\u0026 item : node) {\n        if (!current-\u003echildren.contains(item)) {\n            return false;\n        }\n        current = \u0026current-\u003echildren.at(item);\n    }\n    return true;\n}\n```\n\nМы здесь используем `const Node*`, потому что функция `Has` константная, а значит, поле `root` тоже рассматривается как константное. По этой же причине мы пишем `children.at(item)`, а не `children[item]`: оператор `[]` у `map` не является константным, и его не получится использовать. Вместо `children.contains(item)` можно было бы взять `children.find(item)` и сравнить полученный итератор с `children.end()`.\n\nТеперь напишем `Insert`:\n\n```cpp\nvoid Tree::Insert(const std::vector\u003cstd::string\u003e\u0026 node) {\n    Node* current = \u0026root;\n    for (const auto\u0026 item : node) {\n        if (!current-\u003echildren.contains(item)) {\n            current-\u003echildren[item];  // просто вставляем новый ключ с пустым Node в качестве значения\n        }\n        current = \u0026current-\u003echildren.at(item);\n    }\n}\n```\n\nВ функции `Delete` нам не нужно спускаться на самый последний узел: вместо этого его имя надо будет удалить из предпоследнего узла. Поэтому воспользуемся индексами для итерации по списку промежуточных узлов `node`:\n\n```cpp\nvoid Tree::Delete(const std::vector\u003cstd::string\u003e\u0026 node) {\n    Node* current = \u0026root;\n    for (size_t i = 0; i \u003c node.size(); ++i) {\n        const auto\u0026 item = node[i];\n        if (!current-\u003echildren.contains(item)) {\n            return;\n        }\n        if (i + 1 == node.size()) {\n            current-\u003echildren.erase(item);\n        } else {\n            current = \u0026current-\u003echildren.at(item);\n        }\n    }\n}\n```\n\nГрубая ошибка в этой задаче — пытаться использовать `Node current` вместо указателя. Смотрите, вот такой `Has` на первый взгляд даже будет работать:\n\n```cpp\nbool Tree::Has(const std::vector\u003cstd::string\u003e\u0026 node) const {\n    Node current = root;\n    for (const auto\u0026 item : node) {\n        if (!current.children.contains(item)) {\n            return false;\n        }\n        current = current.children.at(item);\n    }\n    return true;\n}\n```\n\nОднако можно заметить, что здесь на каждой итерации происходит полное копирование поддерева. В этом можно убедиться, если определить для `struct Node` конструктор копирования, печатающий сообщения на экран. Конечно же, при навигации по дереву никаких лишних копирований происходить не должно. Более того, из-за особенностей внутренней реализации `std::map` выражение `current = current.children.at(item)` приведет к неопределённому поведению программы (родительское дерево будет разрушено до обращения к поддереву).\n\n{% endcut %}\n\n### [Задача «Крестики-нолики»](https://new.contest.yandex.ru/42158/problem?id=40119/2022_10_30/DW7eQGSIg8)\n\n{% cut \"Условие\" %}\n\nОдин студент решил написать класс для своей реализации игры «крестики-нолики». Игра ведётся на квадратном поле размера $N \\times N$ двумя игроками. Игроки должны составить $K$ крестиков или ноликов в ряд (по горизонтали, по вертикали или по диагонали).\n\nКласс должен уметь создавать квадратное поле заданных размеров, выполнять очередной ход в пустую клетку, а также проверять, не наступил ли выигрыш. Кроме того, должен быть оператор `\u003c\u003c`, который печатает поле.\n\nСтудент пока не реализовал проверку выигрыша по диагоналям. А ещё его программа почему-то «падает» при попытке напечатать поле. Помогите ему исправить и сдать программу. Вот код студента:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nclass TicTacToe {\npublic:\n    const size_t N;  // размер игрового поля\n    const size_t K;  // сколько фишек нужно поставить в ряд, чтобы выиграть\n\nprivate:\n    // 0 - пусто, 1 - фишка первого игрока (крестик), 2 - фишка второго игрока (нолик)\n    std::vector\u003cstd::vector\u003cint\u003e\u003e Table;\n\n    // номер текущего игрока (1 или 2)\n    int currentPlayer;\n\npublic:\n    TicTacToe(size_t n, size_t k): N(n), K(k), currentPlayer(1) {\n        Table.reserve(N);\n        for (size_t i = 0; i != N; ++i) {\n            Table[i].reserve(N);\n        }\n    }\n\n    int operator()(size_t i, size_t j) const {\n        return Table[i][j];\n    }\n\n    int GetCurrentPlayer() const {\n        return currentPlayer;\n    }\n\n    bool Set(size_t i, size_t j) {  // возвращает true, если ход завершился выигрышем\n        Table[i][j] = currentPlayer;\n        currentPlayer = currentPlayer % 2 + 1;\n        bool wins = CheckRow(i, j) || CheckColumn(i, j) || CheckDiagonal1(i, j) || CheckDiagonal2(i, j);\n        return wins;\n    }\n\nprivate:\n    bool CheckRow(size_t i, size_t j) const {\n        size_t d1 = 0;\n        while (d1 \u003c= j \u0026\u0026 Table[i][j - d1] == Table[i][j]) {\n            ++d1;\n        }\n\n        size_t d2 = 0;\n        while (j + d2 \u003c N \u0026\u0026 Table[i][j + d2] == Table[i][j]) {\n            ++d2;\n        }\n\n        return d1 + d2 \u003e K;\n    }\n\n    bool CheckColumn(size_t i, size_t j) const {\n        size_t d1 = 0;\n        while (d1 \u003c= i \u0026\u0026 Table[i - d1][j] == Table[i][j]) {\n            ++d1;\n        }\n\n        size_t d2 = 0;\n        while (i + d2 \u003c N \u0026\u0026 Table[i + d2][j] == Table[i][j]) {\n            ++d2;\n        }\n\n        return d1 + d2 \u003e K;\n    }\n\n    bool CheckDiagonal1(size_t i, size_t j) const;\n\n    bool CheckDiagonal2(size_t i, size_t j) const;\n};\n\n    std::ostream\u0026 operator \u003c\u003c (std::ostream\u0026 out, TicTacToe\u0026 field) {\n    for (size_t i = 0; i != field.N; ++i) {\n        for (size_t j = 0; j != field.N; ++j) {\n            switch (field(i, j)) {\n                case 0:\n                    std::cout \u003c\u003c '.';\n                    break;\n                case 1:\n                    std::cout \u003c\u003c 'X';\n                    break;\n                case 2:\n                    std::cout \u003c\u003c 'O';\n            }\n        }\n        std::cout \u003c\u003c \"\\n\";\n    }\n    return out;\n}\n```\n\n#### Примечания\n\nВам требуется сдать только исправленный (и дополненный для проверки выигрыша по диагоналям) код класса `TicTacToe` и оператора `\u003c\u003c`. Функции `main` в Вашем коде быть не должно. Ваша программа будет автоматически собрана с нашей функцией `main` примерно такого содержания:\n\n```cpp\n#include \u003ciostream\u003e\n\n#include \"tic_tac_toe.correct.h\"  // это ваше решение\n\nint main() {\n    size_t n, m;\n    std::cin \u003e\u003e n \u003e\u003e m;\n    TicTacToe game(n, m);\n    size_t x, y;\n    while (std::cin \u003e\u003e x \u003e\u003e y) {\n        int curPlayer = game.GetCurrentPlayer();\n        if (game.Set(x, y)) {\n            std::cout \u003c\u003c \"Player #\" \u003c\u003c curPlayer \u003c\u003c \" wins!\\n\";\n        }\n    }\n    std::cout \u003c\u003c game;\n}\n```\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nПрежде всего заметим, что неверно написан конструктор. В нём лишь резервируется память для вектора, но не меняется его размер. Перепишем его так:\n\n```cpp\nTicTacToe(size_t n, size_t k): N(n), K(k), currentPlayer(1) {\n    Table.resize(N);\n    for (size_t i = 0; i != N; ++i) {\n        Table[i].resize(N);\n    }\n}\n```\n\nВо-вторых, в операторе `\u003c\u003c` есть две ошибки: ответ печатается в `std::cout` вместо `out`, и второй аргумент принимается по обычной, а не по константной ссылке.\n\nНаконец, нам нужно реализовать функции `CheckDiagonal1` и `CheckDiagonal2`. Вопреки заблуждению некоторых студентов, видимо, много решавших задачи про матрицы, диагональ тут (как в самых обычных крестиках-ноликах) может быть любая, а не только главная или побочная. Рассмотрим, как сделана, например, аналогичная функция `CheckRow`, проверяющая, образуется ли `K` подряд идущих фишек по горизонтали после хода в указанную позицию:\n\n```cpp\nbool CheckRow(size_t i, size_t j) const {\n    size_t d1 = 0;\n    while (d1 \u003c= j \u0026\u0026 Table[i][j - d1] == Table[i][j]) {  // считаем, сколько слева от нас таких же фишек\n        ++d1;\n    }\n\n    size_t d2 = 0;\n    while (j + d2 \u003c N \u0026\u0026 Table[i][j + d2] == Table[i][j]) { // считаем, сколько справа от нас таких же фишек\n        ++d2;\n    }\n\n    return d1 + d2 \u003e K;  // всего мы насчитали d1 + 1 + d2 фишек вместе с текущей, это число должно быть не меньше K\n}\n```\n\nТут важно проверять корректности индексов: они должны быть неотрицательны и меньше `N`. Напишем по аналогии проверку наличия диагональных выигрышных позиций:\n\n```cpp\nbool CheckDiagonal1(size_t i, size_t j) const {\n    size_t d1 = 0;\n    while (d1 \u003c= i \u0026\u0026 d1 \u003c= j \u0026\u0026 Table[i - d1][j - d1] == Table[i][j]) {\n        ++d1;\n    }\n\n    size_t d2 = 0;\n    while (i + d2 \u003c N \u0026\u0026 j + d2 \u003c N \u0026\u0026 Table[i + d2][j + d2] == Table[i][j]) {\n        ++d2;\n    }\n\n    return d1 + d2 \u003e K;\n}\n\nbool CheckDiagonal2(size_t i, size_t j) const {\n    size_t d1 = 0;\n    while (d1 \u003c= i \u0026\u0026 j + d1 \u003c N \u0026\u0026 Table[i - d1][j + d1] == Table[i][j]) {\n        ++d1;\n    }\n\n    size_t d2 = 0;\n    while (i + d2 \u003c N \u0026\u0026 d2 \u003c= j \u0026\u0026 Table[i + d2][j - d2] == Table[i][j]) {\n        ++d2;\n    }\n\n    return d1 + d2 \u003e K;\n}\n```\n\n{% endcut %}\n\n### [Задача «Работа склада»](https://new.contest.yandex.ru/42158/problem?id=1393/2022_10_30/adcpaMkadD)\n\n{% cut \"Условие\" %}\n\nВы работаете оператором на складе. Время от времени вам привозят новые коробки. Каждая коробка имеет свою грузоподъемность $w_i$ и объем $v_i$. Получая новую коробку, вы ставите на ней серийный номер, используя все целые неотрицательные числа последовательно, начиная с нуля.\n\nИногда вас просят выдать коробку минимальной грузоподъемности, чтобы она выдержала предмет весом $w$, или же коробку минимальной вместимости, в которую можно насыпать песок объемом $v$. Вам нужно быстро определять серийный номер коробки, которая будет выдана. Коробки обратно на склад не возвращаются. Если подходящих коробок несколько, нужно выбрать ту, которая пролежала на складе меньше.\n\nНужно реализовать класс `Stock`, у которого, среди прочих, будет три функции:\n\n1. `void Add(int w, int v);` — добавить коробку на склад;\n\n2. `int GetByW(int min_w);` — вернуть номер коробки грузоподъемности хотя бы $min_w$;\n\n3. `int GetByV(int min_v);` — вернуть номер коробки объема хотя бы $min_v$.\n\nЕсли подходящей коробки нет, соответствующая функция должна вернуть $-1$.\n\n#### Примечания\n\nОбратите внимание, что вам нужно отправить только ваш класс `Stock`, без функции `main`. Не забудьте, что необходимые функции-члены должны быть доступны вне класса.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nРеализуем три дополнительные структуры:\n\n1. `WeightNumber` — структура для хранения вместимостей коробок;\n\n2. `VolumeNumber` — структура для хранения объёмов коробок;\n\n3. `Iterators` — структура для хранения итераторов на коробки. Сами коробки мы будем хранить в двух `std::set`, итераторы на эти множества мы и будем хранить в `Iterators`.\n\nТак как мы планируем хранить данные о коробках в двух разных `std::set`, то для них нужно реализовать компараторы. Идея простая — сначала сортируем по вместимости / объёму, потом по индексу (порядковому номеру).\n\nВсе `Iterators` будем хранить в `std::vector`, так мы просто поддержим требуемые от нас «серийные номера» (индексы).\n\nТеперь разберём функции-члены:\n\n1. `Add` — нам нужно добавить коробку в оба множества и полученные итераторы записать в конец вектора.\n\n2. `GetByW` — вызовем [`lower_bound`](https://en.cppreference.com/w/cpp/container/set/lower_bound) от множества грузоподъёмностей. Если результатом стал `end()`, то коробок, способных поднять такой вес нет. Иначе — мы получим итератор на нужную нам коробку. Удалим её из обоих множеств и вернём искомый индекс.\n\n3. `GetByV` — полный аналог `GetByW`, лишь `lower_bound` вызываем от множества объёмов.\n\n```cpp\n#include \u003cset\u003e\n#include \u003cvector\u003e\n#include \u003ccstdint\u003e\n\nclass Stock {\nprivate:\n    struct WeightNumber {\n        int w;\n        size_t i;\n\n        bool operator \u003c (const WeightNumber\u0026 other) const {\n            if (w == other.w) {\n                return i \u003e other.i;\n            }\n            return w \u003c other.w;\n        }\n    };\n\n    struct VolumeNumber {\n        int v;\n        size_t i;\n\n        bool operator \u003c (const VolumeNumber\u0026 other) const {\n            if (v == other.v) {\n                return i \u003e other.i;\n            }\n            return v \u003c other.v;\n        }\n    };\n\n    struct Iterators {\n        std::set\u003cWeightNumber\u003e::iterator byW;\n        std::set\u003cVolumeNumber\u003e::iterator byV;\n    };\n\n    std::vector\u003cIterators\u003e boxes;\n    std::set\u003cWeightNumber\u003e sortedByW;\n    std::set\u003cVolumeNumber\u003e sortedByV;\n\npublic:\n    void Add(int w, int v) {\n        size_t num = boxes.size();\n        boxes.push_back({sortedByW.insert({w, num}).first, sortedByV.insert({v, num}).first});\n    }\n\n    int GetByW(int min_w) {\n        const auto it = sortedByW.lower_bound({min_w, boxes.size()});\n        if (it == sortedByW.end()) {\n            return -1;\n        }\n\n        size_t res = it-\u003ei;\n        sortedByW.erase(it);\n        sortedByV.erase(boxes[res].byV);\n        return res;\n    }\n\n    int GetByV(int min_v) {\n        const auto it = sortedByV.lower_bound({min_v, boxes.size()});\n        if (it == sortedByV.end()) {\n            return -1;\n        }\n\n        size_t res = it-\u003ei;\n        sortedByV.erase(it);\n        sortedByW.erase(boxes[res].byW);\n        return res;\n    }\n};\n```\n\nЯвным минус такой реализации — из `boxes` не удаляются коробки. Рано или поздно, если бы это был реальный продукт, у вас случится переполнение. Но это решение всё равно проходит тесты, мы не требовали от вас лучшей реализации.\n\nНо в большой продуктовой задаче очень важно чистить за собой ненужные данные. Проблему накопления мусора в этой задаче можно решить через `std::list`, в нём удобное удаление из центра, но нет индексирования.\n\nЧтобы решить проблему с индексированием воспользуемся дополнительным `std::unordered_map`. Да, если коробки сначала только накапливаются, а потом разбираются, то эффективней будет первое решение, но если коробки можно накапливать постепенно, то сильно лучше второе решение.\n\nДля демонстрации мы специально сделали тест, который последовательно вызывает `Add`, а за ним один из `GetBy*`. В первой реализации итоговый `boxes` будет размером с количество вызовов `Add`, во второй же он всегда будет размером $0$ или $1$.\n\nЭто никак не сказывается на времени работы (так как удаление из `sortedBy*` происходит и там, и там), но сказывается на используемой памяти. Для двух миллионов коробок разница занимаемой памяти составляет 60 раз!\n\n```cpp\n#include \u003clist\u003e\n#include \u003cset\u003e\n#include \u003ccstdint\u003e\n#include \u003cunordered_map\u003e\n\nclass Stock {\nprivate:\n    struct WeightNumber {\n        int w;\n        size_t i;\n\n        bool operator \u003c (const WeightNumber\u0026 other) const {\n            if (w == other.w) {\n                return i \u003e other.i;\n            }\n            return w \u003c other.w;\n        }\n    };\n\n    struct VolumeNumber {\n        int v;\n        size_t i;\n\n        bool operator \u003c (const VolumeNumber\u0026 other) const {\n            if (v == other.v) {\n                return i \u003e other.i;\n            }\n            return v \u003c other.v;\n        }\n    };\n\n    struct Iterators {\n        std::set\u003cWeightNumber\u003e::iterator byW;\n        std::set\u003cVolumeNumber\u003e::iterator byV;\n    };\n\n    std::list\u003cIterators\u003e boxes;\n    std::set\u003cWeightNumber\u003e sortedByW;\n    std::set\u003cVolumeNumber\u003e sortedByV;\n    std::unordered_map\u003csize_t, std::list\u003cIterators\u003e::iterator\u003e indexes;\n    size_t current_index{0};\n\npublic:\n    void Add(int w, int v) {\n        boxes.push_front({sortedByW.insert({w, current_index}).first,\n                            sortedByV.insert({v, current_index}).first});\n        indexes.insert({current_index, boxes.begin()});\n        ++current_index;\n    }\n\n    int GetByW(int min_w) {\n        const auto it = sortedByW.lower_bound({min_w, current_index});\n        if (it == sortedByW.end()) {\n            return -1;\n        }\n\n        size_t res = it-\u003ei;\n        sortedByW.erase(it);\n        sortedByV.erase(indexes[res]-\u003ebyV);\n        boxes.erase(indexes[res]);\n        indexes.erase(res);\n        return res;\n    }\n\n    int GetByV(int min_v) {\n        const auto it = sortedByV.lower_bound({min_v, current_index});\n        if (it == sortedByV.end()) {\n            return -1;\n        }\n\n        size_t res = it-\u003ei;\n        sortedByV.erase(it);\n        sortedByW.erase(indexes[res]-\u003ebyW);\n        boxes.erase(indexes[res]);\n        indexes.erase(res);\n        return res;\n    }\n};\n```\n\n{% endcut %}\n\n----------\n\n## Параграф «Шаблоны классов»\n\n### [Задача «Table»](https://new.contest.yandex.ru/42182/problem?id=40119/2022_10_30/A6YCL0h2ac)\n\n{% cut \"Условие\" %}\n\nВам надо написать шаблонный класс `Table` для электронной таблицы. Для простоты будем считать, что все ячейки таблицы имеют один и тот же тип данных `T`. Таблица должна уметь менять свой размер по требованию пользователя. Вновь созданные ячейки должны заполняться значениями по умолчанию типа `T`.\n\nТребования к классу такие:\n\n1. Класс должен называться `Table`.\n\n2. У класса должен быть шаблонный параметр `T` — тип элемента в ячейке.\n\n3. У класса должен быть конструктор, получающий на входе два числа типа `size_t`, — начальные размеры таблицы.\n\n4. У класса должны быть константная и неконстантная версии оператора `[]`, возвращающего нечто такое, к чему снова можно было бы применить оператор `[]`. То есть, должны работать конструкции вида `std::cout \u003c\u003c table[i][j];` и `table[i][j] = value;`. Проверять корректность индексов при этом не нужно.\n\n5. У класса должна быть функция `resize`, получающая на вход два параметра типа `size_t` и меняющая размер таблицы. Старые данные, умещающиеся в новый размер, должны при этом сохраниться.\n\n6. У класса должна быть функция `size`, возвращающая `std::pair\u003csize_t, size_t\u003e` — размер таблицы (в том же порядке, в котором эти аргументы передавались в конструктор).\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\n```cpp\n#include \u003cvector\u003e\n#include \u003cutility\u003e\n\ntemplate \u003ctypename T\u003e\nclass Table {\nprivate:\n    std::vector\u003cstd::vector\u003cT\u003e\u003e data;\n\npublic:\n    Table(size_t m, size_t n) {\n        resize(m, n);\n    }\n\n    // версия для неконстантных таблиц\n    std::vector\u003cT\u003e\u0026 operator [] (size_t i) {\n        return data[i];\n    }\n\n    // версия для константных таблиц\n    const std::vector\u003cT\u003e\u0026 operator [] (size_t i) const {\n        return data[i];\n    }\n\n    void resize(size_t m, size_t n) {\n        data.resize(m);\n        for (size_t i = 0; i \u003c m; ++i) {\n            data[i].resize(n);\n        }\n    }\n\n    std::pair\u003csize_t, size_t\u003e size() const {\n        if (data.empty()) {\n            return {0, 0};\n        } else {\n            return {data.size(), data[0].size()};\n        }\n    }\n};\n```\n\nЧасто задаваемый вопрос — какой индекс в таблице отвечает за строки, а какой — за столбцы. На самом деле это совершенно не важно. Главное, чтобы пара индексов `i` и `j`, по которым будут обращаться в таблицу, была бы согласованной с размерами: `i` должен быть меньше `m`, а `j` меньше `n`.\n\nДругая типичная ошибка — возврат `{data.size(), data[0].size()}` в функции `size()` без проверки пустоты вектора. На пустом `data` тут будет некорректное обращение к памяти в `data[0]`.\n\n{% endcut %}\n\n### [Задача «Queue»](https://new.contest.yandex.ru/42182/problem?id=40119/2022_10_30/N4zvv8PCUo)\n\n{% cut \"Условие\" %}\n\nВам требуется реализовать класс `Queue`, аналогичный адаптеру `std::queue`. Он является обёрткой над некоторым стандартным контейнером и реализует интерфейс очереди. Класс должен быть шаблонным. Первый шаблонный параметр `T` — тип хранимых элементов. Второй шаблонный параметр — контейнер, используемый для хранения элементов (по умолчанию — `std::deque\u003cT\u003e`):\n\n```cpp\ntemplate \u003ctypename T, typename Container = std::deque\u003cT\u003e\u003e\nclass Queue;\n```\n\nПредусмотрите в классе следующее:\n\n1. Конструктор по умолчанию, создающий пустую очередь.\n\n2. Константную функцию `front`, которая возвращает элемент, стоящий в начале очереди.\n\n3. Неконстантную функцию `front`, которая возвращает по ссылке элемент, стоящий в начале очереди — тем самым давая возможность его изменить.\n\n4. Функцию `pop`, которая убирает элемент из начала очереди (и ничего не возвращает)\n\n5. Функцию `push`, которая кладёт переданный элемент в конец очереди.\n\n6. Функцию `size`, которая возвращает количество элементов.\n\n7. Функцию `empty`, которая возвращает true тогда и только тогда, когда очередь пуста\n\n8. Операторы `==` и `!=` для сравнения двух очередей.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nНаш класс будет просто обёрткой над контейнером. Все функции нашего класса будут сводиться к вызову соответствующих функций контейнера. Смысл нашего класса в том, что мы ограничиваем публичный интерфейс, оставляя только функции, специфичные для очереди. Например, у нас не будет оператора `[]` или функций `begin` и `end`, так как для очереди они не нужны. Кроме того, некоторые функции у очереди будут называться иначе (`push` и `pop` вместо `push_back` и `pop_front`), так как для очереди бессмысленно указывать, с какой стороны в неё поступают элементы, и с какой извлекаются.\n\nКонструктор класса `Queue` можно не писать, так как компилятор предоставит автоматически конструктор по умолчанию.\n\n```cpp\n#include \u003cdeque\u003e\n\ntemplate \u003ctypename T, typename Container = std::deque\u003cT\u003e\u003e\nclass Queue {\nprivate:\n    Container data;\n\npublic:\n    const T\u0026 front() const {\n        return data.front();\n    }\n\n    T\u0026 front() {\n        return data.front();\n    }\n\n    void push(const T\u0026 elem) {\n        data.push_back(elem);\n    }\n\n    void pop() {\n        data.pop_front();\n    }\n\n    size_t size() const {\n        return data.size();\n    }\n\n    bool empty() const {\n        return data.empty();\n    }\n\n    bool operator == (const Queue\u0026 other) const {\n        return data == other.data;\n    }\n\n    bool operator != (const Queue\u0026 other) const {\n        return !operator==(other);\n    }\n};\n```\n\nОбратите внимание, что операторы `==` и `!=`, а также функции `size` и `empty` объявлены константными, так как они не меняют очередь. Это позволяет применять их к константным очередям. Также функция `front` перегружена по константности: для константных очередей элемент возвращается для чтения, а для неконстантных — для записи.\n\n{% endcut %}\n\n### [Задача «Key-Value storage»](https://new.contest.yandex.ru/42182/problem?id=40119/2022_10_30/uGc1GEPYgk)\n\n{% cut \"Условие\" %}\n\nВася разрабатывает свою структуру — базу данных «ключ-значение». Эта структура данных должна хранить значение, ассоциированное с ключом, и она будет делать это суперэффективно. Пока для простоты Вася выбрал за основу `std::unordered_map`, но потом он это переделает.\n\nКакие операции должно поддерживать такое хранилище? Правильно: вставка элемента, удаление элемента и поиск элемента. Вася написал прототипы функций `Insert`, `Remove` и `Find`, но функция `Find` почему-то не работает. Помогите Васе её исправить. Вот код Васи:\n\n```cpp\n#include \u003cunordered_map\u003e\n\ntemplate \u003ctypename Key, typename Value\u003e\nclass KeyValueStorage {\nprivate:\n      std::unordered_map\u003cKey, Value\u003e data;\n\npublic:\n    void Insert(const Key\u0026 key, const Value\u0026 value) {\n        data[key] = value;\n    }\n\n    void Remove(const Key\u0026 key) {\n        data.erase(key);\n    }\n\n    bool Find(const Key\u0026 key, Value* const value = nullptr) const;\n};\n\n\n// Почему-то не работает...\n//\n// template \u003ctypename Key, typename Value\u003e\n// bool KeyValueStorage\u003cKey, Value\u003e::Find(const Key\u0026 key, Value* const value) const {\n//     auto it = std::find(data.begin(), data.end(), key);\n//     auto val = *it;\n//     if (value != nullptr)\n//         value = \u0026val;\n//     return it != data.end();\n// }\n\n// Ваша реализация функции KeyValueStorage::find будет вставлена сюда:\n#include \"your_version_of_find.h\"\n```\n\nВаша версия функции `Find` будет вставлена в конце этого кода. Её заголовок должен быть таким же, как в закомментированной части.\n\nФункция `Find` по задумке должна возвращать `true`, если ключ был найден, и `false` в противном случае. Если второй аргумент функции `Find` отличен от `nullptr` и ключ найден, то функция должна записать найденное значение в тот объект, на который ссылается этот аргумент (предполагается, что новая структура данных сможет быстро определять наличие ключа, но само значение будет извлекаться дорого, и делать это нужно лишь при необходимости). Использовать эту функцию предполагается примерно так:\n\n```cpp\n#include \"key_value_storage.h\"\n\n#include \u003cstring\u003e\n\nint main() {\n    KeyValueStorage\u003cstd::string, int\u003e kv;\n    kv.Insert(\"hello\", 42);\n    kv.Insert(\"bye\", -13);\n    int value = 123;\n    auto res = kv.Find(\"wrong\", \u0026value);  // должно вернуться false, а value не должен меняться\n    res = kv.Find(\"bye\", \u0026value);  // должно вернуться true, в value должно быть -13\n    res = kv.Find(\"hello\", nullptr);  // должно вернуться true\n}\n```\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nНаш код будет вставлен после класса. Поэтому для описания тела функции нам потребуется написать шапку `template \u003ctypename Key, typename Value\u003e`, а имя функции предварить префиксом с именем класса - как в закомментированном примере.\n\n```cpp\ntemplate \u003ctypename Key, typename Value\u003e\nbool KeyValueStorage\u003cKey, Value\u003e::Find(const Key\u0026 key, Value* const value) const {\n    auto it = data.find(key);\n    if (it != data.end() \u0026\u0026 value != nullptr) {\n        *value = it-\u003esecond;\n    }\n    return it != data.end();\n}\n```\n\n#### Примечания\n\nРазберём типичные ошибки:\n\n1. Не надо пытаться использовать общий алгоритм `std::find` или `std::find_if`. Нужно использовать встроенную функцию `find` контейнера `unordered_map`. Во-первых, встроенный `find` будет работать быстрее (а `std::find` будет выполнять линейный поиск). Во-вторых, `std::find` не предназначен для поиска по ключу. Он ищет в контейнере готовый образец, а значит, ему придётся передать пару из ключа и значения (которого мы не знаем).\n\n2. Если значение не найдено, не надо ничего делать с `value`. Это можно понять по примеру использования. В этом случае надо просто вернуть `false`.\n\n3. Неправильно писать `value = \u0026it-\u003esecond`. Сам указатель `value` мы поменять не сможем; мы лишь записываем найденное значение в ту ячейку памяти, на которую он указывает (если он не `nullptr`). По условию мы предполагаем, что он в таком случае указывает на корректный существующий объект.\n\n{% endcut %}\n\n### [Задача «Deque»](https://new.contest.yandex.ru/42182/problem?id=40119/2022_10_29/ieRcbasZTm)\n\n{% cut \"Условие\" %}\n\nВ этой задаче вам надо будет написать свой дек. Писать его по-честному долго и сложно, поэтому мы пошли вам навстречу: вам нужно написать упрощенную версию дека без итераторов, и умеющую только добавлять элементы в начало и конец. Поддерживать удаление элементов из дека не требуется.\n\nВ отличие от стандартного дека возьмите за основу два вектора, растущих каждый в свою сторону. Предлагаем такой прототип — а вам нужно реализовать указанные функции:\n\n```cpp\n#include \u003ccstddef\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Deque {\nprivate:\n    std::vector\u003cT\u003e head, tail;\n\npublic:\n    bool Empty() const;\n\n    size_t Size() const;\n\n    void Clear();\n\n    const T\u0026 operator [] (size_t i) const;\n\n    T\u0026 operator [] (size_t i);\n\n    const T\u0026 At(size_t i) const;  // throws std::out_of_range on incorrect index\n\n    T\u0026 At(size_t i);  // throws std::out_of_range on incorrect index\n\n    const T\u0026 Front() const;\n\n    T\u0026 Front();\n\n    const T\u0026 Back() const;\n\n    T\u0026 Back();\n\n    void PushFront(const T\u0026 elem);\n\n    void PushBack(const T\u0026 elem);\n};\n```\n\n#### Примечания\n\nСдайте в систему класс `Deque` с написанными функциями.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДек должен уметь эффективно расти в обе стороны. А вектор умеет эффективно расти только в одну сторону. Поэтому предлагается реализовать решение с помощью двух векторов, смотрящих в разные стороны. По условию удаляться из дека ничего не будет, поэтому в эти векторы будут только добавляться новые элементы в конец. Однако важно помнить, что один из этих векторов может оставаться пустым, если с соответствующей стороны вставок еще не было. Поэтому, например, при вызовe `Front` мы должны сначала посмотреть на первый вектор, а если он пуст — то на второй.\n\n#### Часто задаваемые вопросы\n\n**Q.** *Какой из векторов (`head` или `tail`) соотвествует началу, а какой — концу дека?*\\\n**A.** На самом деле это детали нашей реализации, никак не связанные с объявленным публичным интерфейсом, который требуется реализовать. Можно выбрать любое соответствие и придерживаться его.\n\n**Q.** *Какой должен быть конструктор дека? Нужен ли конструктор от двух векторов?*\\\n**A.** Заметим, что в представленном публичном интерфейсе конструктора нет. Значит, компилятор предоставит по умолчанию конструктор без аргументов, инициализирующий поля `head` и `tail` их дефолтными конструкторами. Конечно, такой конструктор создаёт пустой дек. Другие конструкторы не требуются. Итак, конструктор можно вообще не писать — нам достаточно дефолтного.\n\n**Q.** *Что должны делать функции Front и Back на пустом деке?*\\\n**A.** Как и в `std::deque`, они не должны делать никаких проверок. То, что эти функции не вызываются на пустом деке, лежит на совести программиста.\n\n**Q.** *Что должна делать функция At?*\\\n**A.** Как и в контейнерах стандартной библиотеки, она аналогична оператору `[]`, но проверяет корректность индекса. В случае некорректного индекса она должна генерировать исключение.\n\n**Q.** *Не получается сгенерировать исключение.*\\\n**A.** Во-первых, надо подключить `\u003cstdexcept\u003e` — этот заголовочный файл указан в документации `std::out_of_range`. В конструктор `std::out_of_range` надо передать текстовую строку с описанием ошибки. Строка может быть любой, мы её не проверяем.\n\nИтоговый класс:\n\n```cpp\n#include \u003ccstddef\u003e\n#include \u003cstdexcept\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Deque {\nprivate:\n    std::vector\u003cT\u003e head, tail;\n\n    void CheckIndex(size_t i) const {\n        if (i \u003e= Size()) {\n            throw std::out_of_range(\"Index is out of range\");\n        }\n    }\n\npublic:\n    bool Empty() const {\n        return head.empty() \u0026\u0026 tail.empty();\n    }\n\n    size_t Size() const {\n        return head.size() + tail.size();\n    }\n\n    void Clear() {\n        head.clear();\n        tail.clear();\n    }\n\n    const T\u0026 operator [] (size_t i) const {\n        if (i \u003c head.size()) {\n            return head[head.size() - i - 1];\n        }\n        return tail[i - head.size()];\n    }\n\n    T\u0026 operator [] (size_t i) {\n        if (i \u003c head.size()) {\n            return head[head.size() - i - 1];\n        }\n        return tail[i - head.size()];\n    }\n\n    const T\u0026 At(size_t i) const {\n        CheckIndex(i);\n        return (*this)[i];\n    }\n\n    T\u0026 At(size_t i) {\n        CheckIndex(i);\n        return (*this)[i];\n    }\n\n    const T\u0026 Front() const {\n        if (head.empty()) {\n            return tail.front();\n        }\n        return head.back();\n    }\n\n    T\u0026 Front() {\n        if (head.empty()) {\n            return tail.front();\n        }\n        return head.back();\n    }\n\n    const T\u0026 Back() const {\n        if (tail.empty()) {\n            return head.front();\n        }\n        return tail.back();\n    }\n\n    T\u0026 Back() {\n        if (tail.empty()) {\n            return head.front();\n        }\n        return tail.back();\n    }\n\n    void PushFront(const T\u0026 elem) {\n        head.push_back(elem);\n    }\n\n    void PushBack(const T\u0026 elem) {\n        tail.push_back(elem);\n    }\n};\n```\n\n{% endcut %}\n\n### [Задача «MathVector»](https://new.contest.yandex.ru/42182/problem?id=40119/2022_10_31/ZSTrBhS4ge)\n\n{% cut \"Условие\" %}\n\nМатематический [*вектор*](https://clck.ru/32ZUw5) (не путать с `std::vector`!) – структура линейной алгебры, определяющаяся набором упорядоченных чисел (*координат*). Обозначается как $(x_1, x_2, ..., x_n)$. Число $n$ в таком случае называется *размерностью* вектора.\n\nВ качестве примера можно рассмотреть вектора размерности два с координатами в вещественных числах. В таком случае вектор $(1, 2)$ будет задавать знакомый нам со школы [геометрический вектор](https://en.wikipedia.org/wiki/Euclidean_vector) с началом в координате $(0, 0)$ и концом в $(1, 2)$.\n\nТакже заметим, что координаты вектора необязательно вещественные числа. Это могут быть рациональные, комплексные или любые другие математические объекты, обладающие набором базовых операций сложения и умножения (например [математические матрицы](https://en.wikipedia.org/wiki/Matrix_\\(mathematics\\))).\n\nНад математическим вектором можно проводить две операции:\n\n1. Сложение двух векторов одинаковой размерности: пусть $a = (x_1, x_2, ..., x_n)$, $b = (y_1, y_2, ..., y_n)$, тогда $a + b = (x_1 + y_1, x_2 + y_2, ..., x_n + y_n)$;\n\n2. Умножение вектора на число (тип числа должен быть одинаковым с типом чисел координат у вектора): пусть $c = (x_1, x_2, ..., x_n)$, $\\alpha$ - какое-то число, тогда $\\alpha \\cdot c = (\\alpha x_1, \\alpha x_2, ..., \\alpha x_n)$.\n\nВам дан шаблонный класс `MathVector\u003cT\u003e`, представляющий собой математический вектор с координатами типа `T`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass MathVector {\n private:\n    std::vector\u003cT\u003e data;\n\n public:\n    // Храним в `data` нулевой вектор длины `n`\n    MathVector(size_t n) {\n        data.resize(n);\n    }\n\n    template \u003ctypename Iter\u003e\n    MathVector(Iter first, Iter last) {\n        while (first != last) {\n            data.push_back(*first);\n        }\n    }\n\n    size_t Dimension() const {\n         return data.size();\n    }\n\n    T\u0026 operator [] (size_t i) {\n        return data[i];\n    }\n\n    const T\u0026 operator [] (size_t i) const {\n        return data[i];\n    }\n};\n\n// Output format: (1, 2, 3, 4, 5)\ntemplate \u003ctypename T\u003e\nstd::ostream\u0026 operator \u003c\u003c (std::ostream\u0026 out, const MathVector\u003cT\u003e\u0026 v) {\n    out \u003c\u003c '(';\n    for (size_t i = 0; i != v.Dimension(); ++i) {\n        if (i \u003e 0) {\n            out \u003c\u003c \", \";\n        }\n        out \u003c\u003c v[i];\n    }\n    out \u003c\u003c ')';\n    return out;\n}\n\ntemplate \u003ctypename T\u003e\nMathVector\u003cT\u003e\u0026 operator *= (MathVector\u003cT\u003e\u0026 v, const T\u0026 scalar) {\n    for (size_t i = 0; i != v.Dimension(); ++i) {\n        v[i] *= scalar;\n    }\n    return v;\n}\n\ntemplate \u003ctypename T\u003e\nMathVector\u003cT\u003e operator * (const MathVector\u003cT\u003e\u0026 v, const T\u0026 scalar) {\n    auto tmp(v);\n    tmp *= scalar;\n    return tmp;\n}\n\ntemplate \u003ctypename T\u003e\nMathVector\u003cT\u003e operator * (const T\u0026 scalar, const MathVector\u003cT\u003e\u0026 v) {\n    return v * scalar;\n}\n```\n\nВам требуется исправить ошибки в коде этого класса и дописать операторы `+=` и `+` для сложения векторов. Считайте, что складываться друг с другом всегда будут только векторы одинаковой размерности.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДля начала исправим существующие в коде ошибки:\n\nПервая ошибка находится в конструкторе вектора по двум итераторам. В цикле `while` нет инкремента для итератора, из-за чего получается бесконечный цикл. Правильнее всего переписать цикл на `for`.\n\nВторая ошибка в константном операторе `operator []`. Чтобы явно обозначить константное получение элемента из `std::vector`, необходимо использовать функцию `.at`.\n\nКогда все ошибки исправлены – остаётся только дописать недостающие функции по аналогии с уже существующими.\n\nИтоговый файл:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\ntemplate\u003ctypename T\u003e\nclass MathVector {\nprivate:\n    std::vector\u003cT\u003e data;\n\npublic:\n    // Храним в `data` нулевой вектор длины `n`\n    MathVector(size_t n) {\n        data.resize(n);\n    }\n\n    template\u003ctypename Iter\u003e\n    MathVector(Iter first, Iter last) {\n        for (; first != last; ++first) {\n            data.push_back(*first);\n        }\n    }\n\n    size_t Dimension() const {\n        return data.size();\n    }\n\n    T\u0026 operator [] (size_t i) {\n        return data[i];\n    }\n\n    const T\u0026 operator [] (size_t i) const {\n        return data.at(i);\n    }\n};\n\n// Output format: (1, 2, 3, 4, 5)\ntemplate\u003ctypename T\u003e\nstd::ostream\u0026 operator \u003c\u003c (std::ostream\u0026 out, const MathVector\u003cT\u003e\u0026 v) {\n    out \u003c\u003c '(';\n    for (size_t i = 0; i != v.Dimension(); ++i) {\n        if (i \u003e 0) {\n            out \u003c\u003c \", \";\n        }\n        out \u003c\u003c v[i];\n    }\n    out \u003c\u003c ')';\n    return out;\n}\n\ntemplate\u003ctypename T\u003e\nMathVector\u003cT\u003e\u0026 operator *= (MathVector\u003cT\u003e\u0026 v, const T\u0026 scalar) {\n    for (size_t i = 0; i != v.Dimension(); ++i) {\n        v[i] *= scalar;\n    }\n    return v;\n}\n\ntemplate\u003ctypename T\u003e\nMathVector\u003cT\u003e operator * (const MathVector\u003cT\u003e\u0026 v, const T\u0026 scalar) {\n    auto tmp(v);\n    tmp *= scalar;\n    return tmp;\n}\n\ntemplate\u003ctypename T\u003e\nMathVector\u003cT\u003e operator * (const T\u0026 scalar, const MathVector\u003cT\u003e\u0026 v) {\n    return v * scalar;\n}\n\n\ntemplate\u003ctypename T\u003e\nMathVector\u003cT\u003e\u0026 operator += (MathVector\u003cT\u003e\u0026 v1, const MathVector\u003cT\u003e\u0026 v2) {\n    for (size_t i = 0; i != v1.Dimension(); ++i) {\n        v1[i] += v2[i];\n    }\n    return v1;\n}\n\n\ntemplate\u003ctypename T\u003e\nMathVector\u003cT\u003e operator + (const MathVector\u003cT\u003e\u0026 v1, const MathVector\u003cT\u003e\u0026 v2) {\n    MathVector\u003cT\u003e tmp = v1;\n    tmp += v2;\n    return tmp;\n}\n```\n\n{% endcut %}\n\n### [Задача «Многочлены»](https://new.contest.yandex.ru/42182/problem?id=40119/2022_11_01/1BtAJdQh2O)\n\n{% cut \"Условие\" %}\n\n[Многочлен](https://en.wikipedia.org/wiki/Polynomial) от одной переменной – алгебраическое выражение, состоящие из суммы нескольких произведений числовых коэффициентов на переменную в натуральной степени. Пример: $x^2 + 2x + 1$. Слагаемыми в многочлене называют одночленами.\n\nТак же как и в задаче о математическом векторе, числами здесь могут являться любые объекты со стандартным набором базовых математических операций (сложение, вычитание, умножение, деление), например дробные, вещественные или комплексные числа, а так же математические матрицы и другие алгебраические объекты.\n\nРеализуйте шаблонный класс `Polynomial` (многочлен от одной переменной) на основе контейнера `std::vector`. Тип коэффициентов многочлена передавайте в качестве параметра шаблона. Хранение коэффициентов должно быть плотным (то есть должны храниться все коэффициенты, в том числе и промежуточные нулевые).\n\nСделайте следующее:\n\n1. Напишите конструкторы, которые\n\n   * создают многочлен по заданному вектору коэффициентов (коэффициенты задаются по возрастанию степени).\n   * создают многочлен по заданному коэффициенту (многочлен нулевой степени), который равен значению по умолчанию параметра шаблона.\n   * создают многочлен по заданным итераторам на начало и следующий за концом последовательности коэффициентов (аналогично, по возрастанию степени).\n\n2. Перегрузите операторы `==` и `!=`. Ваш код должен быть очень простым. Операторы должны работать и в том случае, когда один из аргументов является скалярной величиной.\n\n3. Перегрузите операторы `+`, `-` и `*`, а также соответствующие операторы `+=`, `-=` и `*=`. Учтите, что должны быть определены и такие арифметические операции, в которых один из аргументов является скалярной величиной.\n\n4. Перегрузите оператор `[]` для получения коэффициента многочлена перед заданной степенью переменной. Достаточно константной версии этого оператора. Оператор должен работать для любых степеней (в том числе больше текущей максимальной). Напишите также метод `Degree` для вычисления степени многочлена (считайте, что у нулевого многочлена степень равна $-1$).\n\n5. Перегрузите оператор `()` для вычисления значения многочлена в точке. В качестве аргумента этот оператор принимает значение того типа, от которого создан многочлен. Постарайтесь написать эффективный код.\n\n6. Перегрузите оператор `\u003c\u003c` для печати многочлена в поток вывода. Для простоты будем выводить коэффициенты через пробел от **старшей степени к младшей**.\n\n7. Предусмотрите методы `begin()` и `end()` для доступа к константным итераторам, позволяющим перебрать коэффициенты многочлена (это могут быть просто итераторы вектора). При этом ведущие нули коэффициентами не считаются. Итерация должна происходить по возрастанию степени.\n\n#### Примечание\n\nВ вашем решении должен быть только код класса и не должно быть функции `main`. При проверке наша программа будет использовать ваш класс `Polynomial`. Она сама прочитает из входного потока коэффициенты многочленов и выведет их сумму, разность, произведение и т. д.\n\nОбратите внимание, что если какой-то из операторов реализован в вашем решении, но при этом его вызов не компилируется (т. е. реализован неправильно), то вы будете получать не ошибку компиляции, а неправильный ответ, так как тестирующая программа доопределяет те операторы, вызов которых не компилируется.\n\nВы можете считать, что шаблонный параметр — это числовой тип, для которого реализованы все арифметические операции, операции сравнения и вывод в поток. Также переменную этого типа можно сконструировать от `int`. Обратите внимание, что наличие неявного конструктора и оператора приведения типа не гарантируется: необходимо вызывать конструктор явно.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДля начала реализуем конструкторы класса:\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Polynomial {\npublic:\n    using Container = typename std::vector\u003cT\u003e;\n    using ConstIterator = typename Container::const_iterator;\n\nprivate:\n    Container coefficients;\n    inline static const T valueTypeZero{0};\n\n    void Normalize() {\n        while (!coefficients.empty() \u0026\u0026 coefficients.back() == valueTypeZero) {\n            coefficients.pop_back();\n        }\n    }\n\n    Container\u0026 GetCoefficients() {\n        return coefficients;\n    }\n\npublic:\n    Polynomial(const Container\u0026 coeffs)\n        : coefficients{coeffs} {\n            Normalize();\n        }\n\n    Polynomial(const T\u0026 value = {}) {\n        if (value != valueTypeZero) {\n            coefficients.push_back(value);\n        }\n    }\n\n    template\u003ctypename ForwardIt\u003e\n    Polynomial(ForwardIt first, ForwardIt last)\n        : coefficients{first, last} {\n            Normalize();\n    }\n\n    const Container\u0026 GetCoefficients() const {\n        return coefficients;\n    }\n```\n\nДля удобства будем удалять все нулевые коэффициенты с конца вектора. Для этого используем функцию `Normalize` (см. выше). Чтобы проверять, является ли элемент нулевым, создадим в классе приватное константное поле `valueTypeZero` типа `T` равное нулю. Ключевое слово `static` указывает, что новое поле относится к самому классу, а не к его объектам. Ключевое слово `inline` позволяет проинициализировать `static`-поле в момент определения (напоминаем, оно инициализируется нулём).\n\nХранить же наши коэффициенты будем в векторе, где `coefficients[i]` будет значить, что мы смотрим на коэффициент перед $x^i$. У вектора есть конструктор копирования, чем мы воспользуемся при реализации конструктора, который принимает вектор. Аналогично поступим с конструктором, который принимает два итератора. Конструктор, создающий многочлен по заданному коэффициенту будет добавлять в наш вектор этот самый коэффициент, только если он не ноль. Это позволяет лишний раз не вызывать `Normalize()`.\n\nТакже реализуем вспомогательные методы, которые будем использовать в дальнейшем: `GetCoefficients()` и `GetCoefficients() const`. Будем использовать эти методы для явного обращения к коэффициентам.\n\nДалее реализуем операторы `==` и `!=`:\n\n```cpp\n    friend bool operator == (const Polynomial\u003cT\u003e\u0026 lhs, const Polynomial\u003cT\u003e\u0026 rhs) {\n        return lhs.GetCoefficients() == rhs.GetCoefficients();\n    }\n\n    friend bool operator != (const Polynomial\u003cT\u003e\u0026 lhs, const Polynomial\u003cT\u003e\u0026 rhs) {\n        return !(lhs == rhs);\n    }\n```\n\nУ `std::vector` переопределён `operator ==`, чем мы и воспользуемся.\n\nТак как при декларации конструктора класса не используется ключевое слово `explicit`, операторы будут работать и в том случае, когда один из аргументов является скалярной величиной.\n\nДалее реализуем арифметические операции:\n\n```cpp\n    Polynomial\u003cT\u003e\u0026 operator += (const Polynomial\u003cT\u003e\u0026 other) {\n        if (other.Degree() \u003e Degree()) {\n            GetCoefficients().resize(other.Degree() + 1);\n        }\n\n        for (int i = 0; i \u003c= Degree() \u0026\u0026 i \u003c= other.Degree(); ++i) {\n            GetCoefficients()[i] += other.GetCoefficients()[i];\n        }\n        Normalize();\n        return *this;\n    }\n\n    Polynomial\u003cT\u003e\u0026 operator -= (const Polynomial\u003cT\u003e\u0026 other) {\n        if (other.Degree() \u003e Degree()) {\n            GetCoefficients().resize(other.Degree() + 1);\n        }\n\n        for (int i = 0; i \u003c= Degree() \u0026\u0026 i \u003c= other.Degree(); ++i) {\n            GetCoefficients()[i] -= other.GetCoefficients()[i];\n        }\n        Normalize();\n        return *this;\n    }\n\n    Polynomial\u003cT\u003e\u0026 operator *= (const Polynomial\u003cT\u003e\u0026 other) {\n        if (Degree() == -1 || other.Degree() == -1) {\n            GetCoefficients().resize(0);\n            return *this;\n        }\n\n        std::vector\u003cT\u003e tmp(Degree() + other.Degree() + 1);\n        for (int i = 0; i \u003c= Degree(); ++i) {\n            for (int j = 0; j \u003c= other.Degree(); ++j) {\n                tmp[i + j] += GetCoefficients()[i] * other.GetCoefficients()[j];\n            }\n        }\n        GetCoefficients() = std::move(tmp);\n        Normalize();\n        return *this;\n    }\n```\n\nЗаметьте, что в реализации этих методов используется ещё нереализованный метод `Degree()`. Этот метод будет объявлен чуть позже (когда до него дойдёт очередь). Всё что нам надо знать сейчас – он возвращает степень полинома, а если полином равен нулю, то `-1`.\n\nВсе три оператора изначально делают `resize()`, чтобы избежать неопределённое поведение, и согласно правилам математики складывают, вычитают или умножают два многочлена. При этом в умножении рассматривается отдельно краевой случай, когда один из полиномов равен нулю. После каждой операции вызываем функцию `Normalize()`.\n\n```cpp\n    friend Polynomial\u003cT\u003e operator + (Polynomial\u003cT\u003e lhs, const Polynomial\u003cT\u003e\u0026 rhs) {\n        return lhs += rhs;\n    }\n\n    friend Polynomial\u003cT\u003e operator - (Polynomial\u003cT\u003e lhs, const Polynomial\u003cT\u003e\u0026 rhs) {\n        return lhs -= rhs;\n    }\n\n    friend Polynomial\u003cT\u003e operator * (Polynomial\u003cT\u003e lhs, const Polynomial\u003cT\u003e\u0026 rhs) {\n        return lhs *= rhs;\n    }\n```\n\n`lhs` будем принимать не по ссылке, а создавать копию на лету. Это позволит нам изменить и сразу же вернуть её,  применив соответствующий оператор.\n\nДалее реализуем оператор `[]` и функцию `Degree`:\n\n```cpp\n    int Degree() const {\n        return static_cast\u003cint\u003e(GetCoefficients().size()) - 1;\n    }\n\n    const T\u0026 operator [] (size_t power) const {\n        if (static_cast\u003cint\u003e(power) \u003e Degree()) {\n            return valueTypeZero;\n        }\n        return GetCoefficients()[power];\n    }\n```\n\nОбратите внимание, из-за того что мы в самом начале договорились не хранить незначащие нули в конце вектора, код функции `Degree` помещается в одну строчку. Действительно, в таком случае степенью многочлена будет являться длина вектора коэффициентов минус один.\n\nДалее реализуем оператор `()`. Воспользуемся для этого [алгоритмом Горнера](https://en.wikipedia.org/wiki/Horner%27s_method):\n\n```cpp\n    T operator () (const T\u0026 given_value) const {\n        T result = valueTypeZero;\n\n        for (auto i = Degree(); i \u003e= 0; --i) {\n            result *= given_value;\n            result += GetCoefficients()[i];\n        }\n\n        return result;\n    }\n```\n\nПроще говоря, для многочлена $a_1 + a_2 x + a_3 x^2 + ... + a_n x^n$ мы вынесем за скобки $x$ везде, где это возможно. Получится следующее выражение $a_1 + x(a_2 + x(a_3 + ... + x(a_{n-1} a_n x) ...))$. Таким образом нужно просто реализовать цикл с умножением на заданную переменную и сложением со следующим коэффициентом.\n\nРеализация методов `.begin` и `.end` является тривиальной, поскольку мы можем вернуть итераторы самого вектора коэффициентов:\n\n```cpp\n    ConstIterator begin() const {\n        return GetCoefficients().cbegin();\n    }\n\n    ConstIterator end() const {\n        return GetCoefficients().cend();\n    }\n};\n```\n\nОператор `\u003c\u003c` принято реализовывать вне класса. Тут всё просто, пробежим по всем степеням от последней к первой.\n\n```cpp\ntemplate\u003ctypename T\u003e\nstd::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 out, const Polynomial\u003cT\u003e\u0026 polynomial) {\n    for (auto i = polynomial.Degree(); i \u003e= 0; --i) {\n        out \u003c\u003c polynomial[i];\n        if (i != 0) {\n            out \u003c\u003c ' ';\n        }\n    }\n    return out;\n}\n```\n\n{% endcut %}\n\n----------\n\n## Параграф «Жизненный цикл объекта»\n\n### [Задача «Жизнь объекта - 0»](https://new.contest.yandex.ru/42098/problem?id=40119/2022_10_29/TEP03NvXpo)\n\n{% cut \"Условие\" %}\n\nВам дан готовый класс `Logger`, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения:\n\n```cpp\n#include \u003ciostream\u003e\n\nclass Logger {\nprivate:\n    static int counter;\n    const int id;\n\npublic:\n    Logger(): id(++counter) {\n        std::cout \u003c\u003c \"Logger(): \" \u003c\u003c id \u003c\u003c \"\\n\";\n    }\n\n    Logger(const Logger\u0026 other): id(++counter) {\n        std::cout \u003c\u003c \"Logger(const Logger\u0026): \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n    }\n\n    Logger(Logger\u0026\u0026 other): id(++counter) {\n        std::cout \u003c\u003c \"Logger(Logger\u0026\u0026): \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n    }\n\n    Logger\u0026 operator = (const Logger\u0026 other) {\n        std::cout \u003c\u003c \"Logger\u0026 operator = (const Logger\u0026): \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n        return *this;\n    }\n\n    Logger\u0026 operator = (Logger\u0026\u0026 other) {\n        std::cout \u003c\u003c \"Logger\u0026 operator = (Logger\u0026\u0026): \" \u003c\u003c id \u003c\u003c \" \" \u003c\u003c other.id \u003c\u003c \"\\n\";\n        return *this;\n    }\n\n    ~Logger() {\n        std::cout \u003c\u003c \"~Logger(): \" \u003c\u003c id \u003c\u003c \"\\n\";\n    }\n};\n\nint Logger::counter = 0;\n```\n\nВам требуется написать программу, которая работает с этим классом и выводит следующий текст:\n\n```bash\nLogger(): 1\n~Logger(): 1\nLogger(): 2\n~Logger(): 2\n```\n\n#### Примечания\n\nНе вставляйте код класса в решение. Используйте вместо этого директиву `#include \"logger.h\"` в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nТут нужно создать два объекта и как-то искусственно ограничить жизнь второго. Это можно сделать несколькими способами:\n\nНапример, использовать блоки:\n\n```cpp\n#include \"logger.h\"\n\nint main() {\n    { Logger logger; }\n    { Logger logger; }\n}\n```\n\nТакже можно реализовать дополнительную функцию и вызвать её два раза:\n\n```cpp\n#include \"logger.h\"\n\nvoid CreateLogger() {\n    Logger logger;\n}\n\nint main() {\n    CreateLogger();\n    CreateLogger();\n}\n```\n\n{% endcut %}\n\n### [Задача «Жизнь объекта - 1»](https://new.contest.yandex.ru/42098/problem?id=40119/2022_10_29/bqEwcNOfjz)\n\n{% cut \"Условие\" %}\n\nВ предыдущей задаче вам был дан готовый класс `Logger`, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.\n\nВам требуется написать программу, которая работает с этим классом и выводит следующий текст:\n\n```bash\nLogger(): 1\nLogger(const Logger\u0026): 2 1\n~Logger(): 2\n~Logger(): 1\n```\n\n#### Примечания\n\nНе вставляйте код класса в решение. Используйте вместо этого директиву `#include \"logger.h\"` в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВ этой задаче так же создаётся два объекта, но в этот раз вызывается конструктор копирования второго объекта от первого.\n\n```cpp\n#include \"logger.h\"\n\nint main() {\n    Logger logger1;\n    Logger logger2(logger1);  //  Можно записать иначе: Logger logger2 = logger1;\n}\n```\n\n{% endcut %}\n\n### [Задача «Жизнь объекта - 2»](https://new.contest.yandex.ru/42098/problem?id=40119/2022_10_29/eARwa0QSv7)\n\n{% cut \"Условие\" %}\n\nВ предыдущей задаче вам был дан готовый класс `Logger`, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.\n\nВам требуется написать программу, которая работает с этим классом и выводит следующий текст:\n\n```bash\nLogger(): 1\nLogger(Logger\u0026\u0026): 2 1\n~Logger(): 2\n~Logger(): 1\n```\n\n#### Примечания\n\nНе вставляйте код класса в решение. Используйте вместо этого директиву `#include \"logger.h\"` в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nПолный аналог предыдущей задачи за исключением того, что вызывается не конструктор копирования, а move-конструктор:\n\n```cpp\n#include \u003cutility\u003e\n\n#include \"logger.h\"\n\nint main() {\n    Logger logger1;\n    Logger logger2(std::move(logger1));  // Можно записать иначе: Logger logger2 = std::move(logger1);\n}\n```\n\n{% endcut %}\n\n### [Задача «Жизнь объекта - 3»](https://new.contest.yandex.ru/42098/problem?id=40119/2022_10_29/1wlpFEKyza)\n\n{% cut \"Условие\" %}\n\nВ предыдущей задаче вам был дан готовый класс `Logger`, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.\n\nВам требуется написать программу, которая работает с этим классом и выводит следующий текст:\n\n```bash\nLogger(): 1\nLogger(): 2\nLogger\u0026 operator = (const Logger\u0026): 1 2\nLogger\u0026 operator = (Logger\u0026\u0026): 1 2\n~Logger(): 2\n~Logger(): 1\n```\n\n#### Примечания\n\nНе вставляйте код класса в решение. Используйте вместо этого директиву `#include \"logger.h\"` в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДавайте прочитаем требуемый вывод: создаётся два объекта, в первый копируется второй, в первый «перемещается» второй, вызываются деструкторы.\n\nТеперь давайте тоже самое запишем кодом, буквально слово в слово:\n\n```cpp\n#include \u003cutility\u003e\n\n#include \"logger.h\"\n\nint main() {\n    Logger logger1, logger2;\n    logger1 = logger2;\n    logger1 = std::move(logger2);\n}\n```\n\n{% endcut %}\n\n### [Задача «Жизнь объекта - 4»](https://new.contest.yandex.ru/42098/problem?id=40119/2022_10_29/V1g3uqgRw5)\n\n{% cut \"Условие\" %}\n\nВ предыдущей задаче вам был дан готовый класс `Logger`, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.\n\nВам требуется написать программу, которая работает с этим классом и выводит следующий текст:\n\n```bash\nLogger(): 1\nLogger(): 2\nLogger(): 3\n~Logger(): 2\n~Logger(): 3\n~Logger(): 1\n```\n\n#### Примечания\n\nНе вставляйте код класса в решение. Используйте вместо этого директиву `#include \"logger.h\"` в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВ этой задаче важно было заметить, что второй и третий созданные объекты удаляются в противоположном порядке. Есть много способов получить такой порядок, самый простой, пожалуй, через указатели:\n\n```cpp\n#include \"logger.h\"\n\nint main() {\n    Logger logger1;\n    Logger* logger2 = new Logger;\n    Logger* logger3 = new Logger;\n    delete logger2;\n    delete logger3;\n}\n```\n\nТак же можно было использовать какой-нибудь контейнер, например, `std::list`:\n\n```cpp\n#include \u003clist\u003e\n\n#include \"logger.h\"\n\nint main() {\n    Logger logger1;  // создаём первый объект\n    std::list\u003cLogger\u003e loggers(2);  // создаём 2 и 3 объекты\n    loggers.pop_front();  // уничтожаем второй объект\n}\n```\n\n{% endcut %}\n\n### [Задача «Жизнь объекта - 5»](https://new.contest.yandex.ru/42098/problem?id=40119/2022_10_29/2j51TvIVKZ)\n\n{% cut \"Условие\" %}\n\nВ предыдущей задаче вам был дан готовый класс `Logger`, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.\n\nВам требуется написать программу, которая работает с этим классом и выводит по заданному $n$ следующий текст:\n\n```bash\nLogger(): 1\nLogger(): 2\n...\nLogger(): n\n~Logger(): n\n...\n~Logger(): 2\n~Logger(): 1\n```\n\n#### Примечания\n\nНе вставляйте код класса в решение. Используйте вместо этого директиву `#include \"logger.h\"` в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nТут так же было можно пойти несколькими путями, наилучший, на наш взгляд, был через вектор:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\n#include \"logger.h\"\n\nint main() {\n    size_t n = 0;\n    std::cin \u003e\u003e n;\n\n    std::vector\u003cLogger\u003e loggers(n);\n    for (size_t i = 0; i != n; ++i) {\n        loggers.pop_back();\n    }\n}\n```\n\nНекоторые, эксперементируя локально, могли получать искомый ответ при примерно такой версии кода:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\n#include \"logger.h\"\n\nint main() {\n    size_t n = 0;\n    std::cin \u003e\u003e n;\n    std::vector\u003cLogger\u003e loggers(n);\n}\n```\n\nНо в тесты этот код не проходит. Дело в том, что порядок удаления элементов в векторе в деструкторе не детерминирован и может разниться от реализации к реализации. В контесте это прямой порядок, где-то он может быть обратным (и, вообще говоря, любым).\n\n{% endcut %}\n\n### [Задача «Жизнь объекта - 6»](https://new.contest.yandex.ru/42098/problem?id=40119/2022_10_29/iNlb72OTCV)\n\n{% cut \"Условие\" %}\n\nВ предыдущей задаче вам был дан готовый класс `Logger`, который в своих конструкторах, операторах присваивания и деструкторе печатает соответствующие сообщения.\n\nВам требуется написать программу, которая работает с этим классом и выводит по заданному $n$ следующий текст:\n\n```bash\nLogger(): 1\nLogger(): 2\n...\nLogger(): n\n~Logger(): 1\n~Logger(): 2\n...\n~Logger(): n\n```\n\n#### Примечания\n\nНе вставляйте код класса в решение. Используйте вместо этого директиву `#include \"logger.h\"` в начале программы. Не пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nЗадачу можно было решать через любой известный контейнер двумя способами: через указатели:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\n#include \"logger.h\"\n\nint main() {\n    size_t n = 0;\n    std::cin \u003e\u003e n;\n\n    std::vector\u003cLogger*\u003e pointers(n);\n    for (size_t i = 0; i != n; ++i) {\n        pointers[i] = new Logger;\n    }\n\n    for (size_t i = 0; i != n; ++i) {\n        delete pointers[i];\n    }\n}\n```\n\nНо в указателях особо не было смысла, так как у нас есть контейнеры, которые поддерживают удаление из начала, например, `std::list`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n\n#include \"logger.h\"\n\nint main() {\n    size_t n = 0;\n    std::cin \u003e\u003e n;\n\n    std::list\u003cLogger\u003e loggers(n);\n    for (size_t i = 0; i != n; ++i) {\n        loggers.pop_front();\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «TimerGuard»](https://new.contest.yandex.ru/42098/problem?id=40119/2022_10_29/ZIqLAxhFmD)\n\n{% cut \"Условие\" %}\n\nВася хочет замерять время работы разных частей своей программы. Сейчас он делает это средствами стандартной библиотеки так:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cchrono\u003e\n\n#include \"some_long_stuff.h\"\n\nvoid SomeFunc() {\n    auto start1 = std::chrono::high_resolution_clock::now();\n    FirstLongFunction();\n    std::chrono::duration\u003cdouble\u003e diff1 = std::chrono::high_resolution_clock::now() - start1;\n    std::cout \u003c\u003c \"FirstLongFunction elapsed: \" \u003c\u003c diff1.count() \u003c\u003c \"\\n\";\n\n    auto start2 = std::chrono::high_resolution_clock::now();\n    SecondLongFunction();\n    std::chrono::duration\u003cdouble\u003e diff2 = std::chrono::high_resolution_clock::now() - start2;\n    std::cout \u003c\u003c \"SecondLongFunction elapsed: \" \u003c\u003c diff2.count() \u003c\u003c \"\\n\";\n\n    auto start3 = std::chrono::high_resolution_clock::now();\n    ThirdLongFunction();\n    std::chrono::duration\u003cdouble\u003e diff3 = std::chrono::high_resolution_clock::now() - start3;\n    std::cout \u003c\u003c \"ThirdLongFunction elapsed: \" \u003c\u003c diff3.count() \u003c\u003c \"\\n\";\n}\n\nint main() {\n    SomeFunc();\n    return 0;\n}\n```\n\nНо ему очень не удобно каждый раз прописывать начало замера и конец. Помогите ему сделать это удобнее.\n\nНапишите обёртку `TimerGuard`. Это класс, который создается перед началом вычислений и при выходе из своего `scope` пишет в поток время работы, которое он существовал. С его помощью Вася сможет писать так:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cchrono\u003e\n\n#include \"some_long_stuff.h\"\n\nvoid SomeFunc() {\n    {\n        TimerGuard timer(\"FirstLongFunction elapsed: \", std::cout);\n        FirstLongFunction();\n    }\n    {\n        TimerGuard timer(\"SecondLongFunction elapsed: \", std::cout);\n        SecondLongFunction();\n    }\n    {\n        TimerGuard timer(\"ThirdLongFunction elapsed: \", std::cout);\n        ThirdLongFunction();\n    }\n}\n\nint main() {\n    SomeFunc();\n    return 0;\n}\n```\n\nКласс `TimerGuard` должен содержать следующий конструктор:\n\n`TimerGuard(std::string message = \"\", std::ostream\u0026 out = std::cout);`\n\n`message` — сообщение, печатаемое перед перед временем. `out` — поток, в который нужно печатать сообщение.\n\nДеструктор класса должен печатать сообщение в формате `\"{message} {time}\"` (обратите внимание на пробел).\n\n#### Примечания\n\nСдайте в систему только код конструкции `TimerGuard` без функции `main`. Подключите необходимые библиотеки.\n\nОбратите внимание, что данный `guard` очень полезен даже вне этой задачи. Его можно использовать при отладке медленных участков вашей программы!\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВ блоках Васи `TimerGuard` дёргается два раза — при создании (конструктор) и при выходе из блока (деструктор). Так что давайте напишем класс, который при создании будет запоминать все необходимые переменные в поля класса, а в деструкторе выводить их:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cchrono\u003e\n#include \u003cstring\u003e\n\nclass TimerGuard {\n    std::chrono::time_point\u003cstd::chrono::high_resolution_clock\u003e start;\n    std::string outMessage;\n    std::ostream\u0026 outStream;\npublic:\n\n    TimerGuard(std::string message = \"\", std::ostream\u0026 out = std::cout):\n        start(std::chrono::high_resolution_clock::now()),  // start - вызов конструктора\n        outMessage(message),\n        outStream(out)\n    {\n    }\n\n    ~TimerGuard() {\n        auto end = std::chrono::high_resolution_clock::now();  // конец - вызов деструктора\n        std::chrono::duration\u003cdouble\u003e diff = end - start;\n        outStream \u003c\u003c outMessage \u003c\u003c \" \" \u003c\u003c diff.count() \u003c\u003c \"\\n\";\n    }\n};\n```\n\n{% endcut %}\n\n----------\n\n## Параграф «Наследование и полиморфизм»\n\n### [Задача «Периметр фигуры»](https://new.contest.yandex.ru/42116/problem?id=40119/2022_10_29/cSyvGCVLb3)\n\n{% cut \"Условие\" %}\n\nВам надо написать базовый класс `Figure` (геометрическая фигура) и унаследованные от него классы `Triangle` (треугольник) и `Rectangle` (прямоугольник).\n\nКласс `Triangle` должен иметь конструктор, принимающий на вход три числа типа `int` — стороны треугольника. Считайте, что треугольник с такими сторонами всегда существует.\n\nКласс `Rectangle` должен иметь конструктор, принимающий на вход два числа типа `int` — стороны прямоугольника.\n\nКласс `Figure` должен объвлять виртуальную функцию `int Perimeter() const`, возвращающую периметр фигуры.\n\nКлассы-наследники должны переопределить эту функцию правильным образом.\n\nФункцию `main` писать в вашем коде не надо: она будет в нашей проверяющей программе. Наша программа выглядит так:\n\n```cpp\n#include \"figures.h\"\n\n#include \u003cvector\u003e\n#include \u003ciostream\u003e\n\nint main() {\n    std::vector\u003cFigure*\u003e figures;\n\n    std::string type;\n\n    while (std::cin \u003e\u003e type) {\n        if (type == \"Triangle\") {\n            int a, b, c;\n            std::cin \u003e\u003e a \u003e\u003e b \u003e\u003e c;\n            figures.push_back(new Triangle(a, b, c));\n        } else if (type == \"Rectangle\") {\n            int a, b;\n            std::cin \u003e\u003e a \u003e\u003e b;\n            figures.push_back(new Rectangle(a, b));\n        }\n    }\n\n    for (Figure* f : figures) {\n        std::cout \u003c\u003c f-\u003ePerimeter() \u003c\u003c \"\\n\";\n    }\n\n    for (Figure* f : figures) {\n        delete f;\n    }\n}\n```\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВидно, что работа с объектами будет производиться полиморфно, через указатель на базовый класс `Figure`. В частности, фигуры будут удаляться через вызов `delete f`, где `f` имеет тип `Figure*`. Чтобы это корректно работало, в базовом классе нужно предусмотреть виртуальный деструктор.\n\n```cpp\nclass Figure {\npublic:\n    virtual int Perimeter() const = 0;\n\n    virtual ~Figure() {\n    }\n};\n\n\nclass Triangle: public Figure {\n    int A, B, C;\n\npublic:\n    Triangle(int x, int y, int z): A(x), B(y), C(z) {\n    }\n\n    int Perimeter() const override {\n        return A + B + C;\n    }\n};\n\n\nclass Rectangle: public Figure {\n    int A, B;\n\npublic:\n    Rectangle(int a, int b): A(a), B(b) {\n    }\n\n    int Perimeter() const override {\n        return 2 * (A + B);\n    }\n};\n```\n\n{% endcut %}\n\n### [Задача «Notifications»](https://new.contest.yandex.ru/42116/problem?id=40119/2022_10_29/xDFxiJ77Tw)\n\n{% cut \"Условие\" %}\n\nВам даны функции `SendSms` и `SendEmail`, которые «умеют» отправлять сообщения:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nvoid SendSms(const std::string\u0026 number, const std::string\u0026 message) {\n    std::cout \u003c\u003c \"Send '\" \u003c\u003c message \u003c\u003c \"' to number \" \u003c\u003c number \u003c\u003c std::endl;\n}\n\nvoid SendEmail(const std::string\u0026 email, const std::string\u0026 message) {\n    std::cout \u003c\u003c \"Send '\" \u003c\u003c message \u003c\u003c \"' to e-mail \"  \u003c\u003c email \u003c\u003c std::endl;\n}\n\n// Ваш код будет вставлен здесь:\n#include \"your_solution.h\"\n\n// Реализуйте в вашем решении классы NotifierBase, SmsNotifier и EmailNotifier,\n// чтобы следующий код заработал как ожидается:\n\nvoid Notify(const NotifierBase\u0026 notifier, const std::string\u0026 message) {\n    notifier.Notify(message);\n}\n\nint main() {\n    SmsNotifier sms(\"+7-495-777-77-77\");\n    EmailNotifier email(\"na-derevnyu@dedushke.ru\");\n\n    Notify(sms, \"Hello! How are you?\");\n    Notify(email, \"Let's learn C++!\");\n    return 0;\n}\n```\n\nВам нужно написать классы `SmsNotifier` и `EmailNotifier`, унаследованные от базового класса `NotifierBase` и переопределяющие функцию `Notify`, чтобы приведённый код заработал. Функция `Notify` в этих классах должна вызывать данные вам функции `SendSms` или `SendEmail`.\n\n#### Примечания\n\nСдайте в систему только код классов без функции `main` и без уже написанных функций. Подключите все необходимые для вашей реализации библиотеки.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\n`NotifierBase` — родительский абстрактный класс, который не должен содержать функционала, у него должны быть виртуальные метод `Notify` и деструктор.\n\n`SmsNotifier` и `EmailNotifier` наследуются от него и в переопределениях `Notify` вызывают соответствующие функции:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nclass NotifierBase {\npublic:\n    virtual void Notify(const std::string\u0026 message) const = 0;\n    virtual ~NotifierBase() {}\n};\n\nclass SmsNotifier : public NotifierBase {\npublic:\n    SmsNotifier(const std::string\u0026 number)\n        : Number(number) {}\n\n    virtual void Notify(const std::string\u0026 message) const override {\n        SendSms(Number, message);\n    }\n\nprivate:\n    const std::string Number;\n};\n\nclass EmailNotifier : public NotifierBase {\npublic:\n    EmailNotifier(const std::string\u0026 email)\n        : Email(email) {}\n\n    virtual void Notify(const std::string\u0026 message) const override {\n        SendEmail(Email, message);\n    }\n\nprivate:\n    const std::string Email;\n};\n```\n\n{% endcut %}\n\n### [Задача «JSON»](https://new.contest.yandex.ru/42116/problem?id=4105/2022_10_29/UmCS8SuQso)\n\n{% cut \"Условие\" %}\n\nДанные часто нужно сериализовывать, то есть превращать в строку. Это нужно для сохранения на диске, для отправки по сети, для передачи другому процессу. Часто для этого используются несколько общепринятых форматов данных, таких как `JSON`, `YAML`, `XML`. Поскольку на этапе компиляции не всегда известно, в каком именно формате надо сериализовывать данные, часто приходится прибегать к наследованию. Вам необходимо реализовать класс `Serializer` с чисто виртуальными методами:\n\n```cpp\nvoid BeginArray()\nvoid AddArrayItem(const std::string \u0026)\nvoid EndArray()\n```\n\nПосле этого унаследуйте от него класс `JsonSerializer`, определив все эти методы.\n\n`JsonSerializer` должен печатать упрощенную версию JSON (https://ru.wikipedia.org/wiki/JSON), состояющую только из массивов и строк. Массив начинается с квадратной скобки. После каждого элемента, кроме последнего, должна стоять запятая. Заканчивается массив квадратной скобкой. Все строки должны быть взяты в двойные кавычки. Гарантируется, что все строки состоят только из латинских символов и пробелов, поэтому экранировать их не надо.\n\nСдайте в систему только код классов, без функции `main`. Для полной ясности формата вывода посмотрите на примеры из условия.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nBeginArray\u003cbr\u003eEndArray\n\n|\n\n\\[\\]\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nBeginArray\u003cbr\u003eAddArrayItem second\u003cbr\u003eEndArray\n\n|\n\n\\[\"second\"\\]\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nBeginArray\u003cbr\u003eAddArrayItem first\u003cbr\u003eAddArrayItem second\u003cbr\u003eEndArray\n\n|\n\n\\[\"first\",\"second\"\\]\n\n||\n|#\n\n#### Примечания\n\nНе надо определять для вашего класса `operator \u003c\u003c`. Печать должна происходить в функциях, указанных в условии. Мы будем работать с экземпляром вашего класса `JsonSerializer` полиморфно, через указатель на базовый класс `Serializer`. Поэтому не забудьте про виртуальный деструктор.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nИз примеров понятна проблема — она кроется в запятой, которую непонятно когда ставить. Определим приватное поле `isFirst`. Оно будет указывать, первый ли элемент мы добавляем, и не важно, что тут назвать элементом — `Array` или `Item`. Если мы завершаем `Array`, то `isFirst` устанавливаем на `false`, потому что следующий элемент уже не будет первым. Аналогично с `AddArrayItem`. И лишь в случае `BeginArray` мы не должны рисовать никаких запятых. Дефолтно поле выставляем на `true`, так как первый `Array` действительно будет первым:\n\n```cpp\n#include \u003cvector\u003e\n#include \u003ciostream\u003e\n\nclass Serializer {\npublic:\n    virtual void BeginArray() = 0;\n    virtual void AddArrayItem(const std::string \u0026s) = 0;\n    virtual void EndArray() = 0;\n    virtual ~Serializer() {}\n};\n\nclass JsonSerializer : public Serializer {\npublic:\n    void BeginArray() override {\n        if (!isFirst) {\n            std::cout \u003c\u003c \",[\";\n        } else {\n            std::cout \u003c\u003c \"[\";\n        }\n\n        isFirst = true;\n    }\n\n    void AddArrayItem(const std::string\u0026 str) override {\n        if (!isFirst) {\n            std::cout \u003c\u003c \",\";\n        }\n        std::cout \u003c\u003c \"\\\"\" \u003c\u003c str \u003c\u003c \"\\\"\";\n        isFirst = false;\n    }\n\n    void EndArray() override {\n        std::cout \u003c\u003c \"]\";\n        isFirst = false;\n    }\n\nprivate:\n    bool isFirst = true;\n};\n```\n\n{% endcut %}\n\n### [Задача «AdvancedVector»](https://new.contest.yandex.ru/42116/problem?id=40119/2022_10_29/gCbXCP2zqF)\n\n{% cut \"Условие\" %}\n\nРеализуйте класс `AdvancedVector`. Продвинутый вектор отличается от обычного тем, что позволяет обращаться по отрицательным индексам к элементам вектора в обратном порядке ( прямо как в Python). Например, `vec[-1]` возвращает последний элемент, `vec[-2]` возвращает предпоследний и так далее.\n\nКласс `AdvancedVector` должен хранить элементы шаблонного типа `T`. Требуемый функционал не сильно отличается от стандартного `std::vector`:\n\n 1. Класс должен называться `AdvancedVector`.\n\n 2. У класса должен быть шаблонный параметр `T` — тип элементов.\n\n 3. У класса должен быть конструктор по умолчанию.\n\n 4. У класса должен быть конструктор копирования (возможно, предоставленный компилятором).\n\n 5. У класса должен быть шаблонный конструктор, принимающий два итератора и заполняющий вектор из данного диапазона.\n\n 6. У класса должен быть оператор присваивания (возможно, предоставленный компилятором).\n\n 7. У класса должны быть операторы сравнения `==` и `!=`.\n\n 8. У класса должны быть константные функции `empty()` и `size()`.\n\n 9. У класса должны быть функции `pop_back()` и `push_back(const T\u0026)`.\n\n10. У класса должны быть константная и неконстантная версии оператора `[]`.\n\nВ случае положительного индекса нужно вернуть элемент с соответствующим индексом, если он меньше размера вектора. Иначе нужно бросить исключение `std::out_of_range`. В случае отрицательного индекса нужно вернуть элемент с соответствующим индексом, предполагая,  что последний элемент имеет номер $-1$, предпоследний $-2$ и так далее. Но только пока модуль индекса не превосходит `size()`. Если же `std::abs(index) \u003e size`, то нужно бросить исключение `std::out_of_range`.\n\n#### Формат ввода\n\nГарантируется, что передаваемый в `operator []` индекс лежит в отрезке $\\left[-10^{9}; 10^{9}\\right]$.\n\n#### Примечания\n\nСдайте в систему только код класса `AdvancedVector` без функции `main`. Подключите все необходимые для вашей реализации библиотеки.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nМожно было бы написать класс, в котором будет использоваться *композиция* со стандартным вектором:\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass AdvancedVector {\nprivate:\n    std::vector\u003cT\u003e data;\n\npublic:\n    // ...\n};\n```\n\nОднако в таком классе пришлось бы заново определять все публичные операторы и функции, такие как `size`, `empty`, `push_back` и т. д. Попробуем поступить иначе: воспользуемся *наследованием* от `std::vector\u003cT\u003e`. В таком случае будет достаточно переопределить лишь оператор `[]`, а также шаблонный конструктор и конструктор по умолчанию. Все остальные операторы и функции будут автоматически унаследованы от вектора.\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass AdvancedVector: public std::vector\u003cT\u003e {\npublic:\n    AdvancedVector() = default;\n\n    template \u003ctypename Iter\u003e\n    AdvancedVector(Iter first, Iter last): std::vector\u003cT\u003e(first, last) {\n    }\n\n    const T\u0026 operator [](std::int64_t i) const {\n        if (i \u003c 0) {\n            i += this-\u003esize();\n        }\n        return this-\u003eat(i);\n    }\n\n    T\u0026 operator [](std::int64_t i) {\n        if (i \u003c 0) {\n            i += this-\u003esize();\n        }\n        return this-\u003eat(i);\n    }\n};\n```\n\nВ этом решении есть одна особенность. Базовый класс зависит от неизвестного заранее шаблонного параметра. Поэтому вызов функций базового класса требуется [явно предварять](https://stackoverflow.com/questions/4643074/why-do-i-have-to-access-template-base-class-members-through-the-this-pointer) либо префиксом с именем базового класса `std::vector\u003cT\u003e::`, либо конструкцией `this-\u003e`. Это позволит компилятору отложить поиск этого имени до момента инстранцирования шаблона с конкретным типом `T`.\n\nОбратите внимание на реализацию оператора `[]`. Идея в том, чтобы получить настоящий индекс элемента, а затем вызвать унаследованную от вектора функцию `at`. Эта функция делает проверку корректности аргумента: он должен быть меньше размера контейнера. В случае некорректного значения она сама сгенерирует требуемое исключение `std::out_of_range`.\n\nФункция `at` принимает беззнаковый аргумент типа `size_t`. Если в неё передать знаковый тип, то произойдёт неявное преобразование. Например, если `size_t` занимает 8 байт (64 бита), то отрицательный аргумент `i` будет преобразован в $2^{64} - i$. Покажите самостоятельно, что если после прибавления `size()` индекс `i` остался отрицательным, то аргумент функции `at` всё равно будет некорректным.\n\nВ решении реализованы две версии оператора `[]` — константная и неконстантная. Они отличаются лишь версиями функции `at`, которая в векторе тоже перегружена по константности.\n\n{% endcut %}\n\n### [Задача «Жизнь объекта с наследованием»](https://new.contest.yandex.ru/42116/problem?id=40119/2022_10_29/xYIX1LU9JQ)\n\n{% cut \"Условие\" %}\n\nВам дан класс `A`, который в своих конструкторах и деструкторе печатает соответствующие сообщения, а так же `main`:\n\n```cpp\n#include \u003ciostream\u003e\n\nclass A {\npublic:\n    A(int x) {\n        std::cout \u003c\u003c \"Constructor(int): \" \u003c\u003c x \u003c\u003c \"\\n\";\n    }\n    A(const A\u0026) {\n        std::cout \u003c\u003c \"Copy constructor\\n\";\n    }\n    virtual ~A() {\n        std::cout \u003c\u003c \"Destructor\\n\";\n    }\n    virtual void foo() const = 0;\n};\n\n#include \"your_code.h\"\n\nint main() {\n    B b;\n    const A\u0026 a = b;\n    a.foo();\n}\n```\n\nВам требуется написать код класса `B`, чтобы функция `main`, работающая с этим классом, вывела бы следующие сообщения:\n\n```bash\nConstructor(int): 42\nDestructor\n```\n\n#### Примечания\n\nНе пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДля начала давайте поймём, что происходит в `main`: создаётся объект типа `B`, константный указатель типа `A` на этот объект и вызывается виртуальный метод `foo`.\n\nИтого имеем, класс `B` должен наследоваться от класса `A` и переопределять метод `foo`, так же у класса `B` должен быть дефолтный конструктор:\n\n```cpp\nclass B: public A {\npublic:\n\n    B(): A(42) {}\n\n    void foo() const override {}\n};\n```\n\nСамой сложной задачей, что при всех этих условиях `A(42)` должен вызываться в конструкторе `B`. Но написав `B () { A(42); }` ничего не выходило бы. Перед входом в тело конструктора все переменные в классе должны быть инициализированы. Если вы не укажете элемент в списке инициализации конструктора, элементы будут сконструированы по умолчанию, но так как у `A` нет дефолтного конструктора, сделать это в теле класса нельзя.\n\n{% endcut %}\n\n----------\n\n## Параграф «Обработка исключений»\n\n### [Задача «Адреса»](https://new.contest.yandex.ru/42112/problem?id=40119/2022_10_29/pxHQLAVyjK)\n\n{% cut \"Условие\" %}\n\nАлексею поручили написать программу, обрабатывающую почтовые адреса.\n\nДана структура `Address` и несколько работающих с ней функций:\n\n```cpp\n#include \u003cstring\u003e\n\nstruct Address {\n    std::string Country;\n    std::string City;\n    std::string Street;\n    std::string House;\n};\n\nvoid Parse(const std::string\u0026 line, Address* const address);\nvoid Unify(Address* const address);\nstd::string Format(const Address\u0026 address);\n```\n\nФункция `Parse` принимает на вход текстовую строчку и пытается выделить из неё компоненты адреса.\n\nФункция `Unify` пытается привести компоненты адреса к каноническому виду (например, вместо «пр-д Кочновский» записать «Кочновский проезд»).\n\nФункция `Format` возвращает текстовое представление адреса.\n\nФункции `Parse` и `Unify`, в духе Google C\\+\\+ style guide, принимают на вход изменяемые параметры через указатели. Предполагается, что соотвествующие объекты типа `Address` уже созданы.\n\nВ случае ошибок обработки адреса функции `Parse` и `Unify` могут сгенерировать исключения.\n\nАлексей написал код обработки, но он почему-то не работает:\n\n```cpp\n#include \"address.h\"\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string line;\n    Address* address;\n    while (getline(std::cin, line)) {\n        Parse(line, address);\n        Unify(address);\n        std::cout \u003c\u003c Format(*address) \u003c\u003c \"\\n\";\n    }\n}\n```\n\nПредполагалось, что эта программа будет читать поступающие на вход строки, извлекать из них адреса и печатать их обработанные текстовые представления. В случае исключений при обработке строки программа должна напечатать просто “exception” (с переводом строки) и перейти к обработке следующих строк.\n\n#### Примечания\n\nВам нужно исправить ошибки в коде и сдать его в систему. Код структуры `Address` и функций переписывать не надо: просто подключите в своей программе заголовочный файл `address.h`. Утечек памяти в вашей программе быть не должно.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДавайте сначала поймём, в чём фундаментальная ошибка в приведённом неправильном коде обработки. В нём декларируется указатель `address`, но на какое место в памяти он указывает? Указатель является примитивным базовым типом. Локальная переменная `address` никак не инициализируется, и в ней лежит «мусор». Она **не указывает на адрес реального объекта типа `Address` в памяти**. Но функции `Parse` и `Unify` предполагают, что переданный указатель ссылается на существующий объект.\n\nВторая ошибка связана с тем, что в приведённом коде никак не проверяются исключения, которые могут вылететь из функций.\n\nПервый способ решения — создать соответствующую переменную типа `Address` в динамической памяти. В этом случае мы должны будем вручную следить за её временем жизни и в нужный момент удалить. Правильнее будет создавать такую переменную всякий раз перед очередным разбором адреса (хотя в условии это не требуется). Однако вот такой код не будет работать:\n\n```cpp\n#include \"address.h\"\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string line;\n    while (getline(std::cin, line)) {\n        try {\n            Address* address = new Address;\n            Parse(line, address);\n            Unify(address);\n            std::cout \u003c\u003c Format(*address) \u003c\u003c \"\\n\";\n            delete address;\n        } catch (...) {\n            std::cout \u003c\u003c \"exception\\n\";\n        }\n    }\n}\n```\n\nЗдесь при возникновении исключения мы не дойдём до вызова `delete`, и выделенная память утечёт. Исправим его так:\n\n```cpp\n#include \"address.h\"\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string line;\n    while (getline(std::cin, line)) {\n        Address* address = new Address;\n        try {\n            Parse(line, address);\n            Unify(address);\n            std::cout \u003c\u003c Format(*address) \u003c\u003c \"\\n\";\n        } catch (...) {\n            std::cout \u003c\u003c \"exception\\n\";\n        }\n        delete address;\n    }\n}\n```\n\nОднако есть решение проще. Нет никакой необходимости создавать переменную именно в динамической памяти.\n\nВполне может подойти переменная, созданная просто на стеке. Тогда в функции `Parse` и `Unify` надо будет передать её адрес, а в функцию `Format` просто саму эту переменную.\n\n```cpp\n#include \"address.h\"\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nint main() {\n    std::string line;\n    while (getline(std::cin, line)) {\n        try {\n            Address address;\n            Parse(line, \u0026address);\n            Unify(\u0026address);\n            std::cout \u003c\u003c Format(address) \u003c\u003c \"\\n\";\n        } catch (...) {\n            std::cout \u003c\u003c \"exception\\n\";\n        }\n    }\n}\n```\n\nЗдесь нам не нужно следить за временем жизни переменной: как бы мы ни покинули блок кода, локальная стековая переменная будет корректно автоматически уничтожена.\n\n{% endcut %}\n\n### [Задача «Retry»](https://new.contest.yandex.ru/42112/problem?id=40119/2022_10_29/u8gVXstSLK)\n\n{% cut \"Условие\" %}\n\nИногда некоторые действия не получается выполнить с первого раза. Например, обращение по сети в сторонний сервис может обернуться неудачей из-за сетевых проблем или перегрузки сервиса. В таких случаях иногда пишут код, который пытается повторить такое действие несколько раз подряд.\n\nВам надо написать реализацию функции `DoWithRetry` с таким заголовком:\n\n```cpp\n#include \u003cexception\u003e\n#include \u003cfunctional\u003e\n#include \u003coptional\u003e\n\ntemplate \u003ctypename Result, typename Exception = std::exception\u003e\nstd::optional\u003cResult\u003e DoWithRetry(std::function\u003cResult()\u003e func,\n                                  int retryCount, int sleepTime, bool throwLast);\n```\n\nФункция принимает на вход другую функцию без аргументов, возвращающую значение типа `Result`, количество повторов, таймаут между повторами и флажок `throwLast`.\n\nОдним из шаблонных параметров функции является тип исключения, на которое функция реагирует. Функция должна вызвать `func`, и если произошло исключение указанного типа, то вызвать нашу функцию `Sleep` с параметром `sleepTime`, а затем повторить попытку (если попытки еще остались). Максимальное количество вызовов `func`, которое может получиться, равно `retryCount + 1`. Если на последней попытке происходит исключение указанного типа, и `throwLast` истинно, этот же объект исключения должен проброситься дальше из функции. Если же `throwLast` ложно, то надо просто вернуть пустой объект `std::optional`. Если же вызов `func` закончился успешно, то надо просто вернуть результат `func`.\n\n#### Примечания\n\nПро `std::optional` можно прочитать [здесь](https://en.cppreference.com/w/cpp/utility/optional). Если исключение произошло на последней попытке, то после неё «спать» не надо.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\n```cpp\n#include \u003cexception\u003e\n#include \u003cfunctional\u003e\n#include \u003coptional\u003e\n\ntemplate \u003ctypename Result, typename Exception = std::exception\u003e\nstd::optional\u003cResult\u003e DoWithRetry(std::function\u003cResult()\u003e func, int retryCount, int sleepTime, bool throwLast) {\n    for (int i = 0; i \u003c retryCount + 1; ++i) {\n        try {\n            return func();\n        } catch (const Exception\u0026) {\n            if (i == retryCount) {\n                if (throwLast) {\n                    throw;\n                }\n            } else {\n                Sleep(sleepTime);\n            }\n        }\n    }\n    return {};\n}\n```\n\nЗдесь мы перехватываем потенциальные исключения, приводящиеся к типу `Exception` (важно ловить именно их, а не писать `catch (...)`). При этом сам объект исключения нам не нужен, поэтому мы его имя не указываем. При необходимости (после последней попытки при возведённом `throwLast`) мы перекидываем пойманное исключение дальше с помощью `throw` без аргументов.\n\n{% endcut %}\n\n### [Задача «BiMap»](https://new.contest.yandex.ru/42112/problem?id=40119/2022_10_29/OMb8kqodCO)\n\n{% cut \"Условие\" %}\n\nВсе вы знаете контейнер `std::map`, который сопоставляет уникальным ключам значение. Представим теперь, что мы работаем с данными, у которых бывает два типа ключей. Например, студента можно задать номером студенческого билета или логином в системе. При этом не обязательно заданы оба ключа: например, у студента может ещё не быть логина.\n\nВам надо написать класс `BiMap`, к которому можно обратиться за значением по одному из двух типов ключей. Вот заготовка для вашего класса:\n\n```cpp\n#include \u003cstdexcept\u003e\n#include \u003coptional\u003e\n\ntemplate \u003ctypename Key1, typename Key2, typename Value\u003e\nclass BiMap {\npublic:\n    // Вставить значение, указав один или оба ключа.\n    // Генерирует исключение std::invalid_argument(\"some text\") в случае,\n    // если оба ключа пусты, либо один из ключей уже имеется в хранилище.\n    void Insert(const std::optional\u003cKey1\u003e\u0026 key1, const std::optional\u003cKey2\u003e\u0026 key2, const Value\u0026 value);\n\n    // Получить значение по ключу первого типа.\n    // Генерирует исключение std::out_of_range(\"some text\")\n    // в случае отсутствия ключа (как и функция at в std::map).\n    Value\u0026 GetByPrimaryKey(const Key1\u0026 key);\n    const Value\u0026 GetByPrimaryKey(const Key1\u0026 key) const;\n\n    // Аналогичная функция для ключа второго типа.\n    Value\u0026 GetBySecondaryKey(const Key2\u0026 key);\n    const Value\u0026 GetBySecondaryKey(const Key2\u0026 key) const;\n};\n```\n\nФункция `Insert` пытается вставить новое значение в хранилище. Ей могут быть указаны один или оба ключа (поэтому ключи передаются через `std::optional`). Если оба ключа не заданы, или если один из ключей уже есть в хранилище, функция должна сгенерировать исключение `std::invalid_argument` с каким-либо текстовым параметром.\n\nФункции `GetByPrimaryKey` и `GetBySecondaryKey` должны вернуть значение по ключу соответствующего типа. Они очень похожи на функцию `at` в `std::map`: в случае отстутствия ключа должна генерироваться ошибка `std::out_of_range`.\n\nВот пример тестовой программы, демонстрирующей работу этих функций:\n\n```cpp\n#include \"bimap.h\"\n\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nusing namespace std;\n\nstruct Student {\n    string Surname, Name;\n};\n\nostream\u0026 operator \u003c\u003c (ostream\u0026 out, const Student\u0026 s) {\n    return out \u003c\u003c s.Surname \u003c\u003c \" \" \u003c\u003c s.Name;\n}\n\nint main() {\n    BiMap\u003cint, string, Student\u003e bimap;  // студента можно определить либо по номеру, либо по логину\n    bimap.Insert(42, {}, {\"Ivanov\", \"Ivan\"});\n    bimap.Insert({}, \"cshse-ami-512\", {\"Petrov\", \"Petr\"});\n    bimap.Insert(13, \"cshse-ami-999\", {\"Fedorov\", \"Fedor\"});\n\n    cout \u003c\u003c bimap.GetByPrimaryKey(42) \u003c\u003c \"\\n\";  // Ivanov Ivan\n\n    cout \u003c\u003c bimap.GetBySecondaryKey(\"cshse-ami-512\") \u003c\u003c \"\\n\";  // Petrov Petr\n\n    cout \u003c\u003c bimap.GetByPrimaryKey(13) \u003c\u003c \"\\n\";  // Fedorov Fedor\n    cout \u003c\u003c bimap.GetBySecondaryKey(\"cshse-ami-999\") \u003c\u003c \"\\n\";  // Fedorov Fedor\n\n    // меняем значение по первичному ключу - по вторичному оно тоже должно измениться\n    bimap.GetByPrimaryKey(13).Name = \"Oleg\";\n\n    cout \u003c\u003c bimap.GetByPrimaryKey(13) \u003c\u003c \"\\n\";  // Fedorov Oleg\n    cout \u003c\u003c bimap.GetBySecondaryKey(\"cshse-ami-999\") \u003c\u003c \"\\n\";  // Fedorov Oleg\n    return 0;\n}\n```\n\n#### Примечания\n\nВы можете воспользоваться контейнером `std::map` для реализации класса (в частности, можно считать, что на ключах определён `operator \u003c`).\n\nСдайте в систему только код класса `BiMap` без функции `main`. Подключите все необходимые для вашей реализации библиотеки.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДавайте заметим, что вот такое решение нам не подойдёт:\n\n```cpp\ntemplate \u003ctypename Key1, typename Key2, typename Value\u003e\nclass BiMap {\n    std::map\u003cKey1, Value\u003e map1;\n    std::map\u003cKey2, Value\u003e map2;\n};\n```\n\nВ этом решении значения в `map1` и `map2` никак не зависят друг от друга. Если мы обратимся к значению по первому ключу и поменяем его, а потом прочитаем значение по второму ключу, то мы не увидим изменений.\n\nПоэтому нужно, чтобы значения хранились где-то отдельно в одном экземпляре, а отображения из ключей ссылались бы на них. Например, можно сохранять значения в контейнере, а ключи отображать в индексы:\n\n```cpp\ntemplate \u003ctypename Key1, typename Key2, typename Value\u003e\nclass BiMap {\n    std::deque\u003cValue\u003e values;\n    std::map\u003cKey1, size_t\u003e map1;\n    std::map\u003cKey2, size_t\u003e map2;\n};\n```\n\nИндексы можно было бы заменить на итераторы, если выбраны контейнеры `deque` или `list`, но для контейнера `vector` итераторы использовать не получится: при добавлении новых элементов в вектор может произойти реаллокация, и старые итераторы будут инвалидированы.\n\nДругое решение не использует отдельного хранилища значений. Вместо этого значения создаются в динамической памяти. Чтобы не думать о том, кто и в какой момент должен освобождать эту память, можно обернуть их в умный указатель. Так как на значение может быть две ссылки, то нужно использовать умный указатель `shared_ptr`. Рассмотрим это решение подробнее.\n\n```cpp\n#include \u003cmap\u003e\n#include \u003cmemory\u003e\n#include \u003coptional\u003e\n#include \u003cstdexcept\u003e\n\ntemplate \u003ctypename Key1, typename Key2, typename Value\u003e\nclass BiMap {\nprivate:\n    std::map\u003cKey1, std::shared_ptr\u003cValue\u003e\u003e map1;\n    std::map\u003cKey2, std::shared_ptr\u003cValue\u003e\u003e map2;\n\npublic:\n    void Insert(\n        const std::optional\u003cKey1\u003e\u0026 key1,\n        const std::optional\u003cKey2\u003e\u0026 key2,\n        const Value\u0026 value\n    ) {\n        if (!key1.has_value() \u0026\u0026 !key2.has_value()) {\n            throw std::invalid_argument(\"Both keys are empty\");\n        }\n\n        auto shared = std::make_shared\u003cValue\u003e(value);\n\n        if (key1.has_value() \u0026\u0026 map1.find(*key1) != map1.end()) {\n            throw std::invalid_argument(\"Key already exists\");\n        }\n\n        if (key2.has_value() \u0026\u0026 map2.find(*key2) != map2.end()) {\n            throw std::invalid_argument(\"Key already exists\");\n        }\n\n        if (key1.has_value()) {\n            map1[*key1] = shared;\n        }\n\n        if (key2.has_value()) {\n            map2[*key2] = shared;\n        }\n    }\n\n    Value\u0026 GetByPrimaryKey(const Key1\u0026 key) {\n        return *map1.at(key);\n    }\n\n    const Value\u0026 GetByPrimaryKey(const Key1\u0026 key) const {\n        return *map1.at(key);\n    }\n\n    Value\u0026 GetBySecondaryKey(const Key2\u0026 key) {\n        return *map2.at(key);\n    }\n\n    const Value\u0026 GetBySecondaryKey(const Key2\u0026 key) const {\n        return *map2.at(key);\n    }\n};\n```\n\nЗдесь вместо `if (key.has_value())` можно было бы просто написать [`if (key)`](https://en.cppreference.com/w/cpp/utility/optional/operator_bool). В `Get`-функциях мы не проверяем наличие ключа: при его отсутствии вызываемая функция `at` сама сгенерирует исключение нужного типа.\n\nТакже обратите внимание на порядок проверок и присваивания. Писать `map1[*key1] = shared;` сразу после того, как мы проверили `map1.find(*key1)` нельзя, ведь ошибка может встретиться в `key2`.\n\n{% endcut %}\n\n### [Задача «LoggerGuard»](https://new.contest.yandex.ru/42112/problem?id=40119/2022_10_29/IdHQd7DW4l)\n\n{% cut \"Условие\" %}\n\nВася хочет иметь возможность в конце работы своей функции выводить сообщение, что функция завершила работу. На практике исполнение функции может завершиться разными способами:\n\n* Может быть несколько операторов `return`.\n\n* Может вылететь исключение из какой-нибудь вызываемой функции.\n\nС учетом этих обстоятельств у Василия получается раздутый код:\n\n```cpp\n#include \u003ciostream\u003e\n\nint Function() {\n    int value = 1;\n    try {\n        value = SomeFunction();\n        if (value == 0) {\n            std::cout \u003c\u003c \"Function completed\\n\";\n            return value;\n        }\n\n        value = SomeOtherFunction();\n        if (value == 0) {\n            std::cout \u003c\u003c \"Function completed\\n\";\n            return value;\n        }\n\n        value = FinalFunction();  // might throw an exception\n    } catch (...) {\n        std::cout \u003c\u003c \"Function completed\\n\";\n        throw;  // throws the exception further.\n    }\n\n    std::cout \u003c\u003c \"Function completed\\n\";\n    return value;\n}\n```\n\nВместо этого Василий хотел бы не заниматься копированием одного и тоже же кода. Помогите Василию и реализуйте класс `LoggerGuard`, который принимает строку и печатает её во время выхода из функции. С использованием этого класса код Василия станет таким:\n\n```cpp\n#include \u003ciostream\u003e\n\nint Function() {\n    LoggerGuard logger(\"Function completed\");\n\n    int value = 1;\n    try {\n        value = SomeFunction();\n        if (value == 0) {\n            return value;\n        }\n\n        value = SomeOtherFunction();\n        if (value == 0) {\n            return value;\n        }\n\n        value = FinalFunction();  // might throw an exception\n    } catch (...) {\n        throw;  // throws the exception further.\n    }\n\n    return value;\n}\n```\n\nКласс `LoggerGuard` должен содержать следующий конструктор:\n\n```cpp\nLoggerGuard(const std::string\u0026 message, std::ostream\u0026 out = std::cout);\n```\n\nЗдесь `message` — сообщение, печатаемое перед выходом из функции, а `out` — поток, в который надо печатать сообщение. Учтите, что это сообщение не обязано содержать символ перевода строки и вам нужно всегда при выводе самим добавлять `\\n` в конце.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\n`LoggerGuard` должен быть классом, в конструкторе которого запоминается сообщение и поток, а в деструкторе оно печатается. Тогда для печати сообщения при любом выходе из функции достаточно будет создать локальную переменную типа `LoggerGuard`. Как бы мы ни покинули функцию, её деструктор будет вызван автоматически. Эта идея повсеместно используется в C\\+\\+.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nclass LoggerGuard {\nprivate:\n    std::string Message;\n    std::ostream\u0026 Out;\npublic:\n    LoggerGuard(const std::string\u0026 message, std::ostream\u0026 out = std::cout):\n        Message(message), Out(out)\n    {\n    }\n\n    ~LoggerGuard() {\n        Out \u003c\u003c Message \u003c\u003c \"\\n\";\n    }\n};\n```\n\nМы не можем скопировать поток вывода в новую переменную (у класса `std::ostream` нет конструктора копирования). Для этого мы запоминаем поток по ссылке. Так как ссылка должна быть сразу же проинициализирована при создании объекта, то мы пользуемся специальным синтаксисом для инициализации полей класса до входа в тело конструктора.\n\nДругой способ — хранить в классе указатель на поток:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\nclass LoggerGuard {\nprivate:\n    std::string Message;\n    std::ostream* Out;\npublic:\n    LoggerGuard(const std::string\u0026 message, std::ostream\u0026 out = std::cout) {\n        Message = message;\n        Out = \u0026out;\n    }\n\n    ~LoggerGuard() {\n        *Out \u003c\u003c Message \u003c\u003c \"\\n\";\n    }\n};\n```\n\n{% endcut %}\n\n----------\n\n## Параграф «Идиома RAII и умные указатели»\n\n### [Задача «Tree-2»](https://new.contest.yandex.ru/42114/problem?id=40119/2022_10_29/a5LFlLHdXT)\n\n{% cut \"Условие\" %}\n\nКоля пишет класс «Дерево». Узел дерева может хранить целое число, а также знает о своём родителе и о своих потомках. У узла есть функция `AddChild` для добавления потомка с заданным числовым значением, а также функция `Print` для красивой печати поддерева начиная с этого узла.\n\nВот что получилось у Коли:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nclass TreeNode {\nprivate:\n    int value;\n    TreeNode* root = nullptr;\n    std::vector\u003cTreeNode*\u003e children;\n\npublic:\n    TreeNode(int val): value(val) {\n    }\n\n    TreeNode(const TreeNode\u0026) = delete;\n    TreeNode\u0026 operator=(const TreeNode\u0026) = delete;\n\n    TreeNode* AddChild(int child_value) {\n        auto node = new TreeNode(child_value);\n        node-\u003eroot = this;\n        children.push_back(node);\n        return node;\n    }\n\n    void Print(int depth = 0) const {\n        for (int i = 0; i \u003c depth; ++i) {\n            std::cout \u003c\u003c \" \";\n        }\n        std::cout \u003c\u003c \"- \" \u003c\u003c value \u003c\u003c \"\\n\";\n        for (const auto\u0026 child : children) {\n            child-\u003ePrint(depth + 1);\n        }\n    }\n};\n```\n\nИспользоваться этот класс будет примерно так:\n\n```cpp\n#include \"tree.h\"\n\nint main() {\n    TreeNode root(1);\n\n    auto left_son = root.AddChild(10);\n    auto middle_son = root.AddChild(20);\n    auto right_son = root.AddChild(30);\n\n    left_son-\u003eAddChild(100);\n    left_son-\u003eAddChild(200);\n\n    root.Print();\n}\n```\n\nОднако эта работающая на первый взгляд тестовая программа падает, если её собрать с адресным санитайзером. Исправьте код класса `TreeNode`, чтобы решить эту проблему.\n\n#### Примечания\n\nСдайте в систему только код класса `TreeNode` без функции `main`. Подключите все необходимые для вашей реализации библиотеки.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВ решении Коли утекает память. В этом легко убедиться: узлы дерева создаются с помощью `new`, но нигде не удаляются.\n\nСамым простым решением было бы дописать деструктор в конце класса:\n\n```cpp\n~TreeNode() {\n    for (TreeNode* child : children) {\n        delete child;\n    }\n}\n```\n\nЭтот деструктор будет работать рекурсивно: вызов `delete child` приведёт к вызову деструктора для `child` и последующему освобождению памяти.\n\nРассмотрим другое решение, использующее `unique_ptr` вместо голого указателя для хранения дочерних узлов. Тут важно не перестараться: типичная ошибка новичка — обернуть в `unique_ptr` ещё и поле `root`. Здесь родитель владеет дочерними узлами, а не наоборот.\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nstruct TreeNode {\nprivate:\n    int value;\n    TreeNode* root = nullptr;\n    std::vector\u003cstd::unique_ptr\u003cTreeNode\u003e\u003e children;\n\npublic:\n    TreeNode(int val): value(val) {\n    }\n\n    TreeNode(const TreeNode\u0026) = delete;\n    TreeNode\u0026 operator=(const TreeNode\u0026) = delete;\n\n    TreeNode* AddChild(int child_value) {\n        children.push_back(std::make_unique\u003cTreeNode\u003e(child_value));\n        children.back()-\u003eroot = this;\n        return children.back().get();\n    }\n\n    void Print(int depth = 0) const {\n        for (int i = 0; i \u003c depth; ++i) {\n            std::cout \u003c\u003c \" \";\n        }\n        std::cout \u003c\u003c \"- \" \u003c\u003c value \u003c\u003c \"\\n\";\n        for (const auto\u0026 child : children) {\n            child-\u003ePrint(depth + 1);\n        }\n    }\n};\n```\n\nВ таком решении деструктор уже не нужен: в любом случае будет автоматически вызван деструктор для вектора `children`, который вызовет деструкторы для своих элементов типа `unique_ptr\u003cTreeNode\u003e`, которые, в свою очередь, и вызовут `delete`.\n\n{% endcut %}\n\n### [Задача «Monitor»](https://new.contest.yandex.ru/42114/problem?id=10033/2022_10_29/Ct9vZadj17)\n\n{% cut \"Условие\" %}\n\nВася разрабатывает новую систему для проведения олимпиад по программированию. Ему поручено разработать класс `Monitor`, хранящий результаты участников по каждой задаче. Этот класс должен уметь очень быстро возвращать текущие результаты отдельного участника, команды и общие результаты — ведь во время финального этапа на сервис будет приходить большая нагрузка. Каждый может наблюдать в мониторе только за интересующим его срезом — например, только за одной командой.\n\nВасе уже дан готовый класс `ParticipantResults`, описывающий результаты одного участника:\n\n```cpp\n#include \u003cmap\u003e\n#include \u003cstring\u003e\n\nstruct ParticipantResults {\n    std::string login;\n    std::string team;\n    std::map\u003cstd::string, int\u003e scores;  // номер задачи -\u003e баллы\n\n    // ...\n\n    ParticipantResults(const std::string\u0026 l, const std::string\u0026 te): login(l), team(te) {\n    }\n\n    ParticipantResults(const ParticipantResults\u0026) = delete;\n    ParticipantResults\u0026 operator = (const ParticipantResults\u0026) = delete;\n};\n```\n\nЕго изменить вы не можете. Класс может быть «тяжёлым» в инициализации и копировании. Чтобы не создавались лишние копии этого класса, его конструктор копирования и оператор присваивания вообще удалены.\n\nВ классе `Monitor`, который пишет Вася, должны быть следующие функции:\n\n1. `RegisterParticipant(const std::string\u0026 login, const std::string\u0026 team)` — регистрирует участника в указанной команде и возвращает (в каком-то виде) созданный для него `ParticipantResults`. Если участник с таким логином уже зарегистрирован, то выбрасывает исключение `std::invalid_argument`.\n\n2. `GetParticipantResults(const std::string\u0026 login)` — получает (в каком-то виде) `ParticipantResults` для данного участника. Если такого логина нет, выкидывает `std::out_of_range`. Должна быть константная версия (для отрисовки результатов) и неконстантная (для обновлений результатов после очередной посылки).\n\n3. `GetTeamResults(const std::string\u0026 team) const` — возвращает (в каком-то виде) контейнер из `ParticipantResults` для данной команды. Если такой команды нет, выкидывает `std::out_of_range`.\n\n4. `GetAllResults() const` — возвращает (в каком-то виде) контейнер всех результатов.\n\nИспользоваться этот класс будет примерно так:\n\n```cpp\n#include \"participant_results.h\"\n#include \"monitor.h\"\n\n#include \u003ciostream\u003e\n\nint main() {\n    Monitor monitor;\n\n    {\n        auto ptr = monitor.RegisterParticipant(\"Ivanov Ivan\", \"201-1\");\n        ptr-\u003escores[\"A\"] = 10;\n        ptr-\u003escores[\"B\"] = 8;\n    }\n\n    {\n        auto ptr = monitor.RegisterParticipant(\"Petrov Petr\", \"201-2\");\n        ptr-\u003escores[\"A\"] = 5;\n        ptr-\u003escores[\"C\"] = 10;\n    }\n\n    auto ptr = monitor.GetParticipantResults(\"Ivanov Ivan\");\n    ptr-\u003escores[\"Q\"] = 100;\n\n    // тут может быть аналогичный вызов monitor.GetTeamResults(team)\n    for (const auto\u0026 result : monitor.GetAllResults()) {\n        std::cout \u003c\u003c result-\u003elogin \u003c\u003c \"\\t\" \u003c\u003c result-\u003eteam \u003c\u003c \"\\t\";\n        for (const auto\u0026 [problemId, score] : result-\u003escores) {\n            std::cout \u003c\u003c problemId \u003c\u003c \": \" \u003c\u003c score \u003c\u003c \"\\t\";\n        }\n        std::cout \u003c\u003c \"\\n\";\n    }\n}\n```\n\nВася решил, что будет хранить вектор указателей на результаты для каждой команды и общие результаты. Указатели позволят ему сделать результаты «общими» в каждом из этих векторов и не составлять такие векторы заново при каждом вызове функций `GetTeamResults` или `GetAllResults`. Вот заготовка Васи:\n\n```cpp\n#include \u003cmap\u003e\n#include \u003cstdexcept\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nclass Monitor {\nprivate:\n    // удобные псевдонимы типов для краткости:\n    using Ptr = ParticipantResults*;\n    using ConstPtr = const ParticipantResults*;\n\n    std::map\u003cstd::string, Ptr\u003e byParticipant;\n    std::map\u003cstd::string, std::vector\u003cConstPtr\u003e\u003e byTeam;\n    std::vector\u003cConstPtr\u003e allResults;\n\npublic:\n    Monitor() = default;\n    Monitor(const Monitor\u0026) = delete;\n    Monitor\u0026 operator=(const Monitor\u0026) = delete;\n\n    Ptr RegisterParticipant(const std::string\u0026 login, const std::string\u0026 team) {\n        if (byParticipant.contains(login)) {\n            throw std::invalid_argument(\"Participant is already registered\");\n        }\n        // Добавить новую запись об участнике и вернуть её\n    }\n\n    Ptr GetParticipantResults(const std::string\u0026 login) {\n        return byParticipant.at(login);\n    }\n\n    ConstPtr GetParticipantResults(const std::string\u0026 login) const {\n        return byParticipant.at(login);\n    }\n\n    std::vector\u003cConstPtr\u003e GetTeamResults(const std::string\u0026 team) const {\n        return byTeam.at(team);\n    }\n\n    std::vector\u003cConstPtr\u003e GetAllResults() const {\n        return allResults;\n    }\n};\n```\n\nСдайте свою версию класса `Monitor`. Вам нужно дописать функцию `RegisterParticipant` и, если потребуется, ещё что-то. Вы можете выбрать реализацию Васи, а можете заменить её на свою, если хотите.\n\n#### Примечания\n\nВ вашей программе не должно быть функции `main`. Сдайте в систему только код класса `Monitor`. Подключите необходимые заголовочные файлы. Класс `ParticipantResults` подключать или объявлять не нужно: мы его подключим сами. Напоминаем, что обычный указатель можно всегда передать туда, где ожидается указатель на константу, но не наоборот.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nЗаметим сразу, что необходимые исключения из функций `GetParticipantResults` и `GetTeamResults` и так уже пробрасываются: при отсутствии ключа `std::map::at` сгенерирует исключение `std::out_of_range`. Поэтому никаких проверок тут дописывать не надо.\n\nСамое простое решение — создавать объекты класса `ParticipantResults` в динамической памяти и класть в контейнеры указатели.\n\n```cpp\nPtr RegisterParticipant(const std::string\u0026 login, const std::string\u0026 team) {\n    if (byParticipant.contains(login)) {\n        throw std::invalid_argument(\"Participant is already registered\");\n    }\n\n    ParticipantResults* ptr = new ParticipantResults(login, team);\n    allResults.push_back(ptr);\n    byParticipant[login] = ptr;\n    byTeam[team].push_back(ptr);\n}\n```\n\nПри таком подходе получится утечка памяти, так как деструктор вектора `allResults` ничего не будет делать с голыми указателями. Поэтому здесь необходимо реализовать ещё и свой собственный деструктор:\n\n```cpp\n~Monitor() {\n    for (auto ptr : allResults) {\n        delete ptr;\n    }\n}\n```\n\nБолее правильное и безопасное решение — использовать умные указатели. Так как на один и тот же объект `ParticipantResults` мы будем ссылаться из разных мест, то `std::unique_ptr` нам не подойдёт, и нужно использовать `std::shared_ptr` (не забудем подключить заголовочный файл `\u003cmemory\u003e`). Меняем псевдонимы типов `Ptr` и `ConstPtr`:\n\n```cpp\nusing Ptr = std::shared_ptr\u003cParticipantResults\u003e;\nusing ConstPtr = std::shared_ptr\u003cconst ParticipantResults\u003e;\n```\n\nВажно не спутать умный указатель на константу и `const std::shared_ptr\u003cParticipantResults\u003e`.\n\nДописываем функцию `RegisterParticipant`:\n\n```cpp\nPtr RegisterParticipant(const std::string\u0026 login, const std::string\u0026 team) {\n    if (byParticipant.contains(login)) {\n        throw std::invalid_argument(\"Participant is already registered\");\n    }\n\n    Ptr ptr = std::make_shared\u003cParticipantResults\u003e(login, team);\n    allResults.push_back(ptr);\n    byParticipant[login] = ptr;\n    byTeam[team].push_back(ptr);\n    return ptr;\n}\n```\n\nВсю работу по очистке памяти `shared_ptr` сделает за нас, поэтому деструктор тут не нужен. Когда объект типа `Monitor` будет умирать, то будут автоматически вызваны деструкторы вектора и `map`'ов, каждый из которых позовёт деструктор для хранящихся там `shared_ptr`. Деструктор `shared_ptr` будет уменьшать счётчик ссылок на объект, и когда этот счётчик дойдёт до нуля — автоматически вызовет `delete`.\n\n{% endcut %}\n\n### [Задача «Снова жизнь объекта»](https://new.contest.yandex.ru/42114/problem?id=40119/2022_10_29/UTssfKUrg9)\n\n{% cut \"Условие\" %}\n\nВам дан класс `A` и функция `main()`:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmemory\u003e\n\nclass A {\npublic:\n    A(int x) {\n        std::cout \u003c\u003c \"Constructor(int): \" \u003c\u003c x \u003c\u003c \"\\n\";\n    }\n    A(const A\u0026) {\n        std::cout \u003c\u003c \"Copy constructor\\n\";\n    }\n    virtual ~A() {\n        std::cout \u003c\u003c \"Destructor\\n\";\n    }\n    virtual void foo() const {\n        std::cout \u003c\u003c \"A::foo()\\n\";\n    }\n};\n\n#include \"your_code.h\"\n\nint main() {\n    std::unique_ptr\u003cA\u003e ptr(new B);\n    ptr-\u003efoo();\n}\n```\n\nНапишите такой код класса `B`, чтобы функция `main()` вывела бы сообщения:\n\n```\nConstructor(int): 42\nConstructor(int): 17\nA::foo()\nDestructor\nDestructor\n```\n\n#### Примечания\n\nНе пытайтесь вывести нужный текст с помощью непосредственной печати: мы при проверке всё равно заменяем отладочные сообщения в классе на свои.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nИз строчки `std::unique_ptr\u003cA\u003e ptr(new B)` становится понятно, что тип `B*` должен приводиться к типу `A*`. Это возможно, если, например, `B` является наследником класса `A`.\n\nЕщё мы видим, что при инициализации объекта типа `B` должны сконструироваться два объекта типа `A` с аргументами 42 и 17. Про один из них мы знаем: это должен быть подобъект базового класса, который неявно вкладывается в `B` при наследовании. А вот второй объект можно принести, например, в виде композиции. В конструкторе класса `B` важно проинициализировать объекты нужными аргументами: сначала подобъект базового класса, затем — поле.\n\n```cpp\nclass B: public A {\n    A field;\npublic:\n    B(): A(42), field(17) {\n    }\n};\n```\n\n{% endcut %}\n\n### [Задача «Зоопарк»](https://new.contest.yandex.ru/42114/problem?id=40119/2022_10_29/dMJINfkYd0)\n\n{% cut \"Условие\" %}\n\nВы работаете с иерархией классов, описывающих животных:\n\n```cpp\n#include \u003cstring\u003e\n\nclass Animal {\npublic:\n    virtual std::string Voice() const {\n        return \"Not implemented yet\";\n    }\n    virtual ~Animal() {\n    }\n};\n\nclass Tiger: public Animal {\n    std::string Voice() const override {\n        return \"Rrrr\";\n    }\n};\n\nclass Wolf: public Animal {\n    std::string Voice() const override {\n        return \"Wooo\";\n    }\n};\n\nclass Fox: public Animal {\n    std::string Voice() const override {\n        return \"Tyaf\";\n    }\n};\n```\n\nВам нужно определить тип `Zoo`, представляющий из себя набор различных животных, и написать две функции: `Zoo CreateZoo()` и `void Process(const Zoo\u0026 zoo)`.\n\nФункция `CreateZoo` должна читать слова из стандартного ввода. Если на вход поступают слова `Tiger`, `Wolf` или `Fox`, она должна поместить соответствующего зверя в зоопарк. Если на вход поступает другое слово, она должна прекратить чтение и сгенерировать исключение `std::runtime_error`.\n\nФункция `Process` должна перебрать всех зверей в зоопарке в порядке создания и напечатать для каждого из них результат работы виртуальной функции `Voice`.\n\nВаш коллега написал вот такой код, но он почему-то не работает:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstdexcept\u003e\n#include \u003cvector\u003e\n\n#include \"animals.h\"\n\nusing Zoo = std::vector\u003cAnimal\u003e;\n\nZoo CreateZoo() {\n    Zoo zoo;\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        if (word == \"Tiger\") {\n            Tiger t;\n            zoo.push_back(t);\n        } else if (word == \"Wolf\") {\n            Wolf w;\n            zoo.push_back(w);\n        } else if (word == \"Fox\") {\n            Fox f;\n            zoo.push_back(f);\n        } else\n            throw std::runtime_error(\"Unknown animal!\");\n    }\n    return zoo;\n}\n\nvoid Process(const Zoo\u0026 zoo) {\n    for (const auto\u0026 animal : zoo) {\n        std::cout \u003c\u003c animal.Voice() \u003c\u003c \"\\n\";\n    }\n}\n```\n\nИсправьте его и сдайте в систему.\n\n#### Примечания\n\nКод классов из файла `animals.h` переписывать не надо, просто подключите заголовочный файл `animals.h`. Обратите внимание, что в нашей версии файла `animals.h` голоса зверей могут отличаться от того, что приведено в примере. Разумеется, в вашей программе не должно быть утечек памяти. Экземпляр каждого зверя надо создавать ровно один раз (если вам на входе даны два волка, то надо создать ровно два объекта типа `Wolf`, не больше и не меньше).\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДавайте поймём, почему использовать `std::vector\u003cAnimal\u003e` в качестве `Zoo` неправильно. Вектор хранит копии элементов, которые мы туда кладём. Эти копии будут иметь базовый тип `Animal` и ничего не будут знать про исходный тип объекта.\n\nПоэтому в конструкции\n\n```cpp\nTiger t;\nzoo.push_back(t);\n```\n\nбудет взята так называемая *срезка*: от тигра скопируется только подобъект базового класса `Animal`. Конечно же, вызов `Voice` для таких элементов вектора приведёт к вызову функции `Animal::Voice`, которая напечатает `Not implemented yet`.\n\nИспользовать вектор ссылок нельзя, так как ссылка с самого начала должна быть к чему-то привязана. Можно воспользоваться вектором указателей на `Animal` и создавать объекты в динамической памяти. Но тогда придётся вручную следить за их временем жизни. Самым правильным вариантом было бы создать вектор умных указателей `std::unique_ptr\u003cAnimal\u003e`: при уничтожении самого вектора автоматически вызвались бы деструкторы для его элементов, которые освободили бы занимаемую динамическую память.\n\nДля создания нового объекта в динамической памяти и оборачивания указателя на него в `unique_ptr` удобно использовать функцию [`make_unique`](https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique):\n\n```cpp\n#include \u003cstring\u003e\n#include \u003ciostream\u003e\n#include \u003cmemory\u003e\n#include \u003cstdexcept\u003e\n#include \u003cvector\u003e\n\n#include \"animals.h\"\n\nusing Zoo = std::vector\u003cstd::unique_ptr\u003cAnimal\u003e\u003e;\n\nZoo CreateZoo() {\n    Zoo zoo;\n    std::string word;\n    while (std::cin \u003e\u003e word) {\n        if (word == \"Tiger\") {\n            zoo.push_back(std::make_unique\u003cTiger\u003e());\n        } else if (word == \"Wolf\") {\n            zoo.push_back(std::make_unique\u003cWolf\u003e());\n        } else if (word == \"Fox\") {\n            zoo.push_back(std::make_unique\u003cFox\u003e());\n        } else {\n            throw std::runtime_error(\"Unknown animal!\");\n        }\n    }\n    return zoo;\n}\n\nvoid Process(const Zoo\u0026 zoo) {\n    for (const auto\u0026 animal : zoo) {\n        std::cout \u003c\u003c animal-\u003eVoice() \u003c\u003c \"\\n\";\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Выражение»](https://new.contest.yandex.ru/42114/problem?id=40119/2022_10_29/rTIIXS6kyk)\n\n{% cut \"Условие\" %}\n\nПредставим арифметическое выражение, содержащее числовые константы и операции сложения и умножения, в виде дерева. В листьях этого дерева будут находиться константы, а в промежуточных узлах — операции. Вам дан абстрактный базовый класс `Expression`, представляющий из себя такое дерево:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n\nclass Expression {\npublic:\n    virtual int Evaluate() const = 0;\n    virtual std::string ToString() const = 0;\n    virtual ~Expression() {}\n};\n\nusing ExpressionPtr = std::shared_ptr\u003cExpression\u003e;\n\n#include \"your_code.h\"\n\nint main() {\n    ExpressionPtr ex1 = Sum(Product(Const(3), Const(4)), Const(5));\n    std::cout \u003c\u003c ex1-\u003eToString() \u003c\u003c \"\\n\";  // 3 * 4 + 5\n    std::cout \u003c\u003c ex1-\u003eEvaluate() \u003c\u003c \"\\n\";  // 17\n\n    ExpressionPtr ex2 = Product(Const(6), ex1);\n    std::cout \u003c\u003c ex2-\u003eToString() \u003c\u003c \"\\n\";  // 6 * (3 * 4 + 5)\n    std::cout \u003c\u003c ex2-\u003eEvaluate() \u003c\u003c \"\\n\";  // 102\n}\n```\n\nВам надо унаследовать от него классы-наследники для констант, операции сложения и операции умножения так, чтобы приведённый в функции `main` код (и аналогичные примеры) заработали.\n\nФункции базового класса `Evaluate` и `ToString` должны переопределяться в классах-наследниках. `Evaluate` должна вычислять выражение, а `ToString` возвращать его текстовую запись (как в примере). При умножении на сумму запись суммы должна браться в скобки. Никаких особых специальных правил оформления нулевых или единичных множителей писать не нужно.\n\n#### Примечания\n\nКроме классов-наследников, Вам надо будет определить функции `Const`, `Sum` и `Product`, которые используются в функции `main` в примере. Лишних копирований дерева быть не должно: мы будем проверять, что создано ровно столько экземпляров классов, сколько требуется для построения дерева. Разумеется, утечек памяти тоже не должно быть.\n\nДля преобразования чисел в строки используете функцию `std::to_string`.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\n```cpp\nclass ConstExpr: public Expression {\nprivate:\n    int value;\n\npublic:\n    ConstExpr(int v): value(v) {}\n\n    int Evaluate() const override {\n        return value;\n    }\n    std::string ToString() const override {\n        return std::to_string(value);\n    }\n};\n\nclass BinaryOperation: public Expression {\nprotected:\n    ExpressionPtr left;\n    ExpressionPtr right;\n\npublic:\n    BinaryOperation(ExpressionPtr l, ExpressionPtr r): left(l), right(r) {}\n};\n\nclass SumExpr: public BinaryOperation {\npublic:\n    SumExpr(ExpressionPtr l, ExpressionPtr r): BinaryOperation(l, r) {}\n\n    int Evaluate() const override {\n        return left-\u003eEvaluate() + right-\u003eEvaluate();\n    }\n\n    std::string ToString() const override {\n        return left-\u003eToString() + \" + \" + right-\u003eToString();\n    }\n};\n\nclass ProductExpr: public BinaryOperation {\nprivate:\n    static std::string Parentheses(ExpressionPtr ex) {\n        if (dynamic_cast\u003cSumExpr*\u003e(ex.get())) {\n            return std::string(\"(\") + ex-\u003eToString() + \")\";\n        } else {\n            return ex-\u003eToString();\n        }\n    }\npublic:\n    ProductExpr(ExpressionPtr l, ExpressionPtr r): BinaryOperation(l, r) {}\n\n    int Evaluate() const override {\n        return left-\u003eEvaluate() * right-\u003eEvaluate();\n    }\n\n    std::string ToString() const override {\n        return Parentheses(left) + \" * \" + Parentheses(right);\n    }\n};\n\nExpressionPtr Const(int x) {\n    return ExpressionPtr(new ConstExpr(x));\n}\n\nExpressionPtr Sum(ExpressionPtr l, ExpressionPtr r) {\n    return ExpressionPtr(new SumExpr(l, r));\n}\n\nExpressionPtr Product(ExpressionPtr l, ExpressionPtr r) {\n    return ExpressionPtr(new ProductExpr(l, r));\n}\n```\n\nГлавная сложность здесь — понять, когда надо ставить скобки вокруг суммы в произведении. Для этого надо понять, является ли подвыражение именно суммой. К сожалению, базовый класс `Expression` нам недоступен для изменений (иначе можно было бы внести в него виртуальную функцию `NeedParantheses`). Поэтому можно воспользоваться конструкцией [`dynamic_cast`](https://en.cppreference.com/w/cpp/language/dynamic_cast), которая в runtime пытается привести указатель на базовый класс к указателю на производный тип (и возвращает `nullptr`, если это невозможно).\n\nЭта конструкция работает только для иерархий с виртуальными функциями в базовом классе. В нашем примере она используется в функции `ProductExpr::Parentheses`.\n\n{% endcut %}\n\n### [Задача «Документы»](https://new.contest.yandex.ru/42114/problem?id=40119/2022_10_29/So72XU5lPd)\n\n{% cut \"Условие\" %}\n\nВам дан класс Document, от которого унаследованы два класса( `PlainTextDocument` и `HTMLDocument`), определён тип `DocumentCollection`, и написаны две функции (`AddDocument` и `PrintCollection`):\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nclass Document {\nprivate:\n    const std::string Content;\npublic:\n    Document(const std::string\u0026 s): Content(s) {}\n    void Save() const {\n    }\n};\n\nclass PlainTextDocument: public Document {\npublic:\n    PlainTextDocument(const std::string\u0026 s): Document(s) {}\n    virtual void Save() {\n        std::cout \u003c\u003c Content \u003c\u003c \"\\n\";\n    }\n};\n\nclass HTMLDocument: public Document {\npublic:\n    HTMLDocument(const std::string\u0026 s): Document(s) {}\n    virtual void Save() {\n        std::cout \u003c\u003c \"\u003cHTML\u003e\u003cBODY\u003e\" \u003c\u003c Content \u003c\u003c \"\u003c/BODY\u003e\u003c/HTML\u003e\\n\";\n    }\n};\n\nusing DocumentCollection = std::vector\u003cDocument\u003e;\n\nvoid AddDocument(const std::string\u0026 content, const std::string\u0026 type, DocumentCollection\u0026 collection) {\n    if (type == \"plain\") {\n        collection.push_back(PlainTextDocument(content));\n    } else if (type == \"html\") {\n        collection.push_back(HTMLDocument(content));\n    }\n}\n\nvoid PrintCollection(const DocumentCollection\u0026 collection) {\n    for (const auto\u0026 doc : collection) {\n        doc.Save();\n    }\n}\n```\n\nОднако этот код не компилируется, а если исправить ошибки компиляции, то эти функции почему-то работают совсем не так, как задумано. Вам надо исправить этот код. Требования к нему такие:\n\n* Иерархия классов должна сохраниться: `PlainTextDocument` и `HTMLDocument` должны быть наследникамии `Document`.\n\n* Функциия `Save` в классе `Document` должна вести себя полиморфно.\n\n* Тип `DocumentCollection` должен быть вектором (какого-то типа).\n\n* Сигнатуры функций `AddDocument` и `PrintCollection` должны сохраниться. Второй параметр функции `AddDocument` может принимать значения `\"plain\"` или `\"html\"`.\n\n* Утечек памяти быть не должно.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nДля начала найдём ошибки: `virtual` ставится у переопределяемого метода в родительском классе, также у родительского класса должен быть виртуальный деструктор.\n\nЕсли мы хотим хранить объекты разных типов в одном контейнере, то надо хранить указатель на их родительский класс. Воспользуемся умным указателем `std::unique_ptr`, в таком случае нам дополнительно не надо думать про удаление объектов из нашего вектора $\\Rightarrow$ и утечек не будет:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\nclass Document {\nprotected:\n    const std::string Content;\npublic:\n    Document(const std::string\u0026 s): Content(s) {}\n    virtual void Save() const {}\n    virtual ~Document() {}\n};\n\nclass PlainTextDocument: public Document {\npublic:\n    PlainTextDocument(const std::string\u0026 s): Document(s) {}\n    void Save() const override {\n        std::cout \u003c\u003c Content \u003c\u003c \"\\n\";\n    }\n};\n\nclass HTMLDocument: public Document {\npublic:\n    HTMLDocument(const std::string\u0026 s): Document(s) {}\n    void Save() const override {\n        std::cout \u003c\u003c \"\u003cHTML\u003e\u003cBODY\u003e\" \u003c\u003c Content \u003c\u003c \"\u003c/BODY\u003e\u003c/HTML\u003e\\n\";\n    }\n};\n\nusing DocumentCollection = std::vector\u003cstd::unique_ptr\u003cDocument\u003e\u003e;\n\nvoid AddDocument(const std::string\u0026 content, const std::string\u0026 type, DocumentCollection\u0026 collection) {\n    if (type == \"plain\") {\n        collection.emplace_back(new PlainTextDocument(content));\n    } else if (type == \"html\") {\n        collection.emplace_back(new HTMLDocument(content));\n    }\n}\n\nvoid PrintCollection(const DocumentCollection\u0026 collection) {\n    for (const auto\u0026 doc : collection) {\n        doc-\u003eSave();\n    }\n}\n```\n\n{% endcut %}\n\n### [Задача «Коварная матрица»](https://new.contest.yandex.ru/42114/problem?id=40119/2022_10_29/X2oDBKimQ3)\n\n{% cut \"Условие\" %}\n\nВаш друг пишет свою реализацию шаблонного класса «Матрица»:\n\n```cpp\n#include \u003ciostream\u003e\n\ntemplate \u003ctypename T\u003e\nclass Matrix {\nprivate:\n    T** data;\n    size_t rows, columns;\n\npublic:\n    Matrix(size_t m, size_t n): rows(m), columns(n) {\n        data = new T * [rows];\n        size_t i = 0;\n        try {\n            for (; i != rows; ++i) {\n                data[i] = new T[columns];\n            }\n        } catch (...) {\n            for (size_t k = 0; k != i; ++k) {\n                delete [] data[k];\n            }\n            delete [] data;\n            throw;\n        }\n    }\n\n    T* operator [](size_t i) {\n        return data[i];\n    }\n    const T* operator [](size_t i) const {\n        return data[i];\n    }\n\n    size_t GetRows() const {\n        return rows;\n    }\n\n    size_t GetColumns() const {\n        return columns;\n    }\n\n    ~Matrix() {\n        for (size_t i = 0; i != rows; ++i) {\n            delete [] data[i];\n        }\n        delete [] data;\n    }\n\n    // Сюда можно будет вставить ваш код\n    #include \"your_code.h\"\n};\n\ntemplate \u003ctypename T\u003e\nMatrix\u003cT\u003e FillMatrix(size_t m, size_t n) {\n    Matrix\u003cT\u003e A(m, n);\n    for (size_t i = 0; i != m; ++i) {\n        for (size_t j = 0; j != n; ++j) {\n            A[i][j] = i + j;\n        }\n    }\n    return A;\n}\n\ntemplate \u003ctypename T\u003e\nstd::ostream\u0026 operator \u003c\u003c (std::ostream\u0026 out, const Matrix\u003cT\u003e\u0026 A) {\n    for (size_t i = 0; i != A.GetRows(); ++i) {\n        for (size_t j = 0; j != A.GetColumns(); ++j) {\n            out \u003c\u003c A[i][j] \u003c\u003c \" \";\n        }\n        out \u003c\u003c \"\\n\";\n    }\n    return out;\n}\n```\n\nПравда, он зачем-то выбрал очень странную реализацию матрицы на основе двумерного динамического массива, а не вектора. Однако вы можете быть уверенными, что инициализацию и освобождение динамической памяти для отдельно взятой матрицы ваш друг написал правильно.\n\nПока в классе есть только конструктор, деструктор и оператор `[]`. Ещё ваш друг написал функцию `FillMatrix`, возвращающую матрицу, заполненную особым образом, а также оператор `\u003c\u003c` для печати матрицы на экране.\n\nНо почему-то вот такой простой код не работает:\n\n```cpp\n#include \"matrix.h\"\n#include \u003ciostream\u003e\n\nint main() {\n    size_t m, n;\n    std::cin \u003e\u003e m \u003e\u003e n;\n    Matrix\u003cint\u003e A(m, n);\n    // ...\n    A = FillMatrix\u003cint\u003e(m, n);\n    std::cout \u003c\u003c A \u003c\u003c \"\\n\";\n}\n```\n\nВам нужно добиться, чтобы он заработал. Вы можете только дописывать что-то к классу `Matrix` в месте `#include \"your_code.h\"`.\n\n#### Примечания\n\nМы компилируем эту программу с дополнительной опцией компилятора %%-fno-elide-constructors%%, которая отменяет copy elision и требует вызова конструктора при возврате значения из функции.\n\n{% endcut %}\n\n{% cut \"Решение\" %}\n\nВ классе `Matrix` не написан оператор присваивания. Поэтому компилятор неявно предоставил по умолчанию свою версию этого оператора. Эта версия просто копирует все поля как есть. Она могла бы выглядеть так:\n\n```cpp\nMatrix\u0026 operator = (const Matrix\u0026 other) {\n    data = other.data;\n    rows = other.rows;\n    columns = other.columns;\n    return *this;\n}\n```\n\nВидно, что здесь происходит неглубокое копирование: копируется просто сам указатель `data`, но не копируются сами данные.\n\nЭтот оператор вызывается в строке `A = FillMatrix\u003cint\u003e(m, n);`. В результате получается, что два объекта типа `Matrix\u003cint\u003e` содержат указатель на одни и те же данные: это временный объект с результатом работы функции, и изменённый `A`. Каждый из них уверен, что является ответственным за удаление памяти. Сначала умирает временный объект и в своём деструкторе освобождает память, на которую ссылается `data`. Далее либо `A` попытается использовать эту память, либо сам умрёт и попытается освободить её повторно. В любом случае это приведёт к неопределённому поведению программы.\n\nРассмотрим способы решения проблемы.\n\n1. Можно было бы хранить данные матрицы в подходящем контейнере (например, векторе векторов). Тогда при копировании или присваивании матрицы будет вызван конструктор копирования вектора, который сделает глубокую копию. Этот способ предпочтителен, но мы не можем им воспользоваться: по условию задачи мы можем лишь дописывать новые функции в классе.\n\n2. Можно было бы сделать глубокие конструктор копирования и оператор присваивания, выделяющие память под новую матрицу и копирующие туда элементы старой матрицы. На самом деле это сложно и не нужно, потому что есть третий способ.\n\n3. Можно запретить копирование и присваивание матриц в общем случае! Но чтобы пример заработал, можно разрешить его только для случаев, когда справа стоит временный (безымянный) объект. Например, таковым является результат, возвращаемый из функции. Такой объект живёт только пока вычисляется выражение с присваиванием, а потом сразу умирает. Поэтому у него можно просто отобрать владение матрицей, оставив его в согласованном, но пустом состоянии.\n\nНапишем реализацию третьего способа. Нам было бы достаточно определить только оператор присваивания для временного объекта, но всегда следует переопределять в паре с ним и конструктор.\n\nНачнём с конструктора. Запрещаем автогенерацию конструктора копирования в общем случае, но делаем особую версию для случая, когда на вход приходит временный объект:\n\n```cpp\nMatrix(const Matrix\u0026) = delete;\n\nMatrix(Matrix\u0026\u0026 other) {\n    data = other.data;\n    rows = other.rows;\n    columns = other.columns;\n    other.data = nullptr;\n    other.rows = 0;\n    other.columns = 0;\n}\n```\n\nТеперь сделаем то же самое для оператора присваивания. В отличие от конструктора, здесь левая часть (текущий объект) уже существует. Проще всего будет обменяться содержимым с временным объектом. Тогда этот временный объект в своём деструкторе как раз похоронит эти данные.\n\n```cpp\nMatrix\u0026 operator = (const Matrix\u0026) = delete;\n\nMatrix\u0026 operator = (Matrix\u0026\u0026 other) {\n    std::swap(data, other.data);\n    std::swap(rows, other.rows);\n    std::swap(columns, other.columns);\n    return *this;\n}\n```\n\n#### Заметки\n\nВ этой задаче прошло бы и решение с глубоким копированием данных. Но его дольше писать, и в нём проще ошибиться.\n\nДавайте разберёмся, например, почему приведённый в условии конструктор выглядит так сложно. С аналогичными сложностями придётся столкнуться и при написании глубокого конструктора копирования.\n\nПочему, например, конструктор из условия не написан просто так?\n\n```cpp\nMatrix(size_t m, size_t n): rows(m), columns(n) {\n    data = new T * [rows];\n    for (size_t i = 0; i != rows; ++i) {\n        data[i] = new T[columns];\n    }\n}\n```\n\nЕсли из конструктора вылетает исключение, то объект не считается созданным, и к нему не будет применяться деструктор (но он будет применяться ко всем полям создаваемого объекта). Все выделенные к этому моменту ресурсы код конструктора должен подчистить сам. Исключение может произойти в следующих местах:\n\n1. Его может сгенерировать `new`, если не хватит памяти;\n\n2. Его может сгенерировать конструктор неизвестного нам типа `T`, который вызывается внутри `new`;\n\nВ первом `new` проблем не возникает: сам `new` действует как транзакция, и если в нём произойдёт сбой, то утечки не будет. Проблема будет, если сбой произойдёт в последующих `new`. Память, выделенную ранее, придётся подчистить, а исключение перебросить дальше, чтобы объект матрицы не был создан. Это делается в блоке `catch` просто с помощью `throw`:\n\n```cpp\nMatrix(size_t m, size_t n): rows(m), columns(n) {\n    data = new T * [rows];\n    size_t i = 0;\n    try {\n        for (; i != rows; ++i) {\n            data[i] = new T[columns];\n        }\n    } catch (...) {\n        for (size_t k = 0; k != i; ++k) {\n            delete [] data[k];\n        }\n        delete [] data;\n        throw;\n    }\n}\n```\n\nЗаметим, что проблема возникает из-за того, что наш класс владеет сразу несколькими низкоуровневыми массивами. Идиома RAII предлагает каждый из таких ресурсов оборачивать в отдельный класс-обёртку. Нам в качестве такой обёртки подошел бы просто `std::vector`.\n\n{% endcut %}\n\n----------"])</script><script nonce="">self.__next_f.push([1,"70:T1a5f,"])</script><script nonce="">self.__next_f.push([1,"В конце некоторых параграфов вы можете встретить задачи, которые помогут вам лучше разобраться в теме. В этом приложении мы расскажем, как работать с системой их проверки. Спойлер: это не сложно, но есть нюансы. \n\nДавайте разбираться! \n\n## Интерфейс\n\nСамое главное: мы рекомендуем решать задачи с десктопных устройств. Это удобнее, плюс в мобильной версии некоторые элементы могут отображаться некорректно.\n\nДалее — поговорим об интерфейсе. При переходе внутрь задачи вы увидите в левой части экрана описание, а в правой — поле редактора, в котором можно писать код решения.\n\n![Python](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_6_fcc14cc482.webp)\n\nОписание задачи включает:\n\n- Условие.\n\n- Формат ввода/вывода. В этом блоке описаны данные, аналогичные тем, что будут переданы в вашу программу при автоматической проверке задания. Конкретный пример входных данных можно посмотреть в блоке «Пример» (о нём далее).\n\n- Пример. Здесь показаны результаты, которые должна выдать программа при правильной обработке данных.\n\n- Ограничения по памяти и времени, в которые должна уложиться ваша программа.\n\n![Python_hb_screenshot_7.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_7_ca72f38eb8.webp)\n\nОтправить решение можно через поле редактора, либо загрузив файл с вашей программой.\n\n![Python_hb_screenshot_8.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_8_86d233ea2b.webp)\n\nПосле отправки решения система обработает ваш код и начнёт тестировать его на различных вариантах входных данных, сопоставляя ожидаемый эталонный вывод с результатами работы вашего кода.\n\nПары входных и выходных тестовых данных называются тестами.\n\nПроверка решения может занять некоторое время, отследить прогресс проверки вы можете на вкладке «Отправленные решения».\n\n![Python_hb_screenshot_9.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_9_9d96765712.webp)\n\nВ зависимости от результата проверки вы увидите статус:\n\n- Решена полностью — ваше решение успешно скомпилировалось и прошло все тесты.\n- Решена неверно — код не компилируется или не проходит тестирование.\n\n## Как понять в чем ошибка?\nЧтобы узнать детали проверки, нужно перейти внутрь теста:\n\n![Python_hb_screenshot_10.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_10_faa5910cbc.webp)\n\nЗдесь вы увидите вердикт по решению. Вот некоторые варианты вердиктов:\n\n1. **OK** — решение прошло все тесты.\n\n2. **CE (Compilation Error)** — ошибка компиляции, в программе допущена синтаксическая или семантическая ошибка.\n\nВ этом случае разобраться поможет отчёт об ошибке в блоке «Лог компиляции»:\n\n![Python_hb_screenshot_11.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_11_3a9498dc89.webp)\n\nСистема подскажет, какого рода ошибка присутствует в коде, и в какой строке она находится.\n\n3. **WA (Wrong Answer)** — ваша программа выдала неправильный результат на одном из тестов.\n\nДля тестов из примеров отображается ввод, вывод вашей программы, вывод системы проверки ответа и правильный ответ. Это поможет с отладкой вашей программы.\n\n![Python_hb_screenshot_12.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_12_d37061f9ad.webp)\n\nМы не раскрываем другие тестовые данные. Попробуйте самостоятельно рассмотреть различные нетривиальные варианты входных данных и проверить, как на них отрабатывает ваше решение. Это поможет вам научиться тестировать свой код самостоятельно.\n\n4. **RE (Runtime Error)** — ошибка выполнения. Например, это может быть ошибка выхода за границы массива или необработанные исключения.\n\n5. **TL (Time Limit)** — на одном из тестов решение работает слишком долго.\n\n6. **ML (Memory Limit)** — на одном из тестов решение потребляет слишком много памяти.\n\nПодробный список ответов проверяющей системы можно посмотреть [здесь](https://contest.yandex.ru/errors).\n\nВ случае, если вы чувствуете, что вам необходима поддержка и взгляд со стороны, попробуйте обсудить задачу с участниками [комьюнити](https://t.me/handbook_cpp) хендбука.\n\nВот и всё! Надеемся, что эти советы помогут разобраться с системой проверки заданий. Желаем успехов в учёбе!"])</script><script nonce="">self.__next_f.push([1,"1c:[\"$\",\"$L57\",null,{\"bookSlug\":\"cpp\",\"articleSlug\":\"data-types\",\"children\":[\"$\",\"$L58\",null,{\"articleName\":\"2.2 Типы данных\",\"children\":[\"$\",\"$L59\",null,{\"chapters\":[{\"id\":24,\"Name\":\"1. Введение\",\"Articles\":[{\"Name\":\"cpp | 1.2 Введение\",\"Slug\":\"introduction\",\"createdAt\":\"2024-07-03T17:37:51.782Z\",\"updatedAt\":\"2026-01-10T12:07:11.010Z\",\"publishedAt\":\"2024-07-03T17:37:53.000Z\",\"ContestURL\":null,\"Lead\":\"Об\u0026nbsp;этом учебнике.\",\"Content\":\"$5a\",\"Title\":\"Введение\",\"LikesCount\":18,\"Quiz\":[{\"answers\":[{\"text\":\"C++ — это компилируемый язык со статической типизацией, созданный Бьярне Страуструпом в начале 1980-х как расширение C.\",\"generated_as_correct\":true},{\"text\":\"C++ — это скриптовый язык программирования, который был создан для веб-разработки и не имеет отношения к языку C.\",\"generated_as_correct\":false},{\"text\":\"C++ — это язык программирования, который используется для создания мобильных приложений и тесно связан с операционной системой Android.\",\"generated_as_correct\":false},{\"text\":\"C++ — это интерпретируемый язык программирования, разработанный для работы с базами данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое C++ и кто его разработал?\"},{\"answers\":[{\"text\":\"C++ — это компилируемый язык с ручным управлением памятью, в отличие от интерпретируемых языков типа Python.\",\"generated_as_correct\":true},{\"text\":\"C++ — это язык программирования, который похож на Python и другие интерпретируемые языки. Он не предоставляет возможности ручного управления памятью и использует компилятор для преобразования кода в байт-код.\",\"generated_as_correct\":false},{\"text\":\"C++ и интерпретируемые языки программирования, такие как Python, имеют разные подходы к обработке ошибок. В C++ ошибки могут быть обнаружены на этапе компиляции, в то время как в интерпретируемых языках они выявляются во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"C++ — это интерпретируемый язык, который автоматически управляет памятью, подобно Python.\",\"generated_as_correct\":false}],\"question\":\"Чем C++ отличается от интерпретируемых языков программирования, таких как Python?\"},{\"answers\":[{\"text\":\"Ручное управление памятью в C++ даёт программистам контроль над выделением и освобождением памяти, что позволяет оптимизировать ресурсы.\",\"generated_as_correct\":true},{\"text\":\"Ручное управление памятью в C++ автоматически выполняется компилятором, и программистам не нужно беспокоиться о выделении и освобождении памяти.\",\"generated_as_correct\":false},{\"text\":\"Ручное управление памятью в C++ связано с использованием специфических библиотек для работы с графикой и не влияет на процесс программирования в целом.\",\"generated_as_correct\":false},{\"text\":\"Ручное управление памятью в C++ усложняет процесс программирования и делает его менее эффективным.\",\"generated_as_correct\":false}],\"question\":\"Как возможности ручного управления памятью в C++ влияют на процесс программирования?\"},{\"answers\":[{\"text\":\"Компилируемый язык — это язык, где исходный код переводится в машинный код компилятором перед запуском программы.\",\"generated_as_correct\":true},{\"text\":\"Компилируемый язык программирования — это язык, который автоматически переводит исходный код в машинный код во время выполнения программы, без использования компилятора.\",\"generated_as_correct\":false},{\"text\":\"Компилируемый язык программирования связан с созданием алгоритмов для обработки данных и не влияет на скорость выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Компилируемый язык — это язык, который выполняет код построчно, как интерпретируемый язык.\",\"generated_as_correct\":false}],\"question\":\"Что такое компилируемый язык программирования?\"},{\"answers\":[{\"text\":\"Компилируемые языки преобразуют исходный код в машинный перед выполнением, обеспечивая более высокую производительность, в отличие от интерпретируемых языков.\",\"generated_as_correct\":true},{\"text\":\"Компилируемые языки программирования требуют перевода исходного кода в машинный код после каждого запуска программы, в то время как интерпретируемые языки выполняют код напрямую без предварительной компиляции.\",\"generated_as_correct\":false},{\"text\":\"Компилируемые языки программирования используют специальные библиотеки для работы с данными, в то время как интерпретируемые языки полагаются на встроенные функции для обработки информации.\",\"generated_as_correct\":false},{\"text\":\"Компилируемые языки выполняют исходный код построчно во время работы программы, в отличие от интерпретируемых языков, которые предварительно переводят код в машинный.\",\"generated_as_correct\":false}],\"question\":\"Чем компилируемые языки отличаются от интерпретируемых с точки зрения процесса выполнения программы?\"},{\"answers\":[{\"text\":\"Компилируемые языки быстрее, так как код преобразуется в машинный заранее, а не выполняется построчно во время работы программы.\",\"generated_as_correct\":true},{\"text\":\"Компилируемые языки работают медленнее интерпретируемых, потому что каждый раз при запуске программы требуется заново компилировать исходный код в машинный, что занимает дополнительное время.\",\"generated_as_correct\":false},{\"text\":\"Компилируемые языки используют специальные алгоритмы для шифрования исходного кода, что делает их более безопасными по сравнению с интерпретируемыми языками, но не обязательно более производительными.\",\"generated_as_correct\":false},{\"text\":\"Компилируемые языки медленнее интерпретируемых, поскольку требуют дополнительной компиляции при каждом запуске программы.\",\"generated_as_correct\":false}],\"question\":\"Почему компилируемые языки обеспечивают более высокую производительность по сравнению с интерпретируемыми языками?\"},{\"answers\":[{\"text\":\"Статическая типизация проверяет типы переменных на этапе компиляции.\",\"generated_as_correct\":true},{\"text\":\"Статическая типизация — это метод, позволяющий изменять типы переменных во время выполнения программы, что обеспечивает гибкость при работе с данными.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация относится к методам оптимизации кода, которые используются для улучшения производительности программ на этапе компиляции.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация проверяет типы переменных во время выполнения программы.\",\"generated_as_correct\":false}],\"question\":\"Что такое статическая типизация в языках программирования?\"},{\"answers\":[{\"text\":\"Статическая типизация проверяет типы переменных на этапе компиляции, предотвращая ошибки во время выполнения.\",\"generated_as_correct\":true},{\"text\":\"Статическая типизация предотвращает ошибки во время выполнения программы за счёт автоматической конвертации типов данных в процессе компиляции, что исключает возможность несовместимости типов.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация улучшает читаемость кода и облегчает его отладку, но не оказывает значительного влияния на предотвращение ошибок во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация определяет типы переменных во время выполнения программы, что помогает избежать ошибок.\",\"generated_as_correct\":false}],\"question\":\"Почему статическая типизация помогает предотвратить ошибки во время выполнения программы?\"},{\"answers\":[{\"text\":\"Статическая типизация проверяет типы переменных на этапе компиляции, предотвращая ошибки во время выполнения программы.\",\"generated_as_correct\":true},{\"text\":\"Статическая типизация — это метод, при котором типы переменных определяются автоматически во время компиляции без возможности их явного указания программистом, что упрощает процесс разработки по сравнению с динамической типизацией.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация используется для определения структуры данных в базах данных и не имеет отношения к динамической типизации, которая применяется в алгоритмах машинного обучения.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация определяет типы переменных во время выполнения программы, что делает её более гибкой по сравнению с динамической типизацией.\",\"generated_as_correct\":false}],\"question\":\"Как статическая типизация отличается от динамической типизации и в чём её преимущество?\"},{\"answers\":[{\"text\":\"Ручное управление памятью — это когда программист сам выделяет и освобождает память для переменных и объектов.\",\"generated_as_correct\":true},{\"text\":\"Ручное управление памятью — это метод, при котором программист использует специальные библиотеки для автоматического управления памятью, не вмешиваясь в процесс распределения ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Ручное управление памятью — это концепция, связанная с настройкой параметров компилятора для оптимизации использования памяти в процессе выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Ручное управление памятью — это автоматическое управление памятью, которое выполняется компилятором без участия программиста.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой ручное управление памятью в программировании?\"},{\"answers\":[{\"text\":\"Ручное управление памятью требует от программиста явного выделения и освобождения памяти, иначе могут возникнуть утечки и ошибки.\",\"generated_as_correct\":true},{\"text\":\"Ручное управление памятью обеспечивает полное отсутствие утечек памяти, так как программист всегда точно знает, когда и какую память нужно освободить.\",\"generated_as_correct\":false},{\"text\":\"Ручное управление памятью связано с использованием специфических функций для работы с файлами, что может вызвать проблемы при неправильном обращении с данными.\",\"generated_as_correct\":false},{\"text\":\"Ручное управление памятью исключает возможность ошибок и утечек, так как программист полностью контролирует процесс.\",\"generated_as_correct\":false}],\"question\":\"Почему ручное управление памятью может привести к утечкам и ошибкам, если не уделять ему должного внимания?\"},{\"answers\":[{\"text\":\"Ручное управление памятью в C++ даёт программисту контроль над выделением и освобождением памяти, что помогает оптимизировать использование ресурсов.\",\"generated_as_correct\":true},{\"text\":\"Ручное управление памятью в C++ приводит к тому, что программист не может контролировать выделение и освобождение памяти, что часто вызывает утечки памяти и снижает эффективность использования ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Ручное управление памятью в C++ связано с использованием готовых контейнеров и структур данных, которые оптимизируют доступ к памяти и ускоряют выполнение программы.\",\"generated_as_correct\":false},{\"text\":\"Ручное управление памятью в C++ усложняет процесс программирования и не позволяет эффективно использовать ресурсы программы.\",\"generated_as_correct\":false}],\"question\":\"Как ручное управление памятью в C++ может помочь оптимизировать использование ресурсов программы?\"},{\"answers\":[{\"text\":\"Компилятор преобразует исходный код в машинный код для выполнения программы на компьютере.\",\"generated_as_correct\":true},{\"text\":\"Компилятор — это инструмент, который используется для отладки и тестирования программ, он помогает находить ошибки в исходном коде, но не преобразует его в другой формат.\",\"generated_as_correct\":false},{\"text\":\"Компилятор — это устройство, которое используется для хранения исходного кода программ и обеспечивает его защиту от несанкционированного доступа.\",\"generated_as_correct\":false},{\"text\":\"Компилятор используется для перевода машинного кода обратно в исходный код для удобства чтения.\",\"generated_as_correct\":false}],\"question\":\"Что такое компилятор и для чего он используется в программировании?\"},{\"answers\":[{\"text\":\"Компиляторы GCC и Clang преобразуют исходный код C++ в машинный код, создавая исполняемые файлы.\",\"generated_as_correct\":true},{\"text\":\"Компиляторы, такие как GCC или Clang, важны для процесса разработки программ на C++, потому что они автоматически оптимизируют алгоритмы и структуры данных в исходном коде, улучшая производительность программы без участия программиста.\",\"generated_as_correct\":false},{\"text\":\"Компиляторы, такие как GCC или Clang, важны для процесса разработки программ на C++, поскольку они предоставляют инструменты для отладки и профилирования кода, помогая разработчикам выявлять и исправлять ошибки.\",\"generated_as_correct\":false},{\"text\":\"Компиляторы GCC и Clang используются для тестирования и отладки программ на C++, но не участвуют в преобразовании исходного кода в исполняемый формат.\",\"generated_as_correct\":false}],\"question\":\"Почему компиляторы, такие как GCC или Clang, важны для процесса разработки программ на C++?\"},{\"answers\":[{\"text\":\"Компилятор преобразует исходный код в машинный код, создавая исполняемый файл.\",\"generated_as_correct\":true},{\"text\":\"Компилятор преобразует исходный код в формат, понятный только разработчикам, и не может создать исполняемый файл для компьютера.\",\"generated_as_correct\":false},{\"text\":\"Компилятор применяется для анализа и оптимизации алгоритмов в исходном коде, но не участвует в создании исполняемого файла.\",\"generated_as_correct\":false},{\"text\":\"Компилятор служит для перевода исходного кода в формат, который можно распечатать и прочитать.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить компилятор для преобразования исходного кода в исполняемый файл?\"},{\"answers\":[{\"text\":\"Стандарт C++ — это документ с правилами и возможностями языка C++, выпускаемый международным комитетом.\",\"generated_as_correct\":true},{\"text\":\"Стандарт C++ представляет собой программное обеспечение, которое используется для компиляции и исполнения программ на языке C++.\",\"generated_as_correct\":false},{\"text\":\"Стандарт C++ тесно связан с операционными системами и определяет требования к их интерфейсу для работы с программами на C++.\",\"generated_as_correct\":false},{\"text\":\"Стандарт C++ — это сборник примеров кода для языка программирования C++.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой стандарт C++?\"},{\"answers\":[{\"text\":\"Стандарты C++ обеспечивают единое понимание правил и возможностей языка, что важно для создателей компиляторов и разработчиков.\",\"generated_as_correct\":true},{\"text\":\"Стандарты C++ важны только для начинающих разработчиков, чтобы изучить основы языка, в то время как опытные разработчики и создатели компиляторов полагаются на собственные знания и опыт, игнорируя стандарты.\",\"generated_as_correct\":false},{\"text\":\"Стандарты C++ определяют требования к аппаратному обеспечению, на котором выполняется код, и помогают разработчикам выбирать оптимальные конфигурации для своих приложений.\",\"generated_as_correct\":false},{\"text\":\"Стандарты C++ нужны только для формального описания языка и не влияют на работу создателей компиляторов или разработчиков.\",\"generated_as_correct\":false}],\"question\":\"Почему стандарты C++ важны для создателей компиляторов и разработчиков?\"},{\"answers\":[{\"text\":\"Стандарт C++ описывает правила и возможности языка, помогая разработчикам и создателям компиляторов.\",\"generated_as_correct\":true},{\"text\":\"Стандарт C++ определяет только синтаксис языка и не затрагивает его возможности и библиотеки, поэтому его влияние на разработчиков минимально.\",\"generated_as_correct\":false},{\"text\":\"Стандарт C++ важен для обеспечения безопасности программного обеспечения и защиты данных пользователей при разработке приложений.\",\"generated_as_correct\":false},{\"text\":\"Стандарт C++ устанавливает ограничения на использование определённых функций языка, но не влияет на его возможности и не служит руководством для разработчиков.\",\"generated_as_correct\":false}],\"question\":\"Как стандарт C++ влияет на использование языка программирования C++ разработчиками?\"},{\"answers\":[{\"text\":\"Среда разработки (IDE) — это комплекс инструментов для написания, компиляции и отладки кода.\",\"generated_as_correct\":true},{\"text\":\"Среда разработки (IDE) — это онлайн-сервис для хранения и обмена исходными кодами программ, который не включает в себя инструменты для компиляции или отладки.\",\"generated_as_correct\":false},{\"text\":\"Среда разработки (IDE) — это набор стандартов и протоколов для взаимодействия различных программных компонентов в распределённых системах.\",\"generated_as_correct\":false},{\"text\":\"Среда разработки (IDE) — это программа для просмотра и печати исходного кода без возможности его редактирования или компиляции.\",\"generated_as_correct\":false}],\"question\":\"Что такое среда разработки (IDE)?\"},{\"answers\":[{\"text\":\"IDE включает редактор кода, компилятор, средства для запуска и отладки программ.\",\"generated_as_correct\":true},{\"text\":\"Среда разработки (IDE) содержит только редактор кода и инструменты для форматирования текста. Дополнительные функции, такие как компилятор или отладчик, в IDE не предусмотрены.\",\"generated_as_correct\":false},{\"text\":\"Среда разработки (IDE) предоставляет разработчикам набор инструментов для управления версиями кода, совместной работы над проектами и создания графических интерфейсов пользователя, но не включает в себя средства для компиляции и отладки.\",\"generated_as_correct\":false},{\"text\":\"IDE содержит только редактор кода и инструменты для работы с текстовыми файлами.\",\"generated_as_correct\":false}],\"question\":\"Какие основные компоненты включает в себя среда разработки (IDE) и зачем они нужны?\"},{\"answers\":[{\"text\":\"IDE упрощает разработку программ благодаря наличию редактора кода и инструментов для компиляции, запуска и отладки.\",\"generated_as_correct\":true},{\"text\":\"Использование IDE ускоряет процесс разработки программ за счёт автоматического написания кода, что позволяет разработчикам сосредоточиться на тестировании и отладке.\",\"generated_as_correct\":false},{\"text\":\"Использование IDE помогает в управлении версиями кода и облегчает совместную работу над проектами, хотя основные функции IDE связаны с редактированием текста и форматированием кода.\",\"generated_as_correct\":false},{\"text\":\"IDE усложняет разработку программ из-за необходимости изучения множества дополнительных функций и настроек.\",\"generated_as_correct\":false}],\"question\":\"Как использование IDE может упростить процесс разработки программ?\"}],\"StoreCardId\":null,\"numberInCourse\":\"1.1\"}]},{\"id\":25,\"Name\":\"2. Базовые конструкции C++\",\"Articles\":[{\"Name\":\"cpp | 2.1. Первые шаги\",\"Slug\":\"first-steps\",\"createdAt\":\"2024-07-03T17:39:00.982Z\",\"updatedAt\":\"2026-01-10T12:07:10.808Z\",\"publishedAt\":\"2024-07-03T17:39:02.260Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42153/problem\",\"Lead\":\"В\u0026nbsp;этом параграфе мы\u0026nbsp;напишем первую программу на\u0026nbsp;C\\\\+\\\\+ и\u0026nbsp;научимся печатать и\u0026nbsp;считывать с\u0026nbsp;клавиатуры строки и\u0026nbsp;числа.\",\"Content\":\"$5b\",\"Title\":\"Первые шаги\",\"LikesCount\":22,\"Quiz\":[{\"answers\":[{\"text\":\"Функция main в C++ — это точка входа в программу, которая возвращает значение типа int.\",\"generated_as_correct\":true},{\"text\":\"Функция main в языке программирования C++ — это специальная функция, которая автоматически вызывается при завершении программы и используется для очистки памяти.\",\"generated_as_correct\":false},{\"text\":\"Функция main в языке программирования C++ тесно связана с функциями ввода-вывода и используется для обработки пользовательского ввода.\",\"generated_as_correct\":false},{\"text\":\"Функция main в C++ — это любая функция, которая может быть вызвана из других частей программы.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой функция main в языке программирования C++?\"},{\"answers\":[{\"text\":\"Функция main — это точка входа в программу на C++, которая должна быть единственной.\",\"generated_as_correct\":true},{\"text\":\"Функция main в C++ нужна для хранения всех переменных программы и должна быть объявлена несколько раз для разных секций кода.\",\"generated_as_correct\":false},{\"text\":\"Функция main важна в C++, так как она позволяет подключать внешние библиотеки и модули к программе.\",\"generated_as_correct\":false},{\"text\":\"Функция main используется в C++ для вывода результатов программы и может быть объявлена сколько угодно раз.\",\"generated_as_correct\":false}],\"question\":\"Почему важно, чтобы в каждой программе на C++ была ровно одна функция main?\"},{\"answers\":[{\"text\":\"Возврат 0 из функции main означает успешное выполнение программы, а ненулевое значение — ошибку.\",\"generated_as_correct\":true},{\"text\":\"Возвращаемое значение функции main в программе на C++ служит для передачи параметров в операционную систему: 0 означает передачу данных, а любое другое число — завершение программы без передачи данных.\",\"generated_as_correct\":false},{\"text\":\"Возвращаемое значение функции main используется для настройки параметров компилятора и не связано напрямую с успешностью выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Возврат любого числа из функции main указывает на успешное выполнение программы.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать возвращаемое значение функции main для определения успешности выполнения программы?\"},{\"answers\":[{\"text\":\"«Hello, world!» — это первая программа для вывода текста в консоль с помощью библиотеки iostream.\",\"generated_as_correct\":true},{\"text\":\"«Hello, world!» — это название алгоритма, который используется для шифрования данных и не связан с выводом текста в консоль.\",\"generated_as_correct\":false},{\"text\":\"«Hello, world!» — это термин, используемый в теории графов для описания начального состояния графа.\",\"generated_as_correct\":false},{\"text\":\"«Hello, world!» — это программа для тестирования аппаратного обеспечения компьютера.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой программа «Hello, world!»?\"},{\"answers\":[{\"text\":\"iostream используется в «Hello, world!» для вывода текста на экран.\",\"generated_as_correct\":true},{\"text\":\"стандартный библиотечный заголовочный файл iostream в программе «Hello, world!» применяется для математических вычислений и операций с числами.\",\"generated_as_correct\":false},{\"text\":\"стандартный библиотечный заголовочный файл iostream используется для определения переменных и типов данных в программе «Hello, world!».\",\"generated_as_correct\":false},{\"text\":\"iostream нужен в «Hello, world!» для создания графических интерфейсов.\",\"generated_as_correct\":false}],\"question\":\"Для чего используется стандартный библиотечный заголовочный файл iostream в программе «Hello, world!»?\"},{\"answers\":[{\"text\":\"«Hello, world!» — это первая программа для изучения основ вывода текста в консоль с помощью iostream.\",\"generated_as_correct\":true},{\"text\":\"Программа «Hello, world!» предназначена для изучения работы с графическим интерфейсом пользователя и не имеет отношения к выводу текста в консоль.\",\"generated_as_correct\":false},{\"text\":\"Программа «Hello, world!» применяется для тестирования производительности компьютера и не связана с изучением основ программирования.\",\"generated_as_correct\":false},{\"text\":\"«Hello, world!» используется для изучения работы с базами данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить программу «Hello, world!» для изучения основ программирования?\"},{\"answers\":[{\"text\":\"Компиляция из командной строки — это преобразование исходного кода в исполняемый файл.\",\"generated_as_correct\":true},{\"text\":\"Компиляция из командной строки — это процесс запуска программы напрямую из командной строки без преобразования исходного кода.\",\"generated_as_correct\":false},{\"text\":\"Компиляция из командной строки относится к методам отладки программного обеспечения и не связана с преобразованием исходного кода.\",\"generated_as_correct\":false},{\"text\":\"Компиляция из командной строки — это запуск программы из командной строки.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой компиляция из командной строки?\"},{\"answers\":[{\"text\":\"Указание имени файла с исходным кодом и имени исполняемого файла при компиляции из командной строки необходимо для корректной обработки и именования результирующего файла.\",\"generated_as_correct\":true},{\"text\":\"Для компиляции программы из командной строки необходимо указать имя файла с исходным кодом и имя библиотеки, в которую будет сохранён скомпилированный код для последующего использования.\",\"generated_as_correct\":false},{\"text\":\"Для компиляции программы из командной строки важно указать параметры оптимизации, такие как уровень отладки или тип процессора, на котором будет выполняться программа.\",\"generated_as_correct\":false},{\"text\":\"При компиляции программы из командной строки достаточно указать имя исходного файла, а имя исполняемого файла задаётся автоматически на основе имени исходного файла.\",\"generated_as_correct\":false}],\"question\":\"Почему для компиляции программы из командной строки необходимо указывать имя файла с исходным кодом и имя исполняемого файла?\"},{\"answers\":[{\"text\":\"Исходный код преобразуется в исполняемый файл с помощью команды clang++ из командной строки, например: clang++ hello.cpp -o hello.\",\"generated_as_correct\":true},{\"text\":\"Чтобы преобразовать исходный код в исполняемый файл с помощью clang++, необходимо открыть файл с исходным кодом в текстовом редакторе и сохранить его с расширением .exe.\",\"generated_as_correct\":false},{\"text\":\"Компилятор clang++ используется для анализа и оптимизации исходного кода, но не для его преобразования в исполняемый файл.\",\"generated_as_correct\":false},{\"text\":\"Для преобразования исходного кода в исполняемый файл с помощью clang++ нужно использовать интегрированную среду разработки (IDE).\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать компилятор clang++ для преобразования исходного кода в исполняемый файл?\"},{\"answers\":[{\"text\":\"Комментарии в C++ — это пояснения для программиста, игнорируемые компилятором.\",\"generated_as_correct\":true},{\"text\":\"Комментарии в C++ — это специальные команды, которые выполняют определённые действия в программе, но не отображаются в итоговом исполняемом файле.\",\"generated_as_correct\":false},{\"text\":\"Комментарии в C++ используются для создания документации, которая автоматически генерируется из исходного кода программы.\",\"generated_as_correct\":false},{\"text\":\"Комментарии в C++ — это инструкции для компилятора, которые влияют на выполнение программы.\",\"generated_as_correct\":false}],\"question\":\"Что такое комментарии в C++ и для кого они предназначены?\"},{\"answers\":[{\"text\":\"В C++ есть два вида комментариев: однострочные и многострочные.\",\"generated_as_correct\":true},{\"text\":\"В C++ комментарии бывают двух видов: текстовые и графические. Текстовые комментарии используются для пояснений, а графические — для визуализации структуры программы.\",\"generated_as_correct\":false},{\"text\":\"В C++ комментарии играют важную роль в отладке программы, позволяя временно исключать фрагменты кода из компиляции.\",\"generated_as_correct\":false},{\"text\":\"В C++ комментарии делятся на исполняемые и неисполняемые.\",\"generated_as_correct\":false}],\"question\":\"Какие виды комментариев существуют в C++ и чем они отличаются друг от друга?\"},{\"answers\":[{\"text\":\"Комментарии в C++ поясняют код, но сам код должен быть понятным без них.\",\"generated_as_correct\":true},{\"text\":\"Комментарии в C++ используются для оптимизации кода и повышения его производительности, поэтому их наличие делает код более эффективным и понятным для выполнения.\",\"generated_as_correct\":false},{\"text\":\"Комментарии в C++ играют важную роль в процессе отладки программы, так как они позволяют временно исключать фрагменты кода из компиляции без удаления.\",\"generated_as_correct\":false},{\"text\":\"Комментарии в C++ нужны для того, чтобы скрыть сложность кода и сделать его более лаконичным для чтения.\",\"generated_as_correct\":false}],\"question\":\"Почему важно, чтобы комментарии не заменяли понятность самого кода?\"},{\"answers\":[{\"text\":\"Библиотека — это переиспользуемый код в программировании. Заголовочные файлы содержат объявления библиотек и подключаются в начале программы.\",\"generated_as_correct\":true},{\"text\":\"Библиотека в контексте программирования — это специальный файл, содержащий исполняемый код программы. Заголовочные файлы используются для хранения комментариев и не влияют на работу программы.\",\"generated_as_correct\":false},{\"text\":\"Библиотека в программировании — это место, где хранятся данные для долговременного использования. Заголовочные файлы применяются для форматирования вывода данных на экран.\",\"generated_as_correct\":false},{\"text\":\"Библиотека — это исполняемый файл программы. Заголовочные файлы содержат данные для работы программы и подключаются по мере необходимости.\",\"generated_as_correct\":false}],\"question\":\"Что такое библиотека в контексте программирования и для чего используются заголовочные файлы?\"},{\"answers\":[{\"text\":\"Заголовочные файлы содержат объявления библиотек, необходимых для компиляции кода.\",\"generated_as_correct\":true},{\"text\":\"Заголовочные файлы нужны для хранения пользовательских данных, которые используются в программе, и подключение их необходимо для доступа к этим данным.\",\"generated_as_correct\":false},{\"text\":\"Заголовочные файлы важны для организации структуры проекта и помогают в управлении версиями кода, но не имеют отношения к использованию библиотечных конструкций.\",\"generated_as_correct\":false},{\"text\":\"Заголовочные файлы содержат готовые реализации функций, которые автоматически включаются в программу при их подключении.\",\"generated_as_correct\":false}],\"question\":\"Почему важно подключать заголовочные файлы перед использованием библиотечных конструкций?\"},{\"answers\":[{\"text\":\"Для применения стандартной библиотеки C++ в программе нужно подключить нужные заголовочные файлы.\",\"generated_as_correct\":true},{\"text\":\"Стандартную библиотеку C++ можно использовать, просто скопировав нужные функции из документации в свою программу без подключения заголовочных файлов.\",\"generated_as_correct\":false},{\"text\":\"Стандартную библиотеку C++ используют для создания графических интерфейсов в программах.\",\"generated_as_correct\":false},{\"text\":\"Стандартную библиотеку C++ применяют, добавляя её название в список аргументов при компиляции программы.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить стандартную библиотеку C++ в собственной программе?\"},{\"answers\":[{\"text\":\"Ошибки компиляции — это ошибки в коде, которые обнаруживает компилятор до запуска программы.\",\"generated_as_correct\":true},{\"text\":\"Ошибки компиляции — это предупреждения, которые выдаёт компилятор, но они не влияют на выполнение программы и могут быть проигнорированы без последствий для работы программы.\",\"generated_as_correct\":false},{\"text\":\"Ошибки компиляции связаны с проблемами в алгоритмах программы, которые приводят к неправильным результатам вычислений во время её работы.\",\"generated_as_correct\":false},{\"text\":\"Ошибки компиляции — это проблемы, которые возникают после запуска программы и связаны с её неправильным поведением.\",\"generated_as_correct\":false}],\"question\":\"Что такое ошибки компиляции?\"},{\"answers\":[{\"text\":\"Ошибки компиляции выявляются до запуска программы, а ошибки времени выполнения — после.\",\"generated_as_correct\":true},{\"text\":\"Ошибки компиляции связаны с проблемами в алгоритмах программы, тогда как ошибки времени выполнения связаны исключительно с синтаксическими ошибками в коде.\",\"generated_as_correct\":false},{\"text\":\"Ошибки компиляции и ошибки времени выполнения относятся к разным этапам разработки программного обеспечения, но оба типа ошибок могут быть исправлены с помощью отладчика.\",\"generated_as_correct\":false},{\"text\":\"Ошибки компиляции возникают после запуска программы, а ошибки времени выполнения — до.\",\"generated_as_correct\":false}],\"question\":\"Чем ошибки компиляции отличаются от ошибок времени выполнения?\"},{\"answers\":[{\"text\":\"Ошибки компиляции вызываются использованием необъявленных идентификаторов, отсутствием точек с запятой или незакрытыми фигурными скобками.\",\"generated_as_correct\":true},{\"text\":\"Ошибки компиляции происходят из-за некорректного ввода данных пользователем во время выполнения программы, например, если пользователь вводит буквы вместо чисел.\",\"generated_as_correct\":false},{\"text\":\"Ошибки компиляции связаны с проблемами в алгоритмах сортировки и поиска, которые используются в программе для обработки данных.\",\"generated_as_correct\":false},{\"text\":\"Ошибки компиляции происходят из-за проблем с подключением внешних библиотек или неправильной работы функций ввода-вывода.\",\"generated_as_correct\":false}],\"question\":\"Приведите примеры ситуаций, которые могут вызвать ошибки компиляции.\"},{\"answers\":[{\"text\":\"Переменная в C++ — это именованный блок данных определённого типа.\",\"generated_as_correct\":true},{\"text\":\"Переменная в C++ — это константа, значение которой нельзя изменить после объявления.\",\"generated_as_correct\":false},{\"text\":\"Переменная в C++ тесно связана с понятием указателя и используется для управления памятью в динамических структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Переменная в C++ — это функция, которая возвращает значение.\",\"generated_as_correct\":false}],\"question\":\"Что такое переменная в C++?\"},{\"answers\":[{\"text\":\"Указание типа переменной в C++ позволяет компилятору правильно выделить память и определить операции с данными.\",\"generated_as_correct\":true},{\"text\":\"Указание типа переменной при её определении в C++ необходимо только для того, чтобы программист мог лучше понимать структуру своего кода, а на работу программы это никак не влияет.\",\"generated_as_correct\":false},{\"text\":\"Указание типа переменной при её определении в C++ связано с принципами объектно-ориентированного программирования и наследованием свойств от базовых классов.\",\"generated_as_correct\":false},{\"text\":\"Указание типа переменной в C++ нужно только для удобства чтения кода и не влияет на его выполнение.\",\"generated_as_correct\":false}],\"question\":\"Почему важно указывать тип переменной при её определении в C++?\"},{\"answers\":[{\"text\":\"Тип переменной в C++ определяет размер памяти, интерпретацию данных и допустимые операции.\",\"generated_as_correct\":true},{\"text\":\"Знание типа переменной в C++ необходимо исключительно для удобства программиста, оно не влияет на процесс компиляции или выполнение программы.\",\"generated_as_correct\":false},{\"text\":\"Знание типа переменной в C++ помогает при написании комментариев к коду и улучшает читаемость программы, но не имеет практического значения для компилятора.\",\"generated_as_correct\":false},{\"text\":\"Тип переменной в C++ важен только для определения её имени и не влияет на работу с данными.\",\"generated_as_correct\":false}],\"question\":\"Как знание типа переменной влияет на работу с ней в C++?\"},{\"answers\":[{\"text\":\"Потоки — это абстракции для форматированного ввода-вывода данных.\",\"generated_as_correct\":true},{\"text\":\"Потоки в программировании используются исключительно для передачи данных между процессами и не имеют отношения к форматированию данных для вывода на экран.\",\"generated_as_correct\":false},{\"text\":\"Потоки в программировании связаны с управлением многозадачностью и параллельным выполнением операций, не касаясь ввода-вывода данных.\",\"generated_as_correct\":false},{\"text\":\"Потоки используются для прямого доступа и работы с двоичными данными в памяти.\",\"generated_as_correct\":false}],\"question\":\"Что такое потоки в контексте программирования?\"},{\"answers\":[{\"text\":\"Потоки упрощают ввод и вывод данных, представляя их в форматированном, человекочитаемом виде.\",\"generated_as_correct\":true},{\"text\":\"Потоки удобны для ввода и вывода данных, потому что они автоматически преобразуют все данные в шестнадцатеричный формат, что упрощает их анализ и обработку.\",\"generated_as_correct\":false},{\"text\":\"Потоки используются для оптимизации работы с файлами и обеспечивают высокую скорость записи и чтения данных, что важно для работы с большими объёмами информации.\",\"generated_as_correct\":false},{\"text\":\"Потоки удобны для ввода и вывода данных, так как позволяют хранить данные в памяти компьютера в десятичной системе счисления.\",\"generated_as_correct\":false}],\"question\":\"Почему использование потоков удобно для ввода и вывода данных?\"},{\"answers\":[{\"text\":\"`std::cout` в C++ используется для вывода данных на экран, `std::cin` — для ввода с клавиатуры.\",\"generated_as_correct\":true},{\"text\":\"Потоки `std::cout` и `std::cin` применяются в C++ для выполнения арифметических операций и обработки числовых данных.\",\"generated_as_correct\":false},{\"text\":\"Потоки в C++ связаны с управлением памятью и выделением ресурсов для работы программ.\",\"generated_as_correct\":false},{\"text\":\"`std::cout` и `std::cin` в C++ применяются для работы с сетевыми соединениями.\",\"generated_as_correct\":false}],\"question\":\"Как применяются потоки std::cout и std::cin в языке программирования C++?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.1\"},{\"Name\":\"cpp | 2.2. Типы данных\",\"Slug\":\"data-types\",\"createdAt\":\"2024-07-03T17:39:48.343Z\",\"updatedAt\":\"2026-01-10T12:07:10.674Z\",\"publishedAt\":\"2024-07-03T17:39:49.639Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42154/problem\",\"Lead\":\"Здесь мы\u0026nbsp;познакомимся с\u0026nbsp;некоторыми базовыми типами данных и\u0026nbsp;с\u0026nbsp;понятием области видимости переменных.\",\"Content\":\"$5c\",\"Title\":\"Типы данных\",\"LikesCount\":16,\"Quiz\":[{\"answers\":[{\"text\":\"Статическая типизация в C++ — это установление типа данных переменной на этапе компиляции.\",\"generated_as_correct\":true},{\"text\":\"Статическая типизация в C++ позволяет изменять тип данных переменной во время выполнения программы, обеспечивая гибкость и динамичность.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация в C++ связана с использованием статических методов и переменных в классах, что обеспечивает доступ к данным без создания экземпляра объекта.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация в C++ позволяет определять тип данных переменной во время выполнения программы.\",\"generated_as_correct\":false}],\"question\":\"Что такое статическая типизация в языке C++?\"},{\"answers\":[{\"text\":\"В C++ установка типа данных на этапе компиляции обеспечивает контроль типов и предотвращает ошибки при выполнении программы.\",\"generated_as_correct\":true},{\"text\":\"В C++ установка типа данных переменной на этапе компиляции нужна для того, чтобы программа могла автоматически преобразовывать типы данных в зависимости от контекста их использования.\",\"generated_as_correct\":false},{\"text\":\"В C++ установление типа данных переменной на этапе компиляции связано с управлением памятью и оптимизацией ресурсов, что не влияет на предотвращение ошибок во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"В C++ установка типа данных переменной на этапе компиляции позволяет программе изменять типы данных во время выполнения.\",\"generated_as_correct\":false}],\"question\":\"Почему в C++ важно устанавливать тип данных переменной на этапе компиляции?\"},{\"answers\":[{\"text\":\"Статическая типизация в C++ устанавливает типы данных переменных на этапе компиляции, что помогает предотвратить ошибки во время выполнения программы.\",\"generated_as_correct\":true},{\"text\":\"Статическая типизация в C++ обеспечивает автоматическое преобразование типов данных во время выполнения программы, что предотвращает возможные ошибки, связанные с несовместимостью типов.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация в C++ используется для определения области видимости переменных и управления доступом к ним, что помогает предотвратить ошибки, связанные с неправильным использованием переменных.\",\"generated_as_correct\":false},{\"text\":\"Статическая типизация в C++ определяет типы данных переменных во время выполнения программы, что помогает предотвратить ошибки на этапе компиляции.\",\"generated_as_correct\":false}],\"question\":\"Как статическая типизация помогает предотвратить ошибки во время выполнения программы в C++?\"},{\"answers\":[{\"text\":\"Область видимости переменной в C++ — это блок кода, где переменная доступна.\",\"generated_as_correct\":true},{\"text\":\"Область видимости переменной в C++ определяется как набор функций, в которых переменная может быть использована, независимо от их расположения в коде.\",\"generated_as_correct\":false},{\"text\":\"Область видимости переменной в C++ связана с типами данных, которые могут быть присвоены переменной в процессе выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Область видимости переменной в C++ — это вся программа, где переменная может быть использована.\",\"generated_as_correct\":false}],\"question\":\"Что такое область видимости переменной в C++?\"},{\"answers\":[{\"text\":\"Понимание областей видимости помогает управлять доступом к переменным и избегать конфликтов имён.\",\"generated_as_correct\":true},{\"text\":\"Понимание областей видимости важно, потому что оно определяет, какие переменные могут быть использованы в любой части программы без ограничений.\",\"generated_as_correct\":false},{\"text\":\"Понимание областей видимости важно для оптимизации производительности программы, так как оно влияет на распределение памяти и скорость выполнения кода.\",\"generated_as_correct\":false},{\"text\":\"Понимание областей видимости не нужно, так как все переменные доступны глобально.\",\"generated_as_correct\":false}],\"question\":\"Почему понимание областей видимости важно при программировании на C++?\"},{\"answers\":[{\"text\":\"Область видимости в C++ ограничивает доступ к переменным пределами блока, в котором они определены.\",\"generated_as_correct\":true},{\"text\":\"Область видимости в C++ не влияет на доступ к переменным, и все переменные доступны из любого места в программе независимо от их определения.\",\"generated_as_correct\":false},{\"text\":\"Область видимости в C++ связана с типами данных и определяет, какие операции можно выполнять с переменными в разных блоках кода.\",\"generated_as_correct\":false},{\"text\":\"Область видимости в C++ позволяет доступ к переменным из любых блоков кода без ограничений.\",\"generated_as_correct\":false}],\"question\":\"Как область видимости влияет на доступ к переменным в разных блоках кода в C++?\"},{\"answers\":[{\"text\":\"Локальные переменные простых типов в C++ не инициализируются по умолчанию и могут содержать неопределённые значения.\",\"generated_as_correct\":true},{\"text\":\"Локальные переменные простых типов в C++ инициализируются случайными значениями из диапазона допустимых для этого типа данных при их объявлении без явной инициализации.\",\"generated_as_correct\":false},{\"text\":\"Локальные переменные сложных типов в C++ всегда инициализируются значениями по умолчанию, в отличие от переменных простых типов.\",\"generated_as_correct\":false},{\"text\":\"Локальные переменные простых типов в C++ всегда инициализируются значением 0 при объявлении.\",\"generated_as_correct\":false}],\"question\":\"Что происходит с локальными переменными простых типов в C++ при их объявлении, если они не инициализированы явно?\"},{\"answers\":[{\"text\":\"В C++ локальные переменные простых типов не инициализируются по умолчанию для оптимизации.\",\"generated_as_correct\":true},{\"text\":\"В C++ локальные переменные простых типов автоматически инициализируются значениями, зависящими от типа переменной, что предотвращает ошибки при их использовании.\",\"generated_as_correct\":false},{\"text\":\"В C++ локальные переменные простых типов могут быть объявлены с использованием ключевых слов, которые определяют их область видимости и время жизни.\",\"generated_as_correct\":false},{\"text\":\"В C++ локальные переменные простых типов всегда инициализируются значением 0.\",\"generated_as_correct\":false}],\"question\":\"Почему в C++ локальные переменные простых типов не инициализируются по умолчанию?\"},{\"answers\":[{\"text\":\"Локальные переменные простых типов в C++ не инициализируются по умолчанию, что может вызвать неопределённое поведение.\",\"generated_as_correct\":true},{\"text\":\"Локальные переменные простых типов в C++ автоматически инициализируются значением -1, что может вызвать неожиданные результаты при арифметических операциях.\",\"generated_as_correct\":false},{\"text\":\"Локальные переменные в C++ могут быть объявлены как константы, и это влияет на их область видимости и время жизни в программе.\",\"generated_as_correct\":false},{\"text\":\"Локальные переменные простых типов в C++ всегда инициализируются нулевым значением.\",\"generated_as_correct\":false}],\"question\":\"Какие проблемы могут возникнуть при использовании локальных переменных простых типов в C++, если они не были инициализированы?\"},{\"answers\":[{\"text\":\"В C++ есть интегральные типы (int, short int, long int) и типы для вещественных чисел (float, double, long double).\",\"generated_as_correct\":true},{\"text\":\"В C++ фундаментальные типы данных включают логические типы (int, short int, long int) и строковые типы (float, double, long double).\",\"generated_as_correct\":false},{\"text\":\"В C++ типы данных классифицируются по их применению в алгоритмах и структурах данных, например, массивы и списки.\",\"generated_as_correct\":false},{\"text\":\"В C++ все типы данных являются интегральными, включая float и double.\",\"generated_as_correct\":false}],\"question\":\"Какие фундаментальные типы данных существуют в C++ и какие из них относятся к интегральным, а какие — к типам для вещественных чисел?\"},{\"answers\":[{\"text\":\"Знание размеров и диапазонов фундаментальных типов данных в C++ помогает избежать ошибок при работе с данными.\",\"generated_as_correct\":true},{\"text\":\"Знание размеров и диапазонов значений фундаментальных типов данных в C++ нужно только для теоретических целей и не влияет на практическую реализацию программ.\",\"generated_as_correct\":false},{\"text\":\"Знание размеров и диапазонов значений фундаментальных типов данных в C++ полезно для оптимизации алгоритмов сортировки и поиска в больших массивах данных.\",\"generated_as_correct\":false},{\"text\":\"Знание размеров и диапазонов фундаментальных типов данных в C++ необходимо только для работы с библиотеками и внешними модулями.\",\"generated_as_correct\":false}],\"question\":\"Почему важно знать размеры и диапазоны значений фундаментальных типов данных в C++?\"},{\"answers\":[{\"text\":\"Знание типов данных в C++ помогает правильно выбирать их для переменных, учитывая размер и диапазон значений.\",\"generated_as_correct\":true},{\"text\":\"Знание о различных фундаментальных типах данных в C++ помогает программистам выбирать типы данных на основе их цвета в интегрированной среде разработки, что улучшает читаемость кода.\",\"generated_as_correct\":false},{\"text\":\"Знание о различных фундаментальных типах данных в C++ полезно для понимания принципов объектно-ориентированного программирования и наследования классов.\",\"generated_as_correct\":false},{\"text\":\"Знание типов данных в C++ нужно только для того, чтобы соблюдать синтаксис языка и не имеет значения для работы программы.\",\"generated_as_correct\":false}],\"question\":\"Как знание о различных фундаментальных типах данных может помочь при написании программ на C++?\"},{\"answers\":[{\"text\":\"Оператор sizeof в C++ показывает размер переменной или типа данных в байтах.\",\"generated_as_correct\":true},{\"text\":\"Оператор sizeof в C++ служит для вычисления количества элементов в массиве или контейнере во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Оператор sizeof в C++ применяется для определения типа данных переменной во время компиляции.\",\"generated_as_correct\":false},{\"text\":\"Оператор sizeof в C++ определяет минимальное значение переменной или типа данных.\",\"generated_as_correct\":false}],\"question\":\"Что позволяет узнать оператор sizeof в C++?\"},{\"answers\":[{\"text\":\"Оператор sizeof в C++ определяет размер типа данных или переменной в байтах.\",\"generated_as_correct\":true},{\"text\":\"Оператор sizeof в C++ служит для определения максимального значения, которое может хранить переменная данного типа.\",\"generated_as_correct\":false},{\"text\":\"Оператор sizeof в C++ связан с управлением памятью и используется для выделения динамической памяти под переменные.\",\"generated_as_correct\":false},{\"text\":\"Оператор sizeof в C++ используется для определения типа данных переменной.\",\"generated_as_correct\":false}],\"question\":\"Почему важно использовать оператор sizeof при работе с типами данных в C++?\"},{\"answers\":[{\"text\":\"Оператор sizeof в C++ определяет размер переменной или типа данных в байтах.\",\"generated_as_correct\":true},{\"text\":\"Оператор sizeof в C++ позволяет определить размер переменной в килобайтах, что полезно при работе с большими объёмами данных.\",\"generated_as_correct\":false},{\"text\":\"Оператор sizeof используется в C++ для объявления новых типов данных и не связан с определением их размера в байтах.\",\"generated_as_correct\":false},{\"text\":\"Оператор sizeof в C++ используется для подсчёта количества элементов в массиве.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить оператор sizeof для определения размера переменной в байтах?\"},{\"answers\":[{\"text\":\"Переполнение — это состояние, когда результат операции не помещается в тип данных.\",\"generated_as_correct\":true},{\"text\":\"Переполнение — это процесс, при котором данные автоматически преобразуются в более крупный тип данных для хранения большего объёма информации.\",\"generated_as_correct\":false},{\"text\":\"Переполнение относится к ситуации, когда количество элементов в массиве превышает его заданный размер, что требует перераспределения памяти.\",\"generated_as_correct\":false},{\"text\":\"Переполнение — это механизм, позволяющий автоматически увеличивать размер типа данных при необходимости.\",\"generated_as_correct\":false}],\"question\":\"Что такое переполнение в контексте целочисленных типов данных?\"},{\"answers\":[{\"text\":\"Переполнение знаковых типов может вызвать неопределённое поведение, а беззнаковых — вычисления по модулю.\",\"generated_as_correct\":true},{\"text\":\"Переполнение знаковых и беззнаковых типов данных приводит к одинаковому результату — увеличению значения до максимального возможного для данного типа данных.\",\"generated_as_correct\":false},{\"text\":\"Переполнение целочисленных типов данных влияет на точность вычислений, но не имеет различий между знаковыми и беззнаковыми типами.\",\"generated_as_correct\":false},{\"text\":\"Переполнение знаковых и беззнаковых типов данных всегда приводит к одинаковым результатам.\",\"generated_as_correct\":false}],\"question\":\"Чем отличается поведение при переполнении для знаковых и беззнаковых типов данных?\"},{\"answers\":[{\"text\":\"Переполнение целочисленных типов может вызвать неопределённое поведение или вычисления по модулю, что ведёт к ошибкам в программе.\",\"generated_as_correct\":true},{\"text\":\"Переполнение целочисленных типов приводит к тому, что программа автоматически преобразует тип данных в более крупный, такой как long или double, чтобы избежать потери данных.\",\"generated_as_correct\":false},{\"text\":\"Переполнение целочисленных типов связано с проблемами выделения памяти в динамических структурах данных, таких как списки или деревья.\",\"generated_as_correct\":false},{\"text\":\"Переполнение целочисленных типов исправляется автоматически системой и не влияет на работу программы.\",\"generated_as_correct\":false}],\"question\":\"Какие проблемы могут возникнуть в программе из-за переполнения целочисленных типов?\"},{\"answers\":[{\"text\":\"В C++ определены бинарные операции +, -, *, /, %.\",\"generated_as_correct\":true},{\"text\":\"В C++ для чисел определены бинарные операции сложения (+), вычитания (-), деления (/), умножения (*) и операции логического ИЛИ (||).\",\"generated_as_correct\":false},{\"text\":\"В C++ бинарные операции используются для работы с битами и включают побитовое И (\u0026), побитовое ИЛИ (|) и побитовое исключающее ИЛИ (^).\",\"generated_as_correct\":false},{\"text\":\"В C++ определены бинарные операции ^, \u0026, |, ~ для чисел.\",\"generated_as_correct\":false}],\"question\":\"Какие бинарные операции определены в C++ для чисел?\"},{\"answers\":[{\"text\":\"Знание правил арифметических операций в C++ нужно для корректного написания алгоритмов и вычислений.\",\"generated_as_correct\":true},{\"text\":\"Знание арифметических операций в C++ необходимо только для работы с текстовыми данными, а для числовых вычислений можно использовать любые символы и операторы.\",\"generated_as_correct\":false},{\"text\":\"Знание арифметических операций в C++ полезно для понимания принципов работы сетевых протоколов и передачи данных.\",\"generated_as_correct\":false},{\"text\":\"Знание арифметических операций в C++ важно только для работы с библиотеками графического интерфейса.\",\"generated_as_correct\":false}],\"question\":\"Почему важно знать правила выполнения арифметических операций в C++ при написании алгоритмов?\"},{\"answers\":[{\"text\":\"Операция % в C++ вычисляет остаток от деления чисел.\",\"generated_as_correct\":true},{\"text\":\"Операция получения остатка от деления (%) в C++ используется для нахождения наибольшего общего делителя двух чисел.\",\"generated_as_correct\":false},{\"text\":\"Операция получения остатка от деления (%) в C++ тесно связана с логическими операциями и используется для управления потоком выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Операция % в C++ используется для умножения чисел.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить операцию получения остатка от деления (%) в программировании на C++?\"},{\"answers\":[{\"text\":\"В C++ три типа для дробных чисел: float, double, long double.\",\"generated_as_correct\":true},{\"text\":\"В C++ для представления дробных чисел применяются три типа: short, int и long.\",\"generated_as_correct\":false},{\"text\":\"В C++ есть несколько типов данных для работы с числами, включая целочисленные типы, такие как int и long, которые не подходят для записи дробных значений.\",\"generated_as_correct\":false},{\"text\":\"В C++ для дробных чисел используют типы: char, int, long.\",\"generated_as_correct\":false}],\"question\":\"Какие три встроенных типа для записи дробных чисел существуют в C++?\"},{\"answers\":[{\"text\":\"Выбор типа числа с плавающей точкой важен из-за различий в точности и диапазоне значений.\",\"generated_as_correct\":true},{\"text\":\"Выбор типа числа с плавающей точкой важен, потому что от него зависит скорость выполнения арифметических операций, а не точность или объём данных.\",\"generated_as_correct\":false},{\"text\":\"Выбор типа числа с плавающей точкой важен для определения размера переменной в памяти, что влияет на организацию структуры данных в программе.\",\"generated_as_correct\":false},{\"text\":\"Выбор типа числа с плавающей точкой не важен, так как все типы автоматически преобразуются друг в друга без потери данных.\",\"generated_as_correct\":false}],\"question\":\"Почему выбор типа числа с плавающей точкой важен при работе с данными в C++?\"},{\"answers\":[{\"text\":\"Тип double в C++ предпочтительнее использовать для высокой точности дробных чисел.\",\"generated_as_correct\":true},{\"text\":\"Тип double в C++ рекомендуется использовать исключительно для работы с комплексными числами, так как он обеспечивает необходимую точность для их представления.\",\"generated_as_correct\":false},{\"text\":\"Тип double в C++ используется для определения размера массивов и циклов, где требуется высокая гибкость в изменении значений.\",\"generated_as_correct\":false},{\"text\":\"Тип double в C++ применяется для хранения целочисленных значений большого объёма.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях рекомендуется использовать тип double в C++ и почему?\"},{\"answers\":[{\"text\":\"Автоматический вывод типа в C++ — это использование ключевого слова `auto` для определения типа переменной по присвоенному значению.\",\"generated_as_correct\":true},{\"text\":\"Автоматический вывод типа в C++ — это функция, которая позволяет компилятору определять тип переменной по её имени, а не по значению, что упрощает написание кода.\",\"generated_as_correct\":false},{\"text\":\"Автоматический вывод типа в C++ связан с использованием шаблонов и позволяет создавать обобщённые функции и классы, что облегчает разработку универсальных алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Автоматический вывод типа в C++ — это метод, позволяющий компилятору определять тип переменной по её адресу в памяти.\",\"generated_as_correct\":false}],\"question\":\"Что такое автоматический вывод типа в C++?\"},{\"answers\":[{\"text\":\"Автоматический вывод типа в C++ упрощает работу с сложными данными, позволяя компилятору определить тип переменной по её значению.\",\"generated_as_correct\":true},{\"text\":\"Автоматический вывод типа в C++ работает только для базовых типов данных, таких как int и float, и не применим к сложным структурам данных.\",\"generated_as_correct\":false},{\"text\":\"Автоматический вывод типа в C++ связан с использованием шаблонов и позволяет создавать более гибкие алгоритмы, но не влияет на работу со сложными типами данных.\",\"generated_as_correct\":false},{\"text\":\"Автоматический вывод типа в C++ усложняет работу с данными, так как требует от программиста дополнительного указания типа переменной.\",\"generated_as_correct\":false}],\"question\":\"Почему использование автоматического вывода типа может упростить работу с сложными типами данных?\"},{\"answers\":[{\"text\":\"В C++ автоматический вывод типа с помощью `auto` позволяет сократить код, автоматически определяя тип переменной по присвоенному значению.\",\"generated_as_correct\":true},{\"text\":\"Автоматический вывод типа в C++ осуществляется с помощью ключевого слова `var`, которое позволяет компилятору определять тип переменной по её значению, сокращая тем самым объём кода.\",\"generated_as_correct\":false},{\"text\":\"Автоматический вывод типа в C++ связан с использованием шаблонов и позволяет создавать обобщённые функции и классы для работы с различными типами данных.\",\"generated_as_correct\":false},{\"text\":\"В C++ для сокращения кода необходимо явно указывать тип переменной с помощью ключевого слова `auto`.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить автоматический вывод типа в C++ для сокращения кода?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.2\"},{\"Name\":\"cpp | 2.3. Ветвления и циклы\",\"Slug\":\"branches-and-loops\",\"createdAt\":\"2024-07-03T17:40:24.547Z\",\"updatedAt\":\"2026-01-10T12:07:10.178Z\",\"publishedAt\":\"2024-07-03T17:40:25.789Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42155/problem\",\"Lead\":\"В\u0026nbsp;этом параграфе мы\u0026nbsp;познакомимся с\u0026nbsp;операторами ветвления if\u0026nbsp;и\u0026nbsp;switch, циклами while, do-while и\u0026nbsp;for, а\u0026nbsp;также с\u0026nbsp;оператором goto.\",\"Content\":\"$5d\",\"Title\":\"Ветвления и циклы\",\"LikesCount\":16,\"Quiz\":[{\"answers\":[{\"text\":\"Оператор if — это условный оператор, который выполняет код при истинности условия.\",\"generated_as_correct\":true},{\"text\":\"Оператор if используется для циклического повторения блока кода определённое количество раз, независимо от каких-либо условий.\",\"generated_as_correct\":false},{\"text\":\"Оператор if связан с функцией вывода данных в консоль и используется для отображения сообщений пользователю.\",\"generated_as_correct\":false},{\"text\":\"Оператор if используется для бесконечного повторения блока кода.\",\"generated_as_correct\":false}],\"question\":\"Что такое оператор if и для чего он используется в программировании?\"},{\"answers\":[{\"text\":\"Оператор if позволяет программе выполнять разные действия в зависимости от условий, что делает её гибкой.\",\"generated_as_correct\":true},{\"text\":\"Оператор if обеспечивает гибкость программы, автоматически изменяя её код в зависимости от внешних условий без необходимости проверки каких-либо выражений.\",\"generated_as_correct\":false},{\"text\":\"Оператор if используется для объявления переменных в программе и не влияет на её гибкость или адаптивность.\",\"generated_as_correct\":false},{\"text\":\"Оператор if ограничивает программу выполнением одного и того же блока кода независимо от условий.\",\"generated_as_correct\":false}],\"question\":\"Почему использование оператора if позволяет сделать программу более гибкой и адаптивной?\"},{\"answers\":[{\"text\":\"Оператор if позволяет выполнять код при истинности условия, а else и else if обрабатывают альтернативные случаи.\",\"generated_as_correct\":true},{\"text\":\"Оператор if используется исключительно для вывода сообщений на экран, а конструкции else и else if не могут быть применены вместе с ним для реализации различных сценариев в программе.\",\"generated_as_correct\":false},{\"text\":\"Оператор if в программировании связан с циклами и используется для определения количества итераций, не зависящих от условий выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Оператор if всегда выполняет блок кода, а else и else if нужны для завершения программы.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить оператор if вместе с else и else if для реализации различных сценариев в программе?\"},{\"answers\":[{\"text\":\"Сложные условия в программировании создаются с помощью логических операторов \u0026\u0026, || и ! для одновременной проверки нескольких условий.\",\"generated_as_correct\":true},{\"text\":\"Сложные условия в программировании — это специальные функции, которые автоматически проверяют все возможные условия в программе без использования логических операторов.\",\"generated_as_correct\":false},{\"text\":\"Сложные условия в программировании связаны с использованием циклов и итераторов для перебора элементов массива или списка.\",\"generated_as_correct\":false},{\"text\":\"Сложные условия в программировании создаются с помощью математических операторов +, - и * для выполнения арифметических операций.\",\"generated_as_correct\":false}],\"question\":\"Что такое сложные условия в программировании и какие логические операторы используются для их создания?\"},{\"answers\":[{\"text\":\"Приоритет логических операторов определяет порядок вычисления сложных условий в программе.\",\"generated_as_correct\":true},{\"text\":\"Учёт приоритета логических операторов важен, поскольку от этого зависит количество памяти, необходимое для выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Учёт приоритета логических операторов важен для оптимизации скорости выполнения программы, но не влияет на порядок вычисления условий.\",\"generated_as_correct\":false},{\"text\":\"Приоритет логических операторов влияет на количество условий, которые можно проверить одновременно.\",\"generated_as_correct\":false}],\"question\":\"Почему важно учитывать приоритет логических операторов при работе со сложными условиями?\"},{\"answers\":[{\"text\":\"Сложные условия повышают гибкость управления программой за счёт одновременной проверки нескольких условий.\",\"generated_as_correct\":true},{\"text\":\"Сложные условия не влияют на гибкость управления выполнением программы, так как они лишь усложняют структуру кода без добавления новых возможностей для управления потоком выполнения.\",\"generated_as_correct\":false},{\"text\":\"Сложные условия используются для оптимизации производительности программы, позволяя сократить количество операций ввода-вывода и улучшить время отклика системы.\",\"generated_as_correct\":false},{\"text\":\"Сложные условия уменьшают гибкость управления программой, усложняя структуру кода.\",\"generated_as_correct\":false}],\"question\":\"Как использование сложных условий может повлиять на гибкость управления выполнением программы?\"},{\"answers\":[{\"text\":\"Сравнение чисел с плавающей точкой может быть неточным из-за погрешностей машинного представления.\",\"generated_as_correct\":true},{\"text\":\"Процесс сравнения чисел с плавающей точкой может быть неточным из-за ошибок в программном обеспечении, а не из-за ограничений машинного представления.\",\"generated_as_correct\":false},{\"text\":\"Процесс сравнения чисел с плавающей точкой может быть сложным из-за различий в алгоритмах сортировки, используемых в разных языках программирования.\",\"generated_as_correct\":false},{\"text\":\"Сравнение чисел с плавающей точкой всегда точное, так как они хранятся в памяти компьютера без потерь.\",\"generated_as_correct\":false}],\"question\":\"Почему процесс сравнения чисел с плавающей точкой может быть неточным?\"},{\"answers\":[{\"text\":\"Погрешность представления чисел с плавающей точкой в компьютере может приводить к неточным результатам при их прямом сравнении на равенство.\",\"generated_as_correct\":true},{\"text\":\"Ограничения машинного представления чисел с плавающей точкой приводят к тому, что все числа округляются до ближайшего целого, что влияет на результаты их сравнения.\",\"generated_as_correct\":false},{\"text\":\"Ограничения машинного представления чисел с плавающей точкой связаны с количеством разрядов в экспоненте и мантиссе, что влияет на диапазон представимых чисел, но не на точность их сравнения.\",\"generated_as_correct\":false},{\"text\":\"Машинное представление чисел с плавающей точкой всегда точное, и их сравнение не требует дополнительных проверок.\",\"generated_as_correct\":false}],\"question\":\"Какие ограничения машинного представления чисел с плавающей точкой могут влиять на результаты их сравнения?\"},{\"answers\":[{\"text\":\"Сравнивать модуль разности чисел с допустимой погрешностью.\",\"generated_as_correct\":true},{\"text\":\"Вместо прямого сравнения чисел с плавающей точкой на равенство рекомендуется округлять числа до целого и затем сравнивать их на точное равенство.\",\"generated_as_correct\":false},{\"text\":\"Вместо прямого сравнения чисел с плавающей точкой на равенство рекомендуется использовать алгоритмы сортировки для упорядочивания чисел и последующего визуального сравнения.\",\"generated_as_correct\":false},{\"text\":\"Сравнивать числа с плавающей точкой путём умножения их на коэффициент точности.\",\"generated_as_correct\":false}],\"question\":\"Какой подход рекомендуется использовать вместо прямого сравнения чисел с плавающей точкой на равенство?\"},{\"answers\":[{\"text\":\"Оператор switch — это условный оператор для выбора блока кода по значению выражения.\",\"generated_as_correct\":true},{\"text\":\"Оператор switch — это функция, которая автоматически выполняет все блоки кода, независимо от значения выражения, и используется для упрощения сложных вычислений.\",\"generated_as_correct\":false},{\"text\":\"Оператор switch связан с управлением памятью в программировании и используется для выделения и освобождения ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Оператор switch используется для циклического выполнения блоков кода без учёта значения выражения.\",\"generated_as_correct\":false}],\"question\":\"Что такое оператор switch и для чего он используется в программировании?\"},{\"answers\":[{\"text\":\"Оператор switch упрощает код с множеством проверок на равенство, делая его более компактным и читаемым.\",\"generated_as_correct\":true},{\"text\":\"Оператор switch применяется для выполнения арифметических операций над значениями выражений, что делает его предпочтительным при наличии множества проверок на равенство.\",\"generated_as_correct\":false},{\"text\":\"Оператор switch важен для работы с циклами, так как позволяет контролировать количество итераций в зависимости от значения выражения.\",\"generated_as_correct\":false},{\"text\":\"Оператор switch усложняет код с множеством проверок на равенство, делая его менее понятным.\",\"generated_as_correct\":false}],\"question\":\"Почему использование оператора switch предпочтительнее при наличии множества проверок на равенство одного и того же выражения?\"},{\"answers\":[{\"text\":\"Оператор switch упрощает код, заменяя множественные if-else на более компактную конструкцию для выбора между вариантами.\",\"generated_as_correct\":true},{\"text\":\"Оператор switch используется для выполнения циклов, повторяющих определённый блок кода заданное количество раз в зависимости от условия.\",\"generated_as_correct\":false},{\"text\":\"Оператор switch связан с работой массивов и используется для перебора их элементов.\",\"generated_as_correct\":false},{\"text\":\"Оператор switch предназначен для выполнения арифметических операций в коде.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить оператор switch для упрощения кода, содержащего выбор между несколькими вариантами?\"},{\"answers\":[{\"text\":\"Оператор goto — это оператор безусловного перехода к метке в коде.\",\"generated_as_correct\":true},{\"text\":\"Оператор goto используется для последовательного выполнения команд в том порядке, в котором они записаны в программе.\",\"generated_as_correct\":false},{\"text\":\"Оператор goto связан с управлением доступом к переменным в разных областях видимости в программировании.\",\"generated_as_correct\":false},{\"text\":\"Оператор goto используется для создания циклов в программе.\",\"generated_as_correct\":false}],\"question\":\"Что такое оператор goto и для чего он используется в программировании?\"},{\"answers\":[{\"text\":\"Оператор goto делает код сложным для понимания и отладки, поэтому его использование нежелательно в структурированном программировании.\",\"generated_as_correct\":true},{\"text\":\"Оператор goto используется в структурированном программировании для улучшения модульности кода и облегчения его тестирования, что делает его желательным элементом в большинстве случаев.\",\"generated_as_correct\":false},{\"text\":\"Оператор goto связан с управлением памятью в программировании и используется для выделения и освобождения ресурсов, что не имеет прямого отношения к структурированному программированию.\",\"generated_as_correct\":false},{\"text\":\"Оператор goto упрощает структуру кода и делает его более понятным, поэтому его использование поощряется в структурированном программировании.\",\"generated_as_correct\":false}],\"question\":\"Почему оператор goto считается нежелательным в структурированном программировании?\"},{\"answers\":[{\"text\":\"Оператор goto полезен для выхода из вложенных циклов.\",\"generated_as_correct\":true},{\"text\":\"Оператор goto часто применяется для создания модульных программ и улучшения их масштабируемости.\",\"generated_as_correct\":false},{\"text\":\"Оператор goto используется для определения функций и процедур в программировании.\",\"generated_as_correct\":false},{\"text\":\"Оператор goto применяется для улучшения структуры кода.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях использование оператора goto может быть оправдано и полезно?\"},{\"answers\":[{\"text\":\"Цикл while — это цикл, выполняющий код, пока условие истинно.\",\"generated_as_correct\":true},{\"text\":\"Цикл while — это структура данных, которая используется для хранения последовательности значений и их последующего вывода в определённом порядке.\",\"generated_as_correct\":false},{\"text\":\"Цикл while связан с управлением потоками в программировании и используется для синхронизации работы многопоточных приложений.\",\"generated_as_correct\":false},{\"text\":\"Цикл while используется для выполнения блока кода один раз при старте программы.\",\"generated_as_correct\":false}],\"question\":\"Что такое цикл while и для чего он используется в программировании?\"},{\"answers\":[{\"text\":\"Цикл while — это цикл с предусловием, проверяющий условие перед выполнением блока кода.\",\"generated_as_correct\":true},{\"text\":\"Цикл while называется циклом с предусловием, так как он автоматически устанавливает условие после определённого количества итераций.\",\"generated_as_correct\":false},{\"text\":\"Цикл while связан с понятием бесконечного цикла, который может быть прерван только внешним воздействием, например, командой break.\",\"generated_as_correct\":false},{\"text\":\"Цикл while — это цикл, который проверяет условие после выполнения блока кода.\",\"generated_as_correct\":false}],\"question\":\"Почему цикл while называется циклом с предусловием?\"},{\"answers\":[{\"text\":\"Цикл while выполняет код, пока условие истинно.\",\"generated_as_correct\":true},{\"text\":\"Цикл while применяется для однократного выполнения блока кода без проверки условия, что позволяет реализовать алгоритмы, требующие повторения действий.\",\"generated_as_correct\":false},{\"text\":\"Цикл while связан с организацией последовательного выполнения команд в алгоритмах и может быть использован для создания бесконечных циклов, не зависящих от достижения определённого результата.\",\"generated_as_correct\":false},{\"text\":\"Цикл while выполняется один раз независимо от условия.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить цикл while для реализации алгоритма, требующего повторения действий до достижения определённого результата?\"},{\"answers\":[{\"text\":\"Цикл do-while выполняет блок кода хотя бы один раз, затем проверяет условие, в отличие от while, где условие проверяется до выполнения блока.\",\"generated_as_correct\":true},{\"text\":\"Цикл do-while — это разновидность цикла while, которая выполняет блок кода бесконечно, без возможности проверки условия выхода из цикла.\",\"generated_as_correct\":false},{\"text\":\"Цикл do-while используется для создания рекурсивных функций, в отличие от цикла while, который применяется для итерации по массивам.\",\"generated_as_correct\":false},{\"text\":\"Цикл do-while похож на цикл while и отличается тем, что его условие проверяется до выполнения блока кода.\",\"generated_as_correct\":false}],\"question\":\"Что такое цикл do-while и чем он отличается от цикла while?\"},{\"answers\":[{\"text\":\"Цикл do-while выполняет блок кода хотя бы один раз, затем проверяет условие.\",\"generated_as_correct\":true},{\"text\":\"Цикл do-while считается циклом с постусловием, потому что он выполняет блок кода бесконечное количество раз без проверки условия.\",\"generated_as_correct\":false},{\"text\":\"Цикл do-while связан с функциональным программированием и используется для создания рекурсивных функций.\",\"generated_as_correct\":false},{\"text\":\"Цикл do-while проверяет условие перед выполнением блока кода.\",\"generated_as_correct\":false}],\"question\":\"Почему цикл do-while считается циклом с постусловием?\"},{\"answers\":[{\"text\":\"Цикл do-while используют, когда нужно выполнить блок кода хотя бы один раз.\",\"generated_as_correct\":true},{\"text\":\"Цикл do-while применяется, когда необходимо выполнить блок кода неопределённое количество раз без какой-либо проверки условия.\",\"generated_as_correct\":false},{\"text\":\"Цикл do-while используется для создания бесконечных циклов, которые не зависят от каких-либо условий.\",\"generated_as_correct\":false},{\"text\":\"Цикл do-while применяют, когда нужно проверить условие до выполнения блока кода.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях целесообразно использовать цикл do-while?\"},{\"answers\":[{\"text\":\"Цикл for выполняет блок кода заданное количество раз и включает начальное условие, условие продолжения и пост-действие.\",\"generated_as_correct\":true},{\"text\":\"Цикл for — это цикл, который выполняет блок кода бесконечно, пока пользователь не остановит программу. Его основные компоненты: условие начала и условие завершения.\",\"generated_as_correct\":false},{\"text\":\"Цикл for используется для создания бесконечных циклов, которые выполняются до тех пор, пока программа не будет принудительно остановлена. Его структура включает в себя только условие продолжения.\",\"generated_as_correct\":false},{\"text\":\"Цикл for выполняется бесконечно и включает только условие остановки.\",\"generated_as_correct\":false}],\"question\":\"Что такое цикл for и какие основные компоненты его определяют?\"},{\"answers\":[{\"text\":\"Цикл for в C++ гибок, так как позволяет контролировать количество итераций и изменять параметры при каждом повторении.\",\"generated_as_correct\":true},{\"text\":\"Цикл for в C++ предоставляет ограниченные возможности для работы с условиями и не позволяет изменять параметры во время выполнения цикла, что делает его менее гибким по сравнению с другими видами циклов.\",\"generated_as_correct\":false},{\"text\":\"Цикл for в C++ используется исключительно для работы с массивами и не предоставляет дополнительных возможностей для изменения условий выполнения.\",\"generated_as_correct\":false},{\"text\":\"Цикл for в C++ предназначен только для выполнения блока кода бесконечное количество раз без возможности изменения условий.\",\"generated_as_correct\":false}],\"question\":\"Почему цикл for считается гибким и универсальным в языке C++?\"},{\"answers\":[{\"text\":\"Цикл for позволяет выполнять код заданное количество раз с изменением параметра на каждой итерации.\",\"generated_as_correct\":true},{\"text\":\"Цикл for применяется для выполнения блока кода только один раз, без возможности изменения параметров от итерации к итерации.\",\"generated_as_correct\":false},{\"text\":\"Цикл for тесно связан с концепцией рекурсии и используется для вызова функций внутри себя для повторения действий.\",\"generated_as_correct\":false},{\"text\":\"Цикл for предназначен для выполнения бесконечного цикла без возможности изменения параметров.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать цикл for для реализации повторения действий с изменением параметра?\"},{\"answers\":[{\"text\":\"Цикл range-based for позволяет удобно перебирать элементы контейнеров без использования индексов.\",\"generated_as_correct\":true},{\"text\":\"Цикл range-based for применяется исключительно для работы с числовыми значениями и не может быть использован для итерации по элементам контейнеров.\",\"generated_as_correct\":false},{\"text\":\"Цикл range-based for используется для определения размера контейнеров и не предназначен для итерации по их элементам.\",\"generated_as_correct\":false},{\"text\":\"Цикл range-based for применяется для сортировки элементов в контейнерах.\",\"generated_as_correct\":false}],\"question\":\"Что такое цикл range-based for и для каких структур данных он применяется?\"},{\"answers\":[{\"text\":\"Цикл range-based for упрощает перебор элементов контейнера без индексов.\",\"generated_as_correct\":true},{\"text\":\"Цикл range-based for удобен для перебора элементов контейнера, потому что он автоматически сортирует элементы в порядке возрастания перед их обработкой.\",\"generated_as_correct\":false},{\"text\":\"Цикл range-based for используется для определения размера контейнера и не предназначен для перебора его элементов.\",\"generated_as_correct\":false},{\"text\":\"Цикл range-based for требует указания начального и конечного индекса для перебора элементов контейнера.\",\"generated_as_correct\":false}],\"question\":\"Почему цикл range-based for считается удобным для перебора элементов контейнера?\"},{\"answers\":[{\"text\":\"Цикл range-based for упрощает перебор элементов строки без использования индексов.\",\"generated_as_correct\":true},{\"text\":\"Цикл range-based for позволяет перебирать строки, но только если они представлены в виде массива символов с заранее известными индексами.\",\"generated_as_correct\":false},{\"text\":\"Цикл range-based for используется для сортировки элементов в контейнерах, включая строки, по определённому критерию.\",\"generated_as_correct\":false},{\"text\":\"Цикл range-based for нужен для поиска индекса конкретного элемента в строке.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать цикл range-based for при работе со строками?\"},{\"answers\":[{\"text\":\"Вложенные циклы — это циклы внутри других циклов для выполнения вложенных повторений.\",\"generated_as_correct\":true},{\"text\":\"Вложенные циклы — это циклы, которые автоматически повторяют действия после завершения основного цикла, что используется для создания бесконечных циклов.\",\"generated_as_correct\":false},{\"text\":\"Вложенные циклы — это структура данных, используемая для хранения значений, которые могут быть пройдены в процессе выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Вложенные циклы — это циклы, которые выполняются один за другим без вложенности.\",\"generated_as_correct\":false}],\"question\":\"Что такое вложенные циклы?\"},{\"answers\":[{\"text\":\"Вложенные циклы позволяют эффективно реализовывать алгоритмы с повторяющимися действиями в определённом порядке.\",\"generated_as_correct\":true},{\"text\":\"Вложенные циклы используются для реализации алгоритмов, требующих однократного выполнения действий в случайном порядке.\",\"generated_as_correct\":false},{\"text\":\"Вложенные циклы применяются для оптимизации работы с массивами и улучшения производительности программ, но не имеют отношения к порядку выполнения действий в алгоритмах.\",\"generated_as_correct\":false},{\"text\":\"Вложенные циклы нужны для выполнения действий в хаотичном порядке, что усложняет алгоритмы.\",\"generated_as_correct\":false}],\"question\":\"Почему вложенные циклы полезны для реализации алгоритмов, требующих повторения действий в определённом порядке?\"},{\"answers\":[{\"text\":\"Вложенные циклы организуют печать таблицы умножения через перебор строк и столбцов.\",\"generated_as_correct\":true},{\"text\":\"Вложенные циклы применяются для печати таблицы умножения, где внешний цикл отвечает за столбцы, а внутренний — за строки, что на самом деле не соответствует логике построения таблицы.\",\"generated_as_correct\":false},{\"text\":\"Вложенные циклы могут быть использованы для сортировки данных перед печатью таблицы умножения, хотя их основная функция заключается в организации структуры данных.\",\"generated_as_correct\":false},{\"text\":\"Вложенные циклы используются для печати таблицы умножения путём сложения значений строк и столбцов.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать вложенные циклы для печати таблицы умножения?\"},{\"answers\":[{\"text\":\"Оператор break досрочно завершает цикл, а continue — переходит к следующей итерации.\",\"generated_as_correct\":true},{\"text\":\"Операторы break и continue применяются для изменения порядка выполнения команд внутри цикла и для выхода из программы в целом.\",\"generated_as_correct\":false},{\"text\":\"Операторы break и continue связаны с обработкой ошибок и исключений в программировании и не имеют прямого отношения к управлению циклами.\",\"generated_as_correct\":false},{\"text\":\"Оператор break увеличивает количество итераций цикла, а continue — уменьшает их.\",\"generated_as_correct\":false}],\"question\":\"Что такое операторы break и continue и для чего они используются в программировании?\"},{\"answers\":[{\"text\":\"`break` досрочно завершает цикл, `continue` переходит к следующей итерации.\",\"generated_as_correct\":true},{\"text\":\"Операторы `break` и `continue` используются для выхода из программы, причём `break` завершает программу полностью, а `continue` прерывает её выполнение до определённого условия.\",\"generated_as_correct\":false},{\"text\":\"Операторы `break` и `continue` применяются для управления потоком выполнения функций, где `break` возвращает значение функции, а `continue` пропускает вызов функции.\",\"generated_as_correct\":false},{\"text\":\"`break` переходит к следующей итерации цикла, `continue` завершает цикл.\",\"generated_as_correct\":false}],\"question\":\"В чём разница между операторами break и continue?\"},{\"answers\":[{\"text\":\"Оператор `break` завершает цикл, а `continue` пропускает текущую итерацию.\",\"generated_as_correct\":true},{\"text\":\"Операторы `break` и `continue` используются для изменения порядка выполнения инструкций внутри цикла. Оператор `break` меняет последовательность выполнения команд, а `continue` заставляет цикл выполняться бесконечно.\",\"generated_as_correct\":false},{\"text\":\"Операторы `break` и `continue` применяются для определения типа данных, которые будут использоваться в цикле, и не влияют на его выполнение.\",\"generated_as_correct\":false},{\"text\":\"Операторы `break` и `continue` увеличивают количество итераций цикла.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить операторы break и continue для оптимизации выполнения циклов в зависимости от определённых условий?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.3\"},{\"Name\":\"cpp | 2.4. Векторы и строки\",\"Slug\":\"vectors-and-strings\",\"createdAt\":\"2024-07-03T17:40:54.295Z\",\"updatedAt\":\"2026-01-10T12:07:11.546Z\",\"publishedAt\":\"2024-07-03T17:40:56.065Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42156/problem\",\"Lead\":\"Вектор и\u0026nbsp;строка\u0026nbsp;— важные базовые контейнеры стандартной библиотеки C\\\\+\\\\+.\u0026nbsp;Они хранят свои элементы в\u0026nbsp;непрерывном фрагменте памяти. Оба этих контейнера предоставляют доступ к\u0026nbsp;элементам по\u0026nbsp;индексу и\u0026nbsp;позволяют эффективно добавлять новые элементы в\u0026nbsp;конец.\",\"Content\":\"$5e\",\"Title\":\"Векторы и строки\",\"LikesCount\":20,\"Quiz\":[{\"answers\":[{\"text\":\"`std::vector` — динамический массив в C++, обеспечивающий быстрый доступ к элементам и автоматическое изменение размера.\",\"generated_as_correct\":true},{\"text\":\"`std::vector` — это структура данных в C++, которая позволяет хранить элементы разных типов и обеспечивает быстрый доступ к ним по ключу.\",\"generated_as_correct\":false},{\"text\":\"`std::vector` — это функция в стандартной библиотеке C++, которая используется для сортировки элементов массива.\",\"generated_as_correct\":false},{\"text\":\"`std::vector` — статический массив в C++, требующий ручного управления памятью.\",\"generated_as_correct\":false}],\"question\":\"Что такое `std::vector` в контексте стандартной библиотеки C++?\"},{\"answers\":[{\"text\":\"`std::vector` автоматически управляет памятью, предотвращая её утечки.\",\"generated_as_correct\":true},{\"text\":\"`std::vector` предотвращает утечки памяти за счёт использования специальной функции, которая вручную освобождает память после каждого добавления элемента в массив.\",\"generated_as_correct\":false},{\"text\":\"`std::vector` связан с управлением памятью в C++, но его основная функция — обеспечение быстрого доступа к элементам по индексу, что не имеет прямого отношения к предотвращению утечек памяти.\",\"generated_as_correct\":false},{\"text\":\"`std::vector` предотвращает утечки памяти путём фиксированного распределения памяти при создании массива.\",\"generated_as_correct\":false}],\"question\":\"Почему использование `std::vector` предотвращает утечки памяти?\"},{\"answers\":[{\"text\":\"`std::vector` — динамический массив в C++, обеспечивающий быстрое добавление элементов в конец и изменение размера.\",\"generated_as_correct\":true},{\"text\":\"`std::vector` в C++ используется для хранения элементов разных типов, при этом размер вектора фиксирован и не может быть изменён после создания.\",\"generated_as_correct\":false},{\"text\":\"`std::vector` в C++ применяется для реализации сложных алгоритмов сортировки и поиска, не связанных с хранением коллекций элементов.\",\"generated_as_correct\":false},{\"text\":\"`std::vector` в C++ — это структура данных для хранения элементов разного типа с фиксированным размером.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать `std::vector` для работы с коллекцией элементов одинакового типа в программе на C++?\"},{\"answers\":[{\"text\":\"Вектор можно инициализировать списком значений или указанием количества элементов и образца.\",\"generated_as_correct\":true},{\"text\":\"Вектор инициализируется автоматически при объявлении без необходимости указания начальных значений или количества элементов.\",\"generated_as_correct\":false},{\"text\":\"Инициализация вектора связана с определением его типа данных и не зависит от количества элементов или их значений.\",\"generated_as_correct\":false},{\"text\":\"Вектор инициализируется только путём прямого присвоения значений без возможности указать количество элементов.\",\"generated_as_correct\":false}],\"question\":\"Какими способами можно инициализировать вектор?\"},{\"answers\":[{\"text\":\"Инициализация через список задаёт начальные значения элементов, а указание числа и образца — создаёт вектор с одинаковыми элементами.\",\"generated_as_correct\":true},{\"text\":\"Инициализация вектора через список используется для создания пустого вектора, а указание числа элементов и образца — для задания начальных значений каждому элементу.\",\"generated_as_correct\":false},{\"text\":\"Инициализация вектора через список и указание числа элементов и образца — это два метода, которые используются для определения размера вектора в памяти.\",\"generated_as_correct\":false},{\"text\":\"Инициализация через список создаёт вектор с неопределённым количеством элементов, а указание числа и образца задаёт начальные значения.\",\"generated_as_correct\":false}],\"question\":\"В чём разница между инициализацией вектора через список и указанием числа элементов и образца?\"},{\"answers\":[{\"text\":\"Инициализация вектора позволяет задать количество одинаковых элементов, указав их число и образец.\",\"generated_as_correct\":true},{\"text\":\"Для создания коллекции с определённым количеством одинаковых элементов необходимо использовать цикл, который будет добавлять элементы в вектор по одному.\",\"generated_as_correct\":false},{\"text\":\"Инициализация вектора используется для определения его размера, но не для задания количества одинаковых элементов, это делается с помощью других методов обработки данных.\",\"generated_as_correct\":false},{\"text\":\"Инициализация вектора возможна только путём последовательного добавления элементов в цикл.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать инициализацию вектора для создания коллекции с определённым количеством одинаковых элементов?\"},{\"answers\":[{\"text\":\"Индексация элементов вектора начинается с 0.\",\"generated_as_correct\":true},{\"text\":\"Индексация элементов вектора начинается с произвольного числа, которое задаётся пользователем при создании вектора.\",\"generated_as_correct\":false},{\"text\":\"Индексация элементов вектора связана с количеством элементов в векторе и используется для определения его размера.\",\"generated_as_correct\":false},{\"text\":\"Индексация элементов вектора начинается с 1.\",\"generated_as_correct\":false}],\"question\":\"С какого числа начинается индексация элементов вектора?\"},{\"answers\":[{\"text\":\"Индексация вектора начинается с нуля, поэтому отрицательные индексы не допускаются.\",\"generated_as_correct\":true},{\"text\":\"Использование отрицательных индексов при обращении к элементам вектора не допускается, потому что они зарезервированы для специальных операций, не связанных с доступом к элементам.\",\"generated_as_correct\":false},{\"text\":\"Отрицательные индексы не используются при обращении к элементам вектора, поскольку вектор представляет собой упорядоченную последовательность элементов, и индексация в нём организована иначе, чем в других структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Отрицательные индексы используются для обращения к элементам вектора с конца.\",\"generated_as_correct\":false}],\"question\":\"Почему использование отрицательных индексов при обращении к элементам вектора не допускается?\"},{\"answers\":[{\"text\":\"Обращение к элементу вектора по некорректному индексу может вызвать неопределённое поведение программы.\",\"generated_as_correct\":true},{\"text\":\"Обращение к элементу вектора по некорректному индексу вызовет немедленное завершение программы с выводом сообщения об ошибке.\",\"generated_as_correct\":false},{\"text\":\"Обращение к некорректному индексу вектора может вызвать проблемы с производительностью, так как система будет тратить дополнительные ресурсы на проверку границ массива.\",\"generated_as_correct\":false},{\"text\":\"Обращение к элементу вектора по некорректному индексу приведёт к корректной обработке ошибки системой.\",\"generated_as_correct\":false}],\"question\":\"К каким последствиям может привести обращение к элементу вектора по некорректному индексу без проверки его корректности?\"},{\"answers\":[{\"text\":\"Вектор имеет функции size, front, back, empty для работы с элементами.\",\"generated_as_correct\":true},{\"text\":\"Вектор предоставляет функции для работы с элементами, такие как count (возвращает количество уникальных элементов), begin (возвращает начальный индекс), end (возвращает конечный индекс), clear (удаляет все элементы) и другие.\",\"generated_as_correct\":false},{\"text\":\"Вектор используется для хранения элементов и поддерживает операции вставки и удаления, а также предоставляет функции для сортировки и поиска элементов.\",\"generated_as_correct\":false},{\"text\":\"Вектор имеет функции add, remove, update для работы с элементами.\",\"generated_as_correct\":false}],\"question\":\"Какие функции предоставляет вектор для работы с элементами?\"},{\"answers\":[{\"text\":\"front возвращает первый элемент вектора, а back — последний.\",\"generated_as_correct\":true},{\"text\":\"Функции front и back вектора возвращают случайные элементы из вектора, что полезно при реализации алгоритмов случайного выбора.\",\"generated_as_correct\":false},{\"text\":\"Функции front и back вектора связаны с изменением размера вектора и его перераспределением в памяти.\",\"generated_as_correct\":false},{\"text\":\"front и back используются для сортировки элементов в векторе.\",\"generated_as_correct\":false}],\"question\":\"Чем отличаются функции front и back вектора и зачем они нужны?\"},{\"answers\":[{\"text\":\"Функция empty проверяет, пуст ли вектор.\",\"generated_as_correct\":true},{\"text\":\"Функция empty вектора применяется для удаления всех элементов из вектора, очищая его.\",\"generated_as_correct\":false},{\"text\":\"Функция empty вектора тесно связана с операциями сортировки и используется для определения порядка элементов в векторе.\",\"generated_as_correct\":false},{\"text\":\"Функция empty используется для добавления элементов в вектор.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать функцию empty вектора в программировании?\"},{\"answers\":[{\"text\":\"Итерация по индексам — это перебор элементов вектора с использованием индексов типа size_t в цикле.\",\"generated_as_correct\":true},{\"text\":\"Итерация по индексам — это метод прямого доступа к элементам вектора без использования циклов, основанный на применении специальных функций.\",\"generated_as_correct\":false},{\"text\":\"Итерация по индексам относится к алгоритмам сортировки, которые используют индексы для перестановки элементов в векторе.\",\"generated_as_correct\":false},{\"text\":\"Итерация по индексам — это способ доступа к элементам вектора с помощью типа данных float.\",\"generated_as_correct\":false}],\"question\":\"Что такое итерация по индексам в контексте работы с вектором?\"},{\"answers\":[{\"text\":\"Тип `size_t` используется для представления индексов и размеров контейнеров, обеспечивая итерацию по вектору.\",\"generated_as_correct\":true},{\"text\":\"Тип `size_t` используется для представления индексов и размеров контейнеров в стандартной библиотеке, потому что он обеспечивает более высокую точность при работе с дробными значениями.\",\"generated_as_correct\":false},{\"text\":\"Тип `size_t` важен для представления индексов и размеров контейнеров, так как связан с определением максимального размера стека при выполнении программ.\",\"generated_as_correct\":false},{\"text\":\"Тип `size_t` применяется для представления индексов и размеров контейнеров, так как позволяет хранить отрицательные значения.\",\"generated_as_correct\":false}],\"question\":\"Почему для представления индексов и размеров контейнеров в стандартной библиотеке используется тип size_t?\"},{\"answers\":[{\"text\":\"Итерация по индексам вектора выполняется с использованием типа size_t.\",\"generated_as_correct\":true},{\"text\":\"Итерация по индексам для перебора элементов вектора в цикле осуществляется с помощью типа float, который позволяет точно представлять дробные значения индексов.\",\"generated_as_correct\":false},{\"text\":\"Итерация по индексам используется для определения размера вектора и не применяется для перебора его элементов в цикле.\",\"generated_as_correct\":false},{\"text\":\"Итерация по индексам вектора выполняется с использованием типа double.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить итерацию по индексам для перебора элементов вектора в цикле?\"},{\"answers\":[{\"text\":\"Эффективно добавлять и удалять элементы в вектор можно с помощью функций push_back и pop_back соответственно, причём операции выполняются в конце вектора.\",\"generated_as_correct\":true},{\"text\":\"Для добавления и удаления элементов в вектор используются функции insert и erase, которые позволяют эффективно выполнять эти операции в любой части вектора без сдвига соседних элементов.\",\"generated_as_correct\":false},{\"text\":\"Для работы с вектором используются функции size и capacity, которые позволяют определить текущий размер вектора и его вместимость.\",\"generated_as_correct\":false},{\"text\":\"Эффективно добавлять элементы в вектор можно с помощью функции pop_back, а удалять — с помощью функции push_back.\",\"generated_as_correct\":false}],\"question\":\"Какие функции используются для добавления и удаления элементов в вектор и где именно эти операции выполняются эффективно?\"},{\"answers\":[{\"text\":\"Добавление или удаление элементов не в конце вектора неэффективно из-за необходимости сдвига соседних элементов.\",\"generated_as_correct\":true},{\"text\":\"Добавление или удаление элементов в других частях вектора, кроме конца, не считается неэффективным, поскольку современные алгоритмы оптимизируют эти операции, минимизируя сдвиг элементов.\",\"generated_as_correct\":false},{\"text\":\"Добавление и удаление элементов в векторе связано с изменением его размера и может влиять на распределение памяти, но это не делает операции неэффективными.\",\"generated_as_correct\":false},{\"text\":\"Добавление и удаление элементов в любой части вектора одинаково эффективно благодаря использованию функций push_back и pop_back.\",\"generated_as_correct\":false}],\"question\":\"Почему добавление или удаление элементов в других частях вектора, кроме конца, считается неэффективным?\"},{\"answers\":[{\"text\":\"push_back добавляет элемент в конец вектора, pop_back удаляет элемент с конца вектора.\",\"generated_as_correct\":true},{\"text\":\"Функции push_back и pop_back позволяют добавлять элементы в любую часть вектора и удалять элементы из любой части вектора без необходимости сдвига соседних элементов.\",\"generated_as_correct\":false},{\"text\":\"Функции push_back и pop_back используются для сортировки элементов в векторе по возрастанию или убыванию.\",\"generated_as_correct\":false},{\"text\":\"push_back удаляет элемент из конца вектора, pop_back добавляет элемент в конец вектора.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать функции push_back и pop_back для управления элементами в векторе в контексте программирования?\"},{\"answers\":[{\"text\":\"Вектор резервирует дополнительное место в памяти для быстрого добавления элементов, удваивая размер при реаллокации.\",\"generated_as_correct\":true},{\"text\":\"Вектор резервирует дополнительное место в памяти для оптимизации доступа к существующим элементам, а не для добавления новых. При заполнении зарезервированного пространства вектор удаляет старые элементы для освобождения места.\",\"generated_as_correct\":false},{\"text\":\"Вектор используется в управлении памятью для обозначения направления перемещения данных между различными уровнями кэша.\",\"generated_as_correct\":false},{\"text\":\"Вектор резервирует дополнительное место в памяти для временного хранения данных перед их удалением.\",\"generated_as_correct\":false}],\"question\":\"Что такое вектор в контексте управления памятью и зачем он резервирует дополнительное место?\"},{\"answers\":[{\"text\":\"При исчерпании резерва вектора происходит копирование элементов в более просторный блок памяти, что обеспечивает эффективное добавление новых элементов.\",\"generated_as_correct\":true},{\"text\":\"При исчерпании резерва вектора система автоматически удаляет часть старых элементов для освобождения места под новые, что снижает эффективность добавления элементов из-за необходимости дополнительной обработки данных.\",\"generated_as_correct\":false},{\"text\":\"При исчерпании резерва вектора активируется алгоритм сжатия данных, который позволяет увеличить плотность хранения информации в текущем блоке памяти, не прибегая к реаллокации.\",\"generated_as_correct\":false},{\"text\":\"При исчерпании резерва вектора происходит автоматическое удаление старых элементов для добавления новых, что снижает общую эффективность работы с данными.\",\"generated_as_correct\":false}],\"question\":\"Почему при исчерпании резерва вектора происходит реаллокация, и как это влияет на эффективность добавления новых элементов?\"},{\"answers\":[{\"text\":\"Увеличение размера блока памяти в два раза при реаллокации вектора обеспечивает константную сложность добавления элементов.\",\"generated_as_correct\":true},{\"text\":\"При реаллокации вектора размер нового блока памяти увеличивается на фиксированную величину (например, на 10 элементов), что приводит к увеличению времени добавления элементов при исчерпании резерва.\",\"generated_as_correct\":false},{\"text\":\"Изменение размера блока памяти при реаллокации вектора влияет на распределение памяти в куче и может вызвать фрагментацию памяти, что косвенно влияет на производительность добавления элементов.\",\"generated_as_correct\":false},{\"text\":\"Уменьшение размера блока памяти при реаллокации вектора приводит к константной сложности добавления элементов.\",\"generated_as_correct\":false}],\"question\":\"Как изменение размера блока памяти при реаллокации вектора влияет на сложность добавления элементов?\"},{\"answers\":[{\"text\":\"`std::string` — это `std::vector` с дополнительными функциями для работы со строками.\",\"generated_as_correct\":true},{\"text\":\"Контейнер `std::string` отличается от `std::vector` тем, что хранит данные в виде массива чисел, а не символов.\",\"generated_as_correct\":false},{\"text\":\"Контейнер `std::string` используется для хранения текстовых данных в формате Unicode, в то время как `std::vector` предназначен для работы с бинарными данными.\",\"generated_as_correct\":false},{\"text\":\"`std::string` и `std::vector` ничем не отличаются, это просто разные названия одного и того же контейнера.\",\"generated_as_correct\":false}],\"question\":\"Чем отличается контейнер std::string от std::vector?\"},{\"answers\":[{\"text\":\"`std::string` — это особый случай `std::vector`, дополненный функциями для работы со строками.\",\"generated_as_correct\":true},{\"text\":\"`std::string` является особым случаем вектора символов, поскольку его основная функция заключается в преобразовании числовых данных в символьные и обратно, что отличает его от `std::vector`.\",\"generated_as_correct\":false},{\"text\":\"`std::string` рассматривается как особый случай вектора символов из-за его тесной связи с алгоритмами сортировки и поиска, которые используются для обработки данных в структурах типа `std::vector`.\",\"generated_as_correct\":false},{\"text\":\"`std::string` считается особым случаем вектора символов, так как используется исключительно для хранения числовых значений в виде строк.\",\"generated_as_correct\":false}],\"question\":\"Почему std::string считается особым случаем вектора символов?\"},{\"answers\":[{\"text\":\"std::string имеет функции pop_back, resize, substr, find для работы с символами и подстроками.\",\"generated_as_correct\":true},{\"text\":\"std::string в C++ позволяет работать с символами и подстроками только через стандартные операции сложения и сравнения строк, специфические функции для этого не предусмотрены.\",\"generated_as_correct\":false},{\"text\":\"std::string в C++ используется для хранения текстовых данных и может быть выведен на экран с помощью функций из библиотеки iostream.\",\"generated_as_correct\":false},{\"text\":\"std::string используется исключительно для хранения текста и не имеет специфических функций для работы с символами или подстроками.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать специфические функции std::string для работы с символами и подстроками в программировании?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.4\"},{\"Name\":\"cpp | 2.5. Составные типы данных\",\"Slug\":\"complex-data-types\",\"createdAt\":\"2024-07-03T17:41:54.392Z\",\"updatedAt\":\"2026-01-10T12:07:10.311Z\",\"publishedAt\":\"2024-07-03T17:41:55.701Z\",\"ContestURL\":null,\"Lead\":\"C++ позволяет конструировать новые типы данных на основе базовых типов. В этом параграфе мы познакомимся с перечислениями и структурами, а также рассмотрим конструкции std::pair и std::tuple из стандартной библиотеки.\",\"Content\":\"$5f\",\"Title\":\"Составные типы данных\",\"LikesCount\":17,\"Quiz\":[{\"answers\":[{\"text\":\"Перечисления в C++ — это тип данных для хранения конечного набора именованных констант, по умолчанию хранящихся как int.\",\"generated_as_correct\":true},{\"text\":\"Перечисления в C++ представляют собой способ объявления функций, где каждая функция имеет уникальное имя и номер.\",\"generated_as_correct\":false},{\"text\":\"Перечисления в C++ используются для создания сложных структур данных, таких как деревья и графы, и не имеют отношения к константам.\",\"generated_as_correct\":false},{\"text\":\"Перечисления в C++ — это способ объявления массивов с автоматически увеличивающимися индексами.\",\"generated_as_correct\":false}],\"question\":\"Что такое перечисления в C++?\"},{\"answers\":[{\"text\":\"Перечисления в C++ удобны для описания однотипных именованных констант, так как представляют собой набор констант, хранящихся как int и нумеруемых с нуля.\",\"generated_as_correct\":true},{\"text\":\"Перечисления в C++ удобны для описания однотипных именованных констант, потому что позволяют автоматически генерировать уникальные идентификаторы для каждой константы, что делает их идеальными для использования в качестве ключей в ассоциативных массивах.\",\"generated_as_correct\":false},{\"text\":\"Перечисления в C++ используются для создания пользовательских типов данных, которые могут быть полезны при разработке сложных алгоритмов и структур данных. Они не имеют прямого отношения к описанию однотипных именованных констант.\",\"generated_as_correct\":false},{\"text\":\"Перечисления в C++ неудобны для описания однотипных именованных констант, так как требуют ручного задания значений для каждой константы и не обеспечивают автоматической нумерации.\",\"generated_as_correct\":false}],\"question\":\"Почему перечисления в C++ удобно использовать для описания однотипных именованных констант?\"},{\"answers\":[{\"text\":\"Перечисления в C++ хранятся как int и нумеруются с нуля.\",\"generated_as_correct\":true},{\"text\":\"Перечисления в C++ представляют собой набор переменных, которые могут принимать любые значения, и хранятся они как тип char, начиная нумерацию с произвольного числа.\",\"generated_as_correct\":false},{\"text\":\"Перечисления в C++ используются для создания массивов, где каждый элемент связан с определённым индексом, и их хранение зависит от типа данных, указанного при объявлении массива.\",\"generated_as_correct\":false},{\"text\":\"Перечисления в C++ хранятся как string и нумеруются с единицы.\",\"generated_as_correct\":false}],\"question\":\"Как по умолчанию хранятся перечисления в C++ и как нумеруются их значения?\"},{\"answers\":[{\"text\":\"Структура в C++ — это объединение переменных в один тип данных.\",\"generated_as_correct\":true},{\"text\":\"Структура в C++ — это функция, которая позволяет выполнять операции над несколькими переменными одновременно.\",\"generated_as_correct\":false},{\"text\":\"Структура в C++ тесно связана с концепцией классов и используется исключительно для определения методов в программе.\",\"generated_as_correct\":false},{\"text\":\"Структура в C++ — это специальный вид функции для работы с массивами данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое структура в C++?\"},{\"answers\":[{\"text\":\"Структуры объединяют логически связанные данные в один тип, упрощая работу с ними.\",\"generated_as_correct\":true},{\"text\":\"Структуры позволяют объединять переменные разных типов данных, но при этом доступ к каждой переменной осуществляется независимо, без учёта их логической связи.\",\"generated_as_correct\":false},{\"text\":\"Структуры используются для создания сложных алгоритмов сортировки и поиска, что ускоряет обработку больших объёмов данных.\",\"generated_as_correct\":false},{\"text\":\"Структуры усложняют работу с данными, разделяя их на множество независимых переменных.\",\"generated_as_correct\":false}],\"question\":\"Почему использование структур удобно при работе с логически связанными наборами данных?\"},{\"answers\":[{\"text\":\"Структуры в C++ объединяют несколько переменных в один тип данных.\",\"generated_as_correct\":true},{\"text\":\"Структуры в C++ применяются для создания массивов, в которых можно хранить данные разных типов без какой-либо логической связи между ними.\",\"generated_as_correct\":false},{\"text\":\"Структуры в C++ тесно связаны с концепцией наследования и используются для определения иерархии классов в объектно-ориентированном программировании.\",\"generated_as_correct\":false},{\"text\":\"Структуры в C++ предназначены для последовательного выполнения операций над переменными.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить структуры в программе для объединения нескольких переменных?\"},{\"answers\":[{\"text\":\"Выравнивание в C++ — это добавление дополнительных байтов к структуре для эффективного обращения к переменным.\",\"generated_as_correct\":true},{\"text\":\"Выравнивание в C++ — это метод шифрования данных в структуре, который обеспечивает безопасность переменных при их хранении в памяти.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание в C++ — это техника оптимизации кода, которая используется для улучшения визуального представления исходного кода в редакторе.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание в C++ — это процесс удаления байтов из структуры для усложнения доступа к переменным.\",\"generated_as_correct\":false}],\"question\":\"Что такое выравнивание в контексте программирования на C++?\"},{\"answers\":[{\"text\":\"Выравнивание позволяет компилятору эффективнее работать со структурой в памяти.\",\"generated_as_correct\":true},{\"text\":\"Выравнивание необходимо для того, чтобы все переменные структуры имели одинаковый размер, что упрощает их обработку компилятором.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание используется для оптимизации визуального представления структуры в исходном коде программы.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание требуется для уменьшения количества переменных в структуре.\",\"generated_as_correct\":false}],\"question\":\"Почему компилятор использует выравнивание при работе со структурами?\"},{\"answers\":[{\"text\":\"Выравнивание данных упрощает доступ компилятора к переменным структуры в памяти, ускоряя их обработку.\",\"generated_as_correct\":true},{\"text\":\"Выравнивание данных в памяти приводит к тому, что переменные структуры становятся недоступными для компилятора, что замедляет процесс обработки данных и усложняет работу с ними.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание данных в памяти влияет на распределение переменных по регистрам процессора и может изменять порядок их выполнения в потоке команд.\",\"generated_as_correct\":false},{\"text\":\"Выравнивание данных усложняет доступ к переменным структуры и замедляет их обработку.\",\"generated_as_correct\":false}],\"question\":\"Как выравнивание данных в памяти может повлиять на процесс обработки переменных структуры?\"},{\"answers\":[{\"text\":\"`std::pair` — это структура в C++ для хранения двух объектов.\",\"generated_as_correct\":true},{\"text\":\"`std::pair` — это класс в стандартной библиотеке C++, который используется для хранения трёх объектов, доступ к которым осуществляется через поля `first`, `second` и `third`.\",\"generated_as_correct\":false},{\"text\":\"`std::pair` — это инструмент в стандартной библиотеке C++, который применяется для сортировки пар значений по определённому ключу.\",\"generated_as_correct\":false},{\"text\":\"`std::pair` — это тип данных в C++, который хранит одно значение и предоставляет к нему доступ через поле `first`.\",\"generated_as_correct\":false}],\"question\":\"Что такое std::pair в контексте стандартной библиотеки C++?\"},{\"answers\":[{\"text\":\"Поля first и second в std::pair обезличены, что вызывает неопределённость в их назначении.\",\"generated_as_correct\":true},{\"text\":\"Использование полей first и second в std::pair вызывает неопределённость из-за того, что они могут автоматически изменять своё содержимое в зависимости от контекста использования.\",\"generated_as_correct\":false},{\"text\":\"Использование полей first и second в std::pair связано с проблемами при компиляции программ на C++, так как они могут конфликтовать с другими библиотеками.\",\"generated_as_correct\":false},{\"text\":\"Поля first и second в std::pair имеют чётко определённые типы данных, что исключает неопределённость в их использовании.\",\"generated_as_correct\":false}],\"question\":\"Почему использование полей first и second в std::pair может вызвать неопределённость в понимании их назначения?\"},{\"answers\":[{\"text\":\"`std::pair` в C++ позволяет хранить два объекта, доступ к которым можно получить через поля `first` и `second`.\",\"generated_as_correct\":true},{\"text\":\"`std::pair` — это класс в C++, который позволяет хранить неограниченное количество объектов, доступ к которым осуществляется через индексы массива.\",\"generated_as_correct\":false},{\"text\":\"`std::pair` используется в C++ для определения типов данных, которые могут быть использованы в качестве ключей в ассоциативных контейнерах.\",\"generated_as_correct\":false},{\"text\":\"`std::pair` в C++ используется для создания массивов из двух элементов.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать std::pair для хранения двух объектов в программе на C++?\"},{\"answers\":[{\"text\":\"`std::tuple` — это контейнер для хранения нескольких объектов, объявленный в заголовочном файле `tuple`.\",\"generated_as_correct\":true},{\"text\":\"`std::tuple` — это структура данных, которая позволяет динамически добавлять и удалять элементы во время выполнения программы. `std::tuple` объявлен в заголовочном файле `vector`.\",\"generated_as_correct\":false},{\"text\":\"`std::tuple` используется для работы с потоками ввода-вывода в C++ и объявлен в заголовочном файле `iostream`.\",\"generated_as_correct\":false},{\"text\":\"`std::tuple` — это функция для работы с парами значений, объявленная в заголовочном файле `utility`.\",\"generated_as_correct\":false}],\"question\":\"Что такое std::tuple и в каком заголовочном файле он объявлен?\"},{\"answers\":[{\"text\":\"`std::tuple` позволяет хранить несколько объектов, доступ к которым можно получить с помощью `std::get`, в отличие от `std::pair`.\",\"generated_as_correct\":true},{\"text\":\"`std::tuple` похож на `std::pair`, но отличается тем, что позволяет динамически изменять количество хранимых объектов во время выполнения программы. Доступ к элементам осуществляется через индексацию.\",\"generated_as_correct\":false},{\"text\":\"`std::tuple` используется для работы с потоками ввода-вывода в C++, а доступ к его элементам осуществляется через стандартные операции чтения и записи.\",\"generated_as_correct\":false},{\"text\":\"`std::tuple` и `std::pair` не отличаются друг от друга, доступ к элементам `std::tuple` осуществляется через квадратные скобки.\",\"generated_as_correct\":false}],\"question\":\"Чем std::tuple отличается от std::pair и как обеспечивается доступ к элементам std::tuple?\"},{\"answers\":[{\"text\":\"`std::tuple` хранит несколько объектов разных типов с фиксированными типами и размером, что обеспечивает безопасность типов.\",\"generated_as_correct\":true},{\"text\":\"`std::tuple` позволяет хранить несколько объектов, и его размер может изменяться во время выполнения программы, что делает его удобным для работы с переменным количеством данных.\",\"generated_as_correct\":false},{\"text\":\"`std::tuple` применяется для создания сложных структур данных, которые могут быть сериализованы и десериализованы для передачи данных между процессами.\",\"generated_as_correct\":false},{\"text\":\"`std::tuple` позволяет динамически изменять количество и типы хранимых объектов во время выполнения программы.\",\"generated_as_correct\":false}],\"question\":\"Как использование std::tuple может быть полезно при работе с несколькими переменными, и почему важно, что типы элементов и размер кортежа фиксируются на этапе компиляции?\"},{\"answers\":[{\"text\":\"Structured binding позволяет «распаковать» значения из пары, кортежа или структуры в новые переменные.\",\"generated_as_correct\":true},{\"text\":\"Structured binding — это метод шифрования данных, который позволяет упаковывать и распаковывать информацию для безопасного хранения и передачи.\",\"generated_as_correct\":false},{\"text\":\"Structured binding — это концепция в теории баз данных, которая описывает структуру таблиц и связи между ними.\",\"generated_as_correct\":false},{\"text\":\"Structured binding используется для создания сложных структур данных из простых переменных.\",\"generated_as_correct\":false}],\"question\":\"Что такое structured binding в программировании?\"},{\"answers\":[{\"text\":\"Structured binding позволяет легко «распаковать» данные из пар, кортежей или структур в отдельные переменные.\",\"generated_as_correct\":true},{\"text\":\"Structured binding упрощает работу с данными, позволяя объединить несколько переменных в одну структуру без необходимости явного определения типов.\",\"generated_as_correct\":false},{\"text\":\"Structured binding используется для оптимизации памяти при работе с большими объёмами данных в парах, кортежах или структурах.\",\"generated_as_correct\":false},{\"text\":\"Structured binding усложняет доступ к данным в парах, кортежах или структурах, требуя дополнительных усилий для их извлечения.\",\"generated_as_correct\":false}],\"question\":\"Почему использование structured binding упрощает работу с данными в парах, кортежах или структурах?\"},{\"answers\":[{\"text\":\"Structured binding позволяет распаковать значения из кортежа в несколько переменных.\",\"generated_as_correct\":true},{\"text\":\"Structured binding применяется для преобразования кортежа в строку, что позволяет упростить его вывод.\",\"generated_as_correct\":false},{\"text\":\"Structured binding — это метод, который используется для сортировки элементов в кортеже по определённому критерию.\",\"generated_as_correct\":false},{\"text\":\"Structured binding используется для упаковки значений в кортеж.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить structured binding для распаковки значений из кортежа?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.5\"},{\"Name\":\"cpp | 2.6. Ссылки, указатели, константность\",\"Slug\":\"references-pointers-const\",\"createdAt\":\"2024-07-03T17:42:41.487Z\",\"updatedAt\":\"2026-01-10T12:07:11.280Z\",\"publishedAt\":\"2024-07-03T17:42:43.020Z\",\"ContestURL\":null,\"Lead\":\"Ссылки\u0026nbsp;— это псевдонимы для переменных. Указатели хранят адреса других переменных в\u0026nbsp;памяти. Ключевое слово const подчеркивает, что переменная используется только для чтения. Часто оно используется совместно с\u0026nbsp;объявлением ссылок и\u0026nbsp;указателей.\",\"Content\":\"$60\",\"Title\":\"Ссылки, указатели, константность\",\"LikesCount\":27,\"Quiz\":[{\"answers\":[{\"text\":\"Ссылки в C++ — это псевдонимы для уже существующих переменных в памяти.\",\"generated_as_correct\":true},{\"text\":\"Ссылки в C++ используются для создания копий переменных, что позволяет работать с дубликатами данных в разных частях программы.\",\"generated_as_correct\":false},{\"text\":\"Ссылки в C++ тесно связаны с концепцией указателей и используются для динамического распределения памяти.\",\"generated_as_correct\":false},{\"text\":\"Ссылки в C++ позволяют создавать новые переменные и переназначать их в процессе выполнения программы.\",\"generated_as_correct\":false}],\"question\":\"Что такое ссылки в C++ и для чего они используются?\"},{\"answers\":[{\"text\":\"Ссылки в C++ — это псевдонимы для существующих переменных, которые нельзя переназначить.\",\"generated_as_correct\":true},{\"text\":\"Ссылки в C++ представляют собой специальные переменные, которые могут хранить адреса других переменных и изменять их значения напрямую, в то время как самостоятельные переменные хранят свои собственные данные.\",\"generated_as_correct\":false},{\"text\":\"Ссылки в C++ используются для передачи данных по значению, что позволяет оптимизировать работу с памятью и ускорить выполнение программы.\",\"generated_as_correct\":false},{\"text\":\"Ссылки в C++ — это самостоятельные переменные, которые можно переназначать в процессе выполнения программы.\",\"generated_as_correct\":false}],\"question\":\"Чем ссылки в C++ отличаются от самостоятельных переменных?\"},{\"answers\":[{\"text\":\"Ссылки в C++ создают псевдонимы для существующих переменных, обеспечивая доступ к объектам в памяти.\",\"generated_as_correct\":true},{\"text\":\"Ссылки в C++ представляют собой специальные переменные, которые могут динамически изменять свою связь с объектами в памяти и переназначаться на другие объекты по мере необходимости.\",\"generated_as_correct\":false},{\"text\":\"Ссылки в C++ применяются для объявления новых переменных и управления их областью видимости в функции.\",\"generated_as_correct\":false},{\"text\":\"Ссылки в C++ используются для создания новых независимых копий объектов в памяти.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить ссылки в C++ для работы с уже существующими объектами в памяти?\"},{\"answers\":[{\"text\":\"Указатели в C++ — это типы данных для хранения адресов переменных в памяти.\",\"generated_as_correct\":true},{\"text\":\"Указатели в C++ — это константы, которые содержат адреса функций и не могут быть изменены в процессе выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Указатели в C++ используются для объявления массивов и не имеют отношения к адресам переменных в памяти.\",\"generated_as_correct\":false},{\"text\":\"Указатели в C++ — это переменные, которые хранят значения других переменных.\",\"generated_as_correct\":false}],\"question\":\"Что такое указатели в C++?\"},{\"answers\":[{\"text\":\"Указатели в C++ более гибкие, так как их можно переназначать и устанавливать в nullptr.\",\"generated_as_correct\":true},{\"text\":\"Указатели в C++ обеспечивают более быстрый доступ к данным по сравнению со ссылками, потому что они напрямую обращаются к памяти без дополнительных операций.\",\"generated_as_correct\":false},{\"text\":\"Указатели в C++ позволяют оптимизировать использование памяти за счёт более компактного хранения данных по сравнению со ссылками.\",\"generated_as_correct\":false},{\"text\":\"Указатели в C++ более гибкие, потому что они всегда указывают на валидные адреса памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему использование указателей в C++ обеспечивает более гибкий доступ к данным по сравнению со ссылками?\"},{\"answers\":[{\"text\":\"Указатели в C++ хранят адреса переменных в памяти и позволяют гибко работать с данными.\",\"generated_as_correct\":true},{\"text\":\"Указатели в C++ используются исключительно для хранения текстовых строк и не имеют отношения к адресам памяти.\",\"generated_as_correct\":false},{\"text\":\"Указатели в C++ применяются для создания массивов и работы с ними, а также для реализации алгоритмов сортировки.\",\"generated_as_correct\":false},{\"text\":\"Указатели в C++ предназначены для хранения значений переменных и не могут быть переназначены.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить указатели в C++ для работы с адресами памяти?\"},{\"answers\":[{\"text\":\"Ключевое слово `const` в C++ обозначает переменные, которые нельзя изменить после инициализации.\",\"generated_as_correct\":true},{\"text\":\"Ключевое слово `const` в C++ служит для объявления функций, которые не могут изменять состояние объекта, к которому они принадлежат.\",\"generated_as_correct\":false},{\"text\":\"Ключевое слово `const` в C++ связано с управлением доступом к классам и их членам, позволяя определять публичные и приватные методы.\",\"generated_as_correct\":false},{\"text\":\"Ключевое слово `const` в C++ используется для объявления переменных, значения которых могут быть изменены при определённых условиях.\",\"generated_as_correct\":false}],\"question\":\"Что означает использование ключевого слова `const` в C++?\"},{\"answers\":[{\"text\":\"`const` в C++ обозначает переменные как доступные только для чтения, предотвращая их случайное изменение.\",\"generated_as_correct\":true},{\"text\":\"Использование `const` в C++ делает переменные недоступными для чтения, что помогает предотвратить их случайное использование в программе.\",\"generated_as_correct\":false},{\"text\":\"Использование `const` в C++ связано с оптимизацией компилятора и не оказывает влияния на безопасность типов, но может улучшить производительность программы.\",\"generated_as_correct\":false},{\"text\":\"`const` в C++ используется для обозначения переменных, которые можно изменять после инициализации.\",\"generated_as_correct\":false}],\"question\":\"Почему использование `const` может повысить безопасность типов в C++?\"},{\"answers\":[{\"text\":\"`const` в C++ делает переменные доступными только для чтения, предотвращая их случайное изменение.\",\"generated_as_correct\":true},{\"text\":\"Ключевое слово `const` в C++ позволяет объявлять переменные, которые можно изменить с помощью специальных функций, предназначенных для обеспечения безопасности типов.\",\"generated_as_correct\":false},{\"text\":\"Ключевое слово `const` в C++ связано с управлением доступом к функциям и используется для определения методов, которые не могут изменять состояние объекта.\",\"generated_as_correct\":false},{\"text\":\"`const` в C++ используется для временного запрета доступа к переменным, позволяя изменять их после снятия этого запрета.\",\"generated_as_correct\":false}],\"question\":\"Как применение `const` помогает предотвратить случайное изменение значений переменных?\"},{\"answers\":[{\"text\":\"При присваивании в C++ создаётся независимая копия переменной.\",\"generated_as_correct\":true},{\"text\":\"При присваивании одной переменной другой в C++ происходит объединение переменных, и они становятся одной и той же переменной с общим именем.\",\"generated_as_correct\":false},{\"text\":\"При присваивании одной переменной другой в C++ активируется механизм управления памятью, который оптимизирует использование стека и кучи для хранения данных.\",\"generated_as_correct\":false},{\"text\":\"При присваивании в C++ переменные остаются связанными и изменения одной влияют на другую.\",\"generated_as_correct\":false}],\"question\":\"Что происходит при присваивании одной переменной другой в C++?\"},{\"answers\":[{\"text\":\"В C++ при присваивании создаётся новая копия переменной, не связанная с исходной.\",\"generated_as_correct\":true},{\"text\":\"В C++ при присваивании переменных создаётся ссылка на исходную переменную, и любые изменения в копии отражаются на исходной переменной.\",\"generated_as_correct\":false},{\"text\":\"В C++ присваивание переменных отличается от других языков тем, что требует использования специальных ключевых слов для инициализации переменных.\",\"generated_as_correct\":false},{\"text\":\"В C++ при присваивании переменных происходит передача ссылки на исходную переменную.\",\"generated_as_correct\":false}],\"question\":\"Чем отличается присваивание переменных в C++ от некоторых других языков программирования?\"},{\"answers\":[{\"text\":\"Для создания копии переменной в C++ нужны дополнительные ресурсы памяти и времени на копирование данных.\",\"generated_as_correct\":true},{\"text\":\"Для создания копии переменной в C++ требуется только процессорное время, а память остаётся неизменной, так как система автоматически оптимизирует использование ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Для создания копии переменной в C++ важно учитывать тип данных, так как это влияет на способ инициализации и область видимости переменной в программе.\",\"generated_as_correct\":false},{\"text\":\"Создание копии переменной в C++ не требует дополнительных ресурсов, так как происходит ссылка на исходную переменную.\",\"generated_as_correct\":false}],\"question\":\"Какие ресурсы требуются для создания копии переменной в C++ и почему это важно учитывать?\"},{\"answers\":[{\"text\":\"«Висячие» ссылки и указатели возникают при выходе переменной из области видимости.\",\"generated_as_correct\":true},{\"text\":\"«Висячие» ссылки и указатели — это специальные типы данных, которые используются для хранения адресов памяти и автоматически обновляются при изменении переменных.\",\"generated_as_correct\":false},{\"text\":\"«Висячие» ссылки и указатели связаны с алгоритмами сортировки и поиска в структурах данных.\",\"generated_as_correct\":false},{\"text\":\"«Висячие» ссылки и указатели появляются при создании новых переменных в программе.\",\"generated_as_correct\":false}],\"question\":\"Что такое «висячие» ссылки и указатели?\"},{\"answers\":[{\"text\":\"«Висячие» ссылки и указатели ссылаются на несуществующие данные, что приводит к неопределённому поведению.\",\"generated_as_correct\":true},{\"text\":\"«Висячие» ссылки и указатели вызывают определённые ошибки времени выполнения, которые можно легко отследить и исправить с помощью стандартных инструментов отладки.\",\"generated_as_correct\":false},{\"text\":\"«Висячие» ссылки и указатели связаны с проблемами управления памятью, но они не влияют на поведение программы, а только на её производительность.\",\"generated_as_correct\":false},{\"text\":\"«Висячие» ссылки и указатели обеспечивают безопасный доступ к памяти и предотвращают ошибки.\",\"generated_as_correct\":false}],\"question\":\"Почему обращение к памяти через «висячие» ссылки или указатели приводит к неопределённому поведению?\"},{\"answers\":[{\"text\":\"Избежать «висячих» ссылок и указателей можно, контролируя область видимости переменных, на которые они указывают.\",\"generated_as_correct\":true},{\"text\":\"Чтобы избежать «висячих» ссылок и указателей, нужно использовать только константные указатели и ссылки, так как они не могут быть переназначены.\",\"generated_as_correct\":false},{\"text\":\"Чтобы избежать проблем с «висячими» ссылками и указателями, следует использовать сборщик мусора, который автоматически управляет памятью и предотвращает утечки.\",\"generated_as_correct\":false},{\"text\":\"Избежать «висячих» ссылок и указателей можно, используя исключительно статические переменные.\",\"generated_as_correct\":false}],\"question\":\"Как можно избежать ситуаций с «висячими» ссылками и указателями в программах?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.6\"},{\"Name\":\"cpp | 2.7. Функции\",\"Slug\":\"functions\",\"createdAt\":\"2024-07-03T17:44:49.179Z\",\"updatedAt\":\"2026-01-10T12:07:10.875Z\",\"publishedAt\":\"2024-07-03T17:44:50.844Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42071/problem\",\"Lead\":\"Функции позволяют отделить часто используемый код и\u0026nbsp;переиспользовать его с\u0026nbsp;разными значениями аргументов.\",\"Content\":\"$61\",\"Title\":\"Функции\",\"LikesCount\":16,\"Quiz\":[{\"answers\":[{\"text\":\"Функция — это блок кода для выполнения задачи, вызываемый из разных частей программы.\",\"generated_as_correct\":true},{\"text\":\"Функция в программировании — это специальный вид переменной, который автоматически выполняет определённые действия при изменении своего значения.\",\"generated_as_correct\":false},{\"text\":\"Функция в программировании тесно связана с понятием алгоритма и используется для описания последовательности действий, необходимых для решения задачи, но не может быть вызвана из разных частей программы.\",\"generated_as_correct\":false},{\"text\":\"Функция — это комментарий в коде, поясняющий его работу.\",\"generated_as_correct\":false}],\"question\":\"Что такое функция в программировании?\"},{\"answers\":[{\"text\":\"Функции позволяют структурировать код, избегать дублирования и повышать его читаемость за счёт повторного использования и понятных имён.\",\"generated_as_correct\":true},{\"text\":\"Функции в программировании предназначены исключительно для выполнения математических операций и не влияют на структурирование кода или его читаемость. Они не помогают избежать дублирования кода.\",\"generated_as_correct\":false},{\"text\":\"Функции в программировании используются для создания пользовательских интерфейсов и не имеют отношения к дублированию кода или его читаемости.\",\"generated_as_correct\":false},{\"text\":\"Функции усложняют код и делают его менее читаемым из-за необходимости передавать множество аргументов.\",\"generated_as_correct\":false}],\"question\":\"Почему использование функций в программировании помогает избегать дублирования кода и повышать его читаемость?\"},{\"answers\":[{\"text\":\"Функции с аргументами упрощают структуру программы, структурируя код и избегая дублирования.\",\"generated_as_correct\":true},{\"text\":\"Функции с аргументами могут упростить структуру программы, но только если они используются для выполнения однотипных операций без возможности изменения поведения в зависимости от переданных параметров.\",\"generated_as_correct\":false},{\"text\":\"Функции с аргументами важны для работы с базами данных, так как позволяют выполнять запросы и обрабатывать результаты, но их влияние на структуру программы минимально.\",\"generated_as_correct\":false},{\"text\":\"Функции с аргументами усложняют структуру программы из-за необходимости передавать множество параметров.\",\"generated_as_correct\":false}],\"question\":\"Как применение функций с аргументами может упростить структуру программы?\"},{\"answers\":[{\"text\":\"Аргументы функции — это значения, передаваемые функции при вызове.\",\"generated_as_correct\":true},{\"text\":\"Аргументы функции — это переменные, которые создаются внутри функции и используются для хранения промежуточных результатов вычислений.\",\"generated_as_correct\":false},{\"text\":\"Аргументы функции связаны с параметрами функции, которые определяют её поведение, но не влияют на передачу значений при вызове функции.\",\"generated_as_correct\":false},{\"text\":\"Аргументы функции — это результаты, которые функция выдаёт после выполнения.\",\"generated_as_correct\":false}],\"question\":\"Что такое аргументы функции?\"},{\"answers\":[{\"text\":\"Передача по значению создаёт копию, по ссылке — позволяет изменение, по константной ссылке — защищает от изменения.\",\"generated_as_correct\":true},{\"text\":\"Передача аргументов по значению сохраняет исходный аргумент неизменным, передача по ссылке делает аргумент доступным только для чтения, а передача по константной ссылке создаёт новую копию аргумента внутри функции.\",\"generated_as_correct\":false},{\"text\":\"Передача аргументов по значению, по ссылке и по константной ссылке влияет на скорость выполнения функции и объём используемой памяти, но не на возможность изменения аргумента.\",\"generated_as_correct\":false},{\"text\":\"Передача по значению изменяет исходный аргумент, по ссылке создаёт копию, по константной ссылке делает аргумент доступным только для чтения.\",\"generated_as_correct\":false}],\"question\":\"В чём разница между передачей аргументов по значению, по ссылке и по константной ссылке?\"},{\"answers\":[{\"text\":\"Передача по значению создаёт копию, по ссылке — позволяет изменение, по константной ссылке — защищает от изменения.\",\"generated_as_correct\":true},{\"text\":\"Передача аргумента по значению предотвращает любые изменения исходного аргумента, передача по ссылке создаёт неизменяемую копию, а передача по константной ссылке позволяет модифицировать исходный аргумент.\",\"generated_as_correct\":false},{\"text\":\"Выбор способа передачи аргумента влияет на скорость выполнения функции и объём используемой памяти, но не на поведение функции или исходные данные.\",\"generated_as_correct\":false},{\"text\":\"Передача по значению изменяет исходный аргумент, по ссылке создаёт копию, а по константной ссылке предотвращает доступ к аргументу.\",\"generated_as_correct\":false}],\"question\":\"Как выбор способа передачи аргумента (по значению, по ссылке или по константной ссылке) влияет на поведение функции и исходные данные?\"},{\"answers\":[{\"text\":\"Возвращаемое значение функции — это результат её выполнения.\",\"generated_as_correct\":true},{\"text\":\"Возвращаемое значение функции — это имя функции, которое используется для её вызова в программе.\",\"generated_as_correct\":false},{\"text\":\"Возвращаемое значение функции связано с процессом объявления функции и её аргументами, но не имеет отношения к результату выполнения.\",\"generated_as_correct\":false},{\"text\":\"Возвращаемое значение функции — это тип данных, который используется для объявления функции.\",\"generated_as_correct\":false}],\"question\":\"Что такое возвращаемое значение функции?\"},{\"answers\":[{\"text\":\"Функция может возвращать значения любого типа, включая строки и векторы.\",\"generated_as_correct\":true},{\"text\":\"Функция может возвращать исключительно логические значения (true или false) и ничего более.\",\"generated_as_correct\":false},{\"text\":\"Функция может возвращать данные, которые используются для определения области видимости переменных в программе.\",\"generated_as_correct\":false},{\"text\":\"Функция может возвращать только целочисленные значения.\",\"generated_as_correct\":false}],\"question\":\"Какие типы данных может возвращать функция?\"},{\"answers\":[{\"text\":\"Возвращение ссылки на локальную переменную приводит к неопределённому поведению из-за уничтожения переменной после выхода из функции.\",\"generated_as_correct\":true},{\"text\":\"Возвращение ссылки на локальную переменную не приводит к неопределённому поведению, если функция вызывается повторно.\",\"generated_as_correct\":false},{\"text\":\"Возвращение значения функции важно для передачи данных между функциями, но это не связано с неопределённым поведением при работе с локальными переменными.\",\"generated_as_correct\":false},{\"text\":\"Возвращение ссылки на локальную переменную безопасно при использовании статических переменных.\",\"generated_as_correct\":false}],\"question\":\"Почему возвращение ссылки на локальную переменную может привести к неопределённому поведению?\"},{\"answers\":[{\"text\":\"Рекурсивная функция — это функция, которая вызывает сама себя.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивная функция — это функция, которая автоматически вызывает другие функции в своём теле, чтобы решить задачи, которые можно разделить на подзадачи.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивная функция — это метод, используемый в теории графов для определения кратчайших путей между узлами.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивная функция — это функция, которая всегда требует внешнего вызова для своей работы.\",\"generated_as_correct\":false}],\"question\":\"Что такое рекурсивная функция?\"},{\"answers\":[{\"text\":\"Рекурсивные функции полезны для решения задач, разбиваемых на аналогичные подзадачи.\",\"generated_as_correct\":true},{\"text\":\"Рекурсивные функции полезны, потому что они позволяют избежать использования циклов и всегда работают быстрее и эффективнее итеративных решений.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивные функции находят применение в теории графов для определения кратчайших путей и в алгоритмах сортировки, но их основная ценность заключается в возможности визуализации сложных структур данных.\",\"generated_as_correct\":false},{\"text\":\"Рекурсивные функции полезны для выполнения однотипных операций без возможности их разделения на подзадачи.\",\"generated_as_correct\":false}],\"question\":\"Почему рекурсивные функции полезны для решения определённых задач?\"},{\"answers\":[{\"text\":\"Чрезмерное использование рекурсии может привести к переполнению стека.\",\"generated_as_correct\":true},{\"text\":\"При чрезмерном использовании рекурсии возникает проблема бесконечного цикла, которая связана с некорректной работой сборщика мусора.\",\"generated_as_correct\":false},{\"text\":\"При использовании рекурсии важно учитывать сложность алгоритма, так как она может влиять на время выполнения программы и потребление оперативной памяти.\",\"generated_as_correct\":false},{\"text\":\"Чрезмерное использование рекурсии улучшает структуру кода и делает его более читаемым.\",\"generated_as_correct\":false}],\"question\":\"Какие проблемы могут возникнуть при чрезмерном использовании рекурсии?\"},{\"answers\":[{\"text\":\"Функции-компараторы определяют порядок сравнения объектов при сортировке.\",\"generated_as_correct\":true},{\"text\":\"Функции-компараторы — это специальные операторы, которые используются для прямого сравнения значений переменных без использования функций.\",\"generated_as_correct\":false},{\"text\":\"Функции-компараторы используются в математических моделях для прогнозирования временных рядов и анализа данных.\",\"generated_as_correct\":false},{\"text\":\"Функции-компараторы автоматически присваивают значения переменным в процессе выполнения программы.\",\"generated_as_correct\":false}],\"question\":\"Что такое функции-компараторы?\"},{\"answers\":[{\"text\":\"Функции-компараторы позволяют реализовать нестандартный порядок сортировки объектов в коллекциях.\",\"generated_as_correct\":true},{\"text\":\"Функции-компараторы нужны для того, чтобы автоматически изменять значения объектов в коллекции при их сортировке, что делает их полезными для сложных вычислений.\",\"generated_as_correct\":false},{\"text\":\"Функции-компараторы применяются в программировании для определения типа данных объектов в коллекции, что помогает в организации структуры данных.\",\"generated_as_correct\":false},{\"text\":\"Функции-компараторы используются для подсчёта количества объектов в коллекции при сортировке.\",\"generated_as_correct\":false}],\"question\":\"Почему функции-компараторы могут быть полезны при сортировке коллекций объектов?\"},{\"answers\":[{\"text\":\"Функции-компараторы необходимы для сортировки объектов с нестандартным порядком сравнения.\",\"generated_as_correct\":true},{\"text\":\"Функции-компараторы нужны для определения типа данных объектов в коллекциях и автоматического приведения их к общему формату.\",\"generated_as_correct\":false},{\"text\":\"Функции-компараторы используются в алгоритмах машинного обучения для сравнения весов нейронов в процессе обучения.\",\"generated_as_correct\":false},{\"text\":\"Функции-компараторы применяются для подсчёта количества элементов в коллекции.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях использование функций-компараторов может быть необходимо?\"},{\"answers\":[{\"text\":\"Лямбда-функции — это анонимные функции для краткого определения в месте использования.\",\"generated_as_correct\":true},{\"text\":\"Лямбда-функции — это специальные функции, предназначенные исключительно для работы с числовыми данными и требующие предварительного объявления переменных.\",\"generated_as_correct\":false},{\"text\":\"Лямбда-функции используются для создания сложных алгоритмов машинного обучения и не могут быть применены в простых программных конструкциях.\",\"generated_as_correct\":false},{\"text\":\"Лямбда-функции — это сложные структуры данных, требующие предварительного объявления.\",\"generated_as_correct\":false}],\"question\":\"Что такое лямбда-функции?\"},{\"answers\":[{\"text\":\"Лямбда-функции удобны в алгоритмах, так как позволяют быстро определять простые функции без создания именованной функции.\",\"generated_as_correct\":true},{\"text\":\"Лямбда-функции считаются удобными для использования в алгоритмах, потому что они автоматически оптимизируют код и ускоряют выполнение программ.\",\"generated_as_correct\":false},{\"text\":\"Лямбда-функции полезны для создания сложных математических моделей и не имеют отношения к удобству использования в алгоритмах.\",\"generated_as_correct\":false},{\"text\":\"Лямбда-функции сложны в использовании и требуют предварительного объявления перед применением в алгоритмах.\",\"generated_as_correct\":false}],\"question\":\"Почему лямбда-функции считаются удобными для использования в алгоритмах?\"},{\"answers\":[{\"text\":\"Лямбда-функции полезны для быстрого определения простых функций в алгоритмах сравнения или преобразования.\",\"generated_as_correct\":true},{\"text\":\"Лямбда-функции применяются преимущественно для работы с базами данных и взаимодействия с внешними API, так как позволяют упростить эти процессы.\",\"generated_as_correct\":false},{\"text\":\"Лямбда-функции используются для создания графических интерфейсов и визуализации данных, поскольку их анонимный характер облегчает работу с визуальными элементами.\",\"generated_as_correct\":false},{\"text\":\"Лямбда-функции применяются для создания сложных структур данных и управления потоками выполнения программы.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение лямбда-функций может быть особенно полезным?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.7\"},{\"Name\":\"cpp | 2.8. Шаблоны\",\"Slug\":\"templates\",\"createdAt\":\"2024-07-03T17:45:43.282Z\",\"updatedAt\":\"2026-01-10T12:07:11.480Z\",\"publishedAt\":\"2024-07-03T17:45:44.717Z\",\"ContestURL\":null,\"Lead\":\"Шаблоны\u0026nbsp;— это фрагменты обобщённого кода, в\u0026nbsp;котором некоторые типы или константы вынесены в\u0026nbsp;параметры. Шаблоны позволяют писать общий код, пригодный для использования с\u0026nbsp;разными типами данных.\",\"Content\":\"$62\",\"Title\":\"Шаблоны\",\"LikesCount\":16,\"Quiz\":[{\"answers\":[{\"text\":\"Шаблоны в C++ — это механизм для написания обобщённого кода, который можно использовать с разными типами данных.\",\"generated_as_correct\":true},{\"text\":\"Шаблоны в C++ — это предопределённые блоки кода, которые можно использовать только с определёнными типами данных и не поддерживают параметризацию.\",\"generated_as_correct\":false},{\"text\":\"Шаблоны в C++ используются для создания графических интерфейсов и визуализации данных, они помогают структурировать код для работы с пользовательским вводом.\",\"generated_as_correct\":false},{\"text\":\"Шаблоны в C++ — это встроенные функции для работы с конкретными типами данных, которые нельзя параметризовать.\",\"generated_as_correct\":false}],\"question\":\"Что такое шаблоны в C++ и для чего они используются?\"},{\"answers\":[{\"text\":\"Шаблоны в C++ позволяют писать общий код для разных типов данных, что способствует его переиспользованию и гибкости.\",\"generated_as_correct\":true},{\"text\":\"Шаблоны в C++ представляют собой готовые блоки кода, которые можно использовать только для определённых типов данных, что ограничивает их гибкость и возможность переиспользования.\",\"generated_as_correct\":false},{\"text\":\"Шаблоны в C++ используются для создания графических интерфейсов и не имеют отношения к переиспользованию кода или его гибкости.\",\"generated_as_correct\":false},{\"text\":\"Шаблоны в C++ предназначены для создания уникальных алгоритмов, которые нельзя использовать с разными типами данных.\",\"generated_as_correct\":false}],\"question\":\"Почему использование шаблонов в C++ способствует переиспользованию кода и его гибкости?\"},{\"answers\":[{\"text\":\"Шаблоны в C++ позволяют писать общий код для разных типов данных, способствуя переиспользованию и гибкости.\",\"generated_as_correct\":true},{\"text\":\"Шаблоны в C++ используются исключительно для определения констант и не могут быть применены для создания алгоритмов или структур данных.\",\"generated_as_correct\":false},{\"text\":\"Шаблоны в C++ применяются для создания графических интерфейсов и не имеют отношения к алгоритмам или структурам данных.\",\"generated_as_correct\":false},{\"text\":\"Шаблоны в C++ предназначены только для работы с числовыми типами данных и не могут быть использованы для создания обобщённых алгоритмов.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить шаблоны для создания обобщённых алгоритмов и структур данных в C++?\"},{\"answers\":[{\"text\":\"Стандартная библиотека C++ (STL) содержит контейнеры, итераторы и алгоритмы на основе шаблонов.\",\"generated_as_correct\":true},{\"text\":\"Стандартная библиотека C++ (STL) состоит из предопределённых переменных и констант, которые используются для упрощения математических вычислений.\",\"generated_as_correct\":false},{\"text\":\"Стандартная библиотека C++ (STL) предоставляет инструменты для работы с графическим интерфейсом пользователя и сетевыми соединениями.\",\"generated_as_correct\":false},{\"text\":\"Стандартная библиотека C++ (STL) включает в себя только функции для работы с файлами и потоками ввода-вывода.\",\"generated_as_correct\":false}],\"question\":\"Что включает в себя Стандартная библиотека C++ (STL)?\"},{\"answers\":[{\"text\":\"Шаблоны в STL упрощают программирование, предоставляя готовые контейнеры и алгоритмы для работы с данными.\",\"generated_as_correct\":true},{\"text\":\"Шаблоны в STL упрощают процесс программирования за счёт автоматического создания оптимизированных алгоритмов для каждой задачи без необходимости их дополнительной настройки.\",\"generated_as_correct\":false},{\"text\":\"Шаблоны в STL важны для обеспечения совместимости различных библиотек и фреймворков, что способствует более лёгкому внедрению новых технологий в существующие проекты.\",\"generated_as_correct\":false},{\"text\":\"Шаблоны в STL усложняют программирование из-за необходимости вручную настраивать каждый алгоритм под конкретные задачи.\",\"generated_as_correct\":false}],\"question\":\"Почему использование шаблонов в STL упрощает процесс программирования?\"},{\"answers\":[{\"text\":\"STL предоставляет готовые контейнеры, итераторы и алгоритмы, упрощающие работу с данными и повышающие эффективность программирования.\",\"generated_as_correct\":true},{\"text\":\"Контейнеры, итераторы и алгоритмы из STL предназначены исключительно для образовательных целей и не применяются в реальных проектах, так как их использование не приносит ощутимой пользы для повышения эффективности программирования.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры, итераторы и алгоритмы из STL играют важную роль в оптимизации памяти и улучшении производительности аппаратного обеспечения, что косвенно влияет на эффективность программирования.\",\"generated_as_correct\":false},{\"text\":\"STL ограничивает возможности программиста, так как использование её контейнеров и алгоритмов требует отказа от написания собственного кода для работы с данными.\",\"generated_as_correct\":false}],\"question\":\"Как применение контейнеров, итераторов и алгоритмов из STL может повысить эффективность программирования?\"},{\"answers\":[{\"text\":\"Перегрузка функций в C++ — это создание функций с одинаковым именем, но разными аргументами.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка функций в языке C++ позволяет создавать функции с одинаковыми именами и одинаковыми аргументами, но разным количеством параметров.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка функций в языке C++ связана с возможностью изменять имена функций в зависимости от контекста их использования.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка функций в C++ — это изменение типа возвращаемого значения функции при сохранении её имени и аргументов.\",\"generated_as_correct\":false}],\"question\":\"Что такое перегрузка функций в языке C++?\"},{\"answers\":[{\"text\":\"Перегрузка функций позволяет использовать одно имя для функций с разными аргументами, что упрощает код.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка функций делает код менее читаемым, так как усложняет поиск нужных функций из-за использования одинаковых имён для разных операций.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка функций связана с возможностью изменения типа возвращаемого значения функции, что позволяет адаптировать функции под различные условия использования.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка функций усложняет код, так как требует использования разных имён для похожих операций.\",\"generated_as_correct\":false}],\"question\":\"Почему перегрузка функций делает код более читаемым и удобным в использовании?\"},{\"answers\":[{\"text\":\"Перегрузка функций в C++ — это создание функций с одинаковым именем, но разными аргументами, нельзя перегружать по типу возвращаемого значения.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка функций в C++ позволяет использовать одно и то же имя функции для разных задач, при этом возможно перегружать функции по количеству аргументов и по типу возвращаемого значения.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка функций в C++ связана с возможностью изменения порядка аргументов в функции, что позволяет более гибко использовать функции в коде.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка функций в C++ позволяет создавать функции с одинаковым именем и аргументами, но разным типом возвращаемого значения.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать перегрузку функций в программировании на C++ и какие ограничения при этом существуют?\"},{\"answers\":[{\"text\":\"Шаблонные функции позволяют одной функции работать с разными типами данных.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные функции используются для создания строго типизированных функций, которые могут работать только с одним конкретным типом данных.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные функции применяются для организации циклов и итераций по коллекциям данных в программировании.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные функции предназначены для работы исключительно с числовыми типами данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое шаблонные функции и для чего они используются в программировании?\"},{\"answers\":[{\"text\":\"Шаблонные функции упрощают код, позволяя одной функции работать с разными типами данных.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные функции предназначены исключительно для работы с определённым типом данных, что ограничивает их применение и требует написания отдельных функций для разных типов.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные функции используются для создания графических интерфейсов и не влияют на процесс написания основного кода программы.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные функции усложняют код, требуя для каждого типа данных отдельной реализации.\",\"generated_as_correct\":false}],\"question\":\"Каким образом использование шаблонных функций упрощает процесс написания кода?\"},{\"answers\":[{\"text\":\"Шаблонные функции описывают функцию один раз с типом в параметрах, позволяя ей работать с разными типами данных.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные функции автоматически определяют типы данных на этапе выполнения программы и адаптируют код под них.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные функции используются для создания статических библиотек, которые могут быть включены в различные проекты без изменений.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные функции работают только с определённым типом данных, который задаётся при их объявлении.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить шаблонные функции для работы с различными типами данных в одном и том же коде?\"},{\"answers\":[{\"text\":\"Конкретные версии шаблонной функции создаются подстановкой аргументов в угловые скобки, компилятор выводит параметры по типу аргументов.\",\"generated_as_correct\":true},{\"text\":\"Конкретные версии шаблонной функции формируются путём изменения имён функций в зависимости от типа данных, которые они обрабатывают.\",\"generated_as_correct\":false},{\"text\":\"Конкретные версии шаблонной функции зависят от порядка объявления переменных в блоке кода и их области видимости.\",\"generated_as_correct\":false},{\"text\":\"Конкретные версии шаблонной функции определяются путём изменения типов возвращаемых значений функции.\",\"generated_as_correct\":false}],\"question\":\"Как получаются конкретные версии шаблонной функции?\"},{\"answers\":[{\"text\":\"Автоматическое выведение параметров шаблона упрощает использование шаблонов, позволяя компилятору определять версии функций по типам аргументов.\",\"generated_as_correct\":true},{\"text\":\"Возможность компилятора автоматически выводить параметры шаблона упрощает использование шаблонов, потому что программисту больше не нужно заботиться о типах данных, и компилятор автоматически преобразует все переменные в универсальный тип.\",\"generated_as_correct\":false},{\"text\":\"Возможность компилятора автоматически выводить параметры шаблона улучшает производительность программы, так как это позволяет оптимизировать выполнение шаблонных функций в процессе компиляции.\",\"generated_as_correct\":false},{\"text\":\"Автоматическое выведение параметров шаблона усложняет использование шаблонов, требуя от программиста дополнительных усилий для указания типов аргументов.\",\"generated_as_correct\":false}],\"question\":\"Почему возможность компилятора автоматически выводить параметры шаблона упрощает использование шаблонов?\"},{\"answers\":[{\"text\":\"Механизм вывода шаблонных параметров упрощает использование шаблонов, позволяя компилятору автоматически определять параметры по типу аргументов.\",\"generated_as_correct\":true},{\"text\":\"Механизм вывода шаблонных параметров позволяет компилятору автоматически определять параметры шаблона по количеству аргументов, что упрощает использование шаблонов и улучшает читаемость кода.\",\"generated_as_correct\":false},{\"text\":\"Механизм вывода шаблонных параметров связан с оптимизацией работы компилятора и не влияет на читаемость кода, но помогает ускорить процесс компиляции.\",\"generated_as_correct\":false},{\"text\":\"Механизм вывода шаблонных параметров требует от программиста вручную указывать все параметры шаблона, что усложняет код.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях можно использовать механизм вывода шаблонных параметров для улучшения читаемости кода?\"},{\"answers\":[{\"text\":\"Перегрузка шаблонных функций позволяет создавать разные версии функции для работы с различными типами данных.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка шаблонных функций — это процесс создания новых функций с уникальными именами для работы с различными типами данных, что требует явного указания типа данных при вызове функции.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка шаблонных функций связана с использованием алгоритмов сортировки для упорядочивания данных в структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка шаблонных функций означает использование одной функции для всех типов данных без возможности адаптации.\",\"generated_as_correct\":false}],\"question\":\"Что означает перегрузка шаблонных функций в программировании?\"},{\"answers\":[{\"text\":\"Перегрузка шаблонных функций даёт возможность адаптировать функции под разные типы данных, увеличивая гибкость кода.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка шаблонных функций увеличивает сложность кода, так как требует написания отдельных функций для каждого возможного типа данных, что на самом деле снижает гибкость и универсальность кода.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка шаблонных функций связана с улучшением читаемости кода, поскольку позволяет использовать более понятные имена функций, что косвенно влияет на гибкость и универсальность.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка шаблонных функций уменьшает гибкость кода, так как ограничивает использование функций определёнными типами данных.\",\"generated_as_correct\":false}],\"question\":\"Почему перегрузка шаблонных функций увеличивает гибкость и универсальность кода?\"},{\"answers\":[{\"text\":\"Перегрузка шаблонных функций позволяет создавать разные версии функций для различных типов данных.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка шаблонных функций используется для создания единого алгоритма, который автоматически подбирает наиболее подходящий тип данных для выполнения операции без учёта специфики каждого типа.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка шаблонных функций применяется для оптимизации работы с памятью и улучшения производительности программ, но не влияет на адаптацию поведения функций в зависимости от типа данных.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка шаблонных функций требует создания единой версии функции, которая подходит для всех типов данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать перегрузку шаблонных функций для адаптации поведения функций в зависимости от типа данных?\"},{\"answers\":[{\"text\":\"Разрешение неоднозначностей — это процесс определения подходящей версии функции компилятором на основе контекста её вызова.\",\"generated_as_correct\":true},{\"text\":\"Разрешение неоднозначностей в контексте вызова функций в программировании — это механизм, который позволяет программисту вручную указывать компилятору, какую версию функции использовать в каждом конкретном случае.\",\"generated_as_correct\":false},{\"text\":\"Разрешение неоднозначностей в контексте вызова функций в программировании связано с определением порядка выполнения операторов в выражении и не зависит от анализа контекста вызова функции.\",\"generated_as_correct\":false},{\"text\":\"Разрешение неоднозначностей — это автоматическое создание новых функций при обнаружении конфликта имён в разных пространствах имён.\",\"generated_as_correct\":false}],\"question\":\"Что такое разрешение неоднозначностей в контексте вызова функций в программировании?\"},{\"answers\":[{\"text\":\"Разрешение неоднозначностей сложно, так как требует анализа контекста вызова функции для выбора правильной версии.\",\"generated_as_correct\":true},{\"text\":\"Процесс разрешения неоднозначностей сложен из-за необходимости вручную указывать компилятору, в каком пространстве имён искать функцию и какие параметры использовать, что требует глубоких знаний программиста.\",\"generated_as_correct\":false},{\"text\":\"Процесс разрешения неоднозначностей связан с оптимизацией кода и включает в себя минимизацию использования памяти и повышение скорости выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Разрешение неоднозначностей просто, поскольку компилятор автоматически выбирает наиболее подходящую функцию без анализа контекста.\",\"generated_as_correct\":false}],\"question\":\"Почему процесс разрешения неоднозначностей считается сложным и что он включает в себя?\"},{\"answers\":[{\"text\":\"Компилятор анализирует контекст вызова функции, чтобы разрешить неоднозначности и выбрать правильную версию функции.\",\"generated_as_correct\":true},{\"text\":\"Компилятор определяет версию функции исключительно на основе имени функции, не анализируя контекст вызова или параметры.\",\"generated_as_correct\":false},{\"text\":\"Компилятор использует анализ контекста вызова функции для оптимизации производительности программы, не связывая это с выбором версии функции.\",\"generated_as_correct\":false},{\"text\":\"Компилятор выбирает версию функции на основе количества аргументов, игнорируя контекст вызова и пространство имён.\",\"generated_as_correct\":false}],\"question\":\"Как компилятор использует анализ контекста вызова функции для выбора подходящей версии функции?\"},{\"answers\":[{\"text\":\"Шаблонные структуры — это обобщённые структуры данных в программировании, параметризованные типами или константами времени компиляции.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные структуры в программировании — это специальные функции, которые позволяют выполнять динамическое создание объектов различных классов во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные структуры в программировании используются для создания графических интерфейсов и визуализации данных, они не имеют отношения к работе с типами данных.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные структуры — это предопределённые массивы данных, которые используются для хранения информации в программах.\",\"generated_as_correct\":false}],\"question\":\"Что такое шаблонные структуры в программировании?\"},{\"answers\":[{\"text\":\"Шаблонные структуры обеспечивают гибкость кода, позволяя создавать обобщённые решения, которые можно применять с разными типами данных.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные структуры предназначены исключительно для работы с определёнными типами данных и не позволяют переиспользовать код в других контекстах.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные структуры используются для оптимизации производительности программ путём минимизации количества операций во время выполнения, что косвенно влияет на переиспользование кода.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные структуры фиксируют типы данных, с которыми работает код, что ограничивает его переиспользование.\",\"generated_as_correct\":false}],\"question\":\"Почему использование шаблонных структур способствует переиспользованию кода?\"},{\"answers\":[{\"text\":\"Шаблонные структуры обеспечивают гибкость кода, позволяя работать с разными типами данных через параметризацию.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные структуры используются для создания статических данных, которые не могут изменяться в процессе выполнения программы, что делает их непригодными для работы с различными типами данных.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные структуры применяются для оптимизации алгоритмов сортировки и поиска, что позволяет ускорить обработку данных в больших массивах.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные структуры предназначены только для работы с числовыми типами данных и не поддерживают параметризацию.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить шаблонные структуры для работы с различными типами данных?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.8\"},{\"Name\":\"cpp | 2.9. Разбор задач к разделу «Базовые конструкции C++»\",\"Slug\":\"basic-cpp-constructions\",\"createdAt\":\"2024-07-03T17:46:45.640Z\",\"updatedAt\":\"2026-01-10T12:07:10.108Z\",\"publishedAt\":\"2024-07-03T17:46:47.225Z\",\"ContestURL\":null,\"Lead\":\"В\u0026nbsp;этом параграфе мы\u0026nbsp;разберём задачи к\u0026nbsp;главе «Базовые конструкции C\\\\+\\\\+».\",\"Content\":\"$63\",\"Title\":\"Разбор задач к главе «Базовые конструкции C++»\",\"LikesCount\":25,\"Quiz\":[{\"answers\":[{\"text\":\"Строковый литерал в C++ — это текст в двойных кавычках.\",\"generated_as_correct\":true},{\"text\":\"Строковый литерал в C++ — это числовое значение, которое представляется в виде последовательности цифр, заключённой в двойные кавычки.\",\"generated_as_correct\":false},{\"text\":\"Строковый литерал в C++ связан с операциями ввода-вывода и используется для форматирования числовых данных.\",\"generated_as_correct\":false},{\"text\":\"Строковый литерал в C++ — это набор символов, заключённый в квадратные скобки.\",\"generated_as_correct\":false}],\"question\":\"Что такое строковый литерал в C++?\"},{\"answers\":[{\"text\":\"Строковые литералы в C++ используют двойные кавычки для обозначения текстовых данных.\",\"generated_as_correct\":true},{\"text\":\"Строковые литералы в C++ заключены в двойные кавычки, так как это необходимо для выполнения арифметических операций над строками.\",\"generated_as_correct\":false},{\"text\":\"Строковые литералы в C++ заключены в двойные кавычки, что связано с особенностями хранения данных в оперативной памяти и алгоритмами сортировки строк.\",\"generated_as_correct\":false},{\"text\":\"Строковые литералы в C++ заключены в квадратные скобки для обозначения текстовых данных.\",\"generated_as_correct\":false}],\"question\":\"Почему строковые литералы в C++ заключены в двойные кавычки?\"},{\"answers\":[{\"text\":\"Строковые литералы в C++ — это текстовые данные в двойных кавычках, используемые для вывода текста и инициализации переменных.\",\"generated_as_correct\":true},{\"text\":\"Строковые литералы в C++ используются исключительно для хранения числовых значений и не могут быть применены для работы с текстом.\",\"generated_as_correct\":false},{\"text\":\"Строковые литералы в C++ тесно связаны с понятием указателей и используются для динамического выделения памяти под текстовые данные.\",\"generated_as_correct\":false},{\"text\":\"Строковые литералы в C++ применяются для хранения и обработки числовых данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать строковые литералы в программах на C++?\"},{\"answers\":[{\"text\":\"Перевод строки в C++ обозначается как `\\\\n` и используется для разделения строк в выводе.\",\"generated_as_correct\":true},{\"text\":\"Перевод строки в C++ — это функция, которая используется для перемещения курсора на следующую строку при выводе текста. Она обозначается как `nextLine()`.\",\"generated_as_correct\":false},{\"text\":\"Перевод строки в C++ связан с управлением памятью и выделением блоков для хранения данных в строковом формате.\",\"generated_as_correct\":false},{\"text\":\"Перевод строки в C++ обозначается как `\\\\s` и используется для добавления пробела между словами.\",\"generated_as_correct\":false}],\"question\":\"Что такое перевод строки в C++ и как он обозначается?\"},{\"answers\":[{\"text\":\"Символ перевода строки (`\\\\n`) нужен для разделения текста на строки в консольных приложениях.\",\"generated_as_correct\":true},{\"text\":\"Символ перевода строки важен при форматировании вывода в консольных приложениях, потому что он изменяет цвет текста, делая его более заметным для пользователя.\",\"generated_as_correct\":false},{\"text\":\"Символ перевода строки играет важную роль в алгоритмах сортировки данных в консольных приложениях, помогая упорядочивать информацию по определённым критериям.\",\"generated_as_correct\":false},{\"text\":\"Символ перевода строки используется в консольных приложениях для увеличения размера шрифта выводимого текста.\",\"generated_as_correct\":false}],\"question\":\"Почему символ перевода строки важен при форматировании вывода в консольных приложениях?\"},{\"answers\":[{\"text\":\"Символ `\\\\n` в C++ используется для разделения текста на несколько строк при выводе.\",\"generated_as_correct\":true},{\"text\":\"Символ перевода строки используется в C++ для выделения жирным шрифтом текста, который следует за ним.\",\"generated_as_correct\":false},{\"text\":\"Символ перевода строки важен для работы с файлами в C++, он используется для определения начала нового абзаца при записи данных в файл.\",\"generated_as_correct\":false},{\"text\":\"Символ перевода строки в C++ используется для добавления табуляции между элементами вывода.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать символ перевода строки для организации вывода данных в виде нескольких строк?\"},{\"answers\":[{\"text\":\"`int` — это целочисленный тип данных в C++.\",\"generated_as_correct\":true},{\"text\":\"`int` — это тип данных в C++, который используется для хранения дробных чисел и выполнения операций с плавающей точкой.\",\"generated_as_correct\":false},{\"text\":\"`int` — это специальный тип данных в C++, который используется для определения интерфейсов и взаимодействия между различными компонентами программы.\",\"generated_as_correct\":false},{\"text\":\"`int` — это тип данных в C++ для хранения вещественных чисел.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой тип данных `int` в C++?\"},{\"answers\":[{\"text\":\"`int` — целочисленный тип данных в C++, удобен для арифметических операций и хранения счётчиков.\",\"generated_as_correct\":true},{\"text\":\"`int` — это тип данных в C++, который используется для хранения дробных чисел и часто применяется для выполнения арифметических операций и хранения счётчиков.\",\"generated_as_correct\":false},{\"text\":\"`int` — это целочисленный тип данных в C++, который используется для определения размера массивов и не применяется для выполнения арифметических операций или хранения счётчиков.\",\"generated_as_correct\":false},{\"text\":\"`int` — тип данных в C++, используется для хранения вещественных чисел и выполнения арифметических операций.\",\"generated_as_correct\":false}],\"question\":\"Почему тип данных `int` часто используется для выполнения арифметических операций и хранения счётчиков?\"},{\"answers\":[{\"text\":\"`int` — это целочисленный тип данных в C++, используемый для арифметических операций и хранения счётчиков.\",\"generated_as_correct\":true},{\"text\":\"Тип данных `int` в C++ применяется исключительно для хранения текстовых данных и не используется для арифметических операций.\",\"generated_as_correct\":false},{\"text\":\"Тип данных `int` в C++ связан с управлением памятью и используется для выделения и освобождения памяти под массивы и другие структуры данных.\",\"generated_as_correct\":false},{\"text\":\"`int` — это тип данных в C++, который используется для хранения вещественных чисел и выполнения операций с плавающей точкой.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить тип данных `int` в программировании для работы с целыми числами?\"},{\"answers\":[{\"text\":\"Арифметическая прогрессия — это последовательность чисел с постоянным шагом между ними.\",\"generated_as_correct\":true},{\"text\":\"Арифметическая прогрессия — это последовательность чисел, в которой каждый член равен сумме всех предыдущих членов.\",\"generated_as_correct\":false},{\"text\":\"Арифметическая прогрессия тесно связана с геометрической прогрессией и используется для вычисления сложных процентов в финансовых задачах.\",\"generated_as_correct\":false},{\"text\":\"Арифметическая прогрессия — это последовательность чисел, где каждый член получается путём деления предыдущего на постоянное значение.\",\"generated_as_correct\":false}],\"question\":\"Что такое арифметическая прогрессия?\"},{\"answers\":[{\"text\":\"Формула суммы первых n членов арифметической прогрессии используется для вычисления суммы последовательности чисел с постоянным шагом и применяется в задачах программирования.\",\"generated_as_correct\":true},{\"text\":\"Формула суммы первых n членов арифметической прогрессии применяется для определения среднего арифметического значений в последовательности и используется в задачах программирования для сортировки данных.\",\"generated_as_correct\":false},{\"text\":\"Формула суммы первых n членов арифметической прогрессии тесно связана с алгоритмами поиска и сортировки и используется для оптимизации работы с массивами данных в программировании.\",\"generated_as_correct\":false},{\"text\":\"Формула суммы первых n членов арифметической прогрессии используется для определения количества элементов в последовательности в задачах программирования.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать формулу суммы первых n членов арифметической прогрессии в задачах программирования?\"},{\"answers\":[{\"text\":\"Разность прогрессии показывает, на сколько увеличивается или уменьшается каждое следующее число в арифметической прогрессии.\",\"generated_as_correct\":true},{\"text\":\"Разность прогрессии задаёт интервал, через который чередуются чётные и нечётные числа в арифметической прогрессии.\",\"generated_as_correct\":false},{\"text\":\"Разность прогрессии используется для определения количества членов в арифметической прогрессии и не влияет на изменение значений чисел в последовательности.\",\"generated_as_correct\":false},{\"text\":\"Разность прогрессии определяет, во сколько раз увеличивается каждое следующее число в арифметической прогрессии.\",\"generated_as_correct\":false}],\"question\":\"Каким образом разность прогрессии влияет на последовательность чисел в арифметической прогрессии?\"},{\"answers\":[{\"text\":\"`double` — тип данных в C++ для хранения чисел с дробной частью.\",\"generated_as_correct\":true},{\"text\":\"`double` — это тип данных в C++, который используется для хранения строк и текстовых данных, а не чисел.\",\"generated_as_correct\":false},{\"text\":\"`double` — это функция в C++, которая используется для вывода данных на экран.\",\"generated_as_correct\":false},{\"text\":\"`double` — тип данных в C++ для хранения целых чисел.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой тип данных `double` в C++?\"},{\"answers\":[{\"text\":\"`double` — тип данных в C++, подходящий для операций с высокой точностью благодаря возможности хранения чисел с дробной частью.\",\"generated_as_correct\":true},{\"text\":\"Тип данных `double` в C++ обеспечивает высокую точность за счёт использования фиксированного количества знаков после запятой, что делает его идеальным для всех видов вычислений.\",\"generated_as_correct\":false},{\"text\":\"Тип данных `double` в C++ используется для определения размера массивов и управления циклами, что не связано напрямую с высокой точностью вычислений.\",\"generated_as_correct\":false},{\"text\":\"`double` — это целочисленный тип данных в C++, который не подходит для операций, требующих высокой точности.\",\"generated_as_correct\":false}],\"question\":\"Почему тип данных `double` подходит для выполнения операций, требующих высокой точности?\"},{\"answers\":[{\"text\":\"Тип данных `double` используется для хранения чисел с дробной частью и обеспечивает высокую точность вычислений.\",\"generated_as_correct\":true},{\"text\":\"Тип данных `double` в C++ применяется для хранения текстовых данных и используется в ситуациях, когда необходимо обрабатывать большие объёмы символьной информации.\",\"generated_as_correct\":false},{\"text\":\"Тип данных `double` в C++ связан с управлением памятью и используется для выделения динамической памяти под массивы и другие структуры данных.\",\"generated_as_correct\":false},{\"text\":\"Тип данных `double` применяется для хранения целых чисел и обеспечивает быструю скорость вычислений.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях целесообразно использовать тип данных `double` при программировании?\"},{\"answers\":[{\"text\":\"Переполнение типа данных — это превышение максимально возможного значения переменной своего типа.\",\"generated_as_correct\":true},{\"text\":\"Переполнение типа данных — это процесс автоматического преобразования типа данных переменной при превышении её значения, который позволяет избежать ошибок в вычислениях.\",\"generated_as_correct\":false},{\"text\":\"Переполнение типа данных связано с проблемами при форматировании данных в базах данных и не влияет на вычисления в программе.\",\"generated_as_correct\":false},{\"text\":\"Переполнение типа данных — это ошибка, возникающая при делении на ноль.\",\"generated_as_correct\":false}],\"question\":\"Что такое переполнение типа данных?\"},{\"answers\":[{\"text\":\"Переполнение типа данных приводит к ошибкам и некорректным результатам из-за превышения максимального значения переменной.\",\"generated_as_correct\":true},{\"text\":\"Переполнение типа данных вызывает автоматическое преобразование типа данных переменной к более ёмкому типу, что гарантирует корректность вычислений.\",\"generated_as_correct\":false},{\"text\":\"Переполнение типа данных связано с проблемами распределения памяти и может вызвать утечку памяти в программе.\",\"generated_as_correct\":false},{\"text\":\"Переполнение типа данных способствует улучшению точности вычислений за счёт автоматического округления значений.\",\"generated_as_correct\":false}],\"question\":\"К каким последствиям может привести переполнение типа данных в программе?\"},{\"answers\":[{\"text\":\"Для предотвращения переполнения типа данных нужно выбирать подходящий тип данных с учётом диапазона значений.\",\"generated_as_correct\":true},{\"text\":\"Для предотвращения переполнения типа данных достаточно увеличить размер переменной, не обращая внимания на выбранный тип данных.\",\"generated_as_correct\":false},{\"text\":\"Переполнение типа данных можно предотвратить, используя алгоритмы сжатия данных для уменьшения объёма информации, хранящейся в переменных.\",\"generated_as_correct\":false},{\"text\":\"Переполнение типа данных предотвращается автоматическим преобразованием типов данных в процессе выполнения программы.\",\"generated_as_correct\":false}],\"question\":\"Как можно предотвратить переполнение типа данных при работе с переменными?\"},{\"answers\":[{\"text\":\"Ветвления и циклы — конструкции в программировании для управления выполнением кода в зависимости от условий и для повторения блоков кода.\",\"generated_as_correct\":true},{\"text\":\"Ветвления и циклы — это специальные команды в программировании, которые автоматически выполняют код без учёта каких-либо условий или повторений.\",\"generated_as_correct\":false},{\"text\":\"Ветвления и циклы — это концепции в программировании, связанные с созданием пользовательских интерфейсов и обработкой графических данных.\",\"generated_as_correct\":false},{\"text\":\"Ветвления и циклы — это функции в программировании, предназначенные для вывода данных и взаимодействия с пользователем.\",\"generated_as_correct\":false}],\"question\":\"Что такое ветвления и циклы в программировании и для чего они используются?\"},{\"answers\":[{\"text\":\"Ветвления выполняют код по условию, циклы — многократно.\",\"generated_as_correct\":true},{\"text\":\"Ветвления и циклы в программировании выполняют одну и ту же функцию — обеспечивают последовательное выполнение инструкций без учёта условий.\",\"generated_as_correct\":false},{\"text\":\"Ветвления и циклы в программировании тесно связаны с понятием переменных и используются для хранения данных в памяти.\",\"generated_as_correct\":false},{\"text\":\"Ветвления используются для многократного выполнения кода, циклы — для однократного.\",\"generated_as_correct\":false}],\"question\":\"Чем отличаются ветвления от циклов в программировании?\"},{\"answers\":[{\"text\":\"Ветвления позволяют выполнять разные блоки кода в зависимости от условий, а циклы — многократно выполнять один и тот же блок кода.\",\"generated_as_correct\":true},{\"text\":\"Ветвления и циклы в программировании применяются для автоматического изменения исходного кода программы в зависимости от внешних условий, причём ветвления отвечают за повторение кода, а циклы — за его однократное выполнение при определённых условиях.\",\"generated_as_correct\":false},{\"text\":\"Ветвления и циклы используются в программировании для оптимизации хранения данных и улучшения структуры баз данных, что позволяет более эффективно управлять большими объёмами информации.\",\"generated_as_correct\":false},{\"text\":\"Ветвления используются для многократного выполнения блоков кода, а циклы — для выполнения различных блоков кода без учёта условий.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить ветвления и циклы для решения задачи, требующей выполнения различных действий в зависимости от условий?\"},{\"answers\":[{\"text\":\"В прямоугольном треугольнике квадрат гипотенузы равен сумме квадратов катетов.\",\"generated_as_correct\":true},{\"text\":\"Теорема Пифагора утверждает, что в прямоугольном треугольнике сумма длин катетов равна длине гипотенузы.\",\"generated_as_correct\":false},{\"text\":\"Теорема Пифагора используется для определения площади круга через радиус.\",\"generated_as_correct\":false},{\"text\":\"В любом треугольнике квадрат гипотенузы равен разности квадратов катетов.\",\"generated_as_correct\":false}],\"question\":\"Как формулируется теорема Пифагора?\"},{\"answers\":[{\"text\":\"Теорема Пифагора применима только к прямоугольным треугольникам из-за наличия прямого угла.\",\"generated_as_correct\":true},{\"text\":\"Теорема Пифагора применима ко всем треугольникам, так как она описывает общее свойство треугольников, независимо от величины их углов.\",\"generated_as_correct\":false},{\"text\":\"Теорема Пифагора используется для вычисления площади треугольника через длины его сторон, что делает её применимой ко всем типам треугольников.\",\"generated_as_correct\":false},{\"text\":\"Теорема Пифагора применима к любым треугольникам, если известна длина гипотенузы.\",\"generated_as_correct\":false}],\"question\":\"Почему теорема Пифагора применима только к прямоугольным треугольникам?\"},{\"answers\":[{\"text\":\"Теорема Пифагора применяется в тригонометрии и программировании для работы с прямоугольными треугольниками.\",\"generated_as_correct\":true},{\"text\":\"Теорема Пифагора находит применение в физике для расчёта скоростей и ускорений, а в химии — для определения молекулярных структур.\",\"generated_as_correct\":false},{\"text\":\"Теорема Пифагора важна для понимания принципов работы криптографических алгоритмов и используется в теории чисел для доказательства теорем о простых числах.\",\"generated_as_correct\":false},{\"text\":\"Теорема Пифагора используется только в геометрии для нахождения углов в треугольниках.\",\"generated_as_correct\":false}],\"question\":\"В каких областях, помимо геометрии, может быть использована теорема Пифагора и для решения каких задач?\"},{\"answers\":[{\"text\":\"Високосный год — это год с дополнительным днём (29 февраля).\",\"generated_as_correct\":true},{\"text\":\"Високосный год — это год, в котором добавляется дополнительный день (30 февраля), чтобы соответствовать астрономическим событиям.\",\"generated_as_correct\":false},{\"text\":\"Високосный год связан с изменениями в сезонных циклах и влияет на сельскохозяйственные работы, но не имеет отношения к календарной системе.\",\"generated_as_correct\":false},{\"text\":\"Високосный год — это год, который длится на один месяц дольше обычного года.\",\"generated_as_correct\":false}],\"question\":\"Что такое високосный год и чем он отличается от обычного года?\"},{\"answers\":[{\"text\":\"Високосные годы необходимы для синхронизации календаря с астрономическим годом, добавляя 29 февраля.\",\"generated_as_correct\":true},{\"text\":\"Високосные годы введены для того, чтобы каждые четыре года увеличивать количество дней в году на один день, независимо от астрономических циклов и синхронизации с ними.\",\"generated_as_correct\":false},{\"text\":\"Високосные годы важны для определения смены сезонов и климатических изменений, они помогают предсказывать погодные условия на основе календарной даты.\",\"generated_as_correct\":false},{\"text\":\"Високосные годы нужны для того, чтобы раз в четыре года делать год длиннее на один месяц.\",\"generated_as_correct\":false}],\"question\":\"Зачем нужны високосные годы в календарной системе?\"},{\"answers\":[{\"text\":\"Високосные годы учитываются при программировании задач с датами для корректного расчёта количества дней в году.\",\"generated_as_correct\":true},{\"text\":\"Високосные годы учитываются в программировании путём добавления дополнительного дня в августе, чтобы компенсировать различия между календарным и астрономическим годом.\",\"generated_as_correct\":false},{\"text\":\"Високосные годы важны для программирования алгоритмов, определяющих смену времён года, и не имеют отношения к расчёту дат и интервалов времени.\",\"generated_as_correct\":false},{\"text\":\"Високосные годы используются для корректировки количества месяцев в году в программах, работающих с датами.\",\"generated_as_correct\":false}],\"question\":\"Как знание о високосных годах может быть использовано при программировании задач, связанных с датами?\"},{\"answers\":[{\"text\":\"Вектор в C++ — это динамический массив для хранения элементов.\",\"generated_as_correct\":true},{\"text\":\"Вектор в C++ — это структура данных, которая хранит элементы в виде связного списка, где каждый элемент содержит ссылку на следующий.\",\"generated_as_correct\":false},{\"text\":\"Вектор в C++ — это инструмент для работы с графическими данными, который используется в компьютерных играх и других приложениях, требующих высокой производительности.\",\"generated_as_correct\":false},{\"text\":\"Вектор в C++ — это тип данных для хранения одиночного значения.\",\"generated_as_correct\":false}],\"question\":\"Что такое вектор в C++?\"},{\"answers\":[{\"text\":\"Векторы в C++ удобны, так как могут динамически изменять свой размер.\",\"generated_as_correct\":true},{\"text\":\"Векторы в C++ удобны для работы с коллекциями элементов, потому что они позволяют хранить только один тип данных и обеспечивают быстрый доступ к элементам по индексу, но их размер заранее определён и не может изменяться.\",\"generated_as_correct\":false},{\"text\":\"Векторы в C++ используются для реализации алгоритмов сортировки и поиска, что делает их полезными для работы с большими объёмами данных, хотя это не связано напрямую с их размером или гибкостью.\",\"generated_as_correct\":false},{\"text\":\"Векторы в C++ удобны, потому что их размер фиксирован и известен заранее.\",\"generated_as_correct\":false}],\"question\":\"Почему векторы в C++ удобны для использования при работе с коллекциями элементов?\"},{\"answers\":[{\"text\":\"Векторы в C++ удобны для хранения коллекций элементов и динамического изменения их размера.\",\"generated_as_correct\":true},{\"text\":\"Векторы в C++ используются исключительно для работы с числовыми данными и не поддерживают хранение других типов данных, таких как строки или объекты.\",\"generated_as_correct\":false},{\"text\":\"Векторы в C++ тесно связаны с графическим программированием и используются для описания координат точек в пространстве.\",\"generated_as_correct\":false},{\"text\":\"Векторы в C++ применяются только для работы с фиксированными массивами данных.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение векторов в программировании на C++ может быть особенно полезным?\"}],\"StoreCardId\":null,\"numberInCourse\":\"2.9\"}]},{\"id\":26,\"Name\":\"3. Стандартная библиотека C++\",\"Articles\":[{\"Name\":\"cpp | 3.1. Последовательные контейнеры\",\"Slug\":\"sequence-containers\",\"createdAt\":\"2024-07-03T17:47:46.980Z\",\"updatedAt\":\"2026-01-10T12:07:11.345Z\",\"publishedAt\":\"2024-07-03T17:47:48.341Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42157/problem\",\"Lead\":\"Мы\u0026nbsp;знакомы с\u0026nbsp;контейнерами std::vector и\u0026nbsp;std::string. В\u0026nbsp;этом параграфе мы\u0026nbsp;рассмотрим другие последовательные контейнеры стандартной библиотеки. Они не\u0026nbsp;обязательно хранят элементы в\u0026nbsp;непрерывном куске памяти, но\u0026nbsp;позволяют обойти элементы в\u0026nbsp;последовательном порядке.\",\"Content\":\"$64\",\"Title\":\"Последовательные контейнеры\",\"LikesCount\":20,\"Quiz\":[{\"answers\":[{\"text\":\"Шаблонные контейнеры в C++ — это структуры данных для хранения элементов, обеспечивающие операции доступа и управления.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные контейнеры в стандартной библиотеке C++ — это специальные типы данных, которые используются исключительно для хранения текстовых строк и не поддерживают операции вставки или удаления элементов.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные контейнеры в C++ связаны с алгоритмами сортировки и поиска, которые применяются для обработки данных в различных структурах, таких как деревья и графы.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные контейнеры в C++ — это встроенные функции для выполнения математических операций над числовыми значениями.\",\"generated_as_correct\":false}],\"question\":\"Что такое шаблонные контейнеры в стандартной библиотеке C++?\"},{\"answers\":[{\"text\":\"Контейнеры `std::vector` и `std::string` эффективны, так как обеспечивают удобное управление памятью и быстрый доступ к элементам.\",\"generated_as_correct\":true},{\"text\":\"Контейнеры `std::vector` и `std::string` считаются эффективными для управления памятью, потому что они автоматически освобождают память при завершении программы, независимо от того, использовались ли элементы или нет.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры, такие как `std::vector` и `std::string`, используются для обеспечения безопасности типов в C++ и не имеют прямого отношения к управлению памятью.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры `std::vector` и `std::string` неэффективны для управления памятью, поскольку требуют ручного управления выделением и освобождением памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему использование контейнеров, таких как std::vector и std::string, считается эффективным для управления памятью и доступом к элементам?\"},{\"answers\":[{\"text\":\"Шаблонные контейнеры в C++ — это структуры данных для хранения элементов, обеспечивающие эффективное управление памятью.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные контейнеры в C++ используются исключительно для хранения текстовых данных и не могут быть применены для других типов данных.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные контейнеры в C++ тесно связаны с алгоритмами сортировки и поиска, они определяют порядок выполнения операций в программах.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные контейнеры в C++ предназначены для объявления переменных и не используются для хранения данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить шаблонные контейнеры для хранения элементов в программах на C++?\"},{\"answers\":[{\"text\":\"`std::array` — это массив фиксированного размера в C++, известный на этапе компиляции.\",\"generated_as_correct\":true},{\"text\":\"`std::array` — это структура данных в C++, которая используется для хранения элементов переменного размера и обеспечивает доступ к ним через индексы, при этом размер массива может изменяться во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"`std::array` — это функция в C++, которая используется для сортировки элементов массива по определённому критерию.\",\"generated_as_correct\":false},{\"text\":\"`std::array` — это динамический массив в C++, размер которого можно изменять во время выполнения программы.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой контейнер `std::array` в C++?\"},{\"answers\":[{\"text\":\"`std::array` удобен тем, что имеет фиксированный размер, известный на этапе компиляции, и обеспечивает безопасность при использовании.\",\"generated_as_correct\":true},{\"text\":\"`std::array` не имеет преимуществ перед низкоуровневыми массивами и используется исключительно для совместимости с устаревшими библиотеками.\",\"generated_as_correct\":false},{\"text\":\"`std::array` используется для работы с динамической памятью и позволяет изменять размер массива во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"`std::array` требует больше памяти, чем низкоуровневые массивы, и не предоставляет дополнительных возможностей для работы с данными.\",\"generated_as_correct\":false}],\"question\":\"Почему использование `std::array` предпочтительнее низкоуровневых массивов в некоторых случаях?\"},{\"answers\":[{\"text\":\"`std::array` хранит элементы непрерывно в стеке, обеспечивая быстрый доступ и упрощённое управление памятью.\",\"generated_as_correct\":true},{\"text\":\"`std::array` — это контейнер в C++, который хранит элементы в виде связного списка, где каждый элемент содержит ссылку на следующий. Это позволяет легко добавлять и удалять элементы, но замедляет доступ к ним.\",\"generated_as_correct\":false},{\"text\":\"`std::array` используется для хранения данных в виде таблицы, где элементы организованы по строкам и столбцам. Это позволяет эффективно выполнять операции поиска и сортировки.\",\"generated_as_correct\":false},{\"text\":\"`std::array` хранит элементы в динамической памяти, что замедляет доступ к ним и усложняет управление.\",\"generated_as_correct\":false}],\"question\":\"Как особенности хранения элементов `std::array` влияют на его использование в программах?\"},{\"answers\":[{\"text\":\"`std::deque` — это двусторонняя очередь в C++, хранящая элементы кусочно-непрерывно на страницах памяти.\",\"generated_as_correct\":true},{\"text\":\"`std::deque` — это контейнер в C++, который хранит элементы в виде связного списка, где каждый элемент содержит ссылку на следующий и предыдущий элементы.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` — это структура данных в C++, которая используется для реализации стека и очереди, но не поддерживает эффективное добавление и удаление элементов по краям.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` — это контейнер в C++, который хранит элементы последовательно в одной области памяти.\",\"generated_as_correct\":false}],\"question\":\"Что такое `std::deque` и как организовано хранение элементов в этом контейнере?\"},{\"answers\":[{\"text\":\"`std::deque` удобен для вставки и удаления по краям благодаря кусочно-непрерывному хранению элементов.\",\"generated_as_correct\":true},{\"text\":\"`std::deque` удобен для операций вставки и удаления по краям, потому что он автоматически перераспределяет память при каждой операции, обеспечивая быстрый доступ к любым элементам в контейнере.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` используется для хранения данных в виде связного списка, что позволяет эффективно осуществлять поиск элементов по ключу.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` удобен для операций вставки и удаления в середине контейнера.\",\"generated_as_correct\":false}],\"question\":\"Почему `std::deque` удобен для операций, требующих вставки и удаления элементов по краям?\"},{\"answers\":[{\"text\":\"`std::deque` удобен для операций с добавлением и удалением элементов по краям контейнера.\",\"generated_as_correct\":true},{\"text\":\"`std::deque` лучше всего подходит для ситуаций, когда нужно часто изменять размер контейнера в произвольных местах, а не только по краям.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` используется для хранения данных в виде связного списка, где каждый элемент содержит ссылку на следующий и предыдущий элементы.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` оптимален для хранения большого объёма данных в непрерывной области памяти.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях использование `std::deque` может быть предпочтительнее других контейнеров в C++?\"},{\"answers\":[{\"text\":\"`std::list` — это двусвязный список в C++ с узлами, содержащими указатели на предыдущие и следующие узлы.\",\"generated_as_correct\":true},{\"text\":\"`std::list` — это структура данных в C++, которая хранит элементы в виде массива и обеспечивает быстрый доступ к элементам по индексу.\",\"generated_as_correct\":false},{\"text\":\"`std::list` — это функция в C++, используемая для сортировки элементов в массиве.\",\"generated_as_correct\":false},{\"text\":\"`std::list` — это связный список в C++, который хранит элементы в непрерывной области памяти.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой контейнер `std::list` в C++?\"},{\"answers\":[{\"text\":\"Эффективность вставки и удаления в `std::list` обусловлена наличием указателей на предыдущие и следующие узлы.\",\"generated_as_correct\":true},{\"text\":\"Использование двусвязного списка в `std::list` позволяет эффективно вставлять и удалять элементы за счёт того, что все элементы хранятся в непрерывной области памяти, что ускоряет доступ к ним.\",\"generated_as_correct\":false},{\"text\":\"Использование двусвязного списка в `std::list` связано с возможностью эффективной сортировки элементов по ключу, что делает его предпочтительным выбором для определённых алгоритмов поиска.\",\"generated_as_correct\":false},{\"text\":\"Эффективность вставки и удаления в `std::list` связана с тем, что все элементы расположены в непрерывной области памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему использование двусвязного списка в `std::list` позволяет эффективно вставлять и удалять элементы?\"},{\"answers\":[{\"text\":\"`std::list` — двусвязный список, элементы хранятся в отдельных узлах с указателями, что позволяет эффективно вставлять и удалять элементы.\",\"generated_as_correct\":true},{\"text\":\"`std::list` хранит элементы в непрерывной области памяти, что обеспечивает быстрый доступ к элементам по индексу, но затрудняет вставку и удаление элементов в произвольных местах.\",\"generated_as_correct\":false},{\"text\":\"`std::list` используется для хранения данных в виде массива, где каждый элемент имеет фиксированный размер и хранится последовательно в памяти, что оптимизирует доступ по индексу.\",\"generated_as_correct\":false},{\"text\":\"`std::list` хранит элементы в непрерывной памяти, что упрощает доступ, но усложняет вставку и удаление.\",\"generated_as_correct\":false}],\"question\":\"Как особенности хранения элементов в `std::list` влияют на его использование в программировании?\"},{\"answers\":[{\"text\":\"Итераторы в C++ — это объекты для навигации по контейнерам и доступа к их элементам.\",\"generated_as_correct\":true},{\"text\":\"Итераторы в C++ — это функции, которые автоматически перебирают все элементы контейнера и выполняют заданные операции над ними.\",\"generated_as_correct\":false},{\"text\":\"Итераторы в C++ используются для определения размера контейнеров и сравнения их между собой.\",\"generated_as_correct\":false},{\"text\":\"Итераторы в C++ — это типы данных для хранения элементов контейнера.\",\"generated_as_correct\":false}],\"question\":\"Что такое итераторы в C++ и для чего они предназначены?\"},{\"answers\":[{\"text\":\"Итераторы в C++ похожи на указатели, так как позволяют обращаться к элементам контейнера и перемещаться между ними, упрощая работу с различными типами контейнеров.\",\"generated_as_correct\":true},{\"text\":\"Итераторы в C++ работают аналогично массивам, позволяя обращаться к элементам по индексу, а не по ссылке. Это делает их удобными для работы с контейнерами, но ограничивает их применение только статическими структурами данных.\",\"generated_as_correct\":false},{\"text\":\"Итераторы в C++ используются для создания и управления контейнерами, подобно тому как конструкторы используются для создания объектов. Это позволяет программистам легко создавать и модифицировать контейнеры в процессе выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Итераторы в C++ предназначены для хранения элементов контейнера, подобно массивам, и не имеют сходства с указателями в плане навигации по контейнеру.\",\"generated_as_correct\":false}],\"question\":\"Почему итераторы сравнивают с указателями и как это сходство помогает в работе с контейнерами?\"},{\"answers\":[{\"text\":\"Итераторы в C++ позволяют перемещаться по контейнеру и обращаться к его элементам.\",\"generated_as_correct\":true},{\"text\":\"Итераторы в C++ предназначены для создания копий элементов контейнера, а не для навигации по нему.\",\"generated_as_correct\":false},{\"text\":\"Итераторы в C++ применяются для сортировки элементов в контейнере и не используются для непосредственного доступа к ним.\",\"generated_as_correct\":false},{\"text\":\"Итераторы в C++ нужны для подсчёта количества элементов в контейнере.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать итераторы для навигации по контейнеру и доступа к его элементам?\"},{\"answers\":[{\"text\":\"Инвалидация итераторов и ссылок — это потеря их валидности при изменении контейнера.\",\"generated_as_correct\":true},{\"text\":\"Инвалидация итераторов и ссылок — это процесс автоматического обновления итераторов при изменении контейнера, чтобы они всегда указывали на актуальные данные.\",\"generated_as_correct\":false},{\"text\":\"Инвалидация итераторов и ссылок связана с управлением памятью в языках программирования и относится к механизмам сборки мусора.\",\"generated_as_correct\":false},{\"text\":\"Инвалидация итераторов и ссылок происходит при каждом доступе к элементам контейнера.\",\"generated_as_correct\":false}],\"question\":\"Что такое инвалидация итераторов и ссылок?\"},{\"answers\":[{\"text\":\"Инвалидация итераторов и ссылок происходит при изменении размера контейнера, делая их невалидными.\",\"generated_as_correct\":true},{\"text\":\"Инвалидация итераторов и ссылок происходит из-за автоматического освобождения памяти, которое запускается при достижении определённого размера контейнера, независимо от операций добавления или удаления элементов.\",\"generated_as_correct\":false},{\"text\":\"Инвалидация итераторов и ссылок связана с процессом компиляции кода, когда компилятор оптимизирует доступ к элементам контейнера, изменяя структуру данных.\",\"generated_as_correct\":false},{\"text\":\"Инвалидация итераторов и ссылок происходит при каждом доступе к элементам контейнера.\",\"generated_as_correct\":false}],\"question\":\"Почему инвалидация итераторов и ссылок может произойти при изменении контейнера?\"},{\"answers\":[{\"text\":\"Доступ к инвалидированным итераторам или ссылкам может привести к неопределённому поведению программы.\",\"generated_as_correct\":true},{\"text\":\"При доступе к инвалидированным итераторам или ссылкам происходит автоматическое обновление их значений, что позволяет корректно работать с изменённым контейнером без риска ошибок.\",\"generated_as_correct\":false},{\"text\":\"Инвалидация итераторов и ссылок связана с проблемами управления памятью в языках программирования, но не влияет на работу программ, использующих неизменяемые структуры данных.\",\"generated_as_correct\":false},{\"text\":\"Инвалидация итераторов и ссылок приводит к автоматическому обновлению их значений при изменении контейнера.\",\"generated_as_correct\":false}],\"question\":\"Какие проблемы могут возникнуть при доступе к инвалидированным итераторам или ссылкам?\"}],\"StoreCardId\":null,\"numberInCourse\":\"3.1\"},{\"Name\":\"cpp | 3.2. Ассоциативные контейнеры\",\"Slug\":\"associative-containers\",\"createdAt\":\"2024-07-03T17:48:53.124Z\",\"updatedAt\":\"2026-01-10T12:07:10.026Z\",\"publishedAt\":\"2024-07-03T17:48:54.445Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42072/problem\",\"Lead\":\"Ассоциативные контейнеры сопоставляют ключам некоторые значения. В\u0026nbsp;стандартной библиотеке есть ассоциативные контейнеры, основанные на\u0026nbsp;сбалансированных деревьях поиска и\u0026nbsp;контейнеры, основанные на\u0026nbsp;хеш-таблицах.\",\"Content\":\"$65\",\"Title\":\"Ассоциативные контейнеры\",\"LikesCount\":19,\"Quiz\":[{\"answers\":[{\"text\":\"Ассоциативные контейнеры хранят данные в виде пар «ключ-значение» и обеспечивают быстрый доступ по ключу.\",\"generated_as_correct\":true},{\"text\":\"Ассоциативные контейнеры — это контейнеры, которые используются для хранения неуникальных ключей и связанных с ними значений, что позволяет осуществлять доступ к данным только через последовательный поиск.\",\"generated_as_correct\":false},{\"text\":\"Ассоциативные контейнеры — это структуры данных, которые используются в алгоритмах сортировки для временного хранения промежуточных результатов.\",\"generated_as_correct\":false},{\"text\":\"Ассоциативные контейнеры используются для хранения данных в виде массивов с индексами.\",\"generated_as_correct\":false}],\"question\":\"Что такое ассоциативные контейнеры и для чего они используются?\"},{\"answers\":[{\"text\":\"Уникальность ключей в ассоциативных контейнерах обеспечивает быстрый доступ к данным и однозначное соответствие ключ-значение.\",\"generated_as_correct\":true},{\"text\":\"В ассоциативных контейнерах ключи могут повторяться, и это позволяет хранить несколько значений под одним ключом, что увеличивает гибкость хранения данных.\",\"generated_as_correct\":false},{\"text\":\"Уникальность ключей в ассоциативных контейнерах важна для обеспечения безопасности данных и предотвращения их несанкционированного доступа.\",\"generated_as_correct\":false},{\"text\":\"Уникальность ключей в ассоциативных контейнерах не имеет значения, главное — количество хранимых значений.\",\"generated_as_correct\":false}],\"question\":\"Почему в ассоциативных контейнерах важно, чтобы каждый ключ был уникален?\"},{\"answers\":[{\"text\":\"Ассоциативные контейнеры позволяют хранить данные в виде пар «ключ-значение» и обеспечивают быстрый доступ к ним по ключу.\",\"generated_as_correct\":true},{\"text\":\"Ассоциативные контейнеры хранят данные в виде неупорядоченного набора значений без ключей, что позволяет быстро добавлять и удалять элементы, но не обеспечивает быстрого доступа по ключу.\",\"generated_as_correct\":false},{\"text\":\"Ассоциативные контейнеры применяются в алгоритмах сортировки для упорядочивания данных по определённому критерию, что помогает ускорить процесс сортировки больших объёмов данных.\",\"generated_as_correct\":false},{\"text\":\"Ассоциативные контейнеры используются для хранения данных в виде стека, что позволяет эффективно добавлять и удалять элементы.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить ассоциативные контейнеры для оптимизации доступа к данным?\"},{\"answers\":[{\"text\":\"`std::map` — ассоциативный контейнер на основе красно-чёрного дерева, хранящий пары «ключ-значение».\",\"generated_as_correct\":true},{\"text\":\"`std::map` — это структура данных, основанная на связном списке, которая хранит пары «ключ-значение» и обеспечивает быстрый доступ к элементам по индексу.\",\"generated_as_correct\":false},{\"text\":\"`std::map` используется для работы с файлами и потоками ввода-вывода в C++, его реализация основана на стандартных системных вызовах.\",\"generated_as_correct\":false},{\"text\":\"`std::map` — структура данных на основе двоичного дерева, оптимизированная для последовательного доступа к элементам.\",\"generated_as_correct\":false}],\"question\":\"Что такое std::map и на каком типе дерева он основан?\"},{\"answers\":[{\"text\":\"Сбалансированное дерево поиска в std::map обеспечивает операции поиска, вставки и удаления за O(log n) времени благодаря логарифмической высоте дерева.\",\"generated_as_correct\":true},{\"text\":\"Использование сбалансированного дерева поиска в std::map делает операции поиска, вставки и удаления неэффективными, поскольку дерево требует дополнительной балансировки после каждой операции, что значительно увеличивает время выполнения.\",\"generated_as_correct\":false},{\"text\":\"Использование сбалансированного дерева поиска в std::map улучшает читаемость кода и упрощает его понимание, так как структура данных интуитивно понятна программистам.\",\"generated_as_correct\":false},{\"text\":\"Сбалансированное дерево поиска в std::map ускоряет операции за счёт линейного времени выполнения O(n).\",\"generated_as_correct\":false}],\"question\":\"Почему использование сбалансированного дерева поиска в std::map обеспечивает эффективное выполнение операций поиска, вставки и удаления?\"},{\"answers\":[{\"text\":\"`std::map` обеспечивает упорядоченное хранение пар «ключ-значение» и быстрый доступ к элементам за логарифмическое время.\",\"generated_as_correct\":true},{\"text\":\"`std::map` — это простой массив, который хранит пары «ключ-значение» и автоматически сортирует их по значению, что позволяет быстро искать элементы по ключу.\",\"generated_as_correct\":false},{\"text\":\"`std::map` используется для создания графов и работы с сетевыми структурами данных, что полезно при анализе связности и путей в больших системах.\",\"generated_as_correct\":false},{\"text\":\"`std::map` позволяет хранить неупорядоченные данные и обеспечивает быстрый доступ к элементам за постоянное время.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить std::map для упорядоченного хранения данных и какие преимущества это даёт при работе с большими объёмами информации?\"},{\"answers\":[{\"text\":\"Красно-чёрное дерево — это сбалансированное дерево поиска для реализации std::map, обеспечивающее операции за логарифмическое время.\",\"generated_as_correct\":true},{\"text\":\"Красно-чёрное дерево — это структура данных, используемая для хранения неупорядоченных коллекций данных, и применяется в основном для быстрого доступа к элементам по индексу.\",\"generated_as_correct\":false},{\"text\":\"Красно-чёрное дерево — это концепция в теории графов, которая используется для анализа связности и путей в сетях.\",\"generated_as_correct\":false},{\"text\":\"Красно-чёрное дерево — это структура данных для хранения стека, обеспечивающая быстрый доступ к последним добавленным элементам.\",\"generated_as_correct\":false}],\"question\":\"Что такое красно-чёрное дерево и для чего оно используется?\"},{\"answers\":[{\"text\":\"Красно-чёрное дерево эффективно благодаря сбалансированности и выполнению операций за логарифмическое время.\",\"generated_as_correct\":true},{\"text\":\"Красно-чёрное дерево эффективно для операций поиска, вставки и удаления, потому что оно обеспечивает выполнение этих операций за линейное время, что позволяет быстро обрабатывать большие объёмы данных.\",\"generated_as_correct\":false},{\"text\":\"Красно-чёрное дерево используется для реализации контейнера std::map и обеспечивает эффективное хранение данных, но его эффективность обусловлена простотой структуры, а не временем выполнения операций.\",\"generated_as_correct\":false},{\"text\":\"Красно-чёрное дерево эффективно, потому что все операции выполняются за постоянное время.\",\"generated_as_correct\":false}],\"question\":\"Почему красно-чёрное дерево считается эффективным для операций поиска, вставки и удаления?\"},{\"answers\":[{\"text\":\"Красно-чёрное дерево гарантирует выполнение операций за логарифмическое время.\",\"generated_as_correct\":true},{\"text\":\"Красно-чёрное дерево обеспечивает выполнение операций поиска, вставки и удаления за постоянное время, независимо от размера дерева.\",\"generated_as_correct\":false},{\"text\":\"Красно-чёрное дерево используется для оптимизации алгоритмов сортировки и не влияет на время выполнения операций с данными в контейнерах.\",\"generated_as_correct\":false},{\"text\":\"Красно-чёрное дерево выполняет операции за линейное время.\",\"generated_as_correct\":false}],\"question\":\"Как свойства красно-чёрного дерева влияют на время выполнения операций с данными?\"},{\"answers\":[{\"text\":\"`std::unordered_map` — ассоциативный контейнер на основе хеш-таблицы для хранения пар «ключ-значение».\",\"generated_as_correct\":true},{\"text\":\"`std::unordered_map` — это структура данных, которая хранит пары «ключ-значение» и обеспечивает доступ к элементам по индексу, подобно массиву.\",\"generated_as_correct\":false},{\"text\":\"`std::unordered_map` используется для сортировки элементов по ключу и обеспечивает быстрый доступ к данным, но основан на принципе сравнения ключей.\",\"generated_as_correct\":false},{\"text\":\"`std::unordered_map` — это контейнер, который хранит элементы в отсортированном порядке и основан на связном списке.\",\"generated_as_correct\":false}],\"question\":\"Что такое std::unordered_map и на чём он основан?\"},{\"answers\":[{\"text\":\"`std::unordered_map` обеспечивает быстрый доступ к данным благодаря использованию хеш-таблицы.\",\"generated_as_correct\":true},{\"text\":\"`std::unordered_map` обеспечивает быстрый доступ к данным за счёт того, что хранит их в отсортированном порядке, что позволяет использовать бинарный поиск для ускорения доступа.\",\"generated_as_correct\":false},{\"text\":\"`std::unordered_map` использует механизм блокировки для обеспечения потокобезопасности при доступе к данным, что делает его подходящим для многопоточных приложений.\",\"generated_as_correct\":false},{\"text\":\"`std::unordered_map` обеспечивает быстрый доступ к данным за счёт их хранения в упорядоченном виде.\",\"generated_as_correct\":false}],\"question\":\"Почему std::unordered_map обеспечивает быстрый доступ к данным?\"},{\"answers\":[{\"text\":\"std::unordered_map применяется для быстрого доступа к данным по ключу без сохранения порядка.\",\"generated_as_correct\":true},{\"text\":\"std::unordered_map следует использовать, когда необходимо хранить данные в виде связного списка, где элементы связаны между собой по порядку.\",\"generated_as_correct\":false},{\"text\":\"std::unordered_map используется для реализации стека, где доступ к элементам осуществляется по принципу «последний пришёл — первый вышел».\",\"generated_as_correct\":false},{\"text\":\"std::unordered_map подходит для хранения упорядоченных последовательностей данных.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях целесообразно использовать std::unordered_map для хранения данных?\"},{\"answers\":[{\"text\":\"Хеш-таблица — структура данных для быстрого доступа к элементам по ключу с помощью хеш-функции.\",\"generated_as_correct\":true},{\"text\":\"Хеш-таблица — это структура данных, предназначенная для хранения данных в виде связанного списка, где хеш-функция используется для определения порядка следования элементов в списке.\",\"generated_as_correct\":false},{\"text\":\"Хеш-таблица используется в криптографии для шифрования данных, а хеш-функция в её структуре применяется для генерации ключей.\",\"generated_as_correct\":false},{\"text\":\"Хеш-таблица — это массив, в котором хеш-функция определяет размер хранимых данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое хеш-таблица и для чего используется хеш-функция в её структуре?\"},{\"answers\":[{\"text\":\"Хеш-таблицы обеспечивают быстрый доступ к элементам благодаря хеш-функции. Коллизии решаются методом цепочек или другими способами.\",\"generated_as_correct\":true},{\"text\":\"Хеш-таблицы обеспечивают быстрый доступ к элементам за счёт сортировки данных по ключу. Проблема коллизий решается путём перезаписи старых данных новыми, что позволяет избежать дублирования.\",\"generated_as_correct\":false},{\"text\":\"Хеш-таблицы используют сложные алгоритмы для шифрования данных, что обеспечивает высокий уровень безопасности. Проблема коллизий в них не возникает благодаря уникальности каждого ключа.\",\"generated_as_correct\":false},{\"text\":\"Хеш-таблицы обеспечивают быстрый доступ к элементам за счёт их упорядочивания. Коллизии не возникают благодаря уникальности ключей.\",\"generated_as_correct\":false}],\"question\":\"Почему хеш-таблицы обеспечивают быстрый доступ к элементам и как решается проблема коллизий?\"},{\"answers\":[{\"text\":\"Хеш-таблицы эффективны для быстрого доступа, поиска, вставки и удаления элементов по ключу за константное время.\",\"generated_as_correct\":true},{\"text\":\"Хеш-таблицы лучше всего подходят для хранения данных, которые редко изменяются, поскольку при каждом изменении данных требуется пересчёт всей хеш-функции.\",\"generated_as_correct\":false},{\"text\":\"Хеш-таблицы используются для шифрования данных и обеспечения безопасности информации, так как они позволяют быстро преобразовывать данные в зашифрованный вид.\",\"generated_as_correct\":false},{\"text\":\"Хеш-таблицы оптимальны для хранения упорядоченных последовательностей данных и их сортировки по ключу.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение хеш-таблиц может быть особенно эффективным и почему?\"},{\"answers\":[{\"text\":\"«Коллизия — это совпадение хешей двух разных ключей в одной корзине хеш-таблицы».\",\"generated_as_correct\":true},{\"text\":\"«Коллизия — это процесс обновления хеш-таблицы при добавлении нового элемента, который требует перераспределения всех ключей по корзинам».\",\"generated_as_correct\":false},{\"text\":\"«Коллизия относится к алгоритмам шифрования и не имеет отношения к работе хеш-таблиц, это понятие используется в криптографии для описания уязвимостей».\",\"generated_as_correct\":false},{\"text\":\"«Коллизия — это ошибка в алгоритме хеширования, которая приводит к потере данных в хеш-таблице».\",\"generated_as_correct\":false}],\"question\":\"Что такое коллизия в контексте хеш-таблиц?\"},{\"answers\":[{\"text\":\"«Коллизии снижают эффективность хеш-таблицы, так как требуют дополнительных методов разрешения для обработки ключей в одной корзине».\",\"generated_as_correct\":true},{\"text\":\"«Коллизии не влияют на эффективность работы хеш-таблицы, так как система автоматически перераспределяет ключи по другим корзинам без потери производительности».\",\"generated_as_correct\":false},{\"text\":\"«Коллизии связаны с алгоритмами шифрования и не имеют прямого отношения к снижению эффективности работы хеш-таблиц, их влияние больше касается безопасности данных».\",\"generated_as_correct\":false},{\"text\":\"«Коллизии улучшают эффективность хеш-таблицы за счёт более компактного хранения данных в одной корзине».\",\"generated_as_correct\":false}],\"question\":\"Почему возникновение коллизий может снизить эффективность работы хеш-таблицы?\"},{\"answers\":[{\"text\":\"Метод цепочек решает коллизии, выстраивая элементы в односвязный список в одной корзине.\",\"generated_as_correct\":true},{\"text\":\"Метод цепочек предполагает использование дополнительного хеш-функции для перерасчёта ключей при возникновении коллизии, чтобы распределить элементы по разным корзинам.\",\"generated_as_correct\":false},{\"text\":\"Метод цепочек применяется для оптимизации поиска в бинарных деревьях, что позволяет ускорить доступ к элементам.\",\"generated_as_correct\":false},{\"text\":\"Метод цепочек предотвращает коллизии путём изменения размера хеш-таблицы при добавлении новых элементов.\",\"generated_as_correct\":false}],\"question\":\"Как метод цепочек помогает разрешить коллизии в хеш-таблицах?\"},{\"answers\":[{\"text\":\"Итераторы ассоциативных контейнеров — это объекты для доступа и перемещения по элементам контейнера.\",\"generated_as_correct\":true},{\"text\":\"Итераторы ассоциативных контейнеров — это функции, которые автоматически перебирают элементы контейнера и выполняют заданные операции без необходимости явного указания на перемещение по элементам.\",\"generated_as_correct\":false},{\"text\":\"Итераторы ассоциативных контейнеров используются для сортировки элементов в контейнере и обеспечения быстрого доступа к ним по индексу.\",\"generated_as_correct\":false},{\"text\":\"Итераторы ассоциативных контейнеров — это константы, хранящие количество элементов в контейнере.\",\"generated_as_correct\":false}],\"question\":\"Что такое итераторы ассоциативных контейнеров?\"},{\"answers\":[{\"text\":\"Итераторы позволяют выполнять обход, поиск, вставку и удаление элементов в ассоциативных контейнерах.\",\"generated_as_correct\":true},{\"text\":\"Итераторы ассоциативных контейнеров используются исключительно для сортировки элементов внутри контейнера и не предоставляют возможности для их обхода или изменения.\",\"generated_as_correct\":false},{\"text\":\"Итераторы ассоциативных контейнеров тесно связаны с алгоритмами машинного обучения и применяются для обработки данных в нейронных сетях.\",\"generated_as_correct\":false},{\"text\":\"Итераторы используются только для чтения значений элементов в ассоциативных контейнерах.\",\"generated_as_correct\":false}],\"question\":\"Какие операции позволяют выполнять итераторы при работе с элементами контейнера?\"},{\"answers\":[{\"text\":\"Двусторонние итераторы применяются для контейнеров на основе деревьев, а однонаправленные — для хеш-таблиц.\",\"generated_as_correct\":true},{\"text\":\"Двусторонние и однонаправленные итераторы не имеют различий в применении и могут использоваться для любых типов контейнеров, включая векторы и списки.\",\"generated_as_correct\":false},{\"text\":\"Итераторы используются для управления памятью в контейнерах и обеспечивают оптимизацию доступа к элементам, но не имеют различий между двусторонними и однонаправленными типами.\",\"generated_as_correct\":false},{\"text\":\"Итераторы не различаются по типам контейнеров и обеспечивают одинаковый доступ ко всем элементам.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается различие между двусторонними и однонаправленными итераторами и для каких типов контейнеров они применяются?\"},{\"answers\":[{\"text\":\"Мультиконтейнеры позволяют хранить несколько значений под одним ключом.\",\"generated_as_correct\":true},{\"text\":\"Мультиконтейнеры — это специальные контейнеры, которые автоматически сортируют все сохранённые значения по ключу в алфавитном порядке.\",\"generated_as_correct\":false},{\"text\":\"Мультиконтейнеры используются для хранения данных в базах данных и обеспечивают высокую скорость доступа к информации благодаря индексации ключей.\",\"generated_as_correct\":false},{\"text\":\"Мультиконтейнеры предназначены для хранения одного значения под несколькими ключами.\",\"generated_as_correct\":false}],\"question\":\"Что такое мультиконтейнеры?\"},{\"answers\":[{\"text\":\"Мультиконтейнеры позволяют хранить несколько значений под одним ключом.\",\"generated_as_correct\":true},{\"text\":\"Мультиконтейнеры отличаются от обычных контейнеров тем, что они позволяют хранить данные без ключей, в то время как обычные контейнеры требуют для каждого значения уникальный ключ.\",\"generated_as_correct\":false},{\"text\":\"Мультиконтейнеры используются для оптимизации доступа к данным в многопоточных приложениях, в отличие от обычных контейнеров, которые предназначены для последовательной обработки данных.\",\"generated_as_correct\":false},{\"text\":\"Мультиконтейнеры обеспечивают более быструю работу с данными по сравнению с обычными контейнерами за счёт использования уникальных ключей.\",\"generated_as_correct\":false}],\"question\":\"В чём заключается отличие мультиконтейнеров от обычных контейнеров?\"},{\"answers\":[{\"text\":\"Мультиконтейнеры позволяют хранить несколько значений под одним ключом, что полезно для сохранения порядковых номеров слов в текстовом файле.\",\"generated_as_correct\":true},{\"text\":\"Мультиконтейнеры подходят для хранения только уникальных ключей и значений, поэтому их нельзя использовать для сохранения порядкового номера каждого слова в текстовом файле, если слова повторяются.\",\"generated_as_correct\":false},{\"text\":\"Мультиконтейнеры используются для сортировки данных по ключу и значению, что может быть полезно при анализе текстовых файлов, но не имеет отношения к сохранению порядкового номера каждого слова.\",\"generated_as_correct\":false},{\"text\":\"Мультиконтейнеры предназначены для хранения одного значения под каждым ключом, поэтому они не подходят для сохранения порядкового номера каждого слова в текстовом файле.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить мультиконтейнеры для решения задачи сохранения порядкового номера каждого слова в текстовом файле?\"}],\"StoreCardId\":null,\"numberInCourse\":\"3.2\"},{\"Name\":\"cpp | 3.3. Алгоритмы\",\"Slug\":\"algorithms\",\"createdAt\":\"2024-07-03T17:52:21.585Z\",\"updatedAt\":\"2026-01-10T12:07:09.944Z\",\"publishedAt\":\"2024-07-03T17:52:22.792Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42073/problem\",\"Lead\":\"Алгоритмы стандартной библиотеки представляют из себя шаблонные функции для обработки последовательностей: подсчёта, поиска, сортировки и т.д. Такие функции, как правило, принимают на вход два итератора, которые ограничивают рассматриваемый диапазон.\",\"Content\":\"$66\",\"Title\":\"Алгоритмы\",\"LikesCount\":21,\"Quiz\":[{\"answers\":[{\"text\":\"Шаблонные функции стандартной библиотеки — это алгоритмы для обработки последовательностей в C++, работающие с итераторами.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные функции стандартной библиотеки предназначены для работы с отдельными элементами данных и выполняют операции ввода-вывода, не связанные с обработкой последовательностей.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные функции стандартной библиотеки используются для определения типов данных и не имеют отношения к алгоритмам обработки последовательностей.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные функции стандартной библиотеки предназначены для работы с графическим интерфейсом и не связаны с обработкой данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое шаблонные функции стандартной библиотеки и для каких операций они предназначены?\"},{\"answers\":[{\"text\":\"Алгоритмы стандартной библиотеки принимают два итератора для унифицированной работы с разными контейнерами в C++.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы стандартной библиотеки принимают на вход два итератора для того, чтобы ограничить количество элементов, которые можно обрабатывать в контейнерах, что упрощает работу с большими объёмами данных.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы стандартной библиотеки принимают на вход два итератора, что позволяет им эффективно работать с графическими данными и реализовывать алгоритмы машинного обучения.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы стандартной библиотеки принимают два итератора, чтобы ограничить размер обрабатываемых данных и усложнить работу с контейнерами.\",\"generated_as_correct\":false}],\"question\":\"Почему важно, что алгоритмы стандартной библиотеки принимают на вход два итератора?\"},{\"answers\":[{\"text\":\"Алгоритмы стандартной библиотеки C++ предоставляют унифицированный интерфейс для обработки данных в различных контейнерах через итераторы.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы стандартной библиотеки C++ предназначены исключительно для работы с векторами и не могут быть применены к другим типам контейнеров, что ограничивает их полезность при обработке данных.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы стандартной библиотеки C++ используются для оптимизации компиляции программ и не оказывают прямого влияния на работу с контейнерами в коде.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы стандартной библиотеки C++ позволяют работать только с предварительно определёнными типами контейнеров и не поддерживают итераторы.\",\"generated_as_correct\":false}],\"question\":\"Как использование алгоритмов стандартной библиотеки может упростить работу с различными контейнерами в C++?\"},{\"answers\":[{\"text\":\"Пары итераторов определяют диапазон элементов в контейнере: один указывает на начало, другой — на элемент за концом диапазона.\",\"generated_as_correct\":true},{\"text\":\"Пары итераторов — это два итератора, которые указывают на произвольные элементы в контейнере и используются для определения диапазона элементов без чёткой структуры.\",\"generated_as_correct\":false},{\"text\":\"Пары итераторов используются для создания итерационных циклов и не имеют отношения к определению диапазона элементов в контейнере.\",\"generated_as_correct\":false},{\"text\":\"Пары итераторов определяют диапазон элементов в контейнере, где оба итератора указывают на начало и конец диапазона соответственно.\",\"generated_as_correct\":false}],\"question\":\"Что такое пары итераторов и как они определяют диапазон элементов в контейнере?\"},{\"answers\":[{\"text\":\"Второй итератор определяет конец диапазона в контейнере для корректной работы алгоритмов.\",\"generated_as_correct\":true},{\"text\":\"Второй итератор указывает на середину диапазона, что необходимо для алгоритмов, работающих с центральной частью данных в контейнере.\",\"generated_as_correct\":false},{\"text\":\"Второй итератор используется для определения типа данных в контейнере и не связан с указанием на конец диапазона.\",\"generated_as_correct\":false},{\"text\":\"Второй итератор указывает на начало диапазона, что важно для работы алгоритмов.\",\"generated_as_correct\":false}],\"question\":\"Почему важно, что второй итератор указывает на элемент за концом диапазона?\"},{\"answers\":[{\"text\":\"Пары итераторов определяют диапазон элементов в контейнере, обеспечивая гибкость работы с различными контейнерами в функциях стандартной библиотеки.\",\"generated_as_correct\":true},{\"text\":\"Пары итераторов позволяют определить диапазон элементов в контейнере, но первый итератор всегда указывает на середину диапазона, а второй — на конец, что обеспечивает универсальность работы с контейнерами.\",\"generated_as_correct\":false},{\"text\":\"Пары итераторов применяются для сортировки элементов в контейнерах и не влияют на гибкость функций стандартной библиотеки при работе с разными типами данных.\",\"generated_as_correct\":false},{\"text\":\"Пары итераторов фиксируют начальное и конечное значения элементов в контейнере, что ограничивает гибкость работы с разными контейнерами в функциях стандартной библиотеки.\",\"generated_as_correct\":false}],\"question\":\"Как использование пар итераторов обеспечивает гибкость при работе с различными контейнерами в функциях стандартной библиотеки?\"},{\"answers\":[{\"text\":\"`std::sort` — алгоритм в C++ для сортировки элементов в диапазоне.\",\"generated_as_correct\":true},{\"text\":\"`std::sort` — это метод в C++, который используется для поиска определённых элементов в контейнере по заданным критериям.\",\"generated_as_correct\":false},{\"text\":\"`std::sort` — это инструмент в C++, который применяется для работы с файловыми системами и организацией данных на диске.\",\"generated_as_correct\":false},{\"text\":\"`std::sort` — функция в C++ для объединения элементов из разных контейнеров.\",\"generated_as_correct\":false}],\"question\":\"Что такое std::sort и для чего он используется в C++?\"},{\"answers\":[{\"text\":\"`std::sort` — это алгоритм для сортировки элементов в контейнерах C++, что важно для организации данных.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм `std::sort` применяется для поиска уникальных элементов в контейнере, что делает его важным инструментом для работы с данными в C++.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм `std::sort` связан с управлением памятью в C++ и помогает оптимизировать распределение ресурсов при работе с большими объёмами данных.\",\"generated_as_correct\":false},{\"text\":\"`std::sort` используется для объединения нескольких контейнеров в один, что упрощает работу с данными в C++.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритм std::sort считается важным для работы с данными в C++?\"},{\"answers\":[{\"text\":\"`std::sort` сортирует элементы в контейнере в заданном диапазоне.\",\"generated_as_correct\":true},{\"text\":\"`std::sort` используется для поиска определённых элементов в контейнере по заданному критерию, не изменяя их порядок.\",\"generated_as_correct\":false},{\"text\":\"`std::sort` тесно связан с алгоритмами поиска и применяется для определения наличия элементов в контейнере.\",\"generated_as_correct\":false},{\"text\":\"`std::sort` используется для подсчёта количества элементов в контейнере.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить std::sort для упорядочивания элементов в контейнере?\"},{\"answers\":[{\"text\":\"`std::count` подсчитывает количество элементов в диапазоне, равных заданному значению.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм `std::count` предназначен для сортировки элементов в диапазоне по возрастанию или убыванию относительно заданного значения.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм `std::count` связан с операциями по изменению значений элементов в диапазоне на основе заданного условия.\",\"generated_as_correct\":false},{\"text\":\"`std::count` определяет максимальное значение среди элементов в заданном диапазоне.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритм `std::count`?\"},{\"answers\":[{\"text\":\"`std::count` упрощает подсчёт элементов, соответствующих критерию, делая код лаконичным.\",\"generated_as_correct\":true},{\"text\":\"`std::count` — это функция, которая позволяет подсчитывать количество элементов в контейнере, но только если они расположены в определённом порядке, что требует дополнительной сортировки данных перед использованием.\",\"generated_as_correct\":false},{\"text\":\"`std::count` используется для определения типа данных в диапазоне и не имеет отношения к подсчёту элементов, что делает его неприменимым для задач, требующих подсчёта количества вхождений.\",\"generated_as_correct\":false},{\"text\":\"`std::count` усложняет подсчёт элементов и требует написания дополнительных циклов.\",\"generated_as_correct\":false}],\"question\":\"Почему использование `std::count` предпочтительнее написания цикла вручную для подсчёта элементов?\"},{\"answers\":[{\"text\":\"Алгоритм `std::count` подсчитывает количество элементов в диапазоне, равных заданному значению.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм `std::count` предназначен для определения максимального значения среди элементов в диапазоне.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм `std::count` связан с сортировкой элементов в диапазоне по возрастанию или убыванию.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм `std::count` определяет общее количество элементов в диапазоне без учёта их значений.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритм `std::count` для решения задачи подсчёта элементов в диапазоне?\"},{\"answers\":[{\"text\":\"`std::find` ищет первое вхождение заданного элемента в диапазоне и возвращает итератор на него.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм `std::find` предназначен для сортировки элементов в контейнере по возрастанию или убыванию и возвращает отсортированный контейнер.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм `std::find` связан с операциями по изменению структуры данных и используется для добавления новых элементов в контейнер.\",\"generated_as_correct\":false},{\"text\":\"`std::find` определяет, есть ли в контейнере хотя бы один элемент, равный заданному, и возвращает логическое значение.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритм `std::find`?\"},{\"answers\":[{\"text\":\"`std::find` возвращает итератор на конец диапазона при отсутствии искомого элемента.\",\"generated_as_correct\":true},{\"text\":\"`std::find` возвращает итератор на конец диапазона, если элемент найден, а если элемент не найден, то возвращает nullptr.\",\"generated_as_correct\":false},{\"text\":\"`std::find` использует итераторы для перебора элементов контейнера и сравнивает их с заданным значением, но не всегда возвращает итератор на конец диапазона.\",\"generated_as_correct\":false},{\"text\":\"`std::find` возвращает итератор на первый элемент диапазона, если искомый элемент не найден.\",\"generated_as_correct\":false}],\"question\":\"Почему `std::find` возвращает итератор на конец диапазона, если элемент не найден?\"},{\"answers\":[{\"text\":\"`std::find` ищет первое вхождение элемента в диапазоне контейнера.\",\"generated_as_correct\":true},{\"text\":\"Алгоритм `std::find` применяется для подсчёта количества вхождений заданного элемента в контейнер и возвращает количество найденных элементов.\",\"generated_as_correct\":false},{\"text\":\"Алгоритм `std::find` используется для сортировки элементов в контейнере по возрастанию или убыванию.\",\"generated_as_correct\":false},{\"text\":\"`std::find` находит все вхождения элемента в контейнере и возвращает их количество.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях можно применить алгоритм `std::find` для поиска элементов в контейнерах?\"},{\"answers\":[{\"text\":\"Алгоритмы, модифицирующие последовательность, изменяют порядок элементов, например, std::reverse, std::unique.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы, модифицирующие последовательность — это алгоритмы, которые создают новые последовательности на основе существующих, например, std::copy, std::transform, std::merge. Они не изменяют порядок элементов в исходной последовательности.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы, модифицирующие последовательность — это методы, используемые в теории графов для анализа связности и путей в графах, например, алгоритмы поиска в ширину и глубину.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы, модифицирующие последовательность, сохраняют исходный порядок элементов, например, std::sort, std::find.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритмы, модифицирующие последовательность?\"},{\"answers\":[{\"text\":\"Алгоритмы, модифицирующие последовательность, выполняют операции по перестановке, удалению дубликатов и заполнению элементов контейнеров.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы, модифицирующие последовательность, используются для добавления новых элементов в контейнер и удаления элементов по определённому условию, например, с помощью функций std::insert и std::erase.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы, модифицирующие последовательность, применяются для вычисления статистических характеристик элементов контейнера, таких как среднее значение, медиана и стандартное отклонение.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы, модифицирующие последовательность, служат для поиска элементов в контейнерах и не влияют на их структуру или содержимое.\",\"generated_as_correct\":false}],\"question\":\"Какие операции позволяют выполнять алгоритмы, модифицирующие последовательность, над элементами контейнеров?\"},{\"answers\":[{\"text\":\"Алгоритмы, такие как std::reverse, std::unique, std::fill, изменяют порядок, удаляют дубликаты или заполняют элементы в последовательностях.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы, модифицирующие последовательность, применяются только для сортировки элементов по возрастанию или убыванию и не могут выполнять другие операции, такие как удаление дубликатов или заполнение последовательности.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы, модифицирующие последовательность, используются в криптографии для создания сложных шифров и обеспечения безопасности данных.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы, модифицирующие последовательность, применяются исключительно для подсчёта количества элементов в контейнерах.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритмы, модифицирующие последовательность, для обработки данных?\"},{\"answers\":[{\"text\":\"Адаптеры для вставки — это функции, имитирующие итераторы и добавляющие элементы в контейнер.\",\"generated_as_correct\":true},{\"text\":\"Адаптеры для вставки — это встроенные методы контейнеров, которые автоматически сортируют элементы при добавлении их в контейнер, например, `std::sort_inserter`.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры для вставки — это инструменты, используемые для настройки параметров итераторов в контейнерах, они не влияют на процесс добавления элементов, но могут изменять порядок их обхода.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры для вставки — это методы контейнеров, удаляющие элементы при записи.\",\"generated_as_correct\":false}],\"question\":\"Что такое адаптеры для вставки в контексте работы с контейнерами?\"},{\"answers\":[{\"text\":\"Адаптеры для вставки упрощают добавление элементов в контейнеры при работе с модифицирующими алгоритмами.\",\"generated_as_correct\":true},{\"text\":\"Адаптеры для вставки используются для чтения данных из контейнеров и не имеют отношения к добавлению элементов при работе с модифицирующими алгоритмами.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры для вставки важны для обеспечения безопасности потоков при одновременном доступе к данным в многопоточных приложениях.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры для вставки необходимы для удаления элементов из контейнеров при использовании модифицирующих алгоритмов.\",\"generated_as_correct\":false}],\"question\":\"Почему адаптеры для вставки считаются полезными при работе с модифицирующими алгоритмами?\"},{\"answers\":[{\"text\":\"Адаптеры для вставки, вроде `std::back_inserter`, упрощают добавление элементов в контейнер через модифицирующие алгоритмы.\",\"generated_as_correct\":true},{\"text\":\"Адаптеры для вставки применяются для сортировки элементов внутри контейнера, используя специальные алгоритмы сравнения.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры для вставки используются для создания копий контейнеров и применяются при сериализации данных.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры для вставки предназначены для прямого чтения данных из контейнера без возможности их изменения.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить адаптеры для вставки, например, std::back_inserter, при добавлении элементов в контейнер?\"},{\"answers\":[{\"text\":\"`std::is_sorted` проверяет отсортированность последовательности в заданном диапазоне.\",\"generated_as_correct\":true},{\"text\":\"Функция `std::is_sorted` определяет, является ли последовательность уникальной, проверяя, нет ли в ней повторяющихся элементов.\",\"generated_as_correct\":false},{\"text\":\"Функция `std::is_sorted` используется для подсчёта количества элементов в последовательности и сравнения их с заданным значением.\",\"generated_as_correct\":false},{\"text\":\"`std::is_sorted` меняет порядок элементов в последовательности на обратный.\",\"generated_as_correct\":false}],\"question\":\"Что делает функция `std::is_sorted`?\"},{\"answers\":[{\"text\":\"`std::is_sorted` проверяет отсортированность последовательности, что важно для корректной работы алгоритмов сортировки и бинарного поиска.\",\"generated_as_correct\":true},{\"text\":\"Функция `std::is_sorted` нужна для случайного перемешивания элементов в последовательности, чтобы проверить, можно ли применять алгоритмы сортировки.\",\"generated_as_correct\":false},{\"text\":\"Функция `std::is_sorted` применяется для определения среднего значения элементов в последовательности, что может быть полезно при анализе данных.\",\"generated_as_correct\":false},{\"text\":\"`std::is_sorted` используется для непосредственной сортировки элементов в последовательности.\",\"generated_as_correct\":false}],\"question\":\"Почему функция `std::is_sorted` может быть полезна при работе с алгоритмами сортировки?\"},{\"answers\":[{\"text\":\"`std::is_sorted` используется для проверки отсортированности последовательности перед бинарным поиском.\",\"generated_as_correct\":true},{\"text\":\"функцию `std::is_sorted` применяют перед бинарным поиском для проверки, что все элементы последовательности уникальны.\",\"generated_as_correct\":false},{\"text\":\"функцию `std::is_sorted` используют для определения количества элементов в последовательности перед выполнением бинарного поиска.\",\"generated_as_correct\":false},{\"text\":\"`std::is_sorted` применяется перед бинарным поиском для проверки наличия дубликатов в последовательности.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях можно использовать функцию `std::is_sorted` перед применением алгоритмов бинарного поиска?\"},{\"answers\":[{\"text\":\"Алгоритмы бинарного поиска работают с отсортированными последовательностями и обеспечивают быстрый доступ к элементам.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы бинарного поиска применяются для работы с любыми последовательностями данных независимо от их порядка, что делает их универсальными инструментами для поиска информации.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы бинарного поиска тесно связаны с методами шифрования данных и используются для обеспечения безопасности информации в криптографических системах.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы бинарного поиска предназначены для работы с хаотично упорядоченными данными и не требуют предварительной сортировки последовательности.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритмы бинарного поиска и для работы с какими последовательностями они используются?\"},{\"answers\":[{\"text\":\"Алгоритмы бинарного поиска эффективны из-за быстрого доступа к элементам в отсортированных данных.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы бинарного поиска эффективны, потому что они позволяют быстро находить данные в не отсортированных списках, используя специальные математические формулы.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы бинарного поиска используются для шифрования данных и обеспечивают высокий уровень безопасности при передаче информации по сети.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы бинарного поиска эффективны для поиска в неупорядоченных данных.\",\"generated_as_correct\":false}],\"question\":\"Почему алгоритмы бинарного поиска считаются эффективными для поиска данных?\"},{\"answers\":[{\"text\":\"Алгоритмы бинарного поиска обеспечивают быстрый доступ к элементам в отсортированных контейнерах.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы бинарного поиска применяются для сортировки данных в контейнерах, а не для поиска и анализа уже отсортированных последовательностей.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы бинарного поиска используются для оптимизации работы с графами и сетями, что не имеет прямого отношения к анализу данных в отсортированных контейнерах.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы бинарного поиска применяются для поиска данных в несортированных контейнерах.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритмы бинарного поиска для анализа данных в отсортированных контейнерах?\"},{\"answers\":[{\"text\":\"Теоретико-множественные алгоритмы — это алгоритмы для операций над множествами, такими как объединение и пересечение.\",\"generated_as_correct\":true},{\"text\":\"Теоретико-множественные алгоритмы — это методы для визуализации данных, представленные в виде графиков и диаграмм, которые помогают анализировать и интерпретировать информацию.\",\"generated_as_correct\":false},{\"text\":\"Теоретико-множественные алгоритмы используются в теории графов для определения кратчайших путей и связности между узлами в сети.\",\"generated_as_correct\":false},{\"text\":\"Теоретико-множественные алгоритмы применяются для шифрования данных и обеспечения их безопасности.\",\"generated_as_correct\":false}],\"question\":\"Что такое теоретико-множественные алгоритмы?\"},{\"answers\":[{\"text\":\"Теоретико-множественные алгоритмы позволяют эффективно обрабатывать большие объёмы данных через операции слияния, объединения и пересечения множеств.\",\"generated_as_correct\":true},{\"text\":\"Теоретико-множественные алгоритмы полезны для анализа и обработки больших объёмов информации, потому что они позволяют быстро сортировать данные по алфавиту, что упрощает поиск и фильтрацию информации в больших базах данных.\",\"generated_as_correct\":false},{\"text\":\"Теоретико-множественные алгоритмы используются в теории графов для определения связности компонентов и поиска кратчайших путей, что делает их полезными для анализа сложных сетевых структур.\",\"generated_as_correct\":false},{\"text\":\"Теоретико-множественные алгоритмы полезны для анализа и обработки больших объёмов информации, так как они помогают в шифровании данных и обеспечении их безопасности.\",\"generated_as_correct\":false}],\"question\":\"Почему теоретико-множественные алгоритмы полезны для анализа и обработки больших объёмов информации?\"},{\"answers\":[{\"text\":\"Теоретико-множественные алгоритмы выполняют операции слияния, объединения, пересечения и разности над отсортированными последовательностями.\",\"generated_as_correct\":true},{\"text\":\"Теоретико-множественные алгоритмы используются для сортировки данных в алфавитном порядке и не применяются для операций слияния или пересечения.\",\"generated_as_correct\":false},{\"text\":\"Теоретико-множественные алгоритмы применяются для шифрования данных и обеспечения их безопасности при передаче по сети.\",\"generated_as_correct\":false},{\"text\":\"Теоретико-множественные алгоритмы используются для поиска максимального и минимального значений в отсортированных последовательностях.\",\"generated_as_correct\":false}],\"question\":\"Какие операции можно выполнять с помощью теоретико-множественных алгоритмов над отсортированными последовательностями?\"}],\"StoreCardId\":null,\"numberInCourse\":\"3.3\"},{\"Name\":\"cpp | 3.4 Адаптеры и представления\",\"Slug\":\"adapters-and-views\",\"createdAt\":\"2024-07-03T17:53:12.607Z\",\"updatedAt\":\"2026-01-10T12:07:09.864Z\",\"publishedAt\":\"2024-07-03T17:53:14.005Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42077/problem\",\"Lead\":\"Адаптеры над стандартными контейнерами — это не самостоятельные контейнеры. Они используют какой-нибудь другой последовательный контейнер для хранения своих элементов, но при этом предоставляют свой набор функций для работы с ними. Представления (views) не владеют памятью, а лишь ссылаются на диапазон значений другого контейнера.\",\"Content\":\"$67\",\"Title\":\"Адаптеры и представления\",\"LikesCount\":28,\"Quiz\":[{\"answers\":[{\"text\":\"Адаптеры используют контейнеры для хранения элементов и предоставляют специфический интерфейс для работы со стеком, очередью или приоритетной очередью.\",\"generated_as_correct\":true},{\"text\":\"Адаптеры над стандартными контейнерами — это дополнительные библиотеки, которые расширяют возможности стандартных контейнеров, добавляя новые типы данных для хранения информации.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры над стандартными контейнерами используются для оптимизации алгоритмов сортировки и поиска в больших объёмах данных, не изменяя при этом структуру самих контейнеров.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры над стандартными контейнерами создают собственные структуры данных для хранения элементов и не взаимодействуют с другими контейнерами.\",\"generated_as_correct\":false}],\"question\":\"Что такое адаптеры над стандартными контейнерами и для чего они используются?\"},{\"answers\":[{\"text\":\"Адаптеры используют другие контейнеры для хранения элементов и предоставляют специфический интерфейс для работы с ними.\",\"generated_as_correct\":true},{\"text\":\"Адаптеры не хранят элементы самостоятельно, так как они предназначены только для сортировки и фильтрации данных, хранящихся в других контейнерах.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры используются для обеспечения безопасности данных и шифрования информации, хранящейся в контейнерах.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры самостоятельно создают и управляют контейнерами для хранения элементов.\",\"generated_as_correct\":false}],\"question\":\"Почему адаптеры не хранят элементы самостоятельно, а используют другие контейнеры для этого?\"},{\"answers\":[{\"text\":\"Адаптеры предоставляют специфический интерфейс для работы с контейнерами, такими как стек или очередь.\",\"generated_as_correct\":true},{\"text\":\"Адаптеры служат исключительно для визуального представления данных из контейнеров и не предоставляют дополнительных функций для работы со стеками или очередями.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры используются для оптимизации алгоритмов сортировки и поиска в контейнерах, не влияя на структуру данных или интерфейс работы с ними.\",\"generated_as_correct\":false},{\"text\":\"Адаптеры изменяют структуру стандартных контейнеров, чтобы они соответствовали специфическим требованиям стека или очереди.\",\"generated_as_correct\":false}],\"question\":\"Как адаптеры могут упростить работу с контейнерами при реализации специфических структур данных, таких как стек или очередь?\"},{\"answers\":[{\"text\":\"Представления (views) — это ссылки на подмножество данных в контейнере без копирования.\",\"generated_as_correct\":true},{\"text\":\"Представления (views) — это статические копии данных, которые создаются для каждого подмножества элементов контейнера и хранятся в памяти независимо от исходного контейнера.\",\"generated_as_correct\":false},{\"text\":\"Представления (views) используются в графических интерфейсах для отображения данных и не имеют отношения к работе с контейнерами данных.\",\"generated_as_correct\":false},{\"text\":\"Представления (views) — это копии данных, хранящиеся в отдельном контейнере.\",\"generated_as_correct\":false}],\"question\":\"Что такое представления (views) в контексте работы с данными?\"},{\"answers\":[{\"text\":\"Представления ускоряют программу и экономят память, так как ссылаются на данные другого контейнера без их копирования.\",\"generated_as_correct\":true},{\"text\":\"Представления ускоряют работу программы и уменьшают использование памяти, потому что автоматически сжимают данные, хранящиеся в контейнере.\",\"generated_as_correct\":false},{\"text\":\"Представления улучшают производительность программы, так как обеспечивают дополнительный уровень абстракции для работы с данными, независимо от их физического расположения в памяти.\",\"generated_as_correct\":false},{\"text\":\"Представления ускоряют программу, потому что хранят данные в более компактном формате.\",\"generated_as_correct\":false}],\"question\":\"Почему использование представлений может ускорить программу и снизить потребление памяти?\"},{\"answers\":[{\"text\":\"Представления ссылаются на данные контейнера, позволяя работать с ними без копирования.\",\"generated_as_correct\":true},{\"text\":\"Представления работают с данными контейнера путём их полного копирования в новую область памяти, что позволяет избежать изменений в исходном контейнере.\",\"generated_as_correct\":false},{\"text\":\"Представления используются для визуального отображения данных контейнера в пользовательском интерфейсе без изменения их структуры.\",\"generated_as_correct\":false},{\"text\":\"Представления копируют данные контейнера для работы с ними, что ускоряет доступ к информации.\",\"generated_as_correct\":false}],\"question\":\"Как представления позволяют работать с данными контейнера без копирования?\"},{\"answers\":[{\"text\":\"Стек — это структура данных с принципом LIFO, где элементы добавляются и извлекаются с одного конца.\",\"generated_as_correct\":true},{\"text\":\"Стек — это структура данных, где элементы могут быть добавлены и извлечены из любой точки последовательности, что позволяет гибко управлять порядком их обработки.\",\"generated_as_correct\":false},{\"text\":\"Стек используется в программировании для хранения данных в виде связного списка, где каждый элемент содержит ссылку на следующий элемент в последовательности.\",\"generated_as_correct\":false},{\"text\":\"Стек — это структура данных с принципом FIFO, где элементы добавляются с одного конца, а извлекаются с другого.\",\"generated_as_correct\":false}],\"question\":\"Что такое стек и какой принцип он реализует?\"},{\"answers\":[{\"text\":\"Стек работает по принципу LIFO, поэтому добавление и извлечение элементов возможны только с одной стороны.\",\"generated_as_correct\":true},{\"text\":\"Стек позволяет добавлять элементы с одной стороны, но извлекать их можно с любой стороны, в зависимости от приоритета элемента.\",\"generated_as_correct\":false},{\"text\":\"Стек используется для хранения данных в виде связного списка, где каждый элемент содержит ссылку на следующий, что обеспечивает доступ к элементам с разных сторон.\",\"generated_as_correct\":false},{\"text\":\"Стек позволяет добавлять и извлекать элементы с разных сторон, что делает его удобным для некоторых алгоритмов.\",\"generated_as_correct\":false}],\"question\":\"Почему в стеке добавление и извлечение элементов возможно только с одной стороны?\"},{\"answers\":[{\"text\":\"Стек с LIFO полезен в задачах, требующих обработки элементов в обратном порядке.\",\"generated_as_correct\":true},{\"text\":\"Стек с принципом LIFO применяется в задачах, где нужно равномерно распределять нагрузку между элементами, например, в системах балансировки нагрузки или при планировании задач в операционных системах.\",\"generated_as_correct\":false},{\"text\":\"Стек с принципом LIFO находит применение в задачах криптографии для обеспечения безопасности данных при передаче по сети.\",\"generated_as_correct\":false},{\"text\":\"Стек с LIFO используется в задачах, где важен порядок добавления элементов, как в очередях.\",\"generated_as_correct\":false}],\"question\":\"В каких задачах может быть полезно использование стека с принципом LIFO?\"},{\"answers\":[{\"text\":\"Очередь (`std::queue`) реализует принцип FIFO, где элементы добавляются с одного конца и извлекаются с другого.\",\"generated_as_correct\":true},{\"text\":\"Очередь (`std::queue`) — это структура данных, в которой элементы могут быть добавлены и извлечены с любого конца, что позволяет гибко управлять порядком их обработки.\",\"generated_as_correct\":false},{\"text\":\"Очередь (`std::queue`) используется для хранения данных в виде связного списка, где каждый элемент содержит ссылку на следующий и предыдущий элементы.\",\"generated_as_correct\":false},{\"text\":\"Очередь (`std::queue`) работает по принципу LIFO, где элементы добавляются и удаляются с одного конца.\",\"generated_as_correct\":false}],\"question\":\"Что такое очередь (`std::queue`) и какой принцип она реализует?\"},{\"answers\":[{\"text\":\"Принцип FIFO важен для очереди, так как обеспечивает обработку элементов в порядке их добавления.\",\"generated_as_correct\":true},{\"text\":\"Принцип FIFO важен для структуры данных «очередь», потому что он позволяет обрабатывать элементы в порядке, обратном их добавлению, что полезно для задач, требующих обратной последовательности действий.\",\"generated_as_correct\":false},{\"text\":\"Принцип FIFO важен для структуры данных «очередь», так как он связан с алгоритмами сортировки и поиска, которые используются в различных приложениях.\",\"generated_as_correct\":false},{\"text\":\"Принцип FIFO важен для очереди, поскольку позволяет извлекать элементы без учёта порядка их добавления.\",\"generated_as_correct\":false}],\"question\":\"Почему принцип FIFO важен для структуры данных «очередь»?\"},{\"answers\":[{\"text\":\"Очередь полезна для задач, где требуется обработка элементов в порядке их поступления.\",\"generated_as_correct\":true},{\"text\":\"Очередь используется в задачах, где нужно обрабатывать элементы по принципу «последний пришёл — первый вышел», например, при работе с стеками данных.\",\"generated_as_correct\":false},{\"text\":\"Очередь часто используется в алгоритмах сортировки для временного хранения данных перед их последующей обработкой.\",\"generated_as_correct\":false},{\"text\":\"Очередь применяется для задач, где нужно обработать элементы в обратном порядке их поступления.\",\"generated_as_correct\":false}],\"question\":\"В каких задачах может быть полезно применение очереди?\"},{\"answers\":[{\"text\":\"`std::priority_queue` выполняет добавление и удаление за O(log n), получение максимума — за O(1).\",\"generated_as_correct\":true},{\"text\":\"Очередь с приоритетами (`std::priority_queue`) позволяет добавлять элементы за константное время и удалять за линейное, а максимальный элемент можно получить за логарифмическое время.\",\"generated_as_correct\":false},{\"text\":\"Очередь с приоритетами (`std::priority_queue`) используется для хранения данных в виде связного списка, где элементы упорядочены по времени добавления.\",\"generated_as_correct\":false},{\"text\":\"`std::priority_queue` выполняет все операции за константное время O(1).\",\"generated_as_correct\":false}],\"question\":\"Какие операции поддерживает очередь с приоритетами (`std::priority_queue`) и за какое время они выполняются?\"},{\"answers\":[{\"text\":\"Куча позволяет быстро добавлять, удалять элементы и получать максимальный элемент в очереди с приоритетами.\",\"generated_as_correct\":true},{\"text\":\"Куча применяется для реализации очереди с приоритетами, поскольку обеспечивает быстрый доступ ко всем элементам в очереди, что позволяет мгновенно выполнять сортировку по приоритету.\",\"generated_as_correct\":false},{\"text\":\"Куча используется в реализации очереди с приоритетами, потому что она тесно связана с алгоритмами поиска кратчайшего пути и может быть использована для хранения промежуточных результатов.\",\"generated_as_correct\":false},{\"text\":\"Куча используется для реализации очереди с приоритетами, так как обеспечивает быстрый доступ к любому элементу по индексу.\",\"generated_as_correct\":false}],\"question\":\"Почему для реализации очереди с приоритетами используется структура данных «куча»?\"},{\"answers\":[{\"text\":\"очередь с приоритетами эффективна для задач, требующих быстрого извлечения максимального или минимального элемента.\",\"generated_as_correct\":true},{\"text\":\"очередь с приоритетами применяется в задачах, где нужно хранить элементы в порядке их добавления и извлекать их в том же порядке, как в обычной очереди.\",\"generated_as_correct\":false},{\"text\":\"очередь с приоритетами используется для организации доступа к данным в базах данных и управления транзакциями.\",\"generated_as_correct\":false},{\"text\":\"очередь с приоритетами применяется для задач, где нужно последовательно обрабатывать элементы в порядке их поступления.\",\"generated_as_correct\":false}],\"question\":\"В каких задачах может быть полезно применение очереди с приоритетами?\"},{\"answers\":[{\"text\":\"`std::string_view` — это обёртка над подстрокой, которая не копирует данные и не выделяет память.\",\"generated_as_correct\":true},{\"text\":\"`std::string_view` — это независимый тип данных, который создаёт собственную копию строки и управляет памятью самостоятельно, обеспечивая безопасность при работе с данными.\",\"generated_as_correct\":false},{\"text\":\"`std::string_view` используется для шифрования строк и обеспечивает высокий уровень безопасности данных при передаче по сети.\",\"generated_as_correct\":false},{\"text\":\"`std::string_view` — это тип данных, который всегда создаёт копию строки и управляет своей памятью.\",\"generated_as_correct\":false}],\"question\":\"Что такое `std::string_view` и какие основные особенности у этого типа данных?\"},{\"answers\":[{\"text\":\"`std::string_view` ускоряет программу за счёт отсутствия копирования подстрок.\",\"generated_as_correct\":true},{\"text\":\"`std::string_view` ускоряет программу, так как автоматически оптимизирует хранение подстрок в памяти, уменьшая их размер.\",\"generated_as_correct\":false},{\"text\":\"`std::string_view` используется для изменения содержимого строк без прямого доступа к исходному массиву символов, что улучшает безопасность программы.\",\"generated_as_correct\":false},{\"text\":\"`std::string_view` ускоряет программу, потому что выделяет меньше памяти под каждую подстроку.\",\"generated_as_correct\":false}],\"question\":\"Почему использование `std::string_view` может ускорить работу программы при работе с подстроками?\"},{\"answers\":[{\"text\":\"`std::string_view` может привести к ошибкам, если ссылается на строку, которая изменяется или удаляется.\",\"generated_as_correct\":true},{\"text\":\"`std::string_view` неэффективен при работе с небольшими строками, так как добавляет дополнительный уровень абстракции и усложняет код без ощутимого улучшения производительности.\",\"generated_as_correct\":false},{\"text\":\"`std::string_view` может вызвать проблемы при использовании в многопоточных приложениях, так как не предоставляет механизмов для синхронизации доступа к данным.\",\"generated_as_correct\":false},{\"text\":\"`std::string_view` неэффективен, когда необходимо изменять содержимое строки.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях использование `std::string_view` может быть неэффективным или даже привести к ошибкам в программе?\"},{\"answers\":[{\"text\":\"`std::span` — это обёртка для работы с непрерывной последовательностью элементов в памяти без копирования.\",\"generated_as_correct\":true},{\"text\":\"`std::span` — это структура данных, которая создаёт копию массива или вектора и позволяет работать с этой копией в памяти.\",\"generated_as_correct\":false},{\"text\":\"`std::span` используется для управления памятью и выделения динамических массивов в C++.\",\"generated_as_correct\":false},{\"text\":\"`std::span` — это класс для создания копий массивов и векторов в памяти.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой `std::span` в контексте работы с данными в памяти?\"},{\"answers\":[{\"text\":\"`std::span` — это обёртка над непрерывной последовательностью элементов, аналогичная `string_view`, но для массивов и векторов.\",\"generated_as_correct\":true},{\"text\":\"`std::span` является аналогом `string_view` для массивов или векторов, так как он предоставляет возможность изменять размер исходной последовательности элементов.\",\"generated_as_correct\":false},{\"text\":\"`std::span` связан с `string_view`, поскольку оба типа данных используются для работы с текстовой информацией в C++.\",\"generated_as_correct\":false},{\"text\":\"`std::span` используется для создания копий массивов и векторов, подобно `string_view`.\",\"generated_as_correct\":false}],\"question\":\"Почему `std::span` можно считать аналогом `string_view` для массивов или векторов?\"},{\"answers\":[{\"text\":\"`std::span` позволяет работать с подмножеством элементов в памяти без их копирования.\",\"generated_as_correct\":true},{\"text\":\"`std::span` используется для создания новых массивов на основе существующих, при этом данные копируются для обеспечения безопасности при многопоточной работе.\",\"generated_as_correct\":false},{\"text\":\"`std::span` применяется для управления памятью в динамических массивах и векторах, обеспечивая автоматическое освобождение ресурсов при выходе из области видимости.\",\"generated_as_correct\":false},{\"text\":\"`std::span` создаёт копию данных для работы с подмножеством элементов, что помогает избежать проблем с исходным массивом.\",\"generated_as_correct\":false}],\"question\":\"Как использование `std::span` может помочь избежать копирования данных при работе с подмножеством элементов?\"}],\"StoreCardId\":null,\"numberInCourse\":\"3.4\"},{\"Name\":\"cpp | 3.5. Разбор задач к разделу «Стандартная библиотека C++»\",\"Slug\":\"cpp-standard-library\",\"createdAt\":\"2024-07-03T17:54:16.696Z\",\"updatedAt\":\"2026-01-10T12:07:10.604Z\",\"publishedAt\":\"2024-07-03T17:54:18.184Z\",\"ContestURL\":null,\"Lead\":\"В\u0026nbsp;этом параграфе мы\u0026nbsp;разберём задачи к\u0026nbsp;главе «Стандартная библиотека\u0026nbsp;C\\\\+\\\\+».\",\"Content\":\"$68\",\"Title\":\"Разбор задач к главе «Стандартная библиотека C++»\",\"LikesCount\":16,\"Quiz\":[{\"answers\":[{\"text\":\"Функция `Print` выводит элементы контейнера через разделитель в `std::cout`.\",\"generated_as_correct\":true},{\"text\":\"Функция `Print` нужна для сортировки элементов контейнера и их последующего вывода в поток `std::cout` без использования разделителей.\",\"generated_as_correct\":false},{\"text\":\"Функция `Print` применяется для создания и управления потоками ввода-вывода в C++, не обязательно связанными с контейнерами.\",\"generated_as_correct\":false},{\"text\":\"Функция `Print` служит для копирования элементов контейнера в память.\",\"generated_as_correct\":false}],\"question\":\"Для чего предназначена функция `Print`?\"},{\"answers\":[{\"text\":\"Константные ссылки в функции `Print` нужны для избежания копирования параметров.\",\"generated_as_correct\":true},{\"text\":\"В функции `Print` константные ссылки используются для того, чтобы принудительно копировать параметры, что обеспечивает безопасность при работе с данными.\",\"generated_as_correct\":false},{\"text\":\"В функции `Print` константные ссылки применяются для того, чтобы определить тип данных, которые будут выводиться, и адаптировать формат вывода в зависимости от типа.\",\"generated_as_correct\":false},{\"text\":\"Константные ссылки в функции `Print` используются для изменения параметров внутри функции.\",\"generated_as_correct\":false}],\"question\":\"Почему в функции `Print` важно использовать константные ссылки для параметров?\"},{\"answers\":[{\"text\":\"Функция `Print` выводит элементы контейнера в `std::cout`, итерируя по нему с помощью range-based for и используя указанный разделитель.\",\"generated_as_correct\":true},{\"text\":\"Функция `Print` осуществляет вывод элементов контейнера в поток `std::cout` путём прямого обращения к каждому элементу по индексу и вывода его без использования разделителей или специальных конструкций.\",\"generated_as_correct\":false},{\"text\":\"Функция `Print` используется для сортировки элементов контейнера перед их выводом в поток `std::cout`. Она применяет алгоритм быстрой сортировки и выводит элементы в порядке возрастания.\",\"generated_as_correct\":false},{\"text\":\"Функция `Print` выводит элементы контейнера в `std::cout` путём рекурсивного вызова для каждого элемента без использования разделителей.\",\"generated_as_correct\":false}],\"question\":\"Как функция `Print` осуществляет вывод элементов контейнера в поток `std::cout`?\"},{\"answers\":[{\"text\":\"Контейнеры в C++ — это структуры данных для хранения коллекций объектов.\",\"generated_as_correct\":true},{\"text\":\"Контейнеры в стандартной библиотеке C++ — это специальные типы данных, предназначенные исключительно для хранения текстовых значений, таких как строки.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры в C++ связаны с механизмами управления памятью и используются для выделения и освобождения ресурсов, не связанных с хранением данных.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры в C++ — это алгоритмы для сортировки и поиска данных в массивах.\",\"generated_as_correct\":false}],\"question\":\"Что такое контейнеры в стандартной библиотеке C++?\"},{\"answers\":[{\"text\":\"Контейнеры в C++ упрощают работу с коллекциями объектов благодаря наличию готовых методов для хранения и управления данными.\",\"generated_as_correct\":true},{\"text\":\"Контейнеры в C++ представляют собой статические массивы, размер которых нельзя изменять после инициализации, что делает их неудобными для управления динамическими коллекциями объектов.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры в C++ используются для объявления переменных и управления доступом к ним в рамках области видимости, что помогает в организации кода.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры в C++ предназначены только для хранения одиночных значений и не поддерживают работу с коллекциями объектов.\",\"generated_as_correct\":false}],\"question\":\"Почему контейнеры в C++ полезны для управления коллекциями объектов?\"},{\"answers\":[{\"text\":\"Контейнеры `std::vector`, `std::list` и `std::deque` в C++ позволяют хранить и управлять коллекциями объектов, каждый из них имеет свои особенности для различных сценариев использования.\",\"generated_as_correct\":true},{\"text\":\"Контейнеры `std::vector`, `std::list` и `std::deque` используются в C++ для создания статических массивов, где размер задаётся на этапе компиляции и не может быть изменён во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры `std::vector`, `std::list` и `std::deque` применяются в C++ для реализации алгоритмов сортировки и поиска, независимо от типа хранимых данных.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры `std::vector`, `std::list` и `std::deque` в C++ предназначены исключительно для хранения строковых данных и не поддерживают другие типы объектов.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить контейнеры `std::vector`, `std::list` и `std::deque` в программировании на C++?\"},{\"answers\":[{\"text\":\"Итераторы — это объекты для доступа к элементам контейнеров, используемые в циклах и алгоритмах.\",\"generated_as_correct\":true},{\"text\":\"Итераторы — это специальные типы данных, которые хранят все элементы контейнера в себе и позволяют выполнять арифметические операции над ними.\",\"generated_as_correct\":false},{\"text\":\"Итераторы используются для определения размера контейнеров и их типов в процессе компиляции программ.\",\"generated_as_correct\":false},{\"text\":\"Итераторы — это методы, которые создают копии элементов контейнера.\",\"generated_as_correct\":false}],\"question\":\"Что такое итераторы и для чего они используются?\"},{\"answers\":[{\"text\":\"Итераторы позволяют работать с элементами контейнеров единообразно, независимо от типа контейнера.\",\"generated_as_correct\":true},{\"text\":\"Итераторы обеспечивают унифицированный интерфейс за счёт того, что они содержат внутри себя все элементы контейнера и предоставляют к ним прямой доступ по индексу.\",\"generated_as_correct\":false},{\"text\":\"Итераторы используются для оптимизации работы с памятью и ускорения доступа к элементам, но не имеют отношения к унифицированному интерфейсу для работы с контейнерами.\",\"generated_as_correct\":false},{\"text\":\"Итераторы обеспечивают унифицированный интерфейс только для работы с массивами.\",\"generated_as_correct\":false}],\"question\":\"Почему итераторы обеспечивают унифицированный интерфейс для работы с различными контейнерами?\"},{\"answers\":[{\"text\":\"Итераторы обеспечивают доступ к элементам контейнера в циклах и алгоритмах стандартной библиотеки.\",\"generated_as_correct\":true},{\"text\":\"Итераторы позволяют выполнять математические операции над элементами контейнера без необходимости прямого доступа к ним в циклах и алгоритмах стандартной библиотеки.\",\"generated_as_correct\":false},{\"text\":\"Итераторы играют ключевую роль в управлении памятью при работе с контейнерами, хотя их основная функция — обеспечение доступа к элементам — остаётся важной в контексте алгоритмов стандартной библиотеки.\",\"generated_as_correct\":false},{\"text\":\"Итераторы используются для создания копий элементов контейнера в циклах и алгоритмах стандартной библиотеки.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить итераторы в циклах и алгоритмах стандартной библиотеки?\"},{\"answers\":[{\"text\":\"`std::deque` — контейнер в C++, позволяющий эффективно добавлять и удалять элементы с обоих концов.\",\"generated_as_correct\":true},{\"text\":\"`std::deque` — это структура данных в C++, которая обеспечивает быстрый доступ к элементам по индексу, но не поддерживает эффективное добавление или удаление элементов с концов.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` — это алгоритм сортировки в C++, который используется для упорядочивания элементов в контейнере по определённому критерию.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` — контейнер в C++, предназначенный для хранения элементов и эффективного доступа к ним по индексу.\",\"generated_as_correct\":false}],\"question\":\"Что такое `std::deque` и какие операции он позволяет выполнять эффективно?\"},{\"answers\":[{\"text\":\"`std::deque` позволяет быстро добавлять и удалять элементы с обоих концов контейнера.\",\"generated_as_correct\":true},{\"text\":\"`std::deque` обеспечивает быстрый доступ к элементам в середине контейнера, но не с начала и конца.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` используется для хранения данных в виде связного списка, что позволяет эффективно перемещаться по элементам в любом направлении.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` подходит только для задач, требующих последовательного доступа к элементам.\",\"generated_as_correct\":false}],\"question\":\"Почему `std::deque` подходит для задач, требующих быстрого доступа к элементам с начала и конца контейнера?\"},{\"answers\":[{\"text\":\"`std::deque` полезен в задачах, где требуется быстрый доступ к элементам с начала и конца контейнера.\",\"generated_as_correct\":true},{\"text\":\"`std::deque` — это структура данных, которая позволяет эффективно добавлять и удалять элементы только в середине контейнера, что делает её полезной для задач, требующих частого доступа к центральным элементам.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` используется для хранения данных в виде связного списка, где каждый элемент содержит ссылку на предыдущий и следующий элементы, что позволяет эффективно перемещаться по списку в обоих направлениях.\",\"generated_as_correct\":false},{\"text\":\"`std::deque` применяется в задачах, где необходимо добавлять элементы только в середину контейнера.\",\"generated_as_correct\":false}],\"question\":\"В каких типах задач можно применить `std::deque`, и чем он может быть полезен в контексте очередей или стеков?\"},{\"answers\":[{\"text\":\"`std::list` — это двусвязный список для эффективной вставки и удаления элементов в любом месте.\",\"generated_as_correct\":true},{\"text\":\"`std::list` — это контейнер, который представляет собой массив с фиксированным размером, оптимизированный для быстрого доступа к элементам по индексу.\",\"generated_as_correct\":false},{\"text\":\"`std::list` — это структура данных, используемая для реализации алгоритмов сортировки и поиска, но не поддерживающая операции вставки и удаления элементов.\",\"generated_as_correct\":false},{\"text\":\"`std::list` — это контейнер, оптимизированный для быстрого доступа к элементам по индексу, как в массиве.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой контейнер `std::list`?\"},{\"answers\":[{\"text\":\"`std::list` эффективен для вставки и удаления благодаря структуре двусвязного списка.\",\"generated_as_correct\":true},{\"text\":\"`std::list` эффективен для вставки и удаления элементов в любом месте благодаря своей структуре, напоминающей односвязный список, что упрощает доступ к элементам и их перемещение.\",\"generated_as_correct\":false},{\"text\":\"`std::list` используется для хранения последовательностей элементов и поддерживает итераторы, что делает его удобным для перебора элементов, но не обязательно эффективным для вставки и удаления.\",\"generated_as_correct\":false},{\"text\":\"`std::list` эффективен для вставки и удаления элементов благодаря использованию статического массива.\",\"generated_as_correct\":false}],\"question\":\"Почему `std::list` эффективен для вставки и удаления элементов в любом месте?\"},{\"answers\":[{\"text\":\"`std::list` менее эффективен, чем `std::deque`, при частом доступе к элементам по индексу из-за аллокации памяти.\",\"generated_as_correct\":true},{\"text\":\"`std::list` уступает `std::deque` в случаях, когда необходимо часто добавлять элементы в конец контейнера, поскольку `std::list` медленнее выполняет операции добавления в конце.\",\"generated_as_correct\":false},{\"text\":\"`std::list` и `std::deque` имеют разные подходы к реализации итераторов, что влияет на их совместимость с различными алгоритмами стандартной библиотеки.\",\"generated_as_correct\":false},{\"text\":\"`std::list` предпочтительнее `std::deque` для операций добавления и удаления элементов в начале контейнера.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях использование `std::list` может быть менее эффективным по сравнению с `std::deque`?\"},{\"answers\":[{\"text\":\"Алгоритмы стандартной библиотеки C++ — это функции для работы с контейнерами и итераторами.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы стандартной библиотеки C++ — это встроенные операторы языка C++, которые используются для арифметических и логических операций, например, `+`, `-`, `*`.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы стандартной библиотеки C++ — это инструменты для разработки графического интерфейса пользователя в приложениях на C++.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы стандартной библиотеки C++ — это макросы для оптимизации кода.\",\"generated_as_correct\":false}],\"question\":\"Что такое алгоритмы стандартной библиотеки C++?\"},{\"answers\":[{\"text\":\"Алгоритмы стандартной библиотеки C++ оптимизированы и готовы к использованию, что делает их предпочтительными для обработки данных.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы стандартной библиотеки C++ предназначены только для работы с определёнными типами данных и не могут быть использованы для общих задач обработки, поэтому написание собственных функций часто является более универсальным решением.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы стандартной библиотеки C++ важны для обеспечения совместимости программ с различными операционными системами, что делает их полезными для разработки кроссплатформенных приложений.\",\"generated_as_correct\":false},{\"text\":\"Написание собственных функций предпочтительнее использования алгоритмов стандартной библиотеки C++, так как это позволяет лучше контролировать процесс обработки данных.\",\"generated_as_correct\":false}],\"question\":\"Почему использование алгоритмов стандартной библиотеки C++ может быть предпочтительнее написания собственных функций для обработки данных?\"},{\"answers\":[{\"text\":\"Алгоритмы стандартной библиотеки C++ предоставляют функции для работы с контейнерами и итераторами, такие как `std::sort`, `std::find`, `std::copy`.\",\"generated_as_correct\":true},{\"text\":\"Алгоритмы стандартной библиотеки C++ используются исключительно для математических вычислений и не могут применяться для операций над контейнерами или итераторами.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы стандартной библиотеки C++ применяются для создания графических пользовательских интерфейсов и работы с событиями в оконных системах.\",\"generated_as_correct\":false},{\"text\":\"Алгоритмы стандартной библиотеки C++ предназначены для работы с базами данных и не могут использоваться для операций над контейнерами.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить алгоритмы стандартной библиотеки C++ для выполнения операций над контейнерами и итераторами?\"},{\"answers\":[{\"text\":\"`std::unique` удаляет соседние дубликаты из диапазона.\",\"generated_as_correct\":true},{\"text\":\"`std::unique` — это алгоритм, который случайным образом удаляет элементы из диапазона до тех пор, пока не останутся только уникальные значения.\",\"generated_as_correct\":false},{\"text\":\"`std::unique` используется для сортировки элементов в диапазоне по возрастанию или убыванию.\",\"generated_as_correct\":false},{\"text\":\"`std::unique` удаляет все элементы из диапазона, кроме первого.\",\"generated_as_correct\":false}],\"question\":\"Что делает алгоритм `std::unique`?\"},{\"answers\":[{\"text\":\"`std::unique` удаляет только соседние дубликаты, сравнивая элементы последовательно.\",\"generated_as_correct\":true},{\"text\":\"`std::unique` не удаляет повторяющиеся элементы, а просто переставляет их в случайном порядке, сохраняя исходное количество элементов в диапазоне.\",\"generated_as_correct\":false},{\"text\":\"`std::unique` используется для сортировки элементов в диапазоне по определённому критерию, что позволяет группировать одинаковые значения вместе.\",\"generated_as_correct\":false},{\"text\":\"`std::unique` удаляет все дубликаты из диапазона, независимо от их положения.\",\"generated_as_correct\":false}],\"question\":\"Почему `std::unique` не удаляет все повторяющиеся элементы, а только соседние?\"},{\"answers\":[{\"text\":\"`std::unique` перемещает уникальные элементы в начало диапазона и возвращает итератор на новый конец, по которому можно определить количество уникальных элементов.\",\"generated_as_correct\":true},{\"text\":\"`std::unique` подсчитывает количество уникальных элементов в диапазоне и возвращает это значение в виде числа, без изменения самого диапазона.\",\"generated_as_correct\":false},{\"text\":\"`std::unique` используется для сортировки элементов в диапазоне по возрастанию или убыванию, что позволяет легко определить уникальные значения.\",\"generated_as_correct\":false},{\"text\":\"`std::unique` возвращает количество уникальных элементов в диапазоне без изменения его содержимого.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать `std::unique` для определения количества уникальных элементов в диапазоне?\"},{\"answers\":[{\"text\":\"`std::set_difference` вычисляет разность между двумя отсортированными диапазонами.\",\"generated_as_correct\":true},{\"text\":\"`std::set_difference` — это алгоритм, который находит общие элементы в двух несортированных диапазонах и выводит их в случайном порядке.\",\"generated_as_correct\":false},{\"text\":\"`std::set_difference` используется для сортировки элементов в диапазоне по определённому критерию и не связан с операциями над множествами.\",\"generated_as_correct\":false},{\"text\":\"`std::set_difference` находит пересечение двух диапазонов и выводит результат.\",\"generated_as_correct\":false}],\"question\":\"Что делает алгоритм `std::set_difference`?\"},{\"answers\":[{\"text\":\"`std::set_difference` работает с отсортированными диапазонами, чтобы эффективно вычислять разность между ними.\",\"generated_as_correct\":true},{\"text\":\"`std::set_difference` требует отсортированные диапазоны для того, чтобы упростить процесс поиска уникальных элементов в каждом из диапазонов независимо друг от друга.\",\"generated_as_correct\":false},{\"text\":\"`std::set_difference` требует отсортированные диапазоны, потому что это необходимо для корректной работы других алгоритмов стандартной библиотеки, таких как `std::sort`.\",\"generated_as_correct\":false},{\"text\":\"`std::set_difference` требует отсортированные диапазоны, чтобы обеспечить случайный доступ к элементам.\",\"generated_as_correct\":false}],\"question\":\"Почему для использования `std::set_difference` диапазоны должны быть отсортированы?\"},{\"answers\":[{\"text\":\"`std::set_difference` находит разность между двумя отсортированными множествами и записывает результат в выходной диапазон.\",\"generated_as_correct\":true},{\"text\":\"`std::set_difference` применяется для объединения двух множеств и записи всех элементов в указанный выходной диапазон без учёта их наличия в обоих исходных диапазонах.\",\"generated_as_correct\":false},{\"text\":\"`std::set_difference` связан с операциями по сортировке элементов в одном диапазоне согласно значениям из другого диапазона.\",\"generated_as_correct\":false},{\"text\":\"`std::set_difference` используется для нахождения общих элементов в двух множествах.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить `std::set_difference` для работы с множествами?\"},{\"answers\":[{\"text\":\"Приближённый двоичный поиск — это метод нахождения ближайшего элемента в отсортированном массиве.\",\"generated_as_correct\":true},{\"text\":\"Приближённый двоичный поиск — это метод, который позволяет находить среднее значение в массиве путём последовательного перебора всех элементов.\",\"generated_as_correct\":false},{\"text\":\"Приближённый двоичный поиск используется для сортировки элементов в массиве по возрастанию или убыванию с помощью алгоритма быстрой сортировки.\",\"generated_as_correct\":false},{\"text\":\"Приближённый двоичный поиск — это способ точного поиска элемента в любом массиве без сортировки.\",\"generated_as_correct\":false}],\"question\":\"Что такое приближённый двоичный поиск?\"},{\"answers\":[{\"text\":\"Приближённый двоичный поиск эффективен для больших объёмов данных благодаря быстрому нахождению ближайшего элемента в отсортированном массиве.\",\"generated_as_correct\":true},{\"text\":\"Приближённый двоичный поиск эффективен для больших объёмов данных, поскольку он позволяет быстро находить точное значение элемента в не отсортированном массиве.\",\"generated_as_correct\":false},{\"text\":\"Приближённый двоичный поиск эффективен, потому что он основан на принципе рекурсии, который позволяет сократить количество операций при работе с графами.\",\"generated_as_correct\":false},{\"text\":\"Приближённый двоичный поиск эффективен для больших объёмов данных, так как позволяет быстро найти элемент в неупорядоченном массиве.\",\"generated_as_correct\":false}],\"question\":\"Почему приближённый двоичный поиск эффективен для больших объёмов данных?\"},{\"answers\":[{\"text\":\"Приближённый двоичный поиск применяет `std::lower_bound` для нахождения ближайшего элемента в отсортированном массиве.\",\"generated_as_correct\":true},{\"text\":\"Приближённый двоичный поиск находит точный элемент, равный заданному значению, в отсортированном массиве, используя алгоритм линейного поиска.\",\"generated_as_correct\":false},{\"text\":\"Приближённый двоичный поиск используется для сортировки элементов в массиве по возрастанию или убыванию.\",\"generated_as_correct\":false},{\"text\":\"Приближённый двоичный поиск ищет заданное значение в неотсортированном массиве.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить приближённый двоичный поиск для нахождения ближайшего элемента в отсортированном массиве?\"},{\"answers\":[{\"text\":\"`std::multiset` — контейнер для хранения отсортированных элементов с возможностью дубликатов.\",\"generated_as_correct\":true},{\"text\":\"`std::multiset` — это контейнер, который хранит элементы без какой-либо сортировки и автоматически удаляет дубликаты при добавлении новых элементов.\",\"generated_as_correct\":false},{\"text\":\"`std::multiset` — это структура данных, используемая для реализации алгоритмов сортировки и поиска, но она не позволяет хранить дубликаты элементов.\",\"generated_as_correct\":false},{\"text\":\"`std::multiset` — контейнер, который хранит уникальные элементы в неупорядоченном виде.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой контейнер `std::multiset`?\"},{\"answers\":[{\"text\":\"`std::multiset` позволяет хранить дубликаты элементов в отсортированном порядке, обеспечивая быстрый доступ к крайним значениям.\",\"generated_as_correct\":true},{\"text\":\"`std::multiset` полезен в ситуациях, когда необходимо хранить элементы без сортировки и без возможности доступа к минимальным или максимальным элементам, но с возможностью хранения повторяющихся значений.\",\"generated_as_correct\":false},{\"text\":\"`std::multiset` применяется в алгоритмах сортировки для обеспечения стабильности порядка элементов при наличии повторяющихся значений, что важно для некоторых специализированных задач обработки данных.\",\"generated_as_correct\":false},{\"text\":\"`std::multiset` используется для хранения уникальных элементов и не допускает дубликатов.\",\"generated_as_correct\":false}],\"question\":\"Почему использование `std::multiset` может быть предпочтительным в задачах, где требуется хранить элементы с повторяющимися значениями?\"},{\"answers\":[{\"text\":\"`std::multiset` хранит элементы в отсортированном порядке, что позволяет быстро получать доступ к минимальным или максимальным значениям.\",\"generated_as_correct\":true},{\"text\":\"`std::multiset` — это контейнер, который хранит уникальные элементы и обеспечивает быстрый доступ к ним через хеш-таблицу.\",\"generated_as_correct\":false},{\"text\":\"`std::multiset` используется для хранения элементов без учёта их порядка и обеспечивает быстрый доступ ко всем элементам через итераторы.\",\"generated_as_correct\":false},{\"text\":\"`std::multiset` позволяет хранить элементы в любом порядке и обеспечивает быстрый доступ к элементам через индексы.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать `std::multiset` для быстрого доступа к минимальным или максимальным элементам?\"}],\"StoreCardId\":null,\"numberInCourse\":\"3.5\"}]},{\"id\":27,\"Name\":\"4. Идиомы C++\",\"Articles\":[{\"Name\":\"cpp | 4.1 Классы\",\"Slug\":\"classes\",\"createdAt\":\"2024-07-03T17:57:39.759Z\",\"updatedAt\":\"2026-01-10T12:07:10.245Z\",\"publishedAt\":\"2024-07-03T17:57:41.056Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42158/problem\",\"Lead\":\"Класс, как и структура, задаёт тип данных, но дополнительно определяет его поведение. Переменные такого типа называются объектами. В этом параграфе мы напишем класс Time и познакомимся с перегрузкой операторов.\",\"Content\":\"$69\",\"Title\":\"Классы\",\"LikesCount\":29,\"Quiz\":[{\"answers\":[{\"text\":\"Класс в C++ обеспечивает контроль над данными через инварианты, структура — для простых данных.\",\"generated_as_correct\":true},{\"text\":\"Класс в C++ отличается от структуры тем, что класс может содержать только методы, а структура — только данные.\",\"generated_as_correct\":false},{\"text\":\"Класс и структура в C++ различаются способами объявления переменных, где класс использует ключевое слово `class`, а структура — `struct`, но это не влияет на их функциональность.\",\"generated_as_correct\":false},{\"text\":\"Класс в C++ предназначен для хранения простых данных, структура — для сложных.\",\"generated_as_correct\":false}],\"question\":\"Чем отличается класс от структуры в C++?\"},{\"answers\":[{\"text\":\"В C++ класс предпочтительнее для сложных сценариев, требующих контроля состояния объектов.\",\"generated_as_correct\":true},{\"text\":\"В C++ класс используется вместо структуры, потому что он автоматически обеспечивает сортировку данных и упрощает доступ к ним.\",\"generated_as_correct\":false},{\"text\":\"В C++ выбор между классом и структурой зависит от предпочтений программиста и особенностей используемого компилятора.\",\"generated_as_correct\":false},{\"text\":\"В C++ структуру лучше использовать для сложных сценариев с контролем состояния объектов.\",\"generated_as_correct\":false}],\"question\":\"Почему в C++ для некоторых сценариев предпочтительнее использовать класс, а не структуру?\"},{\"answers\":[{\"text\":\"структуры в C++ подходят для простых данных, а классы — для сложных с контролем состояния.\",\"generated_as_correct\":true},{\"text\":\"структуры и классы в C++ не имеют различий в применении и используются исключительно для определения простых типов данных, без возможности контроля над их состоянием.\",\"generated_as_correct\":false},{\"text\":\"структуры и классы в C++ применяются для создания графических интерфейсов и работы с библиотеками сторонних разработчиков.\",\"generated_as_correct\":false},{\"text\":\"структуры и классы в C++ одинаковы и используются только для хранения числовых данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить структуры и классы в C++ для организации данных в программе?\"},{\"answers\":[{\"text\":\"Инвариант класса — это условие для корректности состояния объектов класса.\",\"generated_as_correct\":true},{\"text\":\"Инвариант класса — это дополнительный метод, который используется для расширения функциональности объектов класса.\",\"generated_as_correct\":false},{\"text\":\"Инвариант класса связан с принципами наследования и позволяет объектам класса наследовать свойства других классов.\",\"generated_as_correct\":false},{\"text\":\"Инвариант класса — это необязательное свойство, которое может быть применено к некоторым объектам класса по желанию программиста.\",\"generated_as_correct\":false}],\"question\":\"Что такое инвариант класса?\"},{\"answers\":[{\"text\":\"Инварианты классов обеспечивают корректность состояния объектов, что необходимо для целостности данных в программе.\",\"generated_as_correct\":true},{\"text\":\"Инварианты классов важны, потому что они позволяют изменять состояние объектов класса в произвольное время, что обеспечивает гибкость и динамичность работы программы.\",\"generated_as_correct\":false},{\"text\":\"Инварианты классов связаны с принципами объектно-ориентированного программирования и используются для определения методов класса, что способствует структурированию кода.\",\"generated_as_correct\":false},{\"text\":\"Инварианты классов нужны для определения структуры данных, но не влияют на целостность данных в программе.\",\"generated_as_correct\":false}],\"question\":\"Почему инварианты классов важны для обеспечения целостности данных в программе?\"},{\"answers\":[{\"text\":\"Инварианты классов гарантируют корректность состояния объектов, проверяя выполнение определённых условий.\",\"generated_as_correct\":true},{\"text\":\"Инварианты классов служат для определения возможных состояний объектов, но не гарантируют, что объекты будут находиться только в допустимых состояниях.\",\"generated_as_correct\":false},{\"text\":\"Инварианты классов используются для классификации объектов по их состоянию и не применяются для проверки корректности этих состояний.\",\"generated_as_correct\":false},{\"text\":\"Инварианты классов определяют возможные изменения состояния объектов, но не проверяют их корректность.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать инварианты классов для проверки корректности состояния объектов?\"},{\"answers\":[{\"text\":\"Конструктор — это функция в классе для инициализации полей объекта при его создании.\",\"generated_as_correct\":true},{\"text\":\"Конструктор — это функция, которая вызывается вручную программистом для создания класса и определения его методов.\",\"generated_as_correct\":false},{\"text\":\"Конструктор — это инструмент в интегрированной среде разработки, который помогает создавать визуальные интерфейсы для приложений.\",\"generated_as_correct\":false},{\"text\":\"Конструктор — это метод, который вызывается при каждом использовании объекта для обновления его данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое конструктор в контексте программирования?\"},{\"answers\":[{\"text\":\"Конструкторы задают начальное состояние объектов при их создании.\",\"generated_as_correct\":true},{\"text\":\"Конструкторы используются для уничтожения объектов и освобождения памяти, а не для их инициализации.\",\"generated_as_correct\":false},{\"text\":\"Конструкторы важны для определения методов класса и не имеют отношения к инициализации объектов.\",\"generated_as_correct\":false},{\"text\":\"Конструкторы нужны для изменения состояния объектов после их создания.\",\"generated_as_correct\":false}],\"question\":\"Почему конструкторы важны для инициализации объектов?\"},{\"answers\":[{\"text\":\"Конструктор — это функция в классе для инициализации полей объекта при его создании.\",\"generated_as_correct\":true},{\"text\":\"Конструктор — это функция, которая вызывается автоматически при каждом обращении к объекту и используется для изменения его полей в процессе работы программы.\",\"generated_as_correct\":false},{\"text\":\"Конструкторы используются для определения структуры класса и не имеют отношения к инициализации полей объекта при его создании.\",\"generated_as_correct\":false},{\"text\":\"Конструктор — это метод для удаления объекта и его полей из памяти.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать конструкторы для обеспечения корректности значений полей объекта при его создании?\"},{\"answers\":[{\"text\":\"Константные функции — это функции в классе, которые не изменяют состояние объекта.\",\"generated_as_correct\":true},{\"text\":\"Константные функции в классе — это функции, предназначенные исключительно для создания новых объектов и не влияющие на уже существующие.\",\"generated_as_correct\":false},{\"text\":\"Константные функции в классе связаны с определением статических переменных и используются для инициализации значений при создании объекта.\",\"generated_as_correct\":false},{\"text\":\"Константные функции в классе позволяют изменять состояние объекта при вызове.\",\"generated_as_correct\":false}],\"question\":\"Что такое константные функции в классе?\"},{\"answers\":[{\"text\":\"Константные функции предотвращают изменение состояния объекта, обеспечивая безопасность доступа к данным.\",\"generated_as_correct\":true},{\"text\":\"Константные функции позволяют изменять состояние объекта, если это необходимо для выполнения определённых операций, что помогает предотвратить непреднамеренные изменения данных.\",\"generated_as_correct\":false},{\"text\":\"Константные функции используются для оптимизации производительности программ, так как они позволяют компилятору применять определённые оптимизации, не связанные с изменением состояния объекта.\",\"generated_as_correct\":false},{\"text\":\"Константные функции обеспечивают изменение состояния объекта в контролируемых условиях, предотвращая непреднамеренные модификации.\",\"generated_as_correct\":false}],\"question\":\"Почему использование константных функций способствует предотвращению непреднамеренного изменения состояния объекта?\"},{\"answers\":[{\"text\":\"Константные функции обеспечивают безопасный доступ к данным объекта, не позволяя их изменять.\",\"generated_as_correct\":true},{\"text\":\"Константные функции позволяют изменять данные объекта в защищённом режиме, что повышает безопасность при работе с конфиденциальной информацией.\",\"generated_as_correct\":false},{\"text\":\"Константные функции используются для оптимизации производительности программ, так как они позволяют кэшировать результаты вычислений и избегать повторного выполнения одних и тех же операций.\",\"generated_as_correct\":false},{\"text\":\"Константные функции применяются для изменения состояния объекта в целях повышения безопасности данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить константные функции для обеспечения дополнительной безопасности при работе с данными объекта?\"},{\"answers\":[{\"text\":\"Перегрузка конструкторов позволяет определить в одном классе несколько конструкторов с разными параметрами.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка конструкторов — это механизм, который позволяет изменять параметры существующего конструктора в зависимости от условий инициализации объекта.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка конструкторов связана с наследованием классов и используется для расширения функциональности базовых конструкторов в производных классах.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка конструкторов позволяет использовать один и тот же конструктор для создания объектов с разными именами.\",\"generated_as_correct\":false}],\"question\":\"Что такое перегрузка конструкторов?\"},{\"answers\":[{\"text\":\"Перегрузка конструкторов обеспечивает гибкость при создании объектов класса с разными параметрами.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка конструкторов позволяет создавать несколько объектов с одинаковыми параметрами в одном классе, что упрощает процесс инициализации.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка конструкторов используется для определения методов в классе, что позволяет выполнять различные операции над объектами.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка конструкторов нужна для создания одного объекта с фиксированными параметрами в классе.\",\"generated_as_correct\":false}],\"question\":\"Почему перегрузка конструкторов считается полезным механизмом в программировании?\"},{\"answers\":[{\"text\":\"Перегрузка конструкторов даёт возможность определить несколько конструкторов с разными параметрами в одном классе.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка конструкторов заключается в создании одного конструктора с переменным количеством параметров, что позволяет инициализировать объекты класса разными способами.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка конструкторов используется для определения методов класса, которые могут быть вызваны с разными параметрами.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка конструкторов позволяет создать один конструктор, который автоматически подстраивается под разные параметры при инициализации объектов.\",\"generated_as_correct\":false}],\"question\":\"Как перегрузка конструкторов может быть применена для инициализации объектов класса различными способами?\"},{\"answers\":[{\"text\":\"Перегрузка операторов позволяет использовать стандартные операторы с пользовательскими типами данных.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка операторов в программировании — это возможность использовать стандартные операторы языка только с предопределёнными типами данных, такими как int или string.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов в программировании связана с изменением приоритетов операторов в зависимости от контекста выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов — это изменение названий стандартных операторов языка.\",\"generated_as_correct\":false}],\"question\":\"Что такое перегрузка операторов в программировании?\"},{\"answers\":[{\"text\":\"Перегрузка операторов делает код более читаемым, позволяя использовать стандартные операторы с пользовательскими типами.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка операторов позволяет изменять приоритет операторов в коде, что делает его более компактным и удобным для чтения.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов используется для создания новых ключевых слов в языке программирования, что позволяет расширить его синтаксические возможности.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов усложняет понимание кода, так как изменяет стандартное поведение операторов.\",\"generated_as_correct\":false}],\"question\":\"Почему перегрузка операторов может сделать код более читаемым и удобным в использовании?\"},{\"answers\":[{\"text\":\"Перегрузка операторов позволяет использовать стандартные операторы с объектами пользовательских классов.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка операторов позволяет использовать стандартные операторы языка только с предопределёнными типами данных, не затрагивая пользовательские классы.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов связана с изменением приоритетов операторов в языке программирования и не влияет на работу с объектами пользовательских классов.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов запрещает использование стандартных операторов с объектами пользовательских классов.\",\"generated_as_correct\":false}],\"question\":\"Как перегрузка операторов позволяет использовать стандартные операторы языка с объектами пользовательских классов?\"},{\"answers\":[{\"text\":\"Интерфейс класса — это открытая часть класса, доступная для взаимодействия пользователя с объектами.\",\"generated_as_correct\":true},{\"text\":\"Интерфейс класса — это визуальное представление класса, которое отображает его структуру и связи с другими классами в виде диаграммы.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс класса связан с архитектурой операционной системы и определяет, как класс взаимодействует с аппаратными ресурсами компьютера.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс класса — это внутренняя структура данных, которая определяет поведение объекта.\",\"generated_as_correct\":false}],\"question\":\"Что такое интерфейс класса?\"},{\"answers\":[{\"text\":\"Интерфейс класса определяет доступные методы и функции для работы с объектами класса.\",\"generated_as_correct\":true},{\"text\":\"Интерфейс класса важен только для разработчиков, которые создают класс, но не для пользователей, взаимодействующих с объектами класса.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс класса связан с определением структуры данных внутри класса и не имеет прямого отношения к взаимодействию пользователей с объектами класса.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс класса служит только для внутренней организации кода и не влияет на взаимодействие с объектами класса.\",\"generated_as_correct\":false}],\"question\":\"Почему интерфейс класса важен для взаимодействия пользователей с объектами класса?\"},{\"answers\":[{\"text\":\"Интерфейс класса определяет доступные функции для взаимодействия пользователя с объектами класса.\",\"generated_as_correct\":true},{\"text\":\"Интерфейс класса содержит только переменные, которые определяют состояние объекта, и не включает никаких функций для взаимодействия с пользователем.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс класса используется для определения структуры данных и не имеет отношения к работе с объектами, он важен для организации кода и наследования.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс класса служит для скрытия всех методов и данных объекта от пользователя.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать интерфейс класса для работы с объектами?\"}],\"StoreCardId\":null,\"numberInCourse\":\"4.1\"},{\"Name\":\"cpp | 4.2. Шаблонные классы\",\"Slug\":\"template-classes\",\"createdAt\":\"2024-07-03T17:59:25.293Z\",\"updatedAt\":\"2026-01-10T12:07:11.410Z\",\"publishedAt\":\"2024-07-03T17:59:26.666Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42182/problem\",\"Lead\":\"Классы, как и функции, могут быть шаблонными. Примерами шаблонов классов являются все контейнеры стандартной библиотеки. В этом параграфе мы напишем шаблонный класс «Матрица».\",\"Content\":\"$6a\",\"Title\":\"Шаблонные классы\",\"LikesCount\":20,\"Quiz\":[{\"answers\":[{\"text\":\"Шаблонные классы в C++ позволяют создавать обобщённые структуры данных, параметризуемые типами или константами.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные классы в C++ — это предопределённые классы, которые нельзя изменять и которые предназначены для работы только с определёнными типами данных.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные классы в C++ используются для создания графических интерфейсов и не имеют отношения к работе с различными типами данных.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные классы в C++ предназначены для работы исключительно с числовыми типами данных.\",\"generated_as_correct\":false}],\"question\":\"Что такое шаблонные классы в C++?\"},{\"answers\":[{\"text\":\"Шаблонные классы позволяют создавать гибкие структуры данных, работающие с разными типами, что способствует переиспользованию кода.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные классы позволяют использовать один и тот же код для разных алгоритмов, что упрощает разработку, но не влияет на переиспользование кода в контексте различных типов данных.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные классы способствуют улучшению читаемости кода и упрощают его отладку, что косвенно влияет на переиспользование, но их основная функция — обеспечение типобезопасности.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные классы обеспечивают переиспользование кода путём автоматического создания новых типов данных на основе существующих.\",\"generated_as_correct\":false}],\"question\":\"Почему использование шаблонных классов способствует переиспользованию кода?\"},{\"answers\":[{\"text\":\"Шаблонные классы позволяют создавать гибкие структуры данных, работающие с разными типами данных.\",\"generated_as_correct\":true},{\"text\":\"Шаблонные классы в C++ применяются для создания структур данных, которые автоматически адаптируются под любой тип данных без необходимости параметризации.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные классы используются в C++ для определения функций, которые могут принимать любое количество аргументов, что позволяет создавать гибкие интерфейсы для работы с данными.\",\"generated_as_correct\":false},{\"text\":\"Шаблонные классы предназначены для создания статических структур данных, работающих только с одним типом данных.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить шаблонные классы для создания обобщённых структур данных?\"},{\"answers\":[{\"text\":\"Матрица — это таблица чисел с определёнными математическими операциями.\",\"generated_as_correct\":true},{\"text\":\"Матрица — это геометрическая фигура, состоящая из строк и столбцов, которая используется для визуализации данных и построения графиков.\",\"generated_as_correct\":false},{\"text\":\"Матрица — это структура данных в программировании, используемая для хранения и обработки информации в виде иерархической системы.\",\"generated_as_correct\":false},{\"text\":\"Матрица — это множество чисел без определённой структуры, используемое для вычислений.\",\"generated_as_correct\":false}],\"question\":\"Что такое матрица в математике?\"},{\"answers\":[{\"text\":\"Матрицы позволяют выполнять сложение, вычитание и умножение благодаря своей структуре таблицы чисел, что используется для линейных преобразований и решения систем уравнений.\",\"generated_as_correct\":true},{\"text\":\"Матрицы определяют операции сложения, вычитания и умножения, потому что они представляют собой геометрические фигуры, для которых эти операции имеют наглядную интерпретацию в пространстве.\",\"generated_as_correct\":false},{\"text\":\"Матрицы используются для хранения и обработки данных в компьютерных алгоритмах, и операции с ними определены для обеспечения совместимости с векторными и тензорными операциями в машинном обучении.\",\"generated_as_correct\":false},{\"text\":\"Матрицы определяют операции сложения, вычитания и умножения, так как они представляют собой скалярные величины, которые можно комбинировать любым образом.\",\"generated_as_correct\":false}],\"question\":\"Почему для матриц определены операции сложения, вычитания и умножения?\"},{\"answers\":[{\"text\":\"Матрицы используются для представления данных, линейных преобразований и решения систем уравнений.\",\"generated_as_correct\":true},{\"text\":\"Матрицы применяются в математике и компьютерных науках для создания графических интерфейсов и визуализации данных, но не используются для выполнения математических операций.\",\"generated_as_correct\":false},{\"text\":\"Матрицы играют важную роль в теории игр и используются для анализа стратегий в игровых алгоритмах, но их применение ограничено только этой областью.\",\"generated_as_correct\":false},{\"text\":\"Матрицы применяются только для хранения данных в компьютерных науках и не используются в математических операциях.\",\"generated_as_correct\":false}],\"question\":\"Как матрицы применяются в математике и компьютерных науках?\"},{\"answers\":[{\"text\":\"Перегрузка по константности — это определение разных версий функций в зависимости от константности объекта.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка по константности — это механизм, который позволяет изменять константные объекты, обеспечивая гибкость при работе с данными.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка по константности относится к методам оптимизации компилятора, которые помогают ускорить выполнение программ за счёт более эффективного использования памяти.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка по константности — это автоматическое преобразование константных объектов в неконстантные при вызове функций.\",\"generated_as_correct\":false}],\"question\":\"Что такое перегрузка по константности в контексте программирования?\"},{\"answers\":[{\"text\":\"Перегрузка по константности позволяет определить разные версии функций для константных и неконстантных объектов, обеспечивая безопасность типов.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка по константности обеспечивает безопасность типов путём автоматического преобразования типов данных при вызове функций, что предотвращает ошибки при работе с константными объектами.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка по константности связана с возможностью перегрузки операторов в языке программирования и не имеет прямого отношения к обеспечению безопасности типов.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка по константности гарантирует, что все данные в программе будут константными и не смогут быть изменены.\",\"generated_as_correct\":false}],\"question\":\"Как перегрузка по константности помогает обеспечить безопасность типов?\"},{\"answers\":[{\"text\":\"Перегрузка по константности позволяет определять разные версии функций для константных и неконстантных объектов, обеспечивая безопасность типов.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка по константности применяется для изменения поведения функций в зависимости от типа данных, передаваемых в качестве аргументов, независимо от константности объекта.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка по константности связана с оптимизацией производительности программ и используется для автоматического выбора наиболее эффективного алгоритма в зависимости от размера входных данных.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка по константности нужна для создания одинаковых функций с разными именами в одном классе.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть полезно использовать перегрузку по константности при разработке программного обеспечения?\"},{\"answers\":[{\"text\":\"Итерация по матрице — это доступ к её элементам через цикл с определёнными функциями begin и end.\",\"generated_as_correct\":true},{\"text\":\"Итерация по матрице — это метод вычисления определителя матрицы путём последовательного перемножения её элементов.\",\"generated_as_correct\":false},{\"text\":\"Итерация по матрице — это способ визуализации данных матрицы с помощью графических библиотек, не требующий определения специальных функций.\",\"generated_as_correct\":false},{\"text\":\"Итерация по матрице — это операция сложения всех элементов матрицы в определённом порядке.\",\"generated_as_correct\":false}],\"question\":\"Что такое итерация по матрице?\"},{\"answers\":[{\"text\":\"Функции begin и end нужны для итерации по матрице, так как они возвращают итераторы для перебора элементов.\",\"generated_as_correct\":true},{\"text\":\"Функции begin и end определяют начальное и конечное значения элементов матрицы для выполнения математических операций над ними.\",\"generated_as_correct\":false},{\"text\":\"Функции begin и end используются для определения границ матрицы в контексте алгоритмов сортировки и поиска.\",\"generated_as_correct\":false},{\"text\":\"Функции begin и end задают начальное и конечное значения для вычисления суммы элементов матрицы.\",\"generated_as_correct\":false}],\"question\":\"Почему для итерации по матрице необходимо определить функции begin и end?\"},{\"answers\":[{\"text\":\"Итерация по матрице позволяет последовательно обращаться к её элементам с помощью цикла range-based for и определённых функций begin и end.\",\"generated_as_correct\":true},{\"text\":\"Итерация по матрице осуществляется путём прямого обращения к элементам по их индексам, без использования специальных функций или циклов.\",\"generated_as_correct\":false},{\"text\":\"Итерация по матрице используется для сортировки её элементов по возрастанию или убыванию с помощью встроенных функций языка программирования.\",\"generated_as_correct\":false},{\"text\":\"Итерация по матрице нужна для одновременного доступа ко всем элементам матрицы без использования циклов.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать итерацию по матрице в программировании?\"},{\"answers\":[{\"text\":\"Перегрузка операторов (\u003e\u003e) и (\u003c\u003c) для матриц упрощает потоковый ввод и вывод данных.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка операторов ввода (\u003e\u003e) и вывода (\u003c\u003c) для матриц заключается в использовании специальных функций для сортировки элементов матрицы по возрастанию или убыванию.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов ввода (\u003e\u003e) и вывода (\u003c\u003c) для матриц связана с алгоритмами шифрования и дешифрования данных, что обеспечивает безопасность при передаче матричных данных по сети.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов (\u003e\u003e) и (\u003c\u003c) для матриц используется для выполнения арифметических операций над элементами матрицы.\",\"generated_as_correct\":false}],\"question\":\"Что такое перегрузка операторов ввода (\u003e\u003e) и вывода (\u003c\u003c) для матриц?\"},{\"answers\":[{\"text\":\"Перегрузка операторов ввода и вывода упрощает работу с матрицами, обеспечивая удобный формат для чтения и записи данных.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка потоковых операторов упрощает работу с матрицами за счёт автоматического выполнения математических операций при вводе и выводе данных.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка потоковых операторов важна для оптимизации алгоритмов сортировки и поиска в матрицах.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка потоковых операторов позволяет выполнять арифметические операции над матрицами.\",\"generated_as_correct\":false}],\"question\":\"Почему перегрузка потоковых операторов упрощает работу с матрицами?\"},{\"answers\":[{\"text\":\"Перегрузка операторов \u003e\u003e и \u003c\u003c упрощает потоковый ввод и вывод данных матриц.\",\"generated_as_correct\":true},{\"text\":\"Перегрузка операторов ввода и вывода для матриц используется исключительно для изменения размеров матриц и не имеет отношения к потоковому вводу или выводу данных.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов ввода и вывода для матриц применяется для выполнения математических операций над элементами матрицы, таких как сложение и умножение.\",\"generated_as_correct\":false},{\"text\":\"Перегрузка операторов ввода и вывода используется для сортировки элементов матрицы в определённом порядке.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить перегрузку операторов ввода и вывода для работы с матрицами в потоковом режиме?\"},{\"answers\":[{\"text\":\"Перед сложением матриц нужно проверить их размеры на совпадение.\",\"generated_as_correct\":true},{\"text\":\"Перед выполнением сложения матриц необходимо убедиться, что они имеют одинаковое количество строк, но количество столбцов может быть разным.\",\"generated_as_correct\":false},{\"text\":\"Перед выполнением сложения матриц важно проверить их определители, так как это влияет на возможность выполнения других операций, например, умножения матриц.\",\"generated_as_correct\":false},{\"text\":\"Перед сложением матриц необходимо проверить их элементы на равенство.\",\"generated_as_correct\":false}],\"question\":\"Что необходимо проверить перед выполнением сложения матриц и почему?\"},{\"answers\":[{\"text\":\"«Важно генерировать исключения при несоответствии размеров матриц, чтобы избежать ошибок в арифметических операциях и обеспечить корректность результатов».\",\"generated_as_correct\":true},{\"text\":\"«Генерировать исключения при несоответствии размеров матриц важно для обеспечения безопасности данных, так как это предотвращает несанкционированный доступ к элементам матриц во время арифметических операций».\",\"generated_as_correct\":false},{\"text\":\"«Генерировать исключения при несоответствии размеров матриц важно для оптимизации памяти, так как это позволяет более эффективно распределять ресурсы при работе с большими объёмами данных».\",\"generated_as_correct\":false},{\"text\":\"«Важно генерировать исключения при несоответствии размеров матриц, чтобы автоматически изменять размеры матриц под требуемый формат операции».\",\"generated_as_correct\":false}],\"question\":\"Почему важно генерировать исключения при несоответствии размеров матриц при выполнении арифметических операций?\"},{\"answers\":[{\"text\":\"Сложение и умножение матриц — основа линейных алгебраических операций в научных и технических вычислениях.\",\"generated_as_correct\":true},{\"text\":\"Операции сложения и умножения матриц используются для сортировки данных и поиска оптимальных путей в графах, что является ключевым элементом в алгоритмах машинного обучения.\",\"generated_as_correct\":false},{\"text\":\"Операции сложения и умножения матриц тесно связаны с теорией вероятностей и используются для анализа статистических данных в социальных науках.\",\"generated_as_correct\":false},{\"text\":\"Сложение и умножение матриц используются для вычисления интегралов и решения дифференциальных уравнений.\",\"generated_as_correct\":false}],\"question\":\"Как операции сложения и умножения матриц применяются в научных и технических вычислениях?\"},{\"answers\":[{\"text\":\"Операторы равенства (==) и неравенства (!=) позволяют проверить равенство или неравенство матриц.\",\"generated_as_correct\":true},{\"text\":\"Операторы равенства (==) и неравенства (!=) при сравнении матриц определяют, имеют ли матрицы одинаковую размерность, без учёта их содержимого.\",\"generated_as_correct\":false},{\"text\":\"Операторы равенства (==) и неравенства (!=) используются для определения совместимости матриц при выполнении арифметических операций, таких как сложение и умножение.\",\"generated_as_correct\":false},{\"text\":\"Операторы равенства (==) и неравенства (!=) определяют максимальный и минимальный элементы в матрице.\",\"generated_as_correct\":false}],\"question\":\"Что позволяют определить операторы равенства (==) и неравенства (!=) при сравнении матриц?\"},{\"answers\":[{\"text\":\"Учёт возможности сравнения матриц разных типов важен для корректной проверки их равенства или неравенства в алгоритмах.\",\"generated_as_correct\":true},{\"text\":\"Учёт возможности сравнения матриц разных типов важен, потому что это позволяет автоматически преобразовывать матрицы в один тип для упрощения вычислений, что ускоряет обработку данных.\",\"generated_as_correct\":false},{\"text\":\"Учёт возможности сравнения матриц разных типов важен для оптимизации хранения данных в памяти, так как это позволяет более эффективно распределять ресурсы между различными типами матриц.\",\"generated_as_correct\":false},{\"text\":\"Учёт возможности сравнения матриц разных типов не важен, так как все матрицы должны быть одного типа для корректного сравнения.\",\"generated_as_correct\":false}],\"question\":\"Почему важно учитывать возможность сравнения матриц разных типов при использовании операторов равенства и неравенства?\"},{\"answers\":[{\"text\":\"Сравнение матриц полезно для проверки их равенства или неравенства в алгоритмах и условиях.\",\"generated_as_correct\":true},{\"text\":\"Сравнение матриц применяется для определения их размера и типа данных, что может быть полезно при сортировке матриц по определённым критериям.\",\"generated_as_correct\":false},{\"text\":\"Сравнение матриц может быть использовано для анализа их собственных значений и векторов, что важно в задачах линейной алгебры и машинного обучения.\",\"generated_as_correct\":false},{\"text\":\"Сравнение матриц нужно для вычисления их произведения в различных алгоритмах.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях может быть полезно сравнение матриц, например, при проверке условий или реализации алгоритмов?\"}],\"StoreCardId\":null,\"numberInCourse\":\"4.2\"},{\"Name\":\"cpp | 4.3 Жизненный цикл объекта\",\"Slug\":\"object-lifetime\",\"createdAt\":\"2024-07-03T17:59:51.078Z\",\"updatedAt\":\"2026-01-10T12:07:11.145Z\",\"publishedAt\":\"2024-07-03T17:59:52.418Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42098/problem\",\"Lead\":\"В этом параграфе мы узнаем подробнее про конструкторы, деструктор и оператор присваивания, проследим эволюцию объекта от создания до уничтожения, поговорим про временные объекты, а также рассмотрим два разных способа создать объект: на стеке или в динамической памяти.\",\"Content\":\"$6b\",\"Title\":\"Жизненный цикл объекта\",\"LikesCount\":20,\"Quiz\":[{\"answers\":[{\"text\":\"Конструктор в C++ — это функция в классе для инициализации объектов при их создании.\",\"generated_as_correct\":true},{\"text\":\"Конструктор в языке программирования C++ — это метод, который используется для изменения состояния объекта после его создания.\",\"generated_as_correct\":false},{\"text\":\"Конструктор в языке программирования C++ связан с функциями обработки исключений и используется для управления потоком выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Конструктор в C++ — это функция для удаления объектов из памяти.\",\"generated_as_correct\":false}],\"question\":\"Что такое конструктор в контексте языка программирования C++?\"},{\"answers\":[{\"text\":\"Конструкторы в C++ инициализируют объекты при создании, задавая их начальное состояние.\",\"generated_as_correct\":true},{\"text\":\"Конструкторы используются в C++ исключительно для уничтожения объектов и не имеют отношения к их созданию или инициализации.\",\"generated_as_correct\":false},{\"text\":\"Конструкторы в C++ связаны с наследованием и полиморфизмом, они позволяют определять методы для работы с объектами, но не участвуют в управлении их жизненным циклом.\",\"generated_as_correct\":false},{\"text\":\"Конструкторы в C++ нужны для удаления объектов из памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему конструкторы важны для управления жизненным циклом объектов в C++?\"},{\"answers\":[{\"text\":\"Конструктор инициализирует состояние объекта при его создании с помощью параметров.\",\"generated_as_correct\":true},{\"text\":\"Конструктор — это метод в классе, который автоматически вызывается при каждом обращении к объекту и позволяет настраивать его состояние.\",\"generated_as_correct\":false},{\"text\":\"Конструктор используется для создания классов и определения их структуры, но не влияет на состояние объектов при их создании.\",\"generated_as_correct\":false},{\"text\":\"Конструктор изменяет состояние объекта после его создания.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать конструкторы для настройки состояния объекта при его создании?\"},{\"answers\":[{\"text\":\"Деструктор — это функция в классе, вызываемая при уничтожении объекта для освобождения ресурсов.\",\"generated_as_correct\":true},{\"text\":\"Деструктор — это метод, который вызывается вручную программистом для удаления объекта из памяти, не выполняя при этом никаких дополнительных операций по освобождению ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Деструктор — это элемент в алгоритмах сортировки, который определяет порядок удаления элементов из структуры данных.\",\"generated_as_correct\":false},{\"text\":\"Деструктор — это функция, которая вызывается при создании объекта для инициализации его свойств.\",\"generated_as_correct\":false}],\"question\":\"Что такое деструктор в контексте программирования?\"},{\"answers\":[{\"text\":\"Деструкторы освобождают ресурсы объекта перед его удалением.\",\"generated_as_correct\":true},{\"text\":\"Деструкторы в классах служат для копирования состояния объекта перед его удалением из памяти.\",\"generated_as_correct\":false},{\"text\":\"Деструкторы в классах используются для определения порядка следования методов в иерархии наследования.\",\"generated_as_correct\":false},{\"text\":\"Деструкторы применяются для создания копий объектов перед их уничтожением.\",\"generated_as_correct\":false}],\"question\":\"Для чего используются деструкторы в классах?\"},{\"answers\":[{\"text\":\"Деструкторы автоматически освобождают ресурсы объекта перед его удалением из памяти.\",\"generated_as_correct\":true},{\"text\":\"Деструкторы — это функции, которые программист должен вызывать вручную перед удалением объекта из памяти, чтобы освободить ресурсы.\",\"generated_as_correct\":false},{\"text\":\"Деструкторы используются для инициализации объектов и настройки их свойств при создании.\",\"generated_as_correct\":false},{\"text\":\"Деструкторы выделяют дополнительные ресурсы объекту перед его удалением из памяти.\",\"generated_as_correct\":false}],\"question\":\"Как деструкторы помогают управлять ресурсами объекта перед его удалением из памяти?\"},{\"answers\":[{\"text\":\"Оператор присваивания — это оператор, вызываемый при присваивании нового значения объекту, позволяющий копировать значения полей.\",\"generated_as_correct\":true},{\"text\":\"Оператор присваивания в программировании служит для сравнения значений двух переменных и определения, равны ли они друг другу.\",\"generated_as_correct\":false},{\"text\":\"Оператор присваивания связан с алгоритмами сортировки и используется для упорядочивания элементов в массиве.\",\"generated_as_correct\":false},{\"text\":\"Оператор присваивания используется для объявления новых переменных в программе.\",\"generated_as_correct\":false}],\"question\":\"Что такое оператор присваивания в контексте программирования?\"},{\"answers\":[{\"text\":\"Оператор присваивания копирует значения полей одного объекта в другой и может быть переопределён.\",\"generated_as_correct\":true},{\"text\":\"Оператор присваивания служит для создания новых объектов на основе существующих и не может быть модифицирован для выполнения каких-либо дополнительных операций.\",\"generated_as_correct\":false},{\"text\":\"Оператор присваивания связан с процессом инициализации объектов и используется для определения их начальных значений, но не влияет на копирование или изменение существующих объектов.\",\"generated_as_correct\":false},{\"text\":\"Оператор присваивания удаляет значения полей объекта при копировании в другой объект.\",\"generated_as_correct\":false}],\"question\":\"Какие функции выполняет оператор присваивания при работе с объектами?\"},{\"answers\":[{\"text\":\"Переопределение оператора присваивания позволяет выполнять дополнительную логику при присваивании значения объекту.\",\"generated_as_correct\":true},{\"text\":\"Переопределение оператора присваивания применяется исключительно для изменения типа данных объекта при присваивании нового значения.\",\"generated_as_correct\":false},{\"text\":\"Переопределение оператора присваивания связано с изменением приоритетов операторов в языке программирования и не влияет на выполнение дополнительных действий при присваивании.\",\"generated_as_correct\":false},{\"text\":\"Переопределение оператора присваивания необходимо для автоматического увеличения значения присваиваемой переменной.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать переопределение оператора присваивания для выполнения дополнительных действий?\"},{\"answers\":[{\"text\":\"Автоматические объекты — это объекты в стеке, уничтожаемые при выходе из области видимости.\",\"generated_as_correct\":true},{\"text\":\"Автоматические объекты — это объекты, которые создаются в стеке и сохраняются в памяти до завершения работы программы, независимо от области видимости.\",\"generated_as_correct\":false},{\"text\":\"Автоматические объекты связаны с управлением памятью в языках программирования и часто используются для оптимизации работы с динамическими массивами.\",\"generated_as_correct\":false},{\"text\":\"Автоматические объекты — это объекты, создаваемые в куче и управляемые программистом.\",\"generated_as_correct\":false}],\"question\":\"Что такое автоматические объекты в контексте программирования?\"},{\"answers\":[{\"text\":\"Автоматические объекты уничтожаются при выходе из области видимости, так как их время жизни ограничено блоком кода.\",\"generated_as_correct\":true},{\"text\":\"Автоматические объекты уничтожаются при выходе из области видимости из-за того, что они занимают слишком много памяти и система принудительно удаляет их для оптимизации ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Автоматические объекты уничтожаются при выходе из области видимости по причинам, связанным с управлением памятью в динамической области, что не имеет отношения к их изначальной природе.\",\"generated_as_correct\":false},{\"text\":\"Автоматические объекты уничтожаются при выходе из области видимости, потому что они перемещаются в кучу и освобождают место в стеке.\",\"generated_as_correct\":false}],\"question\":\"Почему автоматические объекты уничтожаются при выходе из области видимости?\"},{\"answers\":[{\"text\":\"Управление временем жизни автоматических объектов важно, так как они уничтожаются при выходе из области видимости, что помогает избежать утечек памяти.\",\"generated_as_correct\":true},{\"text\":\"Управление временем жизни автоматических объектов заключается в том, что программист вручную определяет момент их уничтожения, что позволяет более гибко управлять ресурсами.\",\"generated_as_correct\":false},{\"text\":\"Управление временем жизни автоматических объектов связано с настройкой параметров их взаимодействия с другими объектами в программе, что влияет на логику выполнения кода.\",\"generated_as_correct\":false},{\"text\":\"Управление временем жизни автоматических объектов не требует внимания, так как их время жизни не ограничено и они не влияют на распределение памяти.\",\"generated_as_correct\":false}],\"question\":\"Как управление временем жизни автоматических объектов влияет на разработку программ?\"},{\"answers\":[{\"text\":\"Объекты в динамической памяти создаются оператором `new` и требуют ручного управления временем жизни оператором `delete`.\",\"generated_as_correct\":true},{\"text\":\"Объекты в динамической памяти автоматически создаются операционной системой и управляются ею же, программисту не нужно заботиться об их удалении или управлении временем жизни.\",\"generated_as_correct\":false},{\"text\":\"Объекты в динамической памяти тесно связаны с концепцией стека и используются для хранения временных переменных в функциях.\",\"generated_as_correct\":false},{\"text\":\"Объекты в динамической памяти создаются автоматически и управляются сборщиком мусора.\",\"generated_as_correct\":false}],\"question\":\"Что такое объекты в динамической памяти и как они создаются?\"},{\"answers\":[{\"text\":\"Вручное управление временем жизни объектов в динамической памяти необходимо для предотвращения утечек памяти.\",\"generated_as_correct\":true},{\"text\":\"Вручное управление временем жизни объектов необходимо для ускорения работы программы, поскольку автоматическое управление памятью замедляет выполнение кода.\",\"generated_as_correct\":false},{\"text\":\"Управление временем жизни объектов важно для оптимизации алгоритмов сортировки и поиска в структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Вручное управление временем жизни объектов не требуется, так как операционная система автоматически освобождает память.\",\"generated_as_correct\":false}],\"question\":\"Почему важно вручную управлять временем жизни объектов в динамической памяти?\"},{\"answers\":[{\"text\":\"Утечки памяти возникают, когда программист забывает удалить ненужные объекты с помощью `delete`.\",\"generated_as_correct\":true},{\"text\":\"Утечки памяти происходят из-за неправильного управления объектами в динамической памяти, когда операционная система автоматически удаляет объекты, не дожидаясь команды от программиста.\",\"generated_as_correct\":false},{\"text\":\"Неправильное управление объектами в динамической памяти связано с ошибками в алгоритмах сортировки данных, что может вызвать нестабильность программы.\",\"generated_as_correct\":false},{\"text\":\"Утечки памяти происходят, когда программист слишком часто использует оператор `delete`.\",\"generated_as_correct\":false}],\"question\":\"Как неправильное управление объектами в динамической памяти может привести к утечкам памяти?\"},{\"answers\":[{\"text\":\"Конструктор копирования — это функция для создания глубокой копии объекта.\",\"generated_as_correct\":true},{\"text\":\"Конструктор копирования — это метод, который используется для поверхностного копирования объектов и не учитывает сложные структуры данных или ресурсы.\",\"generated_as_correct\":false},{\"text\":\"Конструктор копирования — это инструмент в графических интерфейсах, который помогает визуализировать структуру объектов и их взаимосвязи.\",\"generated_as_correct\":false},{\"text\":\"Конструктор копирования — это метод для удаления копии объекта.\",\"generated_as_correct\":false}],\"question\":\"Что такое конструктор копирования?\"},{\"answers\":[{\"text\":\"Конструктор копирования обеспечивает глубокое копирование объектов, что необходимо при работе с ресурсами и сложными структурами данных.\",\"generated_as_correct\":true},{\"text\":\"Конструктор копирования нужен для того, чтобы создавать новые объекты с теми же ссылками на ресурсы, что и у исходного объекта, что обеспечивает экономию памяти.\",\"generated_as_correct\":false},{\"text\":\"Конструктор копирования играет важную роль в наследовании классов и определении иерархии объектов в объектно-ориентированном программировании.\",\"generated_as_correct\":false},{\"text\":\"Конструктор копирования служит для создания ссылок на исходные объекты, что упрощает работу с данными.\",\"generated_as_correct\":false}],\"question\":\"Почему использование конструктора копирования важно при работе с объектами, содержащими ресурсы или сложные структуры данных?\"},{\"answers\":[{\"text\":\"Конструктор копирования используется для глубокого копирования состояния объекта.\",\"generated_as_correct\":true},{\"text\":\"Конструктор копирования используется для изменения оригинального объекта, а не для создания его копии.\",\"generated_as_correct\":false},{\"text\":\"Конструктор копирования связан с алгоритмами сортировки и используется для упорядочивания элементов в массиве.\",\"generated_as_correct\":false},{\"text\":\"Конструктор копирования применяется для удаления состояния объекта.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить конструктор копирования для глубокого копирования состояния объекта?\"},{\"answers\":[{\"text\":\"Статические поля и функции — это члены класса, доступные без создания объекта и общие для всех экземпляров класса.\",\"generated_as_correct\":true},{\"text\":\"Статические поля и функции в контексте классов — это специальные методы, которые автоматически вызываются при создании нового экземпляра класса и не могут быть вызваны напрямую.\",\"generated_as_correct\":false},{\"text\":\"Статические поля и функции в контексте классов связаны с алгоритмами сортировки и поиска, которые используются для организации данных в структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Статические поля и функции — это методы, которые могут быть вызваны только после создания экземпляра класса.\",\"generated_as_correct\":false}],\"question\":\"Что такое статические поля и функции в контексте классов?\"},{\"answers\":[{\"text\":\"Статические члены класса делятся между всеми экземплярами и доступны без создания объекта.\",\"generated_as_correct\":true},{\"text\":\"Статические члены класса могут быть доступны без создания объекта, поскольку они хранятся в отдельном пространстве памяти, доступном только через класс, но при этом изменяются при создании каждого нового объекта.\",\"generated_as_correct\":false},{\"text\":\"Статические члены класса используются для определения структуры данных, которая автоматически инициализируется при создании объекта.\",\"generated_as_correct\":false},{\"text\":\"Статические члены класса доступны без создания объекта, потому что они хранятся в оперативной памяти и доступны для всех программ.\",\"generated_as_correct\":false}],\"question\":\"Почему статические члены класса могут быть доступны без создания объекта?\"},{\"answers\":[{\"text\":\"Статические члены класса обеспечивают общий доступ к данным и функциям, не зависящим от конкретных экземпляров класса.\",\"generated_as_correct\":true},{\"text\":\"Статические члены класса используются для хранения данных, которые уникальны для каждого экземпляра класса, и доступ к ним возможен только после создания объекта этого класса.\",\"generated_as_correct\":false},{\"text\":\"Статические члены класса играют важную роль в наследовании и позволяют определять методы, которые могут быть переопределены в подклассах, что способствует полиморфизму.\",\"generated_as_correct\":false},{\"text\":\"Статические члены класса предназначены для хранения данных, уникальных для каждого объекта, и требуют создания экземпляра класса для доступа к ним.\",\"generated_as_correct\":false}],\"question\":\"Как использование статических членов класса способствует организации общего доступа к ресурсам?\"},{\"answers\":[{\"text\":\"Временные объекты — это безымянные объекты, существующие только во время вычисления выражения.\",\"generated_as_correct\":true},{\"text\":\"Временные объекты — это постоянные структуры данных, которые используются для хранения информации на протяжении всего выполнения программы и уничтожаются только при её завершении.\",\"generated_as_correct\":false},{\"text\":\"Временные объекты — это элементы, которые используются в алгоритмах сортировки для временного хранения значений и сравниваются между собой для упорядочивания данных.\",\"generated_as_correct\":false},{\"text\":\"Временные объекты — это именованные переменные, которые используются для хранения данных в течение всей программы.\",\"generated_as_correct\":false}],\"question\":\"Что такое временные объекты?\"},{\"answers\":[{\"text\":\"Временные объекты существуют только во время вычисления выражения и не имеют имени, так как они автоматически уничтожаются после использования.\",\"generated_as_correct\":true},{\"text\":\"Временные объекты не имеют имени, поскольку их создание и уничтожение контролируется программистом вручную, и имена им присваиваются динамически в процессе работы программы.\",\"generated_as_correct\":false},{\"text\":\"Временные объекты не имеют имени, потому что в некоторых языках программирования имена могут быть присвоены только постоянным переменным, а временные объекты относятся к области стека.\",\"generated_as_correct\":false},{\"text\":\"Временные объекты не имеют имени, потому что они предназначены для длительного хранения данных и используются вне контекста выражения.\",\"generated_as_correct\":false}],\"question\":\"Почему временные объекты не имеют имени?\"},{\"answers\":[{\"text\":\"Временные объекты передают данные в функции и уничтожаются после вычисления выражения.\",\"generated_as_correct\":true},{\"text\":\"Временные объекты создаются для передачи данных в функции, но их существование не ограничено временем вычисления выражения, и они могут быть использованы повторно после завершения функции.\",\"generated_as_correct\":false},{\"text\":\"Временные объекты используются в программировании для создания именованных переменных, которые могут быть доступны в различных частях программы.\",\"generated_as_correct\":false},{\"text\":\"Временные объекты сохраняют данные в функции и используются для долговременного хранения информации.\",\"generated_as_correct\":false}],\"question\":\"Как используются временные объекты при передаче данных в функции?\"},{\"answers\":[{\"text\":\"Конструктор перемещения — функция для передачи ресурсов временного объекта в новый без копирования.\",\"generated_as_correct\":true},{\"text\":\"Конструктор перемещения — это функция, которая автоматически удаляет ресурсы временного объекта при создании нового объекта, не передавая их.\",\"generated_as_correct\":false},{\"text\":\"Конструктор перемещения — это инструмент в графических интерфейсах, который используется для визуального перемещения объектов на экране.\",\"generated_as_correct\":false},{\"text\":\"Конструктор перемещения — функция, которая копирует ресурсы из одного объекта в другой.\",\"generated_as_correct\":false}],\"question\":\"Что такое конструктор перемещения?\"},{\"answers\":[{\"text\":\"Конструктор перемещения эффективнее копирования ресурсов, так как передаёт ресурсы без дублирования.\",\"generated_as_correct\":true},{\"text\":\"Использование конструктора перемещения более эффективно, поскольку он создаёт копии ресурсов, что позволяет избежать проблем с доступом к одним и тем же ресурсам из разных объектов.\",\"generated_as_correct\":false},{\"text\":\"Использование конструктора перемещения важно для оптимизации работы с объектами, так как позволяет улучшить взаимодействие между классами и упростить код.\",\"generated_as_correct\":false},{\"text\":\"Конструктор перемещения менее эффективен, так как требует дополнительного копирования ресурсов.\",\"generated_as_correct\":false}],\"question\":\"Почему использование конструктора перемещения считается более эффективным, чем копирование ресурсов?\"},{\"answers\":[{\"text\":\"Конструктор перемещения применяют для передачи ресурсов между объектами без копирования.\",\"generated_as_correct\":true},{\"text\":\"Конструктор перемещения применяется для временного хранения ресурсов объектов, не передавая их другим объектам.\",\"generated_as_correct\":false},{\"text\":\"Конструктор перемещения используется для создания новых объектов на основе существующих, но не связан с передачей ресурсов между ними.\",\"generated_as_correct\":false},{\"text\":\"Конструктор перемещения используют для дублирования ресурсов между объектами.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях целесообразно применять конструктор перемещения для передачи ресурсов между объектами?\"}],\"StoreCardId\":null,\"numberInCourse\":\"4.3\"},{\"Name\":\"cpp | 4.4. Наследование и полиморфизм\",\"Slug\":\"inheritance-and-polymorphism\",\"createdAt\":\"2024-07-03T18:01:05.461Z\",\"updatedAt\":\"2026-01-10T12:07:10.942Z\",\"publishedAt\":\"2024-07-03T18:01:06.788Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42116/problem\",\"Lead\":\"Классы можно выстраивать в иерархии наследования. В этом параграфе мы рассмотрим публичное одиночное наследование классов в C++ и поговорим про виртуальные функции, с помощью которых можно реализовать полиморфное поведение объектов.\",\"Content\":\"$6c\",\"Title\":\"Наследование и полиморфизм\",\"LikesCount\":22,\"Quiz\":[{\"answers\":[{\"text\":\"Наследование — это способ организации классов, при котором наследник получает поля и функции базового класса.\",\"generated_as_correct\":true},{\"text\":\"Наследование — это процесс, при котором классы объединяются в один общий класс, наследуя все свойства друг друга без возможности модификации.\",\"generated_as_correct\":false},{\"text\":\"Наследование — это концепция в базах данных, которая описывает отношения между таблицами и их полями.\",\"generated_as_correct\":false},{\"text\":\"Наследование — это механизм, который позволяет классам скрывать поля и функции базового класса.\",\"generated_as_correct\":false}],\"question\":\"Что такое наследование в контексте организации классов?\"},{\"answers\":[{\"text\":\"Наследование позволяет классу-наследнику получать и модифицировать поля и функции базового класса.\",\"generated_as_correct\":true},{\"text\":\"Наследование приводит к тому, что поля и функции базового класса становятся приватными в классе-наследнике, независимо от их исходной области видимости.\",\"generated_as_correct\":false},{\"text\":\"Наследование влияет на область видимости полей и функций базового класса путём создания новых методов, которые не связаны с исходными полями и функциями.\",\"generated_as_correct\":false},{\"text\":\"Наследование делает все поля и функции базового класса недоступными в классе-наследнике.\",\"generated_as_correct\":false}],\"question\":\"Как наследование влияет на область видимости полей и функций базового класса?\"},{\"answers\":[{\"text\":\"Наследование упрощает разработку и поддержку ПО, позволяя повторно использовать код через иерархию классов.\",\"generated_as_correct\":true},{\"text\":\"Наследование используется для создания полностью независимых классов, которые не связаны друг с другом и не могут повторно использовать код, что делает процесс разработки более сложным и трудоёмким.\",\"generated_as_correct\":false},{\"text\":\"Наследование применяется для определения области видимости переменных в рамках одной функции, что никак не влияет на структуру классов или поддержку программного обеспечения.\",\"generated_as_correct\":false},{\"text\":\"Наследование усложняет структуру программного обеспечения и делает его менее поддерживаемым из-за жёсткой связи между классами.\",\"generated_as_correct\":false}],\"question\":\"Почему наследование считается полезным для разработки и поддержки программного обеспечения?\"},{\"answers\":[{\"text\":\"Множественное наследование — это возможность класса иметь несколько базовых классов.\",\"generated_as_correct\":true},{\"text\":\"Множественное наследование — это механизм, позволяющий классу наследовать методы и свойства от одного родительского класса, но при этом иметь доступ к функциональности нескольких классов через интерфейсы.\",\"generated_as_correct\":false},{\"text\":\"Множественное наследование связано с возможностью класса реализовывать несколько интерфейсов, что позволяет ему использовать различные методы без прямого наследования от нескольких классов.\",\"generated_as_correct\":false},{\"text\":\"Множественное наследование — это процесс, при котором класс может наследовать свойства только одного базового класса.\",\"generated_as_correct\":false}],\"question\":\"Что такое множественное наследование в языках программирования?\"},{\"answers\":[{\"text\":\"Множественное наследование сложно из-за конфликтов имён и двусмысленности в иерархии классов.\",\"generated_as_correct\":true},{\"text\":\"Множественное наследование сложно из-за ограничений, накладываемых языками программирования на количество базовых классов, которые могут быть унаследованы.\",\"generated_as_correct\":false},{\"text\":\"Множественное наследование связано с проблемами безопасности и доступом к приватным членам классов в объектно-ориентированном программировании.\",\"generated_as_correct\":false},{\"text\":\"Множественное наследование сложно из-за ограничений на количество производных классов.\",\"generated_as_correct\":false}],\"question\":\"Почему множественное наследование считается сложным и не всегда оправданным?\"},{\"answers\":[{\"text\":\"Конфликты имён и двусмысленность возникают при множественном наследовании, если базовые классы содержат одинаковые методы или атрибуты.\",\"generated_as_correct\":true},{\"text\":\"Проблемы с конфликтами имён при множественном наследовании возникают только в случае, если производный класс определяет методы с теми же именами, что и в одном из базовых классов, независимо от наличия таких же методов в других базовых классах.\",\"generated_as_correct\":false},{\"text\":\"Множественное наследование может вызвать сложности при определении порядка выполнения конструкторов базовых классов, что не связано напрямую с конфликтами имён или двусмысленностью в иерархии.\",\"generated_as_correct\":false},{\"text\":\"Множественное наследование никогда не приводит к конфликтам имён, если производный класс явно указывает, какие методы использовать.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях использование множественного наследования может вызвать проблемы с конфликтами имён и двусмысленностью в иерархии классов?\"},{\"answers\":[{\"text\":\"Публичное одиночное наследование позволяет классу наследовать и расширять функциональность базового класса, сохраняя видимость его полей и методов.\",\"generated_as_correct\":true},{\"text\":\"Публичное одиночное наследование — это механизм, позволяющий классу наследовать только приватные методы и поля базового класса, что ограничивает доступ к функциональности базового класса для класса-наследника.\",\"generated_as_correct\":false},{\"text\":\"Публичное одиночное наследование связано с алгоритмами сортировки и используется для организации данных в структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Публичное одиночное наследование ограничивает доступ к методам и полям базового класса для класса-наследника.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой публичное одиночное наследование в контексте объектно-ориентированного программирования?\"},{\"answers\":[{\"text\":\"Сохранение видимости полей и методов базового класса при публичном одиночном наследовании позволяет классу-наследнику использовать и расширять его функциональность.\",\"generated_as_correct\":true},{\"text\":\"При использовании публичного одиночного наследования сохранение видимости полей и методов базового класса не важно, поскольку все члены базового класса автоматически становятся приватными в классе-наследнике.\",\"generated_as_correct\":false},{\"text\":\"При использовании публичного одиночного наследования важно учитывать ограничения доступа к статическим методам базового класса, которые не могут быть переопределены в классе-наследнике.\",\"generated_as_correct\":false},{\"text\":\"Сохранение видимости полей и методов базового класса при публичном одиночном наследовании не имеет значения, так как все члены становятся недоступными в классе-наследнике.\",\"generated_as_correct\":false}],\"question\":\"Почему при использовании публичного одиночного наследования важно сохранение видимости полей и методов базового класса?\"},{\"answers\":[{\"text\":\"Публичное одиночное наследование даёт возможность классу-наследнику использовать и дополнять функциональность базового класса.\",\"generated_as_correct\":true},{\"text\":\"Публичное одиночное наследование используется для создания независимых классов, которые не связаны с базовым классом и не наследуют его функциональность.\",\"generated_as_correct\":false},{\"text\":\"Публичное одиночное наследование применяется для организации данных в виде иерархической структуры, но не влияет на функциональность классов.\",\"generated_as_correct\":false},{\"text\":\"Публичное одиночное наследование приводит к потере функциональности базового класса в классе-наследнике.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить публичное одиночное наследование для расширения функциональности существующего класса?\"},{\"answers\":[{\"text\":\"Полиморфизм — это способность объектов обрабатывать данные по-разному в зависимости от их типа.\",\"generated_as_correct\":true},{\"text\":\"Полиморфизм в программировании — это метод, позволяющий объединять данные разных типов в один класс для упрощения структуры программы.\",\"generated_as_correct\":false},{\"text\":\"Полиморфизм в программировании связан с алгоритмами сортировки и используется для упорядочивания данных в массивах.\",\"generated_as_correct\":false},{\"text\":\"Полиморфизм — это принцип, согласно которому все объекты в программе должны обрабатывать данные одинаково.\",\"generated_as_correct\":false}],\"question\":\"Что такое полиморфизм в программировании?\"},{\"answers\":[{\"text\":\"Полиморфизм обеспечивает гибкость кода, позволяя объектам разных классов обрабатывать данные через общий интерфейс.\",\"generated_as_correct\":true},{\"text\":\"Полиморфизм ограничивает возможности кода, заставляя все объекты обрабатывать данные одинаково, независимо от их класса.\",\"generated_as_correct\":false},{\"text\":\"Полиморфизм связан с возможностью изменения типа данных во время выполнения программы, что позволяет динамически адаптировать код к различным условиям.\",\"generated_as_correct\":false},{\"text\":\"Полиморфизм делает код менее гибким, так как требует одинакового подхода к обработке данных для всех объектов.\",\"generated_as_correct\":false}],\"question\":\"Почему полиморфизм считается важным для создания гибкого и универсального кода?\"},{\"answers\":[{\"text\":\"Полиморфизм обеспечивает гибкую обработку данных разных классов через общий интерфейс.\",\"generated_as_correct\":true},{\"text\":\"Полиморфизм используется для создания новых классов на основе существующих, что позволяет объектам наследовать методы и свойства друг друга.\",\"generated_as_correct\":false},{\"text\":\"Полиморфизм связан с алгоритмами сортировки и поиска, которые применяются для упорядочивания данных в различных структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Полиморфизм заставляет все объекты разных классов обрабатывать данные одинаково.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить полиморфизм для работы с объектами разных классов через общий интерфейс?\"},{\"answers\":[{\"text\":\"Параметрический полиморфизм позволяет функциям и классам работать с разными типами данных через шаблоны.\",\"generated_as_correct\":true},{\"text\":\"Параметрический полиморфизм — это концепция в программировании, которая позволяет изменять типы данных внутри функции или класса во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Параметрический полиморфизм связан с теорией графов и используется для оптимизации алгоритмов сортировки.\",\"generated_as_correct\":false},{\"text\":\"Параметрический полиморфизм требует создания отдельных функций для каждого типа данных, что увеличивает объём кода.\",\"generated_as_correct\":false}],\"question\":\"Что такое параметрический полиморфизм?\"},{\"answers\":[{\"text\":\"Параметрический полиморфизм предотвращает дублирование кода благодаря использованию шаблонов для работы с разными типами данных.\",\"generated_as_correct\":true},{\"text\":\"Параметрический полиморфизм позволяет избежать дублирования кода за счёт автоматического преобразования типов данных при вызове функций, что не требует использования шаблонов.\",\"generated_as_correct\":false},{\"text\":\"Параметрический полиморфизм связан с наследованием и позволяет создавать иерархии классов для повторного использования кода.\",\"generated_as_correct\":false},{\"text\":\"Параметрический полиморфизм требует написания отдельных функций для каждого типа данных, что увеличивает объём кода.\",\"generated_as_correct\":false}],\"question\":\"Почему параметрический полиморфизм позволяет избежать дублирования кода?\"},{\"answers\":[{\"text\":\"Параметрический полиморфизм позволяет функциям и классам обрабатывать разные типы данных через шаблоны.\",\"generated_as_correct\":true},{\"text\":\"Параметрический полиморфизм позволяет функциям и классам работать исключительно с числовыми типами данных, используя специальные ключевые слова для их определения.\",\"generated_as_correct\":false},{\"text\":\"Параметрический полиморфизм используется для создания статических методов в классах, что позволяет вызывать их без создания экземпляра объекта.\",\"generated_as_correct\":false},{\"text\":\"Параметрический полиморфизм требует создания отдельных функций для каждого типа данных, что увеличивает объём кода.\",\"generated_as_correct\":false}],\"question\":\"Как параметрический полиморфизм может быть применён для работы с различными типами данных в программировании?\"},{\"answers\":[{\"text\":\"Виртуальные функции позволяют переопределить методы в наследниках и обеспечивают динамическое связывание.\",\"generated_as_correct\":true},{\"text\":\"Виртуальные функции — это специальные функции, которые автоматически вызываются при создании объекта и не могут быть изменены в классах-наследниках.\",\"generated_as_correct\":false},{\"text\":\"Виртуальные функции используются для объявления переменных в классе и не имеют отношения к полиморфизму или динамическому связыванию.\",\"generated_as_correct\":false},{\"text\":\"Виртуальные функции предназначены для статического связывания методов в базовом классе.\",\"generated_as_correct\":false}],\"question\":\"Что такое виртуальные функции в контексте объектно-ориентированного программирования?\"},{\"answers\":[{\"text\":\"Виртуальные функции позволяют переопределять методы в классах-наследниках, обеспечивая динамическое связывание и полиморфизм.\",\"generated_as_correct\":true},{\"text\":\"Виртуальные функции обеспечивают возможность вызова методов базового класса без возможности их переопределения в наследниках, что ограничивает полиморфизм и гибкость работы с объектами.\",\"generated_as_correct\":false},{\"text\":\"Виртуальные функции применяются для оптимизации производительности программ за счёт уменьшения размера исполняемого файла и ускорения доступа к данным.\",\"generated_as_correct\":false},{\"text\":\"Виртуальные функции нужны для статического связывания методов между классами и их наследниками, что не требует полиморфизма.\",\"generated_as_correct\":false}],\"question\":\"Почему использование виртуальных функций важно для реализации полиморфизма?\"},{\"answers\":[{\"text\":\"Виртуальные функции обеспечивают полиморфизм, позволяя гибко работать с объектами разных классов через общий интерфейс.\",\"generated_as_correct\":true},{\"text\":\"Виртуальные функции позволяют создавать новые классы на основе существующих, но не могут быть переопределены в классах-наследниках, что ограничивает их использование для работы с объектами разных классов.\",\"generated_as_correct\":false},{\"text\":\"Виртуальные функции используются для оптимизации работы с памятью и повышения производительности программы, не влияя на гибкость работы с объектами различных классов.\",\"generated_as_correct\":false},{\"text\":\"Виртуальные функции ограничивают возможность работы с объектами различных классов, так как они фиксируют поведение классов на этапе компиляции.\",\"generated_as_correct\":false}],\"question\":\"Как применение виртуальных функций влияет на гибкость работы с объектами различных классов?\"},{\"answers\":[{\"text\":\"Абстрактный класс — это класс с хотя бы одной чисто виртуальной функцией, который нельзя инстанцировать.\",\"generated_as_correct\":true},{\"text\":\"Абстрактный класс — это класс, который используется исключительно для хранения данных и не может содержать методов.\",\"generated_as_correct\":false},{\"text\":\"Абстрактный класс — это концепция в математике, используемая для описания геометрических фигур без привязки к конкретным координатам.\",\"generated_as_correct\":false},{\"text\":\"Абстрактный класс — это класс, который можно инстанцировать для создания объектов.\",\"generated_as_correct\":false}],\"question\":\"Что такое абстрактный класс?\"},{\"answers\":[{\"text\":\"Абстрактный класс не может быть инстанцирован из-за наличия хотя бы одной чисто виртуальной функции.\",\"generated_as_correct\":true},{\"text\":\"Абстрактный класс не может быть инстанцирован из-за ограничений, связанных с его именем, которое не позволяет создавать объекты на его основе.\",\"generated_as_correct\":false},{\"text\":\"Абстрактный класс связан с концепцией полиморфизма, которая позволяет объектам одного класса использовать методы других классов без необходимости инстанцирования.\",\"generated_as_correct\":false},{\"text\":\"Абстрактный класс не может быть инстанцирован, потому что его методы не определены.\",\"generated_as_correct\":false}],\"question\":\"Почему абстрактный класс не может быть инстанцирован?\"},{\"answers\":[{\"text\":\"Абстрактные классы определяют интерфейс для классов-наследников, что обеспечивает гибкость и расширяемость кода.\",\"generated_as_correct\":true},{\"text\":\"Абстрактные классы способствуют гибкости и расширяемости кода за счёт возможности их непосредственного инстанцирования и динамической модификации поведения в процессе выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Абстрактные классы используются для оптимизации производительности кода и уменьшения его размера за счёт минимизации количества используемых объектов.\",\"generated_as_correct\":false},{\"text\":\"Абстрактные классы уменьшают гибкость кода, так как требуют жёсткой реализации всех методов в классах-наследниках.\",\"generated_as_correct\":false}],\"question\":\"Как использование абстрактных классов способствует гибкости и расширяемости кода?\"},{\"answers\":[{\"text\":\"Контейнер — это структура данных для хранения и управления объектами.\",\"generated_as_correct\":true},{\"text\":\"Контейнер — это статическая переменная, предназначенная для хранения одного объекта, которая позволяет получать доступ к этому объекту из разных частей программы.\",\"generated_as_correct\":false},{\"text\":\"Контейнер — это концепция в теории графов, используемая для описания связей между узлами в графе.\",\"generated_as_correct\":false},{\"text\":\"Контейнер — это метод для сортировки данных в алгоритмах.\",\"generated_as_correct\":false}],\"question\":\"Что такое контейнер в контексте структур данных?\"},{\"answers\":[{\"text\":\"Контейнеры, такие как векторы, удобны для работы с коллекциями объектов, так как обеспечивают их хранение и управление.\",\"generated_as_correct\":true},{\"text\":\"Контейнеры, такие как векторы, удобны для работы с коллекциями объектов, потому что они автоматически сортируют объекты по определённым критериям, что упрощает их поиск и анализ.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры, такие как векторы, используются для визуализации данных и представления их в графическом виде, что облегчает анализ и интерпретацию информации.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры, такие как векторы, удобны для работы с коллекциями объектов, потому что позволяют выполнять математические операции над всеми объектами одновременно.\",\"generated_as_correct\":false}],\"question\":\"Почему контейнеры, такие как векторы, удобны для работы с коллекциями объектов?\"},{\"answers\":[{\"text\":\"Контейнеры позволяют удобно хранить и обрабатывать коллекции объектов.\",\"generated_as_correct\":true},{\"text\":\"Контейнеры используются исключительно для визуализации данных и не предназначены для их хранения или обработки.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры применяются в основном для разделения программных сред и обеспечения изоляции процессов, что не связано с управлением объектами.\",\"generated_as_correct\":false},{\"text\":\"Контейнеры предназначены только для временного хранения данных без возможности их обработки.\",\"generated_as_correct\":false}],\"question\":\"Как можно применить контейнеры для управления и обработки объектов?\"},{\"answers\":[{\"text\":\"Умные указатели в C++ — это классы для автоматического управления памятью и предотвращения её утечек.\",\"generated_as_correct\":true},{\"text\":\"Умные указатели в C++ — это специальные переменные, которые позволяют вручную управлять памятью и предотвращать её утечки, но не предоставляют автоматического контроля за ресурсами.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели в C++ используются для оптимизации работы с файлами и потоками ввода-вывода, обеспечивая более эффективное взаимодействие с операционной системой.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели в C++ — это типы данных, которые используются для ручного управления памятью и повышения эффективности программ.\",\"generated_as_correct\":false}],\"question\":\"Что такое умные указатели и для чего они используются в C++?\"},{\"answers\":[{\"text\":\"Умные указатели, такие как std::unique_ptr, обеспечивают безопасное управление памятью и предотвращают её утечки.\",\"generated_as_correct\":true},{\"text\":\"Использование умных указателей, таких как std::unique_ptr, считается более безопасным, поскольку они позволяют множественным объектам одновременно владеть памятью, что предотвращает её утечку.\",\"generated_as_correct\":false},{\"text\":\"Использование умных указателей, таких как std::unique_ptr, обеспечивает более эффективное распределение памяти по сравнению с обычными массивами и векторами в C++.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели, такие как std::unique_ptr, считаются более опасными, так как могут случайно перезаписать важные данные в памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему использование умных указателей, таких как std::unique_ptr, считается более безопасным по сравнению с обычными указателями?\"},{\"answers\":[{\"text\":\"Умные указатели в C++ автоматически управляют памятью и предотвращают её утечки.\",\"generated_as_correct\":true},{\"text\":\"Умные указатели в C++ предотвращают утечки памяти путём автоматического увеличения размера выделяемой памяти при каждом использовании указателя.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели используются в C++ для упрощения работы с динамическими массивами и улучшения читаемости кода, но не влияют на управление памятью.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели в C++ помогают предотвратить утечки памяти путём ручного управления выделением и освобождением ресурсов.\",\"generated_as_correct\":false}],\"question\":\"Как умные указатели помогают предотвратить утечки памяти в программах на C++?\"}],\"StoreCardId\":null,\"numberInCourse\":\"4.4\"},{\"Name\":\"cpp | 4.5. Обработка исключений\",\"Slug\":\"exceptions\",\"createdAt\":\"2024-07-03T18:02:00.166Z\",\"updatedAt\":\"2026-01-10T12:07:10.741Z\",\"publishedAt\":\"2024-07-03T18:02:01.546Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42112/problem\",\"Lead\":\"Некоторые ошибки времени выполнения можно обнаружить заранее с помощью проверок в коде. Механизм исключений позволяет корректно сообщать об ошибках.\",\"Content\":\"$6d\",\"Title\":\"Обработка исключений\",\"LikesCount\":25,\"Quiz\":[{\"answers\":[{\"text\":\"Ошибки времени компиляции обнаруживаются до запуска программы, а ошибки времени выполнения — при её запуске.\",\"generated_as_correct\":true},{\"text\":\"Ошибки времени компиляции возникают из-за проблем с оборудованием, а ошибки времени выполнения связаны с логическими ошибками в коде.\",\"generated_as_correct\":false},{\"text\":\"Ошибки времени компиляции и ошибки времени выполнения в C++ связаны с разными этапами отладки программы, но оба типа ошибок можно предотвратить, используя статический анализ кода.\",\"generated_as_correct\":false},{\"text\":\"Ошибки времени компиляции проявляются при запуске программы, а ошибки времени выполнения — до её запуска.\",\"generated_as_correct\":false}],\"question\":\"Чем отличаются ошибки времени компиляции от ошибок времени выполнения в C++?\"},{\"answers\":[{\"text\":\"Ошибки времени компиляции выявляет компилятор до запуска программы, а ошибки времени выполнения проявляются при работе программы.\",\"generated_as_correct\":true},{\"text\":\"Ошибки времени компиляции возникают из-за проблем с оборудованием, а ошибки времени выполнения связаны с логическими ошибками в алгоритмах программы и могут быть обнаружены до её запуска.\",\"generated_as_correct\":false},{\"text\":\"Ошибки времени компиляции и времени выполнения различаются по способам их отображения в интегрированной среде разработки (IDE), где первые отображаются в виде красных подчёркиваний, а вторые — в виде всплывающих окон с сообщениями об ошибках.\",\"generated_as_correct\":false},{\"text\":\"Ошибки времени компиляции проявляются при запуске программы, а ошибки времени выполнения — до её запуска, при компиляции.\",\"generated_as_correct\":false}],\"question\":\"Почему ошибки времени компиляции обнаруживаются до запуска программы, а ошибки времени выполнения — во время её работы?\"},{\"answers\":[{\"text\":\"Знание различий между ошибками компиляции и выполнения помогает применять нужные методы для их обнаружения и обработки, повышая надёжность ПО.\",\"generated_as_correct\":true},{\"text\":\"Понимание различий между ошибками времени компиляции и времени выполнения помогает только в обнаружении ошибок, но не влияет на процесс их исправления, поскольку все ошибки исправляются одинаково независимо от их типа.\",\"generated_as_correct\":false},{\"text\":\"Понимание различий между ошибками времени компиляции и времени выполнения важно для оптимизации производительности программы, так как это позволяет более эффективно распределять ресурсы и улучшать время отклика системы.\",\"generated_as_correct\":false},{\"text\":\"Понимание различий между ошибками компиляции и выполнения не влияет на разработку надёжного ПО, так как все ошибки обрабатываются одинаково.\",\"generated_as_correct\":false}],\"question\":\"Как понимание различий между ошибками времени компиляции и времени выполнения может помочь в разработке надёжного программного обеспечения?\"},{\"answers\":[{\"text\":\"Механизм исключений в C++ нужен для обработки ошибок во время выполнения программы.\",\"generated_as_correct\":true},{\"text\":\"Механизм исключений в C++ служит для оптимизации производительности программы, автоматически удаляя неиспользуемые блоки кода во время выполнения.\",\"generated_as_correct\":false},{\"text\":\"Механизм исключений в C++ связан с управлением памятью и используется для автоматического освобождения ресурсов, когда программа завершает свою работу.\",\"generated_as_correct\":false},{\"text\":\"Механизм исключений в C++ используется для предотвращения компиляционных ошибок.\",\"generated_as_correct\":false}],\"question\":\"Для чего используется механизм исключений в C++?\"},{\"answers\":[{\"text\":\"Механизм исключений предпочтительнее кодов возврата, так как обеспечивает структурированную обработку ошибок времени выполнения.\",\"generated_as_correct\":true},{\"text\":\"Механизм исключений в C++ используется для обработки синтаксических ошибок, что делает его более предпочтительным по сравнению с кодами возврата, которые применяются только для логических ошибок в коде.\",\"generated_as_correct\":false},{\"text\":\"Механизм исключений в C++ связан с управлением памятью и не имеет прямого отношения к кодам возврата, которые используются для передачи значений между функциями.\",\"generated_as_correct\":false},{\"text\":\"Механизм исключений менее надёжен, чем коды возврата, потому что он не позволяет чётко определить место возникновения ошибки в коде.\",\"generated_as_correct\":false}],\"question\":\"Почему использование механизма исключений считается более предпочтительным, чем использование кодов возврата?\"},{\"answers\":[{\"text\":\"Механизм исключений в C++ позволяет функции сообщить об ошибке через выброс исключения, которое обрабатывается в блоке `try-catch`.\",\"generated_as_correct\":true},{\"text\":\"Механизм исключений в C++ позволяет функциям автоматически исправлять ошибки во время выполнения программы без необходимости дополнительной обработки кода.\",\"generated_as_correct\":false},{\"text\":\"Механизм исключений в C++ тесно связан с управлением памятью и используется для автоматического освобождения ресурсов при возникновении ошибок.\",\"generated_as_correct\":false},{\"text\":\"Механизм исключений в C++ используется для передачи управления между функциями без возможности обработки ошибок.\",\"generated_as_correct\":false}],\"question\":\"Как механизм исключений позволяет функции сообщить об ошибке в то место кода, откуда она была вызвана?\"},{\"answers\":[{\"text\":\"Коды возврата — это специальные значения, возвращаемые функцией для обозначения ошибки.\",\"generated_as_correct\":true},{\"text\":\"Коды возврата — это специальные сообщения, которые функция выводит в консоль при возникновении ошибки, не влияя на поток выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Коды возврата используются в сетевых протоколах для идентификации различных состояний соединения между клиентом и сервером.\",\"generated_as_correct\":false},{\"text\":\"Коды возврата — это имена переменных, которые используются для хранения сообщений об ошибках в программе.\",\"generated_as_correct\":false}],\"question\":\"Что такое коды возврата в контексте обработки ошибок?\"},{\"answers\":[{\"text\":\"Коды возврата усложняют читаемость кода, так как требуют дополнительной проверки возвращаемых значений.\",\"generated_as_correct\":true},{\"text\":\"Коды возврата упрощают обработку ошибок, поскольку они позволяют автоматически исправлять ошибки без необходимости дополнительной проверки возвращаемых значений.\",\"generated_as_correct\":false},{\"text\":\"Коды возврата важны для обеспечения безопасности программы, так как они помогают предотвратить несанкционированный доступ к данным.\",\"generated_as_correct\":false},{\"text\":\"Коды возврата улучшают читаемость кода за счёт упрощения обработки ошибок.\",\"generated_as_correct\":false}],\"question\":\"Почему использование кодов возврата может привести к менее читаемому коду?\"},{\"answers\":[{\"text\":\"Коды возврата — это способ обработки ошибок, при котором функция возвращает специальное значение при ошибке.\",\"generated_as_correct\":true},{\"text\":\"Коды возврата представляют собой механизм, при котором функция генерирует исключение при ошибке, вместо того чтобы возвращать специальное значение.\",\"generated_as_correct\":false},{\"text\":\"Коды возврата используются в программировании для определения порядка выполнения функций и не связаны с обработкой ошибок.\",\"generated_as_correct\":false},{\"text\":\"Коды возврата автоматически исправляют ошибки в программе без необходимости проверки возвращаемого значения.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать коды возврата для обработки ошибок в программах?\"},{\"answers\":[{\"text\":\"Свёртка стека — это процесс вызова деструкторов автоматических объектов при исключении.\",\"generated_as_correct\":true},{\"text\":\"Свёртка стека — это процедура, при которой все объекты в стеке копируются в другое место памяти при возникновении исключения.\",\"generated_as_correct\":false},{\"text\":\"Свёртка стека — это метод оптимизации памяти, который используется для уменьшения размера стека путём сжатия данных.\",\"generated_as_correct\":false},{\"text\":\"Свёртка стека — это процесс создания новых объектов при возникновении исключения.\",\"generated_as_correct\":false}],\"question\":\"Что такое свёртка стека?\"},{\"answers\":[{\"text\":\"Свёртка стека требует, чтобы деструкторы не генерировали исключений, иначе освобождение ресурсов будет некорректным.\",\"generated_as_correct\":true},{\"text\":\"Свёртка стека — это механизм, который позволяет автоматически удалять объекты из памяти без вызова деструкторов. Генерирование исключений деструкторами никак не влияет на этот процесс.\",\"generated_as_correct\":false},{\"text\":\"Свёртка стека связана с управлением памятью в языках программирования и важна для оптимизации производительности, но не имеет отношения к генерации исключений деструкторами.\",\"generated_as_correct\":false},{\"text\":\"Деструкторы должны генерировать исключения при свёртке стека, чтобы обеспечить правильное освобождение ресурсов.\",\"generated_as_correct\":false}],\"question\":\"Почему важно, чтобы деструкторы не генерировали исключений при свёртке стека?\"},{\"answers\":[{\"text\":\"Свёртка стека вызывает деструкторы автоматических объектов при исключении, освобождая ресурсы.\",\"generated_as_correct\":true},{\"text\":\"Свёртка стека позволяет автоматически перераспределить ресурсы между объектами в случае возникновения исключения, что обеспечивает более эффективное использование памяти.\",\"generated_as_correct\":false},{\"text\":\"Свёртка стека связана с алгоритмами сортировки и используется для оптимизации доступа к данным в структурах данных при обработке исключений.\",\"generated_as_correct\":false},{\"text\":\"Свёртка стека создаёт резервные копии объектов при исключении для их последующего восстановления.\",\"generated_as_correct\":false}],\"question\":\"Как свёртка стека помогает управлять ресурсами при возникновении исключения?\"},{\"answers\":[{\"text\":\"Гарантии безопасности исключений описывают, как класс или функция ведёт себя при ошибках. Виды гарантий: отсутствие сбоев, строгая, базовая и отсутствие гарантий.\",\"generated_as_correct\":true},{\"text\":\"Гарантии безопасности исключений — это дополнительные функции, позволяющие полностью игнорировать исключения и продолжать выполнение программы без учёта возможных ошибок.\",\"generated_as_correct\":false},{\"text\":\"Гарантии безопасности исключений связаны с методами шифрования данных и обеспечивают защиту информации при передаче по сети.\",\"generated_as_correct\":false},{\"text\":\"Гарантии безопасности исключений гарантируют, что все исключения будут автоматически обработаны и исправлены без вмешательства программиста.\",\"generated_as_correct\":false}],\"question\":\"Что такое гарантии безопасности исключений и какие основные виды гарантий существуют?\"},{\"answers\":[{\"text\":\"Понимание гарантий безопасности исключений помогает создавать надёжные программы, устойчивые к ошибкам.\",\"generated_as_correct\":true},{\"text\":\"Гарантии безопасности исключений важны только для теоретических исследований и не имеют практического применения в разработке программного обеспечения.\",\"generated_as_correct\":false},{\"text\":\"Гарантии безопасности исключений связаны с принципами объектно-ориентированного программирования и используются для определения иерархии классов и наследования.\",\"generated_as_correct\":false},{\"text\":\"Гарантии безопасности исключений нужны только для оптимизации производительности программ и не влияют на их надёжность.\",\"generated_as_correct\":false}],\"question\":\"Почему понимание гарантий безопасности исключений важно при разработке программ?\"},{\"answers\":[{\"text\":\"Знание о гарантиях безопасности исключений помогает управлять ресурсами и избегать утечек памяти.\",\"generated_as_correct\":true},{\"text\":\"Гарантии безопасности исключений гарантируют абсолютную защиту памяти от любых ошибок, что делает управление ресурсами простым и не требующим дополнительных усилий со стороны разработчика.\",\"generated_as_correct\":false},{\"text\":\"Гарантии безопасности исключений связаны с теорией вероятностей и используются для анализа рисков в финансовых приложениях, что не имеет отношения к управлению памятью.\",\"generated_as_correct\":false},{\"text\":\"Гарантии безопасности исключений обеспечивают автоматическое освобождение памяти без необходимости дополнительного управления со стороны программиста.\",\"generated_as_correct\":false}],\"question\":\"Как знание о гарантиях безопасности исключений может помочь при работе с ресурсами, такими как память?\"},{\"answers\":[{\"text\":\"Умный указатель (RAII) в C++ — это техника автоматического управления ресурсами, предотвращающая утечки памяти.\",\"generated_as_correct\":true},{\"text\":\"Умный указатель (RAII) — это специальный тип данных в C++, который автоматически увеличивает количество ссылок на ресурсы при их использовании.\",\"generated_as_correct\":false},{\"text\":\"Умный указатель (RAII) — это концепция в C++, связанная с наследованием и полиморфизмом, которая позволяет объектам автоматически изменять своё поведение в зависимости от контекста.\",\"generated_as_correct\":false},{\"text\":\"Умный указатель (RAII) в C++ — это инструмент для ручного освобождения памяти по команде программиста.\",\"generated_as_correct\":false}],\"question\":\"Что такое умный указатель (RAII) в контексте программирования на C++?\"},{\"answers\":[{\"text\":\"Умные указатели автоматически освобождают ресурсы, предотвращая утечки памяти.\",\"generated_as_correct\":true},{\"text\":\"Умные указатели в C++ обеспечивают более медленное выполнение программы по сравнению с ручным управлением ресурсами, так как тратят дополнительное время на автоматическое управление памятью.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели в C++ используются для повышения безопасности многопоточных приложений, хотя их основное преимущество заключается в автоматизации работы с файлами.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели усложняют код и замедляют работу программы по сравнению с ручным управлением ресурсами.\",\"generated_as_correct\":false}],\"question\":\"Почему использование умных указателей считается более предпочтительным по сравнению с ручным управлением ресурсами?\"},{\"answers\":[{\"text\":\"Умные указатели в C++ автоматически освобождают память при выходе из области видимости, предотвращая утечки.\",\"generated_as_correct\":true},{\"text\":\"Умные указатели в C++ предотвращают утечки памяти путём автоматического увеличения размера выделенной памяти при достижении её лимита.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели в C++ используются для оптимизации производительности программ путём автоматического управления доступом к файлам и сетевым ресурсам.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели в C++ помогают предотвратить утечки памяти путём ручного вызова функции освобождения памяти.\",\"generated_as_correct\":false}],\"question\":\"Как умные указатели помогают предотвратить утечки памяти в программах на C++?\"},{\"answers\":[{\"text\":\"Ключевое слово noexcept в C++ сообщает, что функция не выбрасывает исключений.\",\"generated_as_correct\":true},{\"text\":\"Ключевое слово noexcept в C++ используется для обозначения функций, которые могут вызывать ошибки во время выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"Ключевое слово noexcept в C++ связано с управлением памятью и помогает предотвратить утечки памяти.\",\"generated_as_correct\":false},{\"text\":\"Ключевое слово noexcept в C++ применяется для принудительного генерирования исключений в функции.\",\"generated_as_correct\":false}],\"question\":\"Что означает ключевое слово noexcept в C++?\"},{\"answers\":[{\"text\":\"`noexcept` сообщает компилятору об отсутствии исключений, что позволяет оптимизировать код.\",\"generated_as_correct\":true},{\"text\":\"`noexcept` используется для обозначения функций, которые могут генерировать исключения, что помогает компилятору оптимизировать код путём добавления дополнительных проверок на исключения.\",\"generated_as_correct\":false},{\"text\":\"`noexcept` важен для обеспечения безопасности потоков в многопоточных приложениях, поскольку он предотвращает одновременный доступ к ресурсам.\",\"generated_as_correct\":false},{\"text\":\"`noexcept` используется для указания, что функция генерирует исключения, что помогает в оптимизации кода.\",\"generated_as_correct\":false}],\"question\":\"Почему использование noexcept может быть важным для оптимизации кода?\"},{\"answers\":[{\"text\":\"`noexcept` влияет на работу стандартных контейнеров и алгоритмов в C++, если функции не генерируют исключений, что позволяет оптимизировать код.\",\"generated_as_correct\":true},{\"text\":\"Применение `noexcept` влияет на работу стандартных контейнеров и алгоритмов в C++, так как это ключевое слово автоматически ускоряет выполнение любых функций, независимо от их способности генерировать исключения.\",\"generated_as_correct\":false},{\"text\":\"Применение `noexcept` влияет на работу стандартных контейнеров и алгоритмов в C++, поскольку оно связано с управлением памятью и выделением ресурсов в процессе выполнения программы.\",\"generated_as_correct\":false},{\"text\":\"`noexcept` влияет на работу стандартных контейнеров и алгоритмов в C++, если функции генерируют исключения, что позволяет оптимизировать код.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применение noexcept может повлиять на работу стандартных контейнеров и алгоритмов в C++?\"}],\"StoreCardId\":null,\"numberInCourse\":\"4.5\"},{\"Name\":\"cpp | 4.6 Идиома RAII и умные указатели\",\"Slug\":\"raii-and-smart-pointers\",\"createdAt\":\"2024-07-03T18:02:47.035Z\",\"updatedAt\":\"2026-01-10T12:07:11.212Z\",\"publishedAt\":\"2024-07-03T18:02:48.348Z\",\"ContestURL\":\"https://new.contest.yandex.ru/42114/problem\",\"Lead\":\"Идиома RAII помогает эффективно организовать работу с ресурсами (например, памятью или файлами) и создавать более надёжный код. На этой идее построены «умные указатели» — классы unique_ptr и shared_ptr из стандартной библиотеки.\",\"Content\":\"$6e\",\"Title\":\"Идиома RAII и умные указатели\",\"LikesCount\":28,\"Quiz\":[{\"answers\":[{\"text\":\"RAII — захват ресурса при инициализации объекта и освобождение при его уничтожении.\",\"generated_as_correct\":true},{\"text\":\"RAII — это метод в программировании, который позволяет автоматически освобождать ресурсы при каждом вызове функции, независимо от жизненного цикла объекта.\",\"generated_as_correct\":false},{\"text\":\"RAII — это концепция в программировании, связанная с управлением доступом к ресурсам в многопоточных приложениях.\",\"generated_as_correct\":false},{\"text\":\"RAII — автоматическое освобождение ресурсов при создании объекта.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой идиома RAII в программировании?\"},{\"answers\":[{\"text\":\"RAII предотвращает утечки ресурсов, захватывая их при инициализации объекта и освобождая при его уничтожении.\",\"generated_as_correct\":true},{\"text\":\"RAII — это подход в программировании, который позволяет захватывать ресурсы при запуске программы и освобождать их только при её завершении, что предотвращает утечки ресурсов.\",\"generated_as_correct\":false},{\"text\":\"RAII — это концепция в программировании, которая используется для оптимизации производительности программ путём эффективного распределения ресурсов между процессами.\",\"generated_as_correct\":false},{\"text\":\"RAII предотвращает утечки ресурсов путём их ручного освобождения программистом в любой момент времени.\",\"generated_as_correct\":false}],\"question\":\"Как идиома RAII помогает предотвратить утечки ресурсов в программах?\"},{\"answers\":[{\"text\":\"RAII применяется для автоматического управления ресурсами при инициализации и уничтожении объектов.\",\"generated_as_correct\":true},{\"text\":\"Идиома RAII применяется для управления ресурсами в программировании, но захват и освобождение ресурсов происходят по запросу программиста в любой момент времени, независимо от жизненного цикла объекта.\",\"generated_as_correct\":false},{\"text\":\"Идиома RAII используется для оптимизации алгоритмов сортировки и поиска в структурах данных.\",\"generated_as_correct\":false},{\"text\":\"RAII используется для ручного управления ресурсами в программировании.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях применяется идиома RAII для управления ресурсами?\"},{\"answers\":[{\"text\":\"Файловый дескриптор — это указатель на структуру, используемый для работы с файлами в C и C++, обеспечивающий доступ к файлам и операции чтения/записи.\",\"generated_as_correct\":true},{\"text\":\"Файловый дескриптор — это название функции в языках программирования C и C++, которая отвечает за создание новых файлов и каталогов.\",\"generated_as_correct\":false},{\"text\":\"Файловый дескриптор — это элемент графического интерфейса, который отображает информацию о файле и позволяет пользователю взаимодействовать с ним через кнопки и меню.\",\"generated_as_correct\":false},{\"text\":\"Файловый дескриптор — это имя файла, используемое в программах на C и C++ для идентификации файлов в системе.\",\"generated_as_correct\":false}],\"question\":\"Что такое файловый дескриптор?\"},{\"answers\":[{\"text\":\"Файловый дескриптор в C и C++ — это указатель на структуру, обеспечивающий работу с файлами и управление доступом к ним.\",\"generated_as_correct\":true},{\"text\":\"Файловый дескриптор в языках программирования C и C++ — это специальный код, который используется для шифрования и дешифрования данных в файле.\",\"generated_as_correct\":false},{\"text\":\"Файловый дескриптор в языках программирования C и C++ связан с управлением памятью и используется для выделения и освобождения блоков памяти при работе с файлами.\",\"generated_as_correct\":false},{\"text\":\"Файловый дескриптор в C и C++ используется для хранения пути к файлу и его атрибутов.\",\"generated_as_correct\":false}],\"question\":\"Для чего используется файловый дескриптор в языках программирования C и C++?\"},{\"answers\":[{\"text\":\"Файловый дескриптор — это указатель, который помогает ОС управлять доступом к файлу.\",\"generated_as_correct\":true},{\"text\":\"Файловый дескриптор представляет собой копию файла, которая хранится в оперативной памяти и используется операционной системой для временного доступа к данным.\",\"generated_as_correct\":false},{\"text\":\"Файловый дескриптор используется в операционных системах для идентификации процессов и управления их приоритетами при выполнении задач.\",\"generated_as_correct\":false},{\"text\":\"Файловый дескриптор — это имя файла, которое используется операционной системой для его идентификации.\",\"generated_as_correct\":false}],\"question\":\"Как файловый дескриптор помогает операционной системе управлять доступом к файлу?\"},{\"answers\":[{\"text\":\"Конструктор и деструктор — это методы в классе, вызываемые при создании и уничтожении объекта.\",\"generated_as_correct\":true},{\"text\":\"Конструктор и деструктор — это функции, которые используются для создания и изменения состояния объекта во время его существования.\",\"generated_as_correct\":false},{\"text\":\"Конструктор и деструктор — это термины, связанные с алгоритмами сортировки и поиска в структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Конструктор и деструктор — это методы для ручного управления памятью объекта.\",\"generated_as_correct\":false}],\"question\":\"Что такое конструктор и деструктор в контексте программирования?\"},{\"answers\":[{\"text\":\"Конструкторы инициализируют объекты, а деструкторы освобождают ресурсы при их уничтожении, что важно для управления жизненным циклом.\",\"generated_as_correct\":true},{\"text\":\"Конструкторы и деструкторы важны, поскольку они позволяют объектам самостоятельно выполнять свои методы в любой момент времени по запросу пользователя, не завися от создания или уничтожения объекта.\",\"generated_as_correct\":false},{\"text\":\"Конструкторы и деструкторы играют роль в наследовании классов и определении иерархии между ними, что важно для структурирования кода и повторного использования компонентов.\",\"generated_as_correct\":false},{\"text\":\"Конструкторы и деструкторы нужны для прямого взаимодействия объектов с пользователем и не связаны с управлением ресурсами.\",\"generated_as_correct\":false}],\"question\":\"Почему конструкторы и деструкторы считаются важными для управления жизненным циклом объектов?\"},{\"answers\":[{\"text\":\"Конструкторы инициализируют объекты, а деструкторы освобождают ресурсы при уничтожении объектов.\",\"generated_as_correct\":true},{\"text\":\"Конструкторы и деструкторы применяются для изменения состояния объектов во время их существования, не влияя на инициализацию или освобождение ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Конструкторы и деструкторы используются для определения структуры класса и не имеют отношения к инициализации объектов или освобождению ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Конструкторы освобождают ресурсы, а деструкторы инициализируют объекты.\",\"generated_as_correct\":false}],\"question\":\"Как конструкторы и деструкторы применяются на практике для инициализации объектов и освобождения ресурсов?\"},{\"answers\":[{\"text\":\"Умные указатели в C++ — это классы для безопасного управления памятью, автоматически освобождающие её при выходе из области видимости.\",\"generated_as_correct\":true},{\"text\":\"Умные указатели в C++ — это специальные переменные, которые используются для хранения адресов памяти и не требуют освобождения памяти вручную, однако они не связаны с классами и работают на уровне примитивных типов данных.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели в C++ используются для создания ссылок на объекты и не имеют отношения к управлению памятью.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели в C++ — это обычные указатели, которые требуют ручного управления памятью и не предоставляют дополнительных функций для её освобождения.\",\"generated_as_correct\":false}],\"question\":\"Что такое умные указатели в C++ и для чего они используются?\"},{\"answers\":[{\"text\":\"Умные указатели автоматически освобождают память, предотвращая утечки.\",\"generated_as_correct\":true},{\"text\":\"Умные указатели считаются более безопасными, потому что они позволяют множественным переменным одновременно управлять одной и той же памятью без риска её утечки.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели обеспечивают более безопасное управление памятью за счёт использования дополнительных библиотек для отслеживания использования памяти, что не требуется для обычных указателей.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели требуют ручного управления памятью, что делает их более безопасными.\",\"generated_as_correct\":false}],\"question\":\"Почему использование умных указателей считается более безопасным по сравнению с обычными указателями?\"},{\"answers\":[{\"text\":\"Умные указатели автоматически освобождают память при выходе из области видимости.\",\"generated_as_correct\":true},{\"text\":\"Умные указатели, такие как `std::unique_ptr` и `std::shared_ptr`, предотвращают утечки памяти путём автоматического увеличения размера выделенной памяти при достижении её предела.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели, такие как `std::unique_ptr` и `std::shared_ptr`, используются для оптимизации производительности программ на C++ и не имеют прямого отношения к предотвращению утечек памяти.\",\"generated_as_correct\":false},{\"text\":\"Умные указатели предотвращают утечки памяти путём ручного вызова функции освобождения памяти.\",\"generated_as_correct\":false}],\"question\":\"Как умные указатели, такие как `std::unique_ptr` и `std::shared_ptr`, помогают предотвратить утечки памяти?\"},{\"answers\":[{\"text\":\"`std::unique_ptr` — умный указатель в C++, обеспечивающий исключительное владение ресурсом.\",\"generated_as_correct\":true},{\"text\":\"`std::unique_ptr` — это обычный указатель в C++, который не управляет ресурсом автоматически и может быть легко скопирован.\",\"generated_as_correct\":false},{\"text\":\"`std::unique_ptr` используется для создания массивов в C++ и не имеет свойств владения ресурсом.\",\"generated_as_correct\":false},{\"text\":\"`std::unique_ptr` — это указатель в C++, который может быть скопирован и передан другим переменным.\",\"generated_as_correct\":false}],\"question\":\"Что такое `std::unique_ptr` и каким свойством владения ресурсом он обладает?\"},{\"answers\":[{\"text\":\"`std::unique_ptr` нельзя копировать, поскольку он обеспечивает исключительное владение ресурсом, что предотвращает дублирование и утечки памяти.\",\"generated_as_correct\":true},{\"text\":\"`std::unique_ptr` нельзя копировать, так как это приводит к потере данных. При попытке копирования `std::unique_ptr` удаляет ресурс, что делает его непригодным для дальнейшего использования.\",\"generated_as_correct\":false},{\"text\":\"`std::unique_ptr` используется для управления ресурсами в C++, но его нельзя копировать из-за ограничений, связанных с многопоточностью. Это обеспечивает безопасность при одновременном доступе к ресурсам.\",\"generated_as_correct\":false},{\"text\":\"`std::unique_ptr` нельзя копировать, потому что это приводит к увеличению потребления памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему `std::unique_ptr` нельзя копировать, и как это влияет на управление ресурсами?\"},{\"answers\":[{\"text\":\"`std::unique_ptr` полезен для исключительного управления уникальными ресурсами в C++.\",\"generated_as_correct\":true},{\"text\":\"`std::unique_ptr` применяется для управления ресурсами, которые должны быть доступны глобально в приложении, и не освобождает их автоматически.\",\"generated_as_correct\":false},{\"text\":\"`std::unique_ptr` полезен для оптимизации производительности в многопоточных приложениях, так как обеспечивает быстрый доступ к ресурсам без блокировок.\",\"generated_as_correct\":false},{\"text\":\"`std::unique_ptr` применяется для создания копий ресурсов и их совместного использования между объектами.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях использование `std::unique_ptr` может быть особенно полезным?\"},{\"answers\":[{\"text\":\"`std::shared_ptr` — умный указатель в C++, обеспечивающий совместное владение ресурсом и автоматический подсчёт ссылок.\",\"generated_as_correct\":true},{\"text\":\"`std::shared_ptr` — это функция в C++, которая позволяет создавать копии ресурсов и управлять их временем жизни вручную, не используя подсчёт ссылок.\",\"generated_as_correct\":false},{\"text\":\"`std::shared_ptr` — это механизм в C++, который используется для синхронизации доступа к ресурсам в многопоточных приложениях.\",\"generated_as_correct\":false},{\"text\":\"`std::shared_ptr` — это простой указатель в C++, который не управляет временем жизни ресурса и требует ручного освобождения памяти.\",\"generated_as_correct\":false}],\"question\":\"Что такое `std::shared_ptr` в C++ и для чего он используется?\"},{\"answers\":[{\"text\":\"`std::shared_ptr` использует подсчёт ссылок для автоматического освобождения ресурса при выходе последнего указателя из области видимости.\",\"generated_as_correct\":true},{\"text\":\"`std::shared_ptr` управляет временем освобождения ресурса, сохраняя его в памяти до тех пор, пока программа не будет завершена, независимо от количества указателей, ссылающихся на ресурс.\",\"generated_as_correct\":false},{\"text\":\"`std::shared_ptr` используется для управления доступом к ресурсам в многопоточных приложениях, обеспечивая синхронизацию между потоками.\",\"generated_as_correct\":false},{\"text\":\"`std::shared_ptr` освобождает ресурс сразу после того, как любой из указателей выходит из области видимости.\",\"generated_as_correct\":false}],\"question\":\"Каким образом `std::shared_ptr` управляет временем освобождения ресурса?\"},{\"answers\":[{\"text\":\"`std::shared_ptr` автоматически управляет памятью, освобождая ресурсы при выходе последнего указателя из области видимости.\",\"generated_as_correct\":true},{\"text\":\"`std::shared_ptr` предотвращает утечки памяти путём автоматического увеличения размера выделенной памяти при достижении её лимита, не требуя ручного управления ресурсами.\",\"generated_as_correct\":false},{\"text\":\"`std::shared_ptr` используется для обеспечения потокобезопасности при работе с ресурсами в многопоточных приложениях C++.\",\"generated_as_correct\":false},{\"text\":\"`std::shared_ptr` предотвращает утечки памяти, блокируя доступ к ресурсам после их первоначального выделения.\",\"generated_as_correct\":false}],\"question\":\"Как использование `std::shared_ptr` может помочь избежать утечек памяти в программах на C++?\"},{\"answers\":[{\"text\":\"Копирование и присваивание объектов в C++ — это механизмы для создания копий объектов и передачи значений между ними.\",\"generated_as_correct\":true},{\"text\":\"Копирование и присваивание объектов в C++ — это методы, позволяющие изменять исходные объекты при создании их копий, что обеспечивает более гибкое управление данными.\",\"generated_as_correct\":false},{\"text\":\"Копирование и присваивание объектов в C++ тесно связаны с концепцией наследования и полиморфизма, которые позволяют объектам разных классов взаимодействовать друг с другом.\",\"generated_as_correct\":false},{\"text\":\"Копирование и присваивание объектов в C++ — это способы обмена ссылками между объектами для оптимизации использования памяти.\",\"generated_as_correct\":false}],\"question\":\"Что такое копирование и присваивание объектов в C++?\"},{\"answers\":[{\"text\":\"Управление копированием и присваиванием в C++ предотвращает ошибки с ресурсами и утечку памяти.\",\"generated_as_correct\":true},{\"text\":\"Управление копированием и присваиванием объектов в C++ важно, поскольку это позволяет увеличить скорость выполнения программы за счёт автоматического управления памятью.\",\"generated_as_correct\":false},{\"text\":\"Правильное управление копированием и присваиванием объектов в C++ связано с оптимизацией алгоритмов сортировки и поиска в структурах данных.\",\"generated_as_correct\":false},{\"text\":\"Управление копированием и присваиванием в C++ нужно для автоматического удаления объектов из памяти.\",\"generated_as_correct\":false}],\"question\":\"Почему правильное управление копированием и присваиванием объектов важно в C++?\"},{\"answers\":[{\"text\":\"Неправильное управление копированием и присваиванием в C++ вызывает ошибки, такие как двойное освобождение ресурсов или утечка памяти.\",\"generated_as_correct\":true},{\"text\":\"Неправильное управление копированием и присваиванием в C++ приводит к ошибкам в логике программы, но не влияет на управление памятью или ресурсами.\",\"generated_as_correct\":false},{\"text\":\"Неправильное управление копированием и присваиванием может вызвать проблемы с производительностью процессора и замедлить выполнение программы из-за неэффективного использования системных ресурсов.\",\"generated_as_correct\":false},{\"text\":\"Неправильное управление копированием и присваиванием в C++ помогает избежать ошибок и улучшает безопасность программы.\",\"generated_as_correct\":false}],\"question\":\"Как неправильное управление копированием и присваиванием может привести к ошибкам в программе на C++?\"},{\"answers\":[{\"text\":\"Семантика перемещения в C++ — механизм для эффективной передачи ресурсов между объектами без копирования.\",\"generated_as_correct\":true},{\"text\":\"Семантика перемещения в C++ — это метод, который используется для создания копий объектов при их перемещении из одной области памяти в другую.\",\"generated_as_correct\":false},{\"text\":\"Семантика перемещения в C++ связана с алгоритмами сортировки и поиска, которые применяются для упорядочивания данных в контейнерах.\",\"generated_as_correct\":false},{\"text\":\"Семантика перемещения в C++ используется для автоматического копирования объектов при их передаче.\",\"generated_as_correct\":false}],\"question\":\"Что такое семантика перемещения в C++?\"},{\"answers\":[{\"text\":\"Семантика перемещения в C++ оптимизирует передачу ресурсов между объектами, избегая копирования.\",\"generated_as_correct\":true},{\"text\":\"Семантика перемещения в C++ нужна для автоматического увеличения объёма памяти, выделяемого под ресурсы, что упрощает управление памятью, но не влияет на операции копирования.\",\"generated_as_correct\":false},{\"text\":\"Семантика перемещения в C++ тесно связана с концепцией многопоточности и используется для синхронизации доступа к ресурсам между потоками.\",\"generated_as_correct\":false},{\"text\":\"Семантика перемещения в C++ предназначена для автоматического копирования ресурсов при их передаче между объектами.\",\"generated_as_correct\":false}],\"question\":\"Почему использование семантики перемещения может быть полезным при работе с ресурсами в C++?\"},{\"answers\":[{\"text\":\"Семантика перемещения применяется для оптимизации передачи ресурсов между объектами через умные указатели.\",\"generated_as_correct\":true},{\"text\":\"Семантика перемещения применяется для оптимизации работы с умными указателями при выполнении арифметических операций над данными, которые они содержат.\",\"generated_as_correct\":false},{\"text\":\"Семантика перемещения используется в контексте умных указателей для улучшения читаемости кода и упрощения его структуры.\",\"generated_as_correct\":false},{\"text\":\"Семантика перемещения используется для увеличения размера выделяемой памяти при работе с умными указателями.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях семантика перемещения может применяться для оптимизации работы с умными указателями?\"}],\"StoreCardId\":null,\"numberInCourse\":\"4.6\"},{\"Name\":\"cpp | 4.7. Разбор задач к разделу «Идиомы C++»\",\"Slug\":\"cpp-idioms\",\"createdAt\":\"2024-07-03T18:03:21.945Z\",\"updatedAt\":\"2026-01-10T12:07:10.392Z\",\"publishedAt\":\"2024-07-03T18:03:23.208Z\",\"ContestURL\":null,\"Lead\":\"В\u0026nbsp;этом параграфе мы\u0026nbsp;разберём задачи к\u0026nbsp;главе «Идиомы C\\\\+\\\\+».\",\"Content\":\"$6f\",\"Title\":\"Разбор задач к главе «Идиомы C++»\",\"LikesCount\":16,\"Quiz\":null,\"StoreCardId\":null,\"numberInCourse\":\"4.7\"}]},{\"id\":95,\"Name\":\"5. Приложение\",\"Articles\":[{\"Name\":\"cpp | 5.1 Как работать с системой проверки заданий\",\"Slug\":\"cpp-kak-rabotat-s-sistemoi-proverki-zadanii\",\"createdAt\":\"2024-08-27T15:10:04.437Z\",\"updatedAt\":\"2026-01-10T12:07:10.536Z\",\"publishedAt\":\"2024-08-27T15:10:07.132Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"$70\",\"Title\":\"Как работать с системой проверки заданий\",\"LikesCount\":16,\"Quiz\":[{\"answers\":[{\"text\":\"Интерфейс системы проверки заданий — это среда для решения задач с полем для ввода кода и описанием условий.\",\"generated_as_correct\":true},{\"text\":\"Интерфейс системы проверки заданий — это платформа для общения между пользователями, где они могут обсуждать задачи и делиться своими решениями, но не имеют возможности их проверить.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс системы проверки заданий связан с настройкой параметров сервера и управлением доступом к ресурсам, не имеет отношения к решению задач.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс системы проверки заданий предназначен только для просмотра результатов проверки без возможности ввода решения.\",\"generated_as_correct\":false}],\"question\":\"Что представляет собой интерфейс системы проверки заданий?\"},{\"answers\":[{\"text\":\"Интерфейс системы проверки заданий содержит описание задачи и поле для ввода кода, что позволяет пользователям решать задачи и отправлять решения на проверку.\",\"generated_as_correct\":true},{\"text\":\"Интерфейс системы проверки заданий содержит только поле для ввода кода и кнопку отправки, без какого-либо описания задачи или дополнительных пояснений.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс системы проверки заданий включает в себя элементы управления для настройки параметров компилятора и выбора языка программирования, что позволяет пользователям оптимизировать процесс решения задач.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс системы проверки заданий предоставляет только возможность загрузки готовых решений без описания задачи или поля для ввода кода.\",\"generated_as_correct\":false}],\"question\":\"Какие элементы включает в себя интерфейс системы проверки заданий и зачем они нужны?\"},{\"answers\":[{\"text\":\"Интерфейс системы проверки заданий позволяет пользователям решать задачи, предоставляя описание и поле для ввода кода.\",\"generated_as_correct\":true},{\"text\":\"Интерфейс системы проверки заданий служит исключительно для отображения результатов проверки решений, не предоставляя возможности ввода кода или ознакомления с условиями задачи.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс системы проверки заданий используется для настройки параметров сервера и управления доступом пользователей к различным разделам системы.\",\"generated_as_correct\":false},{\"text\":\"Интерфейс системы проверки заданий предназначен только для просмотра условий задач, без возможности отправки решений.\",\"generated_as_correct\":false}],\"question\":\"Как интерфейс системы проверки заданий помогает пользователям решать задачи?\"},{\"answers\":[{\"text\":\"Тесты — это пары вход-выход для проверки решений задач.\",\"generated_as_correct\":true},{\"text\":\"Тесты — это специальные программы, которые самостоятельно исправляют ошибки в коде на основе анализа его структуры.\",\"generated_as_correct\":false},{\"text\":\"Тесты — это метод визуализации данных, который помогает анализировать результаты работы алгоритмов.\",\"generated_as_correct\":false},{\"text\":\"Тесты — это только входные данные для программы.\",\"generated_as_correct\":false}],\"question\":\"Что такое тесты в контексте проверки решения задачи?\"},{\"answers\":[{\"text\":\"Система проверяет решение задачи, сравнивая результаты работы кода с эталонными выходными данными для различных входных значений.\",\"generated_as_correct\":true},{\"text\":\"Система использует тесты для проверки решения, при этом тесты содержат только выходные данные, на основании которых делается вывод о правильности решения без учёта входных данных.\",\"generated_as_correct\":false},{\"text\":\"Система применяет тесты для определения сложности алгоритма, анализируя время выполнения и объём используемой памяти, а не для оценки правильности решения.\",\"generated_as_correct\":false},{\"text\":\"Система оценивает решение задачи на основе количества выполненных тестов, не учитывая соответствие выходных данных ожидаемым результатам.\",\"generated_as_correct\":false}],\"question\":\"Как система использует тесты для оценки правильности решения?\"},{\"answers\":[{\"text\":\"Тесты — это пары входных и выходных данных для проверки решения задачи.\",\"generated_as_correct\":true},{\"text\":\"Тесты — это специальные программы, которые самостоятельно генерируют входные данные и проверяют корректность решения задачи на основе внутренних алгоритмов, не требующих эталонных выходных данных.\",\"generated_as_correct\":false},{\"text\":\"Тесты используются для оценки производительности системы, измеряя время выполнения и потребление ресурсов при обработке различных входных данных.\",\"generated_as_correct\":false},{\"text\":\"Тесты — это набор выходных данных, которые автоматически генерируются для проверки правильности решения задачи.\",\"generated_as_correct\":false}],\"question\":\"Каким образом тесты помогают определить, насколько хорошо решение справляется с различными случаями?\"},{\"answers\":[{\"text\":\"Статус решения — это результат проверки задачи системой: «Решена полностью» или «Решена неверно».\",\"generated_as_correct\":true},{\"text\":\"Статус решения — это комментарий системы о качестве кода, который может быть «Отлично», «Хорошо» или «Плохо».\",\"generated_as_correct\":false},{\"text\":\"Статус решения — это категория, которая определяет уровень сложности задачи в системе.\",\"generated_as_correct\":false},{\"text\":\"Статус решения — это время, за которое система проверяет решение задачи.\",\"generated_as_correct\":false}],\"question\":\"Что такое статус решения в контексте проверки задач системой?\"},{\"answers\":[{\"text\":\"Система выдаёт статусы «Решена полностью» (успешная компиляция и прохождение тестов) или «Решена неверно» (проблемы с компиляцией или тестированием).\",\"generated_as_correct\":true},{\"text\":\"Система может выдать статус «Решена автоматически», если решение задачи было найдено без участия пользователя, или «Решена вручную», если пользователь внёс изменения в код.\",\"generated_as_correct\":false},{\"text\":\"Статус решения задачи связан с уровнем сложности задачи и не зависит от результатов компиляции или тестирования кода.\",\"generated_as_correct\":false},{\"text\":\"Система выдаёт статус «Задача отменена», если решение успешно прошло все тесты.\",\"generated_as_correct\":false}],\"question\":\"Какие возможные статусы решения задачи может выдать система и что они означают?\"},{\"answers\":[{\"text\":\"Статус решения помогает определить, успешно ли код прошёл проверку системы, что позволяет выявить и исправить ошибки.\",\"generated_as_correct\":true},{\"text\":\"Статус решения показывает, насколько эффективно код использует системные ресурсы. Если статус «Решена полностью», то код оптимизирован и работает быстро, а если «Решена неверно», то код требует дополнительной оптимизации для повышения производительности.\",\"generated_as_correct\":false},{\"text\":\"Статус решения используется для определения уровня сложности задачи и выбора подходящих алгоритмов для её решения. Он помогает разработчикам понять, какие методы лучше всего применять в зависимости от поставленной задачи.\",\"generated_as_correct\":false},{\"text\":\"Статус решения указывает на скорость выполнения кода и его оптимизацию.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать информацию о статусе решения для улучшения кода или решения задачи?\"},{\"answers\":[{\"text\":\"Вердикты — это результаты тестирования решения системой, которые могут быть, например, OK, CE, WA, RE, TL или ML.\",\"generated_as_correct\":true},{\"text\":\"Вердикты — это уведомления от системы, которые сообщают о статусе выполнения задачи, например, о начале тестирования или о том, что задача была принята на сервер.\",\"generated_as_correct\":false},{\"text\":\"Вердикты — это специальные коды, которые используются для шифрования данных в системе проверки решений.\",\"generated_as_correct\":false},{\"text\":\"Вердикты — это комментарии разработчиков о качестве кода, представленные системой проверки.\",\"generated_as_correct\":false}],\"question\":\"Что такое вердикты в контексте системы проверки решений?\"},{\"answers\":[{\"text\":\"Вердикт CE — ошибка компиляции, вердикт RE — ошибка выполнения.\",\"generated_as_correct\":true},{\"text\":\"Вердикт CE выдаётся, когда программа потребляет слишком много памяти, а вердикт RE — когда программа работает слишком долго на одном из тестов.\",\"generated_as_correct\":false},{\"text\":\"Вердикт CE связан с проблемами в алгоритме решения задачи, а вердикт RE — с неправильным выбором структуры данных.\",\"generated_as_correct\":false},{\"text\":\"Вердикт CE указывает на превышение лимита времени, а вердикт RE — на превышение лимита памяти.\",\"generated_as_correct\":false}],\"question\":\"Чем отличается вердикт CE от вердикта RE?\"},{\"answers\":[{\"text\":\"Вердикты системы проверки помогают выявить и исправить ошибки в коде, такие как ошибки компиляции, неправильные ответы, ошибки выполнения, превышение времени или памяти.\",\"generated_as_correct\":true},{\"text\":\"Вердикты системы проверки указывают только на успешное прохождение всех тестов и не предоставляют информации о возможных ошибках в решении.\",\"generated_as_correct\":false},{\"text\":\"Вердикты системы проверки полезны для определения эффективности алгоритмов и выбора оптимального подхода к решению задачи, но не помогают в выявлении конкретных ошибок в коде.\",\"generated_as_correct\":false},{\"text\":\"Вердикты системы проверки нужны только для подтверждения успешного завершения всех тестов и не используются для поиска ошибок в программе.\",\"generated_as_correct\":false}],\"question\":\"Как можно использовать информацию о вердиктах для улучшения решения задачи?\"}],\"StoreCardId\":null,\"numberInCourse\":\"5.1\"},{\"Name\":\"cpp | 5.2 Как пользоваться хендбуком\",\"Slug\":\"cpp-kak-polzovatsia-khendbukom\",\"createdAt\":\"2024-08-27T15:10:58.002Z\",\"updatedAt\":\"2026-01-10T12:07:10.464Z\",\"publishedAt\":\"2024-08-27T15:11:06.453Z\",\"ContestURL\":null,\"Lead\":null,\"Content\":\"Если вы хотите вернуться к параграфу попозже, то можете оставить закладку на том месте, где вы остановились.\\n\\nДля этого можно отметить главы как прочитанные. Плюс из этого же меню можно перейти к задачам хендбука:\\n\\n![Python_hb_screenshot_1 (1).webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_1_1_1b00eb0564.webp)\\n\\nИзменение статуса главы отразится на странице содержания и в прогресс-баре хендбука:\\n\\n![Python_hb_screenshot_2 (3).webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_2_3_a94219c466.webp)\\n\\nДля перемещения по хендбуку вы можете воспользоваться навигацией внутри страниц:\\n\\n![Python_hb_screenshot_4.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_4_e01772afef.webp)\\n\\nВот и всё! Как видите, это не сложно. Надеемся, у вас всё получится. А если нет — вступайте в [коммьюнити](https://t.me/handbook_cpp)  хендбука: там вам обязательно придут на помощь.\",\"Title\":\"Как пользоваться хендбуком\",\"LikesCount\":28,\"Quiz\":[{\"answers\":[{\"text\":\"Закладка в хендбуке — это способ отметить место в тексте для быстрого возврата.\",\"generated_as_correct\":true},{\"text\":\"Закладка в хендбуке — это специальный значок, который ставится автоматически в конце каждой главы, чтобы пользователь мог продолжить чтение с нового раздела.\",\"generated_as_correct\":false},{\"text\":\"Закладка в хендбуке — это элемент оформления, который используется для украшения страниц и привлечения внимания к ключевым моментам текста.\",\"generated_as_correct\":false},{\"text\":\"Закладка в хендбуке — это инструмент для скрытия ненужной информации в тексте.\",\"generated_as_correct\":false}],\"question\":\"Что такое закладка в хендбуке?\"},{\"answers\":[{\"text\":\"Закладки облегчают возврат к нужным местам в хендбуке, повышая удобство использования.\",\"generated_as_correct\":true},{\"text\":\"Закладки в хендбуке предназначены исключительно для украшения и не влияют на функциональность или удобство использования.\",\"generated_as_correct\":false},{\"text\":\"Закладки в хендбуке связаны с системой уведомлений и помогают пользователям получать оповещения о новых разделах и обновлениях.\",\"generated_as_correct\":false},{\"text\":\"Закладки затрудняют навигацию по хендбуку и снижают удобство использования.\",\"generated_as_correct\":false}],\"question\":\"Как закладки влияют на удобство использования хендбука?\"},{\"answers\":[{\"text\":\"Закладка в хендбуке позволяет отметить место в тексте для быстрого возврата к нему.\",\"generated_as_correct\":true},{\"text\":\"Закладка в хендбуке нужна для того, чтобы отмечать важные цитаты и ключевые моменты текста, которые затем можно будет использовать для цитирования.\",\"generated_as_correct\":false},{\"text\":\"Закладка в хендбуке применяется для организации заметок и комментариев к тексту, что помогает структурировать информацию для дальнейшего анализа.\",\"generated_as_correct\":false},{\"text\":\"Закладка в хендбуке нужна для временного скрытия информации, чтобы сосредоточиться на других разделах текста.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях может быть полезно использовать закладку в хендбуке?\"},{\"answers\":[{\"text\":\"Функция «Изменение статуса главы» позволяет отмечать главы как прочитанные, что отражается в прогресс-баре.\",\"generated_as_correct\":true},{\"text\":\"Функция «Изменение статуса главы» даёт возможность пользователям удалять прочитанные главы из хендбука, что отображается на странице содержания.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» используется для изменения порядка глав в хендбуке и не влияет на отображение прогресса чтения.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» позволяет скрывать прочитанные главы из списка содержания хендбука.\",\"generated_as_correct\":false}],\"question\":\"Что позволяет делать функция «Изменение статуса главы»?\"},{\"answers\":[{\"text\":\"Функция «Изменение статуса главы» помогает отслеживать прочитанные главы и прогресс чтения.\",\"generated_as_correct\":true},{\"text\":\"Функция «Изменение статуса главы» автоматически помечает главы как прочитанные через определённое время после открытия, независимо от действий пользователя.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» используется для изменения порядка глав в хендбуке и не влияет на отображение прогресса чтения.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» нужна для скрытия уже прочитанных глав из списка содержания.\",\"generated_as_correct\":false}],\"question\":\"Как функция «Изменение статуса главы» помогает пользователям в процессе чтения?\"},{\"answers\":[{\"text\":\"Функция «Изменение статуса главы» помогает отмечать прочитанные главы и отслеживать прогресс.\",\"generated_as_correct\":true},{\"text\":\"Функция «Изменение статуса главы» позволяет пользователям добавлять комментарии к каждой главе, что помогает им лучше запоминать прочитанное.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» применяется для настройки визуальных параметров хендбука, таких как шрифт и фон, что улучшает читаемость текста.\",\"generated_as_correct\":false},{\"text\":\"Функция «Изменение статуса главы» нужна для изменения содержания глав в хендбуке.\",\"generated_as_correct\":false}],\"question\":\"В каких случаях может быть полезно использование функции «Изменение статуса главы»?\"},{\"answers\":[{\"text\":\"«Навигация внутри страниц — это перемещение по хендбуку с помощью специальных элементов».\",\"generated_as_correct\":true},{\"text\":\"«Навигация внутри страниц хендбука — это функция, которая позволяет изменять порядок разделов в документе для удобства чтения».\",\"generated_as_correct\":false},{\"text\":\"«Навигация внутри страниц хендбука связана с настройкой внешнего вида документа, включая выбор шрифтов и цветов для оформления текста».\",\"generated_as_correct\":false},{\"text\":\"«Навигация внутри страниц хендбука — это возможность печати отдельных разделов документа».\",\"generated_as_correct\":false}],\"question\":\"Что такое навигация внутри страниц хендбука?\"},{\"answers\":[{\"text\":\"Навигационные элементы упрощают перемещение по хендбуку, позволяя быстро переходить к нужным разделам.\",\"generated_as_correct\":true},{\"text\":\"Навигационные элементы в хендбуке служат исключительно для украшения и не влияют на процесс перемещения между разделами.\",\"generated_as_correct\":false},{\"text\":\"Навигационные элементы помогают в хендбуке для улучшения визуального восприятия информации и не связаны с функциональностью перемещения по тексту.\",\"generated_as_correct\":false},{\"text\":\"Навигационные элементы в хендбуке нужны только для печати оглавления.\",\"generated_as_correct\":false}],\"question\":\"Как навигационные элементы помогают при работе с хендбуком?\"},{\"answers\":[{\"text\":\"Навигационные элементы упрощают перемещение по хендбуку и быстрый доступ к нужным разделам.\",\"generated_as_correct\":true},{\"text\":\"Навигационные элементы на страницах хендбука полезны только для дизайнеров, которые хотят улучшить визуальное оформление документа.\",\"generated_as_correct\":false},{\"text\":\"Навигационные элементы на страницах хендбука помогают в процессе печати документа, оптимизируя расположение текста на листе.\",\"generated_as_correct\":false},{\"text\":\"Навигационные элементы используются для украшения страниц хендбука и не влияют на удобство использования.\",\"generated_as_correct\":false}],\"question\":\"В каких ситуациях использование навигационных элементов на страницах хендбука может быть особенно полезным?\"}],\"StoreCardId\":null,\"numberInCourse\":\"5.2\"}]}],\"activeArticleSlug\":\"data-types\",\"csrfToken\":\"\",\"hasNotes\":true,\"children\":\"$L71\"}]}]}]\n"])</script><script nonce="">self.__next_f.push([1,"71:[[[\"$\",\"meta\",null,{\"property\":\"og:type\",\"content\":\"article\",\"itemProp\":\"\"}],[\"$\",\"meta\",null,{\"property\":\"article:modified_time\",\"content\":\"2026-01-10T12:07:10.674Z\",\"itemProp\":\"\"}],[],[\"$\",\"meta\",null,{\"property\":\"article:section\",\"content\":\"Основы С++\",\"itemProp\":\"\"}]],\"$L72\"]\n"])</script><script nonce="">self.__next_f.push([1,"73:I[9348,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"ReadingProgress\"]\n74:I[16524,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"BookBreadcrumbs\"]\n75:I[87301,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"WYSIWYGClient\"]\n76:T5441,"])</script><script nonce="">self.__next_f.push([1,"C++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.\n\nВ этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.\n\n\n## Области видимости\nВ С++ существует понятие [области видимости](https://en.cppreference.com/w/cpp/language/scope) (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:\n\n```cpp\n#include \u003ciostream\u003e\n\nint a = 1;  // глобальная переменная\n\nint main() {\n    int b = 2;  // локальная переменная\n    {\n        int c = 3;  // локальная переменная внутри блока\n        std::cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c \" \" \u003c\u003c c \u003c\u003c \"\\n\";  // корректно\n    }\n\n    // Эта строчка не скомпилируется,\n    // так как переменная c не определена в данной области:\n    std::cout \u003c\u003c c \u003c\u003c \"\\n\";\n}\n```\n\nВ этом примере есть три области:\n- глобальная, в которой определена переменная `a`;\n- тело функции `main`, в которой определена переменная `b`;\n- внутренний блок, в котором определена переменная `c`.\n\nВ последней строке примера переменная `c` недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.\n\nРассмотрим пример:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int x = 1;\n    std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // напечатает 1\n    {\n        int x = 2;  // новая переменная, к предыдущему x не имеет отношения\n        std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // напечатает 2\n    }\n    std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // снова напечатает 1\n}\n```\n\n\n## Инициализация локальных переменных\n\nЛокальные переменные простых типов, таких как `int`, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: [*мы не должны платить за то, что не используем*](https://en.cppreference.com/w/cpp/language/Zero-overhead_principle).\n\nСледующий фрагмент кода может напечатать всё что угодно:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    int x;\n    std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // неопределённое поведение!\n    int y;\n    std::cin \u003e\u003e y;  // а это допустимый сценарий\n}\n```\n\nКомпиляторы `g++` и `clang++` обычно дают предупреждения о чтении неинициализированных переменных при использовании опции `-Wall` или `-Wuninitialized`:\n\n\u003cpre\u003e\n$ clang++ -Wall program.cpp\nprogram.cpp:5:18: warning: variable 'x' is uninitialized when used here [-Wuninitialized]\n    std::cout \u003c\u003c x \u003c\u003c \"\\n\";  // неопределённое поведение!\n                 ^\nprogram.cpp:4:10: note: initialize the variable 'x' to silence this warning\n    int x;\n         ^\n          = 0\n1 warning generated.\n\u003c/pre\u003e\n\nЗаметим, что `std::string` является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать `std::string s = \"\";`. Пишите просто `std::string s;`.\n\n\n## Простые типы данных\n\nС типом `int` мы уже знакомы. Рассмотрим другие [фундаментальные типы данных](https://en.cppreference.com/w/cpp/language/types) в С++. Это так называемые интегральные типы и типы для вещественных чисел.\n\n```cpp\nint main() {\n    char c = '1';    // символ\n    bool b = true;   // логическая переменная, принимает значения false и true\n    int i = 42;      // целое число (занимает, как правило, 4 байта)\n    short int si = 17;           // короткое целое (занимает 2 байта)\n    long li = 12321321312;       // длинное целое (как правило, 8 байт)\n    long long lli = 12321321312; // длинное целое (как правило, 8 байт)\n    float f = 2.71828;           // дробное число с плавающей запятой (4 байта)\n    double d = 3.141592;         // дробное число двойной точности (8 байт)\n    long double ld = 1e15;       // длинное дробное (как правило, 16 байт)\n}\n```\n\nОбратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную `c` символ единицы. Фактически в памяти хранится [ASCII-код](https://en.cppreference.com/w/cpp/language/ascii) этого символа, который равен 49.\n\nНапомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.\n\nО том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора [`sizeof`](https://en.cppreference.com/w/cpp/language/sizeof).\n\nНапример, на 64-битной Linux-системе компилятор `clang++` использует такие размеры для типов:\n\n```cpp\nint main() {\n    std::cout \u003c\u003c \"char: \" \u003c\u003c sizeof(char) \u003c\u003c \"\\n\";                 //  1\n    std::cout \u003c\u003c \"bool: \" \u003c\u003c sizeof(bool) \u003c\u003c \"\\n\";                 //  1\n    std::cout \u003c\u003c \"short int: \" \u003c\u003c sizeof(short int) \u003c\u003c \"\\n\";       //  2 (по стандарту \u003e= 2)\n    std::cout \u003c\u003c \"int: \" \u003c\u003c sizeof(int) \u003c\u003c \"\\n\";                   //  4 (по стандарту \u003e= 2)\n    std::cout \u003c\u003c \"long int: \" \u003c\u003c sizeof(long int) \u003c\u003c \"\\n\";         //  8 (по стандарту \u003e= 4)\n    std::cout \u003c\u003c \"long long int: \" \u003c\u003c sizeof(long long) \u003c\u003c \"\\n\";   //  8 (по стандарту \u003e= 8)\n    std::cout \u003c\u003c \"float: \" \u003c\u003c sizeof(float) \u003c\u003c \"\\n\";               //  4\n    std::cout \u003c\u003c \"double: \" \u003c\u003c sizeof(double) \u003c\u003c \"\\n\";             //  8\n    std::cout \u003c\u003c \"long double: \" \u003c\u003c sizeof(long double) \u003c\u003c \"\\n\";   // 16\n}\n```\n\n\n## Размеры стандартных типов\n\nПо умолчанию числовые типы – знаковые. Они имеют диапазон значений от $-2^{n-1}$ до $2^{n-1} - 1$, где $n$ – количество битов, занимаемых типом. Приставка `unsigned` перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до $2^n - 1$:\n\n```cpp\nint main() {\n    unsigned int ui = 4294967295;  // 2^32 - 1\n}\n```\n\nМинимальное и максимальное значение, помещающееся в данный числовой тип, можно получить так:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003climits\u003e  // необходимо для numeric_limits\n\nint main() {\n    // посчитаем для типа int:\n    std::cout \u003c\u003c \"minimum value: \" \u003c\u003c std::numeric_limits\u003cint\u003e::min() \u003c\u003c \"\\n\"\n              \u003c\u003c \"maximum value: \" \u003c\u003c std::numeric_limits\u003cint\u003e::max() \u003c\u003c \"\\n\";\n}\n```\n\nДанный пример на 64-битной Linux-системе напечатает:\n\n\u003cpre\u003e\nminimum value: -2147483648\nmaximum value: 2147483647\n\u003c/pre\u003e\n\nПриведённые выше примеры вывода оператора `sizeof` верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. Например, `sizeof(long int)` стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. Также бывают [встраиваемые системы](https://en.wikipedia.org/wiki/Embedded_system), под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.\n\nВ заголовочном файле `cstdint` стандартной библиотеки имеются [целочисленные типы с фиксированным размером](https://en.cppreference.com/w/cpp/types/integer):\n- `int8_t` / `uint8_t`\n- `int16_t` / `uint16_t`\n- `int32_t` / `uint32_t`\n- `int64_t` / `uint64_t`\n\nЧисло в имени типа означает количество бит, используемых для хранения в памяти. Например, `int32_t` содержит 32 бита (4 байта) и часто соответствует типу `int`. Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.\n\n\n## Переполнение целочисленных типов\n\nСтандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    unsigned int a = 123456;  // на 64-битной платформе sizeof(a) == 4\n\n    // Произведение a * a не помещается в 4 байта, так как оно больше 2^32\n    std::cout \u003c\u003c a * a \u003c\u003c \"\\n\";\n}\n```\n\nВ этом примере выражение `a * a` будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.\n\nБеззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:\n\n```cpp\nint main() {\n    unsigned int x = 0;      // на 64-битной платформе sizeof(x) == 4\n    unsigned int y = x - 1;  // 4294967295, то есть 2**32 - 1\n    unsigned int z = y + 1;  // 0\n}\n```\n\nНаоборот, для знаковых типов переполнение приводит к так называемому [неопределённому поведению](https://en.cppreference.com/w/cpp/language/ub) (UB, undefined behavior).\n\nТакая ситуация не считается ошибкой компиляции (в самом деле, на стадии компиляции значения переменных могут быть ещё неизвестны). Но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.\n\n**Беззнаковые типы** следует использовать, когда вы имеете дело с битовыми наборами. В остальных случаях предпочтительнее использовать **знаковые типы**.\n\n## Арифметические операции\n\nБинарные операции `+`, `-` и `*` работают для чисел стандартным образом. Результат операции деления `/`, применённой к целым числам, всегда округляется в сторону нуля. Таким образом, для положительных чисел операция `/` возвращает неполное частное. Остаток от деления целых чисел можно получить с помощью операции `%`.\n\n```cpp\nint main() {\n    int a = 7, b = 3;\n    int q = a / b;  // 2\n    int r = a % b;  // 1\n}\n```\n\nЕсли при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, `double`) с помощью оператора `static_cast`:\n\n```cpp\nint main() {\n    int a = 6, b = 4;\n    double q = static_cast\u003cdouble\u003e(a) / b;  // 1.5\n}\n```\n\nМожно было бы написать чуть более кратко: `double q = a * 1.0 / b;`. Тогда преобразование аргументов произошло бы неявно.\n\nАрифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:\n\n```cpp\n#include \u003ciostream\u003e\n\nint main() {\n    char c = 'A';\n    c += 25;  // увеличиваем ASCII-код символа на 25\n    std::cout \u003c\u003c c \u003c\u003c \"\\n\";  // Z\n}\n```\n\n\u003cfigure\u003e\n  \u003cimg src=\"https://yastatic.net/s3/education-portal/media/C_1_869495082d_9c26d1f093.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\"\u003e\n  \u003cfigcaption\u003e\n    Таблица ASCII с шестнадцатеричными кодами символов. Слева указана старшая шестнадцатеричная цифра, сверху — младшая. Цветом выделены так называемые управляющие символы, обычно не имеющие графического представления.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\nОперация `+` применительно к строкам означает конкатенирование (то есть склейку). Это пример *перегрузки* операции: изначальному оператору сложения чисел в стандартной библиотеке для строки придали новый смысл.\n\n```cpp\n#include \u003cstring\u003e\n\nint main() {\n    std::string a = \"Hello, \";\n    std::string b = \"world!\";\n    std::string c = a + b;  // Hello, world!\n}\n```\n\nДля каждой бинарной операции (например, `+`) есть версия со знаком равенства (`+=`) для случая, когда левый аргумент совпадает с переменной, которой присваивается результат:\n\n```cpp\nint main() {\n    int x = 5;\n    x += 3;  // x = x + 3\n    x *= x;  // x = x * x\n}\n```\n\nНаконец, имеются операторы `++` и `--` для увеличения или уменьшения переменной на единицу. Они бывают префиксные (`++x`) и постфиксные (`x++`). Отличие состоит в значении выражения, которое будет вычисляться при применении такого оператора. Мы рассмотрим это позже, а пока привыкнем по умолчанию использовать префиксный оператор для обычных чисел:\n\n```cpp\nint main() {\n    int x = 5;\n    ++x;  // 6\n    --x;  // снова 5\n}\n```\n\n## Числа с плавающей точкой\n\nВ языке C++ существуют три встроенных типа для записи дробных чисел: `float` (4 байта), `double` (8 байт) и `long double` (16 или 8 байт, в зависимости от платформы). В большинстве случаев рекомендуется использовать тип `double`.Тип `float` разумно использовать там, где обрабатываются огромные массивы чисел, и возникает необходимость экономить память.\n\nКак правило, хранение дробных чисел в С++ основано на стандарте [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754). Число представляется в виде двоичной дроби в [экспоненциальной записи](https://en.wikipedia.org/wiki/Scientific_notation): отдельно хранятся бит знака, порядок и [мантисса](https://en.wikipedia.org/wiki/Significand).\n\n![C_2_5f62557ba8.svg](https://yastatic.net/s3/education-portal/media/C_2_5f62557ba8_ec6023e6f3.svg)\n\nТакое представление выгодно отличается от чисел с фиксированной точкой, где хранится фиксированное количество разрядов. Оно позволяет, хотя и с разной степенью точности, представлять числа, отличающиеся на порядки.\n\nПри работе с рациональными числами, знаменатель которых не является степенью двойки, неизбежно возникают погрешности представления. В следующем параграфе мы разберём как следует сравнивать такие числа.\n\n\n## Автоматический вывод типа\n\nКомпилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово `auto`:\n\n```cpp\nint main() {\n    auto x = 42;  // int\n    auto pi = 3.14159;  // double\n}\n```\n\nКлючевое слово `auto` позволяет сократить код и не выписывать сложные типы (нам встретятся дальше монстры вроде `std::unordered_multimap\u003cKey, Value\u003e::const_iterator`). Важно подчеркнуть, что точный тип переменной всё равно становится известен в момент компиляции.\n\nПри использовании `auto` со строками нужно быть осторожным. Важно знать, что конструкция `auto s = \"hello\"` выведет низкоуровневый тип `const char *` (указатель на неизменяемый набор символов в памяти), а не тип-обёртку `std::string`.\n\nТочные правила вывода типов похожи на правила вывода шаблонных параметров, с которыми мы познакомимся в [параграфе про шаблоны](https://education.yandex.ru/handbook/cpp/article/templates).\n\nВ следующем параграфе мы подробнее поговорим о ветвлении и циклах."])</script><script nonce="">self.__next_f.push([1,"77:Tce8a,"])</script><script nonce="">self.__next_f.push([1,"\u003cp\u003eC++ — язык со статической типизацией. У каждой переменной на этапе компиляции должен быть чётко определённый тип данных. Про каждый тип данных заранее известно, сколько места в памяти занимает переменная такого типа.\u003c/p\u003e\n\u003cp\u003eВ этом параграфе мы познакомимся с некоторыми базовыми типами данных и с понятием области видимости переменных.\u003c/p\u003e\n\u003ch2 id=\"oblasti-vidimosti\"\u003eОбласти видимости\u003c/h2\u003e\n\u003cp\u003eВ С++ существует понятие \u003ca href=\"https://en.cppreference.com/w/cpp/language/scope\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eобласти видимости\u003c/a\u003e (scope) переменной. Эта область ограничивается блоком кода, в котором переменная определена. Рассмотрим пример:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"%23include%20%3Ciostream%3E%0A%0Aint%20a%20%3D%201%3B%20%20%2F%2F%20%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%0A%0Aint%20main()%20%7B%0A%20%20%20%20int%20b%20%3D%202%3B%20%20%2F%2F%20%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20int%20c%20%3D%203%3B%20%20%2F%2F%20%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B0%0A%20%20%20%20%20%20%20%20std%3A%3Acout%20%3C%3C%20a%20%3C%3C%20%22%20%22%20%3C%3C%20b%20%3C%3C%20%22%20%22%20%3C%3C%20c%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D0%BE%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20%D0%AD%D1%82%D0%B0%20%D1%81%D1%82%D1%80%D0%BE%D1%87%D0%BA%D0%B0%20%D0%BD%D0%B5%20%D1%81%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D0%B8%D1%80%D1%83%D0%B5%D1%82%D1%81%D1%8F%2C%0A%20%20%20%20%2F%2F%20%D1%82%D0%B0%D0%BA%20%D0%BA%D0%B0%D0%BA%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20c%20%D0%BD%D0%B5%20%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B0%20%D0%B2%20%D0%B4%D0%B0%D0%BD%D0%BD%D0%BE%D0%B9%20%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8%3A%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20c%20%3C%3C%20%22%5Cn%22%3B%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// глобальная переменная\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e6\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e b = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// локальная переменная\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e7\u003c/span\u003e    {\n\u003cspan class=\"line-number\"\u003e8\u003c/span\u003e        \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e c = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// локальная переменная внутри блока\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e9\u003c/span\u003e        std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\" \"\u003c/span\u003e \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\" \"\u003c/span\u003e \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// корректно\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e10\u003c/span\u003e    }\n\u003cspan class=\"line-number\"\u003e11\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e12\u003c/span\u003e    \u003cspan class=\"hljs-comment\"\u003e// Эта строчка не скомпилируется,\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e13\u003c/span\u003e    \u003cspan class=\"hljs-comment\"\u003e// так как переменная c не определена в данной области:\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e14\u003c/span\u003e    std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e15\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eВ этом примере есть три области:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eглобальная, в которой определена переменная \u003ccode\u003ea\u003c/code\u003e;\u003c/li\u003e\n\u003cli\u003eтело функции \u003ccode\u003emain\u003c/code\u003e, в которой определена переменная \u003ccode\u003eb\u003c/code\u003e;\u003c/li\u003e\n\u003cli\u003eвнутренний блок, в котором определена переменная \u003ccode\u003ec\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eВ последней строке примера переменная \u003ccode\u003ec\u003c/code\u003e недоступна, так как её область видимости уже закончилась. В случае коллизии имён компилятор всегда выбирает самую вложенную область видимости.\u003c/p\u003e\n\u003cp\u003eРассмотрим пример:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"%23include%20%3Ciostream%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20int%20x%20%3D%201%3B%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20x%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D0%BD%D0%B0%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%B0%D0%B5%D1%82%201%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20int%20x%20%3D%202%3B%20%20%2F%2F%20%D0%BD%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%2C%20%D0%BA%20%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D0%B4%D1%83%D1%89%D0%B5%D0%BC%D1%83%20x%20%D0%BD%D0%B5%20%D0%B8%D0%BC%D0%B5%D0%B5%D1%82%20%D0%BE%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D1%8F%0A%20%20%20%20%20%20%20%20std%3A%3Acout%20%3C%3C%20x%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D0%BD%D0%B0%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%B0%D0%B5%D1%82%202%0A%20%20%20%20%7D%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20x%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D1%81%D0%BD%D0%BE%D0%B2%D0%B0%20%D0%BD%D0%B0%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%B0%D0%B5%D1%82%201%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// напечатает 1\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e6\u003c/span\u003e    {\n\u003cspan class=\"line-number\"\u003e7\u003c/span\u003e        \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// новая переменная, к предыдущему x не имеет отношения\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e8\u003c/span\u003e        std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// напечатает 2\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e9\u003c/span\u003e    }\n\u003cspan class=\"line-number\"\u003e10\u003c/span\u003e    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// снова напечатает 1\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e11\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003ch2 id=\"inicializaciya-lokalnyh-peremennyh\"\u003eИнициализация локальных переменных\u003c/h2\u003e\n\u003cp\u003eЛокальные переменные простых типов, таких как \u003ccode\u003eint\u003c/code\u003e, не инициализируются по умолчанию нулём. Компилятор просто выделяет для них байты в стековой памяти, но при этом он не обязан как-либо их заполнять. Это один из принципов C++: \u003ca href=\"https://en.cppreference.com/w/cpp/language/Zero-overhead_principle\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e\u003cem\u003eмы не должны платить за то, что не используем\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eСледующий фрагмент кода может напечатать всё что угодно:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"%23include%20%3Ciostream%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20int%20x%3B%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20x%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20%D0%BD%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D0%BE%D0%B5%20%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5!%0A%20%20%20%20int%20y%3B%0A%20%20%20%20std%3A%3Acin%20%3E%3E%20y%3B%20%20%2F%2F%20%D0%B0%20%D1%8D%D1%82%D0%BE%20%D0%B4%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BC%D1%8B%D0%B9%20%D1%81%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D0%B9%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e x;\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// неопределённое поведение!\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e6\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e y;\n\u003cspan class=\"line-number\"\u003e7\u003c/span\u003e    std::cin \u0026gt;\u0026gt; y;  \u003cspan class=\"hljs-comment\"\u003e// а это допустимый сценарий\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e8\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eКомпиляторы \u003ccode\u003eg++\u003c/code\u003e и \u003ccode\u003eclang++\u003c/code\u003e обычно дают предупреждения о чтении неинициализированных переменных при использовании опции \u003ccode\u003e-Wall\u003c/code\u003e или \u003ccode\u003e-Wuninitialized\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\n$ clang++ -Wall program.cpp\nprogram.cpp:5:18: warning: variable 'x' is uninitialized when used here [-Wuninitialized]\n    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \"\\n\";  // неопределённое поведение!\n                 ^\nprogram.cpp:4:10: note: initialize the variable 'x' to silence this warning\n    int x;\n         ^\n          = 0\n1 warning generated.\n\u003c/pre\u003e\n\u003cp\u003eЗаметим, что \u003ccode\u003estd::string\u003c/code\u003e является сложным типом и переменные такого типа всегда по умолчанию инициализируются пустой строкой. Поэтому нет необходимости писать \u003ccode\u003estd::string s = \"\";\u003c/code\u003e. Пишите просто \u003ccode\u003estd::string s;\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"prostye-tipy-dannyh\"\u003eПростые типы данных\u003c/h2\u003e\n\u003cp\u003eС типом \u003ccode\u003eint\u003c/code\u003e мы уже знакомы. Рассмотрим другие \u003ca href=\"https://en.cppreference.com/w/cpp/language/types\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eфундаментальные типы данных\u003c/a\u003e в С++. Это так называемые интегральные типы и типы для вещественных чисел.\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"int%20main()%20%7B%0A%20%20%20%20char%20c%20%3D%20'1'%3B%20%20%20%20%2F%2F%20%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%0A%20%20%20%20bool%20b%20%3D%20true%3B%20%20%20%2F%2F%20%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%2C%20%D0%BF%D1%80%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D1%82%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%20false%20%D0%B8%20true%0A%20%20%20%20int%20i%20%3D%2042%3B%20%20%20%20%20%20%2F%2F%20%D1%86%D0%B5%D0%BB%D0%BE%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%20(%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D1%82%2C%20%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%204%20%D0%B1%D0%B0%D0%B9%D1%82%D0%B0)%0A%20%20%20%20short%20int%20si%20%3D%2017%3B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%D0%BA%D0%BE%D1%80%D0%BE%D1%82%D0%BA%D0%BE%D0%B5%20%D1%86%D0%B5%D0%BB%D0%BE%D0%B5%20(%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D1%82%202%20%D0%B1%D0%B0%D0%B9%D1%82%D0%B0)%0A%20%20%20%20long%20li%20%3D%2012321321312%3B%20%20%20%20%20%20%20%2F%2F%20%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%86%D0%B5%D0%BB%D0%BE%D0%B5%20(%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%208%20%D0%B1%D0%B0%D0%B9%D1%82)%0A%20%20%20%20long%20long%20lli%20%3D%2012321321312%3B%20%2F%2F%20%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%86%D0%B5%D0%BB%D0%BE%D0%B5%20(%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%208%20%D0%B1%D0%B0%D0%B9%D1%82)%0A%20%20%20%20float%20f%20%3D%202.71828%3B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%20%D1%81%20%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9%20%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9%20(4%20%D0%B1%D0%B0%D0%B9%D1%82%D0%B0)%0A%20%20%20%20double%20d%20%3D%203.141592%3B%20%20%20%20%20%20%20%20%20%2F%2F%20%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%20%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9%20%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20(8%20%D0%B1%D0%B0%D0%B9%D1%82)%0A%20%20%20%20long%20double%20ld%20%3D%201e15%3B%20%20%20%20%20%20%20%2F%2F%20%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5%20%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D0%B5%20(%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%2016%20%D0%B1%D0%B0%D0%B9%D1%82)%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e c = \u003cspan class=\"hljs-string\"\u003e'1'\u003c/span\u003e;    \u003cspan class=\"hljs-comment\"\u003e// символ\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e b = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;   \u003cspan class=\"hljs-comment\"\u003e// логическая переменная, принимает значения false и true\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e;      \u003cspan class=\"hljs-comment\"\u003e// целое число (занимает, как правило, 4 байта)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eshort\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e si = \u003cspan class=\"hljs-number\"\u003e17\u003c/span\u003e;           \u003cspan class=\"hljs-comment\"\u003e// короткое целое (занимает 2 байта)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e6\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e li = \u003cspan class=\"hljs-number\"\u003e12321321312\u003c/span\u003e;       \u003cspan class=\"hljs-comment\"\u003e// длинное целое (как правило, 8 байт)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e7\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e lli = \u003cspan class=\"hljs-number\"\u003e12321321312\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// длинное целое (как правило, 8 байт)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e8\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e f = \u003cspan class=\"hljs-number\"\u003e2.71828\u003c/span\u003e;           \u003cspan class=\"hljs-comment\"\u003e// дробное число с плавающей запятой (4 байта)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e9\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e d = \u003cspan class=\"hljs-number\"\u003e3.141592\u003c/span\u003e;         \u003cspan class=\"hljs-comment\"\u003e// дробное число двойной точности (8 байт)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e10\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e ld = \u003cspan class=\"hljs-number\"\u003e1e15\u003c/span\u003e;       \u003cspan class=\"hljs-comment\"\u003e// длинное дробное (как правило, 16 байт)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e11\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eОбратите внимание, что символы, в отличие от строк (то есть массивов символов), записываются в апострофах, а не в кавычках. В примере выше мы записываем в переменную \u003ccode\u003ec\u003c/code\u003e символ единицы. Фактически в памяти хранится \u003ca href=\"https://en.cppreference.com/w/cpp/language/ascii\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eASCII-код\u003c/a\u003e этого символа, который равен 49.\u003c/p\u003e\n\u003cp\u003eНапомним, что каждый тип данных занимает заранее известное количество байтов памяти. Стандарт языка С++ не накладывает жёстких ограничений на размеры типов, они могут отличаться для разных платформ и компиляторов.\u003c/p\u003e\n\u003cp\u003eО том, что делать с этой особенностью, мы расскажем ниже. А пока отметим, что узнать размер переменной или типа на этапе компиляции можно с помощью оператора \u003ca href=\"https://en.cppreference.com/w/cpp/language/sizeof\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e\u003ccode\u003esizeof\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eНапример, на 64-битной Linux-системе компилятор \u003ccode\u003eclang++\u003c/code\u003e использует такие размеры для типов:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"int%20main()%20%7B%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22char%3A%20%22%20%3C%3C%20sizeof(char)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%201%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22bool%3A%20%22%20%3C%3C%20sizeof(bool)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%201%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22short%20int%3A%20%22%20%3C%3C%20sizeof(short%20int)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%2F%2F%20%202%20(%D0%BF%D0%BE%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D1%83%20%3E%3D%202)%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22int%3A%20%22%20%3C%3C%20sizeof(int)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%204%20(%D0%BF%D0%BE%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D1%83%20%3E%3D%202)%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22long%20int%3A%20%22%20%3C%3C%20sizeof(long%20int)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%2F%2F%20%208%20(%D0%BF%D0%BE%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D1%83%20%3E%3D%204)%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22long%20long%20int%3A%20%22%20%3C%3C%20sizeof(long%20long)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%2F%2F%20%208%20(%D0%BF%D0%BE%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D1%83%20%3E%3D%208)%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22float%3A%20%22%20%3C%3C%20sizeof(float)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%204%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22double%3A%20%22%20%3C%3C%20sizeof(double)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%208%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22long%20double%3A%20%22%20%3C%3C%20sizeof(long%20double)%20%3C%3C%20%22%5Cn%22%3B%20%20%20%2F%2F%2016%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"char: \"\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-built_in\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e) \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;                 \u003cspan class=\"hljs-comment\"\u003e//  1\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"bool: \"\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-built_in\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e) \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;                 \u003cspan class=\"hljs-comment\"\u003e//  1\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"short int: \"\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-built_in\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eshort\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e) \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;       \u003cspan class=\"hljs-comment\"\u003e//  2 (по стандарту \u0026gt;= 2)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"int: \"\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-built_in\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e) \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;                   \u003cspan class=\"hljs-comment\"\u003e//  4 (по стандарту \u0026gt;= 2)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e6\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"long int: \"\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-built_in\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e) \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;         \u003cspan class=\"hljs-comment\"\u003e//  8 (по стандарту \u0026gt;= 4)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e7\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"long long int: \"\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-built_in\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e) \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;   \u003cspan class=\"hljs-comment\"\u003e//  8 (по стандарту \u0026gt;= 8)\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e8\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"float: \"\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-built_in\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003efloat\u003c/span\u003e) \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;               \u003cspan class=\"hljs-comment\"\u003e//  4\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e9\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"double: \"\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-built_in\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e) \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;             \u003cspan class=\"hljs-comment\"\u003e//  8\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e10\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"long double: \"\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"hljs-built_in\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e) \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;   \u003cspan class=\"hljs-comment\"\u003e// 16\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e11\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003ch2 id=\"razmery-standartnyh-tipov\"\u003eРазмеры стандартных типов\u003c/h2\u003e\n\u003cp\u003eПо умолчанию числовые типы – знаковые. Они имеют диапазон значений от \u003cspan class=\"yfm-latex\" data-content=\"-2%5E%7Bn-1%7D\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e до \u003cspan class=\"yfm-latex\" data-content=\"2%5E%7Bn-1%7D%20-%201\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e, где \u003cspan class=\"yfm-latex\" data-content=\"n\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e – количество битов, занимаемых типом. Приставка \u003ccode\u003eunsigned\u003c/code\u003e перед типом делает его беззнаковым. В этом случае диапазон допустимых значений будет от 0 до \u003cspan class=\"yfm-latex\" data-content=\"2%5En%20-%201\" data-options=\"%7B%22displayMode%22%3Afalse%7D\"\u003e\u003c/span\u003e:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"int%20main()%20%7B%0A%20%20%20%20unsigned%20int%20ui%20%3D%204294967295%3B%20%20%2F%2F%202%5E32%20-%201%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e ui = \u003cspan class=\"hljs-number\"\u003e4294967295\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// 2^32 - 1\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eМинимальное и максимальное значение, помещающееся в данный числовой тип, можно получить так:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"%23include%20%3Ciostream%3E%0A%23include%20%3Climits%3E%20%20%2F%2F%20%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%BE%20%D0%B4%D0%BB%D1%8F%20numeric_limits%0A%0Aint%20main()%20%7B%0A%20%20%20%20%2F%2F%20%D0%BF%D0%BE%D1%81%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D0%BC%20%D0%B4%D0%BB%D1%8F%20%D1%82%D0%B8%D0%BF%D0%B0%20int%3A%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20%22minimum%20value%3A%20%22%20%3C%3C%20std%3A%3Anumeric_limits%3Cint%3E%3A%3Amin()%20%3C%3C%20%22%5Cn%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%3C%20%22maximum%20value%3A%20%22%20%3C%3C%20std%3A%3Anumeric_limits%3Cint%3E%3A%3Amax()%20%3C%3C%20%22%5Cn%22%3B%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026lt;limits\u0026gt;\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e// необходимо для numeric_limits\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e    \u003cspan class=\"hljs-comment\"\u003e// посчитаем для типа int:\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e6\u003c/span\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"minimum value: \"\u003c/span\u003e \u0026lt;\u0026lt; std::numeric_limits\u0026lt;\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e\u0026gt;::\u003cspan class=\"hljs-built_in\"\u003emin\u003c/span\u003e() \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e7\u003c/span\u003e              \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"maximum value: \"\u003c/span\u003e \u0026lt;\u0026lt; std::numeric_limits\u0026lt;\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e\u0026gt;::\u003cspan class=\"hljs-built_in\"\u003emax\u003c/span\u003e() \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e8\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eДанный пример на 64-битной Linux-системе напечатает:\u003c/p\u003e\n\u003cpre\u003e\nminimum value: -2147483648\nmaximum value: 2147483647\n\u003c/pre\u003e\n\u003cp\u003eПриведённые выше примеры вывода оператора \u003ccode\u003esizeof\u003c/code\u003e верны для 64-битных архитектур, которые на сегодняшний день распространены повсеместно. Однако если бы мы скомпилировали и запустили такую программу на компьютере с 32-битной архитектурой, то получили бы другие результаты. Например, \u003ccode\u003esizeof(long int)\u003c/code\u003e стал бы равен 4, в то время как на современных компьютерах мы получили бы 8. Также бывают \u003ca href=\"https://en.wikipedia.org/wiki/Embedded_system\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eвстраиваемые системы\u003c/a\u003e, под которые тоже можно писать на С++. Там битность архитектуры может быть ещё меньше, чем 32.\u003c/p\u003e\n\u003cp\u003eВ заголовочном файле \u003ccode\u003ecstdint\u003c/code\u003e стандартной библиотеки имеются \u003ca href=\"https://en.cppreference.com/w/cpp/types/integer\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eцелочисленные типы с фиксированным размером\u003c/a\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eint8_t\u003c/code\u003e / \u003ccode\u003euint8_t\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint16_t\u003c/code\u003e / \u003ccode\u003euint16_t\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint32_t\u003c/code\u003e / \u003ccode\u003euint32_t\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint64_t\u003c/code\u003e / \u003ccode\u003euint64_t\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eЧисло в имени типа означает количество бит, используемых для хранения в памяти. Например, \u003ccode\u003eint32_t\u003c/code\u003e содержит 32 бита (4 байта) и часто соответствует типу \u003ccode\u003eint\u003c/code\u003e. Если система не поддерживает какой-то тип, то программа с ним просто не скомпилируется.\u003c/p\u003e\n\u003ch2 id=\"perepolnenie-celochislennyh-tipov\"\u003eПереполнение целочисленных типов\u003c/h2\u003e\n\u003cp\u003eСтандартные числовые типы имеют ограниченный размер и ограниченное множество допустимых значений. При арифметических операциях над числами таких типов может возникнуть переполнение — ситуация, когда результат операции не помещается в тип:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"%23include%20%3Ciostream%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20unsigned%20int%20a%20%3D%20123456%3B%20%20%2F%2F%20%D0%BD%D0%B0%2064-%D0%B1%D0%B8%D1%82%D0%BD%D0%BE%D0%B9%20%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D0%B5%20sizeof(a)%20%3D%3D%204%0A%0A%20%20%20%20%2F%2F%20%D0%9F%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20a%20*%20a%20%D0%BD%D0%B5%20%D0%BF%D0%BE%D0%BC%D0%B5%D1%89%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%B2%204%20%D0%B1%D0%B0%D0%B9%D1%82%D0%B0%2C%20%D1%82%D0%B0%D0%BA%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%BE%20%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B5%202%5E32%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20a%20*%20a%20%3C%3C%20%22%5Cn%22%3B%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e123456\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// на 64-битной платформе sizeof(a) == 4\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e6\u003c/span\u003e    \u003cspan class=\"hljs-comment\"\u003e// Произведение a * a не помещается в 4 байта, так как оно больше 2^32\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e7\u003c/span\u003e    std::cout \u0026lt;\u0026lt; a * a \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e8\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eВ этом примере выражение \u003ccode\u003ea * a\u003c/code\u003e будет иметь тот же тип, что и аргументы. То, что на самом деле будет вычислено, зависит от знаковости типа.\u003c/p\u003e\n\u003cp\u003eБеззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"int%20main()%20%7B%0A%20%20%20%20unsigned%20int%20x%20%3D%200%3B%20%20%20%20%20%20%2F%2F%20%D0%BD%D0%B0%2064-%D0%B1%D0%B8%D1%82%D0%BD%D0%BE%D0%B9%20%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D0%B5%20sizeof(x)%20%3D%3D%204%0A%20%20%20%20unsigned%20int%20y%20%3D%20x%20-%201%3B%20%20%2F%2F%204294967295%2C%20%D1%82%D0%BE%20%D0%B5%D1%81%D1%82%D1%8C%202**32%20-%201%0A%20%20%20%20unsigned%20int%20z%20%3D%20y%20%2B%201%3B%20%20%2F%2F%200%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;      \u003cspan class=\"hljs-comment\"\u003e// на 64-битной платформе sizeof(x) == 4\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e y = x - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// 4294967295, то есть 2**32 - 1\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e z = y + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eНаоборот, для знаковых типов переполнение приводит к так называемому \u003ca href=\"https://en.cppreference.com/w/cpp/language/ub\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eнеопределённому поведению\u003c/a\u003e (UB, undefined behavior).\u003c/p\u003e\n\u003cp\u003eТакая ситуация не считается ошибкой компиляции (в самом деле, на стадии компиляции значения переменных могут быть ещё неизвестны). Но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eБеззнаковые типы\u003c/strong\u003e следует использовать, когда вы имеете дело с битовыми наборами. В остальных случаях предпочтительнее использовать \u003cstrong\u003eзнаковые типы\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"arifmeticheskie-operacii\"\u003eАрифметические операции\u003c/h2\u003e\n\u003cp\u003eБинарные операции \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e и \u003ccode\u003e*\u003c/code\u003e работают для чисел стандартным образом. Результат операции деления \u003ccode\u003e/\u003c/code\u003e, применённой к целым числам, всегда округляется в сторону нуля. Таким образом, для положительных чисел операция \u003ccode\u003e/\u003c/code\u003e возвращает неполное частное. Остаток от деления целых чисел можно получить с помощью операции \u003ccode\u003e%\u003c/code\u003e.\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"int%20main()%20%7B%0A%20%20%20%20int%20a%20%3D%207%2C%20b%20%3D%203%3B%0A%20%20%20%20int%20q%20%3D%20a%20%2F%20b%3B%20%20%2F%2F%202%0A%20%20%20%20int%20r%20%3D%20a%20%25%20b%3B%20%20%2F%2F%201%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, b = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e q = a / b;  \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e r = a % b;  \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eЕсли при делении нужно получить обычное частное, то один из аргументов нужно привести к вещественному типу (например, \u003ccode\u003edouble\u003c/code\u003e) с помощью оператора \u003ccode\u003estatic_cast\u003c/code\u003e:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"int%20main()%20%7B%0A%20%20%20%20int%20a%20%3D%206%2C%20b%20%3D%204%3B%0A%20%20%20%20double%20q%20%3D%20static_cast%3Cdouble%3E(a)%20%2F%20b%3B%20%20%2F%2F%201.5%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, b = \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e q = \u003cspan class=\"hljs-built_in\"\u003estatic_cast\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e\u0026gt;(a) / b;  \u003cspan class=\"hljs-comment\"\u003e// 1.5\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eМожно было бы написать чуть более кратко: \u003ccode\u003edouble q = a * 1.0 / b;\u003c/code\u003e. Тогда преобразование аргументов произошло бы неявно.\u003c/p\u003e\n\u003cp\u003eАрифметические операции над символами, а также сравнение символов друг с другом — это фактически операции над их ASCII-кодами:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"%23include%20%3Ciostream%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20char%20c%20%3D%20'A'%3B%0A%20%20%20%20c%20%2B%3D%2025%3B%20%20%2F%2F%20%D1%83%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%20ASCII-%D0%BA%D0%BE%D0%B4%20%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%B0%20%D0%BD%D0%B0%2025%0A%20%20%20%20std%3A%3Acout%20%3C%3C%20c%20%3C%3C%20%22%5Cn%22%3B%20%20%2F%2F%20Z%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e c = \u003cspan class=\"hljs-string\"\u003e'A'\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e    c += \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// увеличиваем ASCII-код символа на 25\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e6\u003c/span\u003e    std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// Z\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e7\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"https://yastatic.net/s3/education-portal/media/C_1_869495082d_9c26d1f093.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\" /\u003e\n  \u003cfigcaption\u003e\n    Таблица ASCII с шестнадцатеричными кодами символов. Слева указана старшая шестнадцатеричная цифра, сверху — младшая. Цветом выделены так называемые управляющие символы, обычно не имеющие графического представления.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eОперация \u003ccode\u003e+\u003c/code\u003e применительно к строкам означает конкатенирование (то есть склейку). Это пример \u003cem\u003eперегрузки\u003c/em\u003e операции: изначальному оператору сложения чисел в стандартной библиотеке для строки придали новый смысл.\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"%23include%20%3Cstring%3E%0A%0Aint%20main()%20%7B%0A%20%20%20%20std%3A%3Astring%20a%20%3D%20%22Hello%2C%20%22%3B%0A%20%20%20%20std%3A%3Astring%20b%20%3D%20%22world!%22%3B%0A%20%20%20%20std%3A%3Astring%20c%20%3D%20a%20%2B%20b%3B%20%20%2F%2F%20Hello%2C%20world!%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    std::string a = \u003cspan class=\"hljs-string\"\u003e\"Hello, \"\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e    std::string b = \u003cspan class=\"hljs-string\"\u003e\"world!\"\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e6\u003c/span\u003e    std::string c = a + b;  \u003cspan class=\"hljs-comment\"\u003e// Hello, world!\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e7\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eДля каждой бинарной операции (например, \u003ccode\u003e+\u003c/code\u003e) есть версия со знаком равенства (\u003ccode\u003e+=\u003c/code\u003e) для случая, когда левый аргумент совпадает с переменной, которой присваивается результат:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"int%20main()%20%7B%0A%20%20%20%20int%20x%20%3D%205%3B%0A%20%20%20%20x%20%2B%3D%203%3B%20%20%2F%2F%20x%20%3D%20x%20%2B%203%0A%20%20%20%20x%20*%3D%20x%3B%20%20%2F%2F%20x%20%3D%20x%20*%20x%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e    x += \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// x = x + 3\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    x *= x;  \u003cspan class=\"hljs-comment\"\u003e// x = x * x\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eНаконец, имеются операторы \u003ccode\u003e++\u003c/code\u003e и \u003ccode\u003e--\u003c/code\u003e для увеличения или уменьшения переменной на единицу. Они бывают префиксные (\u003ccode\u003e++x\u003c/code\u003e) и постфиксные (\u003ccode\u003ex++\u003c/code\u003e). Отличие состоит в значении выражения, которое будет вычисляться при применении такого оператора. Мы рассмотрим это позже, а пока привыкнем по умолчанию использовать префиксный оператор для обычных чисел:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"int%20main()%20%7B%0A%20%20%20%20int%20x%20%3D%205%3B%0A%20%20%20%20%2B%2Bx%3B%20%20%2F%2F%206%0A%20%20%20%20--x%3B%20%20%2F%2F%20%D1%81%D0%BD%D0%BE%D0%B2%D0%B0%205%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e    ++x;  \u003cspan class=\"hljs-comment\"\u003e// 6\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e    --x;  \u003cspan class=\"hljs-comment\"\u003e// снова 5\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e5\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003ch2 id=\"chisla-s-plavayushej-tochkoj\"\u003eЧисла с плавающей точкой\u003c/h2\u003e\n\u003cp\u003eВ языке C++ существуют три встроенных типа для записи дробных чисел: \u003ccode\u003efloat\u003c/code\u003e (4 байта), \u003ccode\u003edouble\u003c/code\u003e (8 байт) и \u003ccode\u003elong double\u003c/code\u003e (16 или 8 байт, в зависимости от платформы). В большинстве случаев рекомендуется использовать тип \u003ccode\u003edouble\u003c/code\u003e.Тип \u003ccode\u003efloat\u003c/code\u003e разумно использовать там, где обрабатываются огромные массивы чисел, и возникает необходимость экономить память.\u003c/p\u003e\n\u003cp\u003eКак правило, хранение дробных чисел в С++ основано на стандарте \u003ca href=\"https://en.wikipedia.org/wiki/IEEE_754\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eIEEE 754\u003c/a\u003e. Число представляется в виде двоичной дроби в \u003ca href=\"https://en.wikipedia.org/wiki/Scientific_notation\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eэкспоненциальной записи\u003c/a\u003e: отдельно хранятся бит знака, порядок и \u003ca href=\"https://en.wikipedia.org/wiki/Significand\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eмантисса\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\u003cfigure class=\"fig-img\"\u003e\u003cimg class=\"img\" src=\"https://yastatic.net/s3/education-portal/media/C_2_5f62557ba8_ec6023e6f3.svg\" alt=\"C\" /\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eТакое представление выгодно отличается от чисел с фиксированной точкой, где хранится фиксированное количество разрядов. Оно позволяет, хотя и с разной степенью точности, представлять числа, отличающиеся на порядки.\u003c/p\u003e\n\u003cp\u003eПри работе с рациональными числами, знаменатель которых не является степенью двойки, неизбежно возникают погрешности представления. В следующем параграфе мы разберём как следует сравнивать такие числа.\u003c/p\u003e\n\u003ch2 id=\"avtomaticheskij-vyvod-tipa\"\u003eАвтоматический вывод типа\u003c/h2\u003e\n\u003cp\u003eКомпилятор C++ умеет автоматически выводить тип переменной по значению, которое ей присваивается. Для этого вместо типа надо написать ключевое слово \u003ccode\u003eauto\u003c/code\u003e:\u003c/p\u003e\n\n  \u003cdiv class=\"code-block\"\u003e\n    \u003cdiv class=\"code-block-header\" data-content-ignore=\"1\"\u003e\n      \u003cbutton class=\"copy-code-button\"\u003e\n        Скопировать код\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre class=\"pre-code-lines\" data-content=\"int%20main()%20%7B%0A%20%20%20%20auto%20x%20%3D%2042%3B%20%20%2F%2F%20int%0A%20%20%20%20auto%20pi%20%3D%203.14159%3B%20%20%2F%2F%20double%0A%7D%0A\" data-options=\"%7B%22langName%22%3A%22cpp%22%7D\"\u003e\u003ccode class=\"hljs cpp\"\u003e\u003cspan class=\"line-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n\u003cspan class=\"line-number\"\u003e2\u003c/span\u003e    \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// int\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e3\u003c/span\u003e    \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e pi = \u003cspan class=\"hljs-number\"\u003e3.14159\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// double\u003c/span\u003e\n\u003cspan class=\"line-number\"\u003e4\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\n  \u003c/div\u003e\n\u003cp\u003eКлючевое слово \u003ccode\u003eauto\u003c/code\u003e позволяет сократить код и не выписывать сложные типы (нам встретятся дальше монстры вроде \u003ccode\u003estd::unordered_multimap\u0026lt;Key, Value\u0026gt;::const_iterator\u003c/code\u003e). Важно подчеркнуть, что точный тип переменной всё равно становится известен в момент компиляции.\u003c/p\u003e\n\u003cp\u003eПри использовании \u003ccode\u003eauto\u003c/code\u003e со строками нужно быть осторожным. Важно знать, что конструкция \u003ccode\u003eauto s = \"hello\"\u003c/code\u003e выведет низкоуровневый тип \u003ccode\u003econst char *\u003c/code\u003e (указатель на неизменяемый набор символов в памяти), а не тип-обёртку \u003ccode\u003estd::string\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eТочные правила вывода типов похожи на правила вывода шаблонных параметров, с которыми мы познакомимся в \u003ca href=\"https://education.yandex.ru/handbook/cpp/article/templates\"\u003eпараграфе про шаблоны\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eВ следующем параграфе мы подробнее поговорим о ветвлении и циклах.\u003c/p\u003e\n"])</script><script nonce="">self.__next_f.push([1,"72:[\"$\",\"div\",null,{\"className\":\"styles_container__SBhDc\",\"children\":[[\"$\",\"$L73\",null,{\"targetEl\":\"#article-content\",\"offset\":60}],[\"$\",\"div\",null,{\"className\":\"styles_articleCover__EKYZn\",\"children\":[[\"$\",\"$L74\",null,{\"className\":\"styles_breadcrumbs__nMPkF\",\"items\":[{\"title\":\"Хендбуки\",\"href\":\"/handbook\",\"hardNavigate\":true},{\"title\":\"Основы С++\",\"href\":\"/handbook/cpp\",\"showMobile\":true},{\"title\":\"Типы данных\"}]}],null,[\"$\",\"h1\",null,{\"ref\":\"$undefined\",\"className\":\"styles_root__EmBCZ styles_title__Ae0WW\",\"style\":{},\"data-search-hidden\":true,\"children\":\"2.2 Типы данных\",\"data-variant\":\"heading\",\"data-weight\":\"medium\",\"data-color\":\"primary\"}],null]}],[\"$\",\"main\",null,{\"className\":\"styles_root__R5rVX\",\"data-testid\":\"ArticleContent-root\",\"data-ai-main-material\":true,\"children\":[null,[\"$\",\"div\",null,{\"className\":\"hljs_hljs-atelier-heath__2Efzm styles_content__jb6Og\",\"id\":\"article-content\",\"children\":[\"$\",\"$L75\",null,{\"Content\":\"$76\",\"csrfToken\":\"\",\"isNotesAvailable\":true,\"vars\":{},\"html\":\"$77\"}]}]]}],\"$L78\",\"$L79\",\"$L7a\",null,\"$L7b\"]}]\n"])</script><script nonce="">self.__next_f.push([1,"7c:I[78166,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"ArticleProgressConnected\"]\n7d:I[87289,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"ArticleActionConnected\"]\nfa:I[554,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"NavigationBlock\"]\nfb:I[30885,[\"1281\",\"static/chunks/1281-08bad9a3d2a60887.js\",\"5080\",\"static/chunks/5080-82f4daed94452227.js\",\"4194\",\"static/chunks/4194-172db2b948bd13ee.js\",\"5609\",\"static/chunks/5609-185e25579372eca4.js\",\"8619\",\"static/chunks/8619-3a701f3773450188.js\",\"9275\",\"static/chunks/9275-7c8f52465eb2613c.js\",\"9515\",\"static/chunks/9515-b7b857111af67561.js\",\"3121\",\"static/chunks/app/handbook/%5Bbook%5D/article/%5Barticle%5D/page-c867d0c23edc611e.js\"],\"HanbookCommunityBanner\"]\n78:[\"$\",\"$L7c\",null,{\"bookSlug\":\"cpp\",\"articleSlug\":\"data-types\",\"passportUrl\":\"https://passport.yandex.ru/auth/?origin=education\u0026retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandb"])</script><script nonce="">self.__next_f.push([1,"ook%2Fcpp%2Farticle%2Fdata-types\",\"csrfToken\":\"\",\"ErrorAction\":{\"id\":3760,\"Text\":\"Сообщить об ошибке\",\"URL\":\"https://forms.yandex.ru/surveys/academy/?proekt=handbooks\",\"Title\":\"Сообщить об ошибке\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":null,\"Description\":null,\"MetrikaGoalParams\":null},\"paragraphV2\":true,\"isAuthorized\":false}]\n"])</script><script nonce="">self.__next_f.push([1,"79:[\"$\",\"$L7d\",null,{\"contestURL\":\"https://new.contest.yandex.ru/42154/problem\",\"CTAs\":[],\"ErrorAction\":\"$78:props:ErrorAction\",\"questions\":[{\"question\":[\"$\",\"$L75\",null,{\"Content\":\"Что такое статическая типизация в языке C++?\",\"html\":\"\u003cp\u003eЧто такое статическая типизация в языке C++?\u003c/p\u003e\\n\"}],\"answers\":[{\"text\":[\"$\",\"$L75\",null,{\"Content\":\"Статическая типизация в C++ — это установление типа данных переменной на этапе компиляции.\",\"html\":\"\u003cp\u003eСтатическая типизация в C++ — это установление типа данных переменной на этапе компиляции.\u003c/p\u003e\\n\"}],\"generated_as_correct\":true},{\"text\":[\"$\",\"$L75\",null,{\"Content\":\"Статическая типизация в C++ позволяет изменять тип данных переменной во время выполнения программы, обеспечивая гибкость и динамичность.\",\"html\":\"\u003cp\u003eСтатическая типизация в C++ позволяет изменять тип данных переменной во время выполнения программы, обеспечивая гибкость и динамичность.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false},{\"text\":[\"$\",\"$L75\",null,{\"Content\":\"Статическая типизация в C++ связана с использованием статических методов и переменных в классах, что обеспечивает доступ к данным без создания экземпляра объекта.\",\"html\":\"\u003cp\u003eСтатическая типизация в C++ связана с использованием статических методов и переменных в классах, что обеспечивает доступ к данным без создания экземпляра объекта.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false},{\"text\":[\"$\",\"$L75\",null,{\"Content\":\"Статическая типизация в C++ позволяет определять тип данных переменной во время выполнения программы.\",\"html\":\"\u003cp\u003eСтатическая типизация в C++ позволяет определять тип данных переменной во время выполнения программы.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false}]},{\"question\":[\"$\",\"$L75\",null,{\"Content\":\"Почему в C++ важно устанавливать тип данных переменной на этапе компиляции?\",\"html\":\"\u003cp\u003eПочему в C++ важно устанавливать тип данных переменной на этапе компиляции?\u003c/p\u003e\\n\"}],\"answers\":[{\"text\":[\"$\",\"$L75\",null,{\"Content\":\"В C++ установка типа данных на этапе компиляции обеспечивает контроль типов и предотвращает ошибки при выполнении программы.\",\"html\":\"\u003cp\u003eВ C++ установка типа данных на этапе компиляции обеспечивает контроль типов и предотвращает ошибки при выполнении программы.\u003c/p\u003e\\n\"}],\"generated_as_correct\":true},{\"text\":[\"$\",\"$L75\",null,{\"Content\":\"В C++ установка типа данных переменной на этапе компиляции нужна для того, чтобы программа могла автоматически преобразовывать типы данных в зависимости от контекста их использования.\",\"html\":\"\u003cp\u003eВ C++ установка типа данных переменной на этапе компиляции нужна для того, чтобы программа могла автоматически преобразовывать типы данных в зависимости от контекста их использования.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false},{\"text\":[\"$\",\"$L75\",null,{\"Content\":\"В C++ установление типа данных переменной на этапе компиляции связано с управлением памятью и оптимизацией ресурсов, что не влияет на предотвращение ошибок во время выполнения программы.\",\"html\":\"\u003cp\u003eВ C++ установление типа данных переменной на этапе компиляции связано с управлением памятью и оптимизацией ресурсов, что не влияет на предотвращение ошибок во время выполнения программы.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false},{\"text\":[\"$\",\"$L75\",null,{\"Content\":\"В C++ установка типа данных переменной на этапе компиляции позволяет программе изменять типы данных во время выполнения.\",\"html\":\"\u003cp\u003eВ C++ установка типа данных переменной на этапе компиляции позволяет программе изменять типы данных во время выполнения.\u003c/p\u003e\\n\"}],\"generated_as_correct\":false}]},{\"question\":[\"$\",\"$L75\",null,{\"Content\":\"Как статическая типизация помогает предотвратить ошибки во время выполнения программы в C++?\",\"html\":\"\u003cp\u003eКак статическая типизация помогает предотвратить ошибки во время выполнения программы в C++?\u003c/p\u003e\\n\"}],\"answers\":[{\"text\":\"$L7e\",\"generated_as_correct\":true},{\"text\":\"$L7f\",\"generated_as_correct\":false},{\"text\":\"$L80\",\"generated_as_correct\":false},{\"text\":\"$L81\",\"generated_as_correct\":false}]},{\"question\":\"$L82\",\"answers\":[{\"text\":\"$L83\",\"generated_as_correct\":true},{\"text\":\"$L84\",\"generated_as_correct\":false},{\"text\":\"$L85\",\"generated_as_correct\":false},{\"text\":\"$L86\",\"generated_as_correct\":false}]},{\"question\":\"$L87\",\"answers\":[{\"text\":\"$L88\",\"generated_as_correct\":true},{\"text\":\"$L89\",\"generated_as_correct\":false},{\"text\":\"$L8a\",\"generated_as_correct\":false},{\"text\":\"$L8b\",\"generated_as_correct\":false}]},{\"question\":\"$L8c\",\"answers\":[{\"text\":\"$L8d\",\"generated_as_correct\":true},{\"text\":\"$L8e\",\"generated_as_correct\":false},{\"text\":\"$L8f\",\"generated_as_correct\":false},{\"text\":\"$L90\",\"generated_as_correct\":false}]},{\"question\":\"$L91\",\"answers\":[{\"text\":\"$L92\",\"generated_as_correct\":true},{\"text\":\"$L93\",\"generated_as_correct\":false},{\"text\":\"$L94\",\"generated_as_correct\":false},{\"text\":\"$L95\",\"generated_as_correct\":false}]},{\"question\":\"$L96\",\"answers\":[{\"text\":\"$L97\",\"generated_as_correct\":true},{\"text\":\"$L98\",\"generated_as_correct\":false},{\"text\":\"$L99\",\"generated_as_correct\":false},{\"text\":\"$L9a\",\"generated_as_correct\":false}]},{\"question\":\"$L9b\",\"answers\":[{\"text\":\"$L9c\",\"generated_as_correct\":true},{\"text\":\"$L9d\",\"generated_as_correct\":false},{\"text\":\"$L9e\",\"generated_as_correct\":false},{\"text\":\"$L9f\",\"generated_as_correct\":false}]},{\"question\":\"$La0\",\"answers\":[{\"text\":\"$La1\",\"generated_as_correct\":true},{\"text\":\"$La2\",\"generated_as_correct\":false},{\"text\":\"$La3\",\"generated_as_correct\":false},{\"text\":\"$La4\",\"generated_as_correct\":false}]},{\"question\":\"$La5\",\"answers\":[{\"text\":\"$La6\",\"generated_as_correct\":true},{\"text\":\"$La7\",\"generated_as_correct\":false},{\"text\":\"$La8\",\"generated_as_correct\":false},{\"text\":\"$La9\",\"generated_as_correct\":false}]},{\"question\":\"$Laa\",\"answers\":[{\"text\":\"$Lab\",\"generated_as_correct\":true},{\"text\":\"$Lac\",\"generated_as_correct\":false},{\"text\":\"$Lad\",\"generated_as_correct\":false},{\"text\":\"$Lae\",\"generated_as_correct\":false}]},{\"question\":\"$Laf\",\"answers\":[{\"text\":\"$Lb0\",\"generated_as_correct\":true},{\"text\":\"$Lb1\",\"generated_as_correct\":false},{\"text\":\"$Lb2\",\"generated_as_correct\":false},{\"text\":\"$Lb3\",\"generated_as_correct\":false}]},{\"question\":\"$Lb4\",\"answers\":[{\"text\":\"$Lb5\",\"generated_as_correct\":true},{\"text\":\"$Lb6\",\"generated_as_correct\":false},{\"text\":\"$Lb7\",\"generated_as_correct\":false},{\"text\":\"$Lb8\",\"generated_as_correct\":false}]},{\"question\":\"$Lb9\",\"answers\":[{\"text\":\"$Lba\",\"generated_as_correct\":true},{\"text\":\"$Lbb\",\"generated_as_correct\":false},{\"text\":\"$Lbc\",\"generated_as_correct\":false},{\"text\":\"$Lbd\",\"generated_as_correct\":false}]},{\"question\":\"$Lbe\",\"answers\":[{\"text\":\"$Lbf\",\"generated_as_correct\":true},{\"text\":\"$Lc0\",\"generated_as_correct\":false},{\"text\":\"$Lc1\",\"generated_as_correct\":false},{\"text\":\"$Lc2\",\"generated_as_correct\":false}]},{\"question\":\"$Lc3\",\"answers\":[{\"text\":\"$Lc4\",\"generated_as_correct\":true},{\"text\":\"$Lc5\",\"generated_as_correct\":false},{\"text\":\"$Lc6\",\"generated_as_correct\":false},{\"text\":\"$Lc7\",\"generated_as_correct\":false}]},{\"question\":\"$Lc8\",\"answers\":[{\"text\":\"$Lc9\",\"generated_as_correct\":true},{\"text\":\"$Lca\",\"generated_as_correct\":false},{\"text\":\"$Lcb\",\"generated_as_correct\":false},{\"text\":\"$Lcc\",\"generated_as_correct\":false}]},{\"question\":\"$Lcd\",\"answers\":[{\"text\":\"$Lce\",\"generated_as_correct\":true},{\"text\":\"$Lcf\",\"generated_as_correct\":false},{\"text\":\"$Ld0\",\"generated_as_correct\":false},{\"text\":\"$Ld1\",\"generated_as_correct\":false}]},{\"question\":\"$Ld2\",\"answers\":[{\"text\":\"$Ld3\",\"generated_as_correct\":true},{\"text\":\"$Ld4\",\"generated_as_correct\":false},{\"text\":\"$Ld5\",\"generated_as_correct\":false},{\"text\":\"$Ld6\",\"generated_as_correct\":false}]},{\"question\":\"$Ld7\",\"answers\":[{\"text\":\"$Ld8\",\"generated_as_correct\":true},{\"text\":\"$Ld9\",\"generated_as_correct\":false},{\"text\":\"$Lda\",\"generated_as_correct\":false},{\"text\":\"$Ldb\",\"generated_as_correct\":false}]},{\"question\":\"$Ldc\",\"answers\":[{\"text\":\"$Ldd\",\"generated_as_correct\":true},{\"text\":\"$Lde\",\"generated_as_correct\":false},{\"text\":\"$Ldf\",\"generated_as_correct\":false},{\"text\":\"$Le0\",\"generated_as_correct\":false}]},{\"question\":\"$Le1\",\"answers\":[{\"text\":\"$Le2\",\"generated_as_correct\":true},{\"text\":\"$Le3\",\"generated_as_correct\":false},{\"text\":\"$Le4\",\"generated_as_correct\":false},{\"text\":\"$Le5\",\"generated_as_correct\":false}]},{\"question\":\"$Le6\",\"answers\":[{\"text\":\"$Le7\",\"generated_as_correct\":true},{\"text\":\"$Le8\",\"generated_as_correct\":false},{\"text\":\"$Le9\",\"generated_as_correct\":false},{\"text\":\"$Lea\",\"generated_as_correct\":false}]},{\"question\":\"$Leb\",\"answers\":[{\"text\":\"$Lec\",\"generated_as_correct\":true},{\"text\":\"$Led\",\"generated_as_correct\":false},{\"text\":\"$Lee\",\"generated_as_correct\":false},{\"text\":\"$Lef\",\"generated_as_correct\":false}]},{\"question\":\"$Lf0\",\"answers\":[{\"text\":\"$Lf1\",\"generated_as_correct\":true},{\"text\":\"$Lf2\",\"generated_as_correct\":false},{\"text\":\"$Lf3\",\"generated_as_correct\":false},{\"text\":\"$Lf4\",\"generated_as_correct\":false}]},{\"question\":\"$Lf5\",\"answers\":[{\"text\":\"$Lf6\",\"generated_as_correct\":true},{\"text\":\"$Lf7\",\"generated_as_correct\":false},{\"text\":\"$Lf8\",\"generated_as_correct\":false},{\"text\":\"$Lf9\",\"generated_as_correct\":false}]}],\"passportUrl\":\"https://passport.yandex.ru/auth/?origin=education\u0026retpath=https%3A%2F%2Feducation.yandex.ru%2Fhandbook%2Fcpp%2Farticle%2Fdata-types\",\"isAuthorized\":false,\"csrfToken\":\"\",\"paragraphV2\":true}]\n"])</script><script nonce="">self.__next_f.push([1,"7a:[\"$\",\"div\",null,{\"className\":\"styles_article-navigate__SKki7\",\"data-testid\":\"ArticleNavigate-root\",\"children\":[[\"$\",\"$Lfa\",\"first-steps\",{\"label\":\"Предыдущий параграф\",\"title\":\"2.1. Первые шаги\",\"lead\":\"В\u0026nbsp;этом параграфе мы\u0026nbsp;напишем первую программу на\u0026nbsp;C\\\\+\\\\+ и\u0026nbsp;научимся печатать и\u0026nbsp;считывать с\u0026nbsp;клавиатуры строки и\u0026nbsp;числа.\",\"url\":\"./first-steps\",\"direction\":\"back\"}],[\"$\",\"$Lfa\",\"branches-and-loops\",{\"label\":\"Следующий параграф\",\"title\":\"2.3. Ветвления и циклы\",\"lead\":\"В\u0026nbsp;этом параграфе мы\u0026nbsp;познакомимся с\u0026nbsp;операторами ветвления if\u0026nbsp;и\u0026nbsp;switch, циклами while, do-while и\u0026nbsp;for, а\u0026nbsp;также с\u0026nbsp;оператором goto.\",\"url\":\"./branches-and-loops\",\"direction\":\"forward\"}]]}]\n"])</script><script nonce="">self.__next_f.push([1,"7b:[\"$\",\"$Lfb\",null,{\"banner\":{\"id\":108,\"Title\":\"Вступайте в\u0026nbsp;сообщество хендбука\",\"Description\":\"Здесь можно найти единомышленников, экспертов и\u0026nbsp;просто интересных собеседников. А\u0026nbsp;ещё\u0026nbsp;— получить помощь или поделиться знаниями.\",\"ActionType\":null,\"Icon\":{\"data\":{\"id\":16699,\"attributes\":{\"name\":\"Poluchajte\",\"alternativeText\":null,\"caption\":null,\"width\":237,\"height\":124,\"formats\":null,\"hash\":\"Poluchajte_obnovleniya_ot_obrazovaniya_30910b54df_61ea47b298\",\"ext\":\".svg\",\"mime\":\"image/svg+xml\",\"size\":33.89,\"url\":\"https://yastatic.net/s3/education-portal/media/Poluchajte_obnovleniya_ot_obrazovaniya_30910b54df_61ea47b298.svg\",\"previewUrl\":null,\"provider\":\"strapi-plugin-yandexify\",\"provider_metadata\":null,\"createdAt\":\"2025-09-02T08:53:15.484Z\",\"updatedAt\":\"2025-12-23T22:37:04.357Z\"}}},\"Action\":{\"id\":5540,\"Text\":\"Вступить\",\"URL\":\"https://t.me/handbook_cpp\",\"Title\":\"Вступить\",\"MetrikaCounter\":null,\"MetrikaGoalId\":null,\"IsExternal\":true,\"Variant\":\"primary\",\"IsDisabled\":false,\"HardNavigate\":false,\"Description\":null,\"MetrikaGoalParams\":null}},\"referer\":null}]\n"])</script><script nonce="">self.__next_f.push([1,"7e:[\"$\",\"$L75\",null,{\"Content\":\"Статическая типизация в C++ устанавливает типы данных переменных на этапе компиляции, что помогает предотвратить ошибки во время выполнения программы.\",\"html\":\"\u003cp\u003eСтатическая типизация в C++ устанавливает типы данных переменных на этапе компиляции, что помогает предотвратить ошибки во время выполнения программы.\u003c/p\u003e\\n\"}]\n7f:[\"$\",\"$L75\",null,{\"Content\":\"Статическая типизация в C++ обеспечивает автоматическое преобразование типов данных во время выполнения программы, что предотвращает возможные ошибки, связанные с несовместимостью типов.\",\"html\":\"\u003cp\u003eСтатическая типизация в C++ обеспечивает автоматическое преобразование типов данных во время выполнения программы, что предотвращает возможные ошибки, связанные с несовместимостью типов.\u003c/p\u003e\\n\"}]\n80:[\"$\",\"$L75\",null,{\"Content\":\"Статическая типизация в C++ используется для определения области видимости переменных и управления доступом к ним, что помогает предотвратить ошибки, связанные с неправильным использованием переменных.\",\"html\":\"\u003cp\u003eСтатическая типизация в C++ используется для определения области видимости переменных и управления доступом к ним, что помогает предотвратить ошибки"])</script><script nonce="">self.__next_f.push([1,", связанные с неправильным использованием переменных.\u003c/p\u003e\\n\"}]\n81:[\"$\",\"$L75\",null,{\"Content\":\"Статическая типизация в C++ определяет типы данных переменных во время выполнения программы, что помогает предотвратить ошибки на этапе компиляции.\",\"html\":\"\u003cp\u003eСтатическая типизация в C++ определяет типы данных переменных во время выполнения программы, что помогает предотвратить ошибки на этапе компиляции.\u003c/p\u003e\\n\"}]\n82:[\"$\",\"$L75\",null,{\"Content\":\"Что такое область видимости переменной в C++?\",\"html\":\"\u003cp\u003eЧто такое область видимости переменной в C++?\u003c/p\u003e\\n\"}]\n83:[\"$\",\"$L75\",null,{\"Content\":\"Область видимости переменной в C++ — это блок кода, где переменная доступна.\",\"html\":\"\u003cp\u003eОбласть видимости переменной в C++ — это блок кода, где переменная доступна.\u003c/p\u003e\\n\"}]\n84:[\"$\",\"$L75\",null,{\"Content\":\"Область видимости переменной в C++ определяется как набор функций, в которых переменная может быть использована, независимо от их расположения в коде.\",\"html\":\"\u003cp\u003eОбласть видимости переменной в C++ определяется как набор функций, в которых переменная может быть использована, независимо от их расположения в коде.\u003c/p\u003e\\n\"}]\n85:[\"$\",\"$L75\",null,{\"Content\":\"Область видимости переменной в C++ связана с типами данных, которые могут быть присвоены п"])</script><script nonce="">self.__next_f.push([1,"еременной в процессе выполнения программы.\",\"html\":\"\u003cp\u003eОбласть видимости переменной в C++ связана с типами данных, которые могут быть присвоены переменной в процессе выполнения программы.\u003c/p\u003e\\n\"}]\n86:[\"$\",\"$L75\",null,{\"Content\":\"Область видимости переменной в C++ — это вся программа, где переменная может быть использована.\",\"html\":\"\u003cp\u003eОбласть видимости переменной в C++ — это вся программа, где переменная может быть использована.\u003c/p\u003e\\n\"}]\n87:[\"$\",\"$L75\",null,{\"Content\":\"Почему понимание областей видимости важно при программировании на C++?\",\"html\":\"\u003cp\u003eПочему понимание областей видимости важно при программировании на C++?\u003c/p\u003e\\n\"}]\n88:[\"$\",\"$L75\",null,{\"Content\":\"Понимание областей видимости помогает управлять доступом к переменным и избегать конфликтов имён.\",\"html\":\"\u003cp\u003eПонимание областей видимости помогает управлять доступом к переменным и избегать конфликтов имён.\u003c/p\u003e\\n\"}]\n89:[\"$\",\"$L75\",null,{\"Content\":\"Понимание областей видимости важно, потому что оно определяет, какие переменные могут быть использованы в любой части программы без ограничений.\",\"html\":\"\u003cp\u003eПонимание областей видимости важно, потому что оно определяет, какие переменные могут быть использованы в любой части программы без ограниче"])</script><script nonce="">self.__next_f.push([1,"ний.\u003c/p\u003e\\n\"}]\n8a:[\"$\",\"$L75\",null,{\"Content\":\"Понимание областей видимости важно для оптимизации производительности программы, так как оно влияет на распределение памяти и скорость выполнения кода.\",\"html\":\"\u003cp\u003eПонимание областей видимости важно для оптимизации производительности программы, так как оно влияет на распределение памяти и скорость выполнения кода.\u003c/p\u003e\\n\"}]\n8b:[\"$\",\"$L75\",null,{\"Content\":\"Понимание областей видимости не нужно, так как все переменные доступны глобально.\",\"html\":\"\u003cp\u003eПонимание областей видимости не нужно, так как все переменные доступны глобально.\u003c/p\u003e\\n\"}]\n8c:[\"$\",\"$L75\",null,{\"Content\":\"Как область видимости влияет на доступ к переменным в разных блоках кода в C++?\",\"html\":\"\u003cp\u003eКак область видимости влияет на доступ к переменным в разных блоках кода в C++?\u003c/p\u003e\\n\"}]\n8d:[\"$\",\"$L75\",null,{\"Content\":\"Область видимости в C++ ограничивает доступ к переменным пределами блока, в котором они определены.\",\"html\":\"\u003cp\u003eОбласть видимости в C++ ограничивает доступ к переменным пределами блока, в котором они определены.\u003c/p\u003e\\n\"}]\n8e:[\"$\",\"$L75\",null,{\"Content\":\"Область видимости в C++ не влияет на доступ к переменным, и все переменные доступны из любого места в программе независимо от их определения.\",\"html\":\"\u003cp\u003eОб"])</script><script nonce="">self.__next_f.push([1,"ласть видимости в C++ не влияет на доступ к переменным, и все переменные доступны из любого места в программе независимо от их определения.\u003c/p\u003e\\n\"}]\n8f:[\"$\",\"$L75\",null,{\"Content\":\"Область видимости в C++ связана с типами данных и определяет, какие операции можно выполнять с переменными в разных блоках кода.\",\"html\":\"\u003cp\u003eОбласть видимости в C++ связана с типами данных и определяет, какие операции можно выполнять с переменными в разных блоках кода.\u003c/p\u003e\\n\"}]\n90:[\"$\",\"$L75\",null,{\"Content\":\"Область видимости в C++ позволяет доступ к переменным из любых блоков кода без ограничений.\",\"html\":\"\u003cp\u003eОбласть видимости в C++ позволяет доступ к переменным из любых блоков кода без ограничений.\u003c/p\u003e\\n\"}]\n91:[\"$\",\"$L75\",null,{\"Content\":\"Что происходит с локальными переменными простых типов в C++ при их объявлении, если они не инициализированы явно?\",\"html\":\"\u003cp\u003eЧто происходит с локальными переменными простых типов в C++ при их объявлении, если они не инициализированы явно?\u003c/p\u003e\\n\"}]\n92:[\"$\",\"$L75\",null,{\"Content\":\"Локальные переменные простых типов в C++ не инициализируются по умолчанию и могут содержать неопределённые значения.\",\"html\":\"\u003cp\u003eЛокальные переменные простых типов в C++ не инициализируются по умолчанию и могут содер"])</script><script nonce="">self.__next_f.push([1,"жать неопределённые значения.\u003c/p\u003e\\n\"}]\n93:[\"$\",\"$L75\",null,{\"Content\":\"Локальные переменные простых типов в C++ инициализируются случайными значениями из диапазона допустимых для этого типа данных при их объявлении без явной инициализации.\",\"html\":\"\u003cp\u003eЛокальные переменные простых типов в C++ инициализируются случайными значениями из диапазона допустимых для этого типа данных при их объявлении без явной инициализации.\u003c/p\u003e\\n\"}]\n94:[\"$\",\"$L75\",null,{\"Content\":\"Локальные переменные сложных типов в C++ всегда инициализируются значениями по умолчанию, в отличие от переменных простых типов.\",\"html\":\"\u003cp\u003eЛокальные переменные сложных типов в C++ всегда инициализируются значениями по умолчанию, в отличие от переменных простых типов.\u003c/p\u003e\\n\"}]\n95:[\"$\",\"$L75\",null,{\"Content\":\"Локальные переменные простых типов в C++ всегда инициализируются значением 0 при объявлении.\",\"html\":\"\u003cp\u003eЛокальные переменные простых типов в C++ всегда инициализируются значением 0 при объявлении.\u003c/p\u003e\\n\"}]\n96:[\"$\",\"$L75\",null,{\"Content\":\"Почему в C++ локальные переменные простых типов не инициализируются по умолчанию?\",\"html\":\"\u003cp\u003eПочему в C++ локальные переменные простых типов не инициализируются по умолчанию?\u003c/p\u003e\\n\"}]\n97:[\"$\",\"$L75\",null,{\"Content\":\"В C++ "])</script><script nonce="">self.__next_f.push([1,"локальные переменные простых типов не инициализируются по умолчанию для оптимизации.\",\"html\":\"\u003cp\u003eВ C++ локальные переменные простых типов не инициализируются по умолчанию для оптимизации.\u003c/p\u003e\\n\"}]\n98:[\"$\",\"$L75\",null,{\"Content\":\"В C++ локальные переменные простых типов автоматически инициализируются значениями, зависящими от типа переменной, что предотвращает ошибки при их использовании.\",\"html\":\"\u003cp\u003eВ C++ локальные переменные простых типов автоматически инициализируются значениями, зависящими от типа переменной, что предотвращает ошибки при их использовании.\u003c/p\u003e\\n\"}]\n99:[\"$\",\"$L75\",null,{\"Content\":\"В C++ локальные переменные простых типов могут быть объявлены с использованием ключевых слов, которые определяют их область видимости и время жизни.\",\"html\":\"\u003cp\u003eВ C++ локальные переменные простых типов могут быть объявлены с использованием ключевых слов, которые определяют их область видимости и время жизни.\u003c/p\u003e\\n\"}]\n9a:[\"$\",\"$L75\",null,{\"Content\":\"В C++ локальные переменные простых типов всегда инициализируются значением 0.\",\"html\":\"\u003cp\u003eВ C++ локальные переменные простых типов всегда инициализируются значением 0.\u003c/p\u003e\\n\"}]\n9b:[\"$\",\"$L75\",null,{\"Content\":\"Какие проблемы могут возникнуть при использова"])</script><script nonce="">self.__next_f.push([1,"нии локальных переменных простых типов в C++, если они не были инициализированы?\",\"html\":\"\u003cp\u003eКакие проблемы могут возникнуть при использовании локальных переменных простых типов в C++, если они не были инициализированы?\u003c/p\u003e\\n\"}]\n9c:[\"$\",\"$L75\",null,{\"Content\":\"Локальные переменные простых типов в C++ не инициализируются по умолчанию, что может вызвать неопределённое поведение.\",\"html\":\"\u003cp\u003eЛокальные переменные простых типов в C++ не инициализируются по умолчанию, что может вызвать неопределённое поведение.\u003c/p\u003e\\n\"}]\n9d:[\"$\",\"$L75\",null,{\"Content\":\"Локальные переменные простых типов в C++ автоматически инициализируются значением -1, что может вызвать неожиданные результаты при арифметических операциях.\",\"html\":\"\u003cp\u003eЛокальные переменные простых типов в C++ автоматически инициализируются значением -1, что может вызвать неожиданные результаты при арифметических операциях.\u003c/p\u003e\\n\"}]\n9e:[\"$\",\"$L75\",null,{\"Content\":\"Локальные переменные в C++ могут быть объявлены как константы, и это влияет на их область видимости и время жизни в программе.\",\"html\":\"\u003cp\u003eЛокальные переменные в C++ могут быть объявлены как константы, и это влияет на их область видимости и время жизни в программе.\u003c/p\u003e\\n\"}]\n9f:[\"$\",\"$L75\",null,{"])</script><script nonce="">self.__next_f.push([1,"\"Content\":\"Локальные переменные простых типов в C++ всегда инициализируются нулевым значением.\",\"html\":\"\u003cp\u003eЛокальные переменные простых типов в C++ всегда инициализируются нулевым значением.\u003c/p\u003e\\n\"}]\na0:[\"$\",\"$L75\",null,{\"Content\":\"Какие фундаментальные типы данных существуют в C++ и какие из них относятся к интегральным, а какие — к типам для вещественных чисел?\",\"html\":\"\u003cp\u003eКакие фундаментальные типы данных существуют в C++ и какие из них относятся к интегральным, а какие — к типам для вещественных чисел?\u003c/p\u003e\\n\"}]\na1:[\"$\",\"$L75\",null,{\"Content\":\"В C++ есть интегральные типы (int, short int, long int) и типы для вещественных чисел (float, double, long double).\",\"html\":\"\u003cp\u003eВ C++ есть интегральные типы (int, short int, long int) и типы для вещественных чисел (float, double, long double).\u003c/p\u003e\\n\"}]\na2:[\"$\",\"$L75\",null,{\"Content\":\"В C++ фундаментальные типы данных включают логические типы (int, short int, long int) и строковые типы (float, double, long double).\",\"html\":\"\u003cp\u003eВ C++ фундаментальные типы данных включают логические типы (int, short int, long int) и строковые типы (float, double, long double).\u003c/p\u003e\\n\"}]\na3:[\"$\",\"$L75\",null,{\"Content\":\"В C++ типы данных классифицируются по их применению в алгоритмах и структурах данных, например, массивы и списки.\",\"html\":\"\u003cp\u003eВ C++ типы данных классифицируются по их применению в алг"])</script><script nonce="">self.__next_f.push([1,"оритмах и структурах данных, например, массивы и списки.\u003c/p\u003e\\n\"}]\na4:[\"$\",\"$L75\",null,{\"Content\":\"В C++ все типы данных являются интегральными, включая float и double.\",\"html\":\"\u003cp\u003eВ C++ все типы данных являются интегральными, включая float и double.\u003c/p\u003e\\n\"}]\na5:[\"$\",\"$L75\",null,{\"Content\":\"Почему важно знать размеры и диапазоны значений фундаментальных типов данных в C++?\",\"html\":\"\u003cp\u003eПочему важно знать размеры и диапазоны значений фундаментальных типов данных в C++?\u003c/p\u003e\\n\"}]\na6:[\"$\",\"$L75\",null,{\"Content\":\"Знание размеров и диапазонов фундаментальных типов данных в C++ помогает избежать ошибок при работе с данными.\",\"html\":\"\u003cp\u003eЗнание размеров и диапазонов фундаментальных типов данных в C++ помогает избежать ошибок при работе с данными.\u003c/p\u003e\\n\"}]\na7:[\"$\",\"$L75\",null,{\"Content\":\"Знание размеров и диапазонов значений фундаментальных типов данных в C++ нужно только для теоретических целей и не влияет на практическую реализацию программ.\",\"html\":\"\u003cp\u003eЗнание размеров и диапазонов значений фундаментальных типов данных в C++ нужно только для теоретических целей и не влияет на практическую реализацию программ.\u003c/p\u003e\\n\"}]\na8:[\"$\",\"$L75\",null,{\"Content\":\"Знание размеров и диапазонов значений фундаментальных типов данных в C++ полезно для оптимизац"])</script><script nonce="">self.__next_f.push([1,"ии алгоритмов сортировки и поиска в больших массивах данных.\",\"html\":\"\u003cp\u003eЗнание размеров и диапазонов значений фундаментальных типов данных в C++ полезно для оптимизации алгоритмов сортировки и поиска в больших массивах данных.\u003c/p\u003e\\n\"}]\na9:[\"$\",\"$L75\",null,{\"Content\":\"Знание размеров и диапазонов фундаментальных типов данных в C++ необходимо только для работы с библиотеками и внешними модулями.\",\"html\":\"\u003cp\u003eЗнание размеров и диапазонов фундаментальных типов данных в C++ необходимо только для работы с библиотеками и внешними модулями.\u003c/p\u003e\\n\"}]\naa:[\"$\",\"$L75\",null,{\"Content\":\"Как знание о различных фундаментальных типах данных может помочь при написании программ на C++?\",\"html\":\"\u003cp\u003eКак знание о различных фундаментальных типах данных может помочь при написании программ на C++?\u003c/p\u003e\\n\"}]\nab:[\"$\",\"$L75\",null,{\"Content\":\"Знание типов данных в C++ помогает правильно выбирать их для переменных, учитывая размер и диапазон значений.\",\"html\":\"\u003cp\u003eЗнание типов данных в C++ помогает правильно выбирать их для переменных, учитывая размер и диапазон значений.\u003c/p\u003e\\n\"}]\nac:[\"$\",\"$L75\",null,{\"Content\":\"Знание о различных фундаментальных типах данных в C++ помогает программистам выбирать типы данных на основе их цвета в ин"])</script><script nonce="">self.__next_f.push([1,"тегрированной среде разработки, что улучшает читаемость кода.\",\"html\":\"\u003cp\u003eЗнание о различных фундаментальных типах данных в C++ помогает программистам выбирать типы данных на основе их цвета в интегрированной среде разработки, что улучшает читаемость кода.\u003c/p\u003e\\n\"}]\nad:[\"$\",\"$L75\",null,{\"Content\":\"Знание о различных фундаментальных типах данных в C++ полезно для понимания принципов объектно-ориентированного программирования и наследования классов.\",\"html\":\"\u003cp\u003eЗнание о различных фундаментальных типах данных в C++ полезно для понимания принципов объектно-ориентированного программирования и наследования классов.\u003c/p\u003e\\n\"}]\nae:[\"$\",\"$L75\",null,{\"Content\":\"Знание типов данных в C++ нужно только для того, чтобы соблюдать синтаксис языка и не имеет значения для работы программы.\",\"html\":\"\u003cp\u003eЗнание типов данных в C++ нужно только для того, чтобы соблюдать синтаксис языка и не имеет значения для работы программы.\u003c/p\u003e\\n\"}]\naf:[\"$\",\"$L75\",null,{\"Content\":\"Что позволяет узнать оператор sizeof в C++?\",\"html\":\"\u003cp\u003eЧто позволяет узнать оператор sizeof в C++?\u003c/p\u003e\\n\"}]\nb0:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ показывает размер переменной или типа данных в байтах.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ показывает размер переменной и"])</script><script nonce="">self.__next_f.push([1,"ли типа данных в байтах.\u003c/p\u003e\\n\"}]\nb1:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ служит для вычисления количества элементов в массиве или контейнере во время выполнения программы.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ служит для вычисления количества элементов в массиве или контейнере во время выполнения программы.\u003c/p\u003e\\n\"}]\nb2:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ применяется для определения типа данных переменной во время компиляции.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ применяется для определения типа данных переменной во время компиляции.\u003c/p\u003e\\n\"}]\nb3:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ определяет минимальное значение переменной или типа данных.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ определяет минимальное значение переменной или типа данных.\u003c/p\u003e\\n\"}]\nb4:[\"$\",\"$L75\",null,{\"Content\":\"Почему важно использовать оператор sizeof при работе с типами данных в C++?\",\"html\":\"\u003cp\u003eПочему важно использовать оператор sizeof при работе с типами данных в C++?\u003c/p\u003e\\n\"}]\nb5:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ определяет размер типа данных или переменной в байтах.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ определяет размер типа данных или переменной в байтах.\u003c/p\u003e\\n\"}]\nb6:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ служит для определения максимального значения, кото"])</script><script nonce="">self.__next_f.push([1,"рое может хранить переменная данного типа.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ служит для определения максимального значения, которое может хранить переменная данного типа.\u003c/p\u003e\\n\"}]\nb7:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ связан с управлением памятью и используется для выделения динамической памяти под переменные.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ связан с управлением памятью и используется для выделения динамической памяти под переменные.\u003c/p\u003e\\n\"}]\nb8:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ используется для определения типа данных переменной.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ используется для определения типа данных переменной.\u003c/p\u003e\\n\"}]\nb9:[\"$\",\"$L75\",null,{\"Content\":\"Как можно применить оператор sizeof для определения размера переменной в байтах?\",\"html\":\"\u003cp\u003eКак можно применить оператор sizeof для определения размера переменной в байтах?\u003c/p\u003e\\n\"}]\nba:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ определяет размер переменной или типа данных в байтах.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ определяет размер переменной или типа данных в байтах.\u003c/p\u003e\\n\"}]\nbb:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ позволяет определить размер переменной в килобайтах, что полезно при работе с большими объёмами данных.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ позв"])</script><script nonce="">self.__next_f.push([1,"оляет определить размер переменной в килобайтах, что полезно при работе с большими объёмами данных.\u003c/p\u003e\\n\"}]\nbc:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof используется в C++ для объявления новых типов данных и не связан с определением их размера в байтах.\",\"html\":\"\u003cp\u003eОператор sizeof используется в C++ для объявления новых типов данных и не связан с определением их размера в байтах.\u003c/p\u003e\\n\"}]\nbd:[\"$\",\"$L75\",null,{\"Content\":\"Оператор sizeof в C++ используется для подсчёта количества элементов в массиве.\",\"html\":\"\u003cp\u003eОператор sizeof в C++ используется для подсчёта количества элементов в массиве.\u003c/p\u003e\\n\"}]\nbe:[\"$\",\"$L75\",null,{\"Content\":\"Что такое переполнение в контексте целочисленных типов данных?\",\"html\":\"\u003cp\u003eЧто такое переполнение в контексте целочисленных типов данных?\u003c/p\u003e\\n\"}]\nbf:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение — это состояние, когда результат операции не помещается в тип данных.\",\"html\":\"\u003cp\u003eПереполнение — это состояние, когда результат операции не помещается в тип данных.\u003c/p\u003e\\n\"}]\nc0:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение — это процесс, при котором данные автоматически преобразуются в более крупный тип данных для хранения большего объёма информации.\",\"html\":\"\u003cp\u003eПереполнение — это процесс, при котором данные автоматич"])</script><script nonce="">self.__next_f.push([1,"ески преобразуются в более крупный тип данных для хранения большего объёма информации.\u003c/p\u003e\\n\"}]\nc1:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение относится к ситуации, когда количество элементов в массиве превышает его заданный размер, что требует перераспределения памяти.\",\"html\":\"\u003cp\u003eПереполнение относится к ситуации, когда количество элементов в массиве превышает его заданный размер, что требует перераспределения памяти.\u003c/p\u003e\\n\"}]\nc2:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение — это механизм, позволяющий автоматически увеличивать размер типа данных при необходимости.\",\"html\":\"\u003cp\u003eПереполнение — это механизм, позволяющий автоматически увеличивать размер типа данных при необходимости.\u003c/p\u003e\\n\"}]\nc3:[\"$\",\"$L75\",null,{\"Content\":\"Чем отличается поведение при переполнении для знаковых и беззнаковых типов данных?\",\"html\":\"\u003cp\u003eЧем отличается поведение при переполнении для знаковых и беззнаковых типов данных?\u003c/p\u003e\\n\"}]\nc4:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение знаковых типов может вызвать неопределённое поведение, а беззнаковых — вычисления по модулю.\",\"html\":\"\u003cp\u003eПереполнение знаковых типов может вызвать неопределённое поведение, а беззнаковых — вычисления по модулю.\u003c/p\u003e\\n\"}]\nc5:[\"$\",\"$L75\",null,{\"Content\":\"Перепо"])</script><script nonce="">self.__next_f.push([1,"лнение знаковых и беззнаковых типов данных приводит к одинаковому результату — увеличению значения до максимального возможного для данного типа данных.\",\"html\":\"\u003cp\u003eПереполнение знаковых и беззнаковых типов данных приводит к одинаковому результату — увеличению значения до максимального возможного для данного типа данных.\u003c/p\u003e\\n\"}]\nc6:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение целочисленных типов данных влияет на точность вычислений, но не имеет различий между знаковыми и беззнаковыми типами.\",\"html\":\"\u003cp\u003eПереполнение целочисленных типов данных влияет на точность вычислений, но не имеет различий между знаковыми и беззнаковыми типами.\u003c/p\u003e\\n\"}]\nc7:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение знаковых и беззнаковых типов данных всегда приводит к одинаковым результатам.\",\"html\":\"\u003cp\u003eПереполнение знаковых и беззнаковых типов данных всегда приводит к одинаковым результатам.\u003c/p\u003e\\n\"}]\nc8:[\"$\",\"$L75\",null,{\"Content\":\"Какие проблемы могут возникнуть в программе из-за переполнения целочисленных типов?\",\"html\":\"\u003cp\u003eКакие проблемы могут возникнуть в программе из-за переполнения целочисленных типов?\u003c/p\u003e\\n\"}]\nc9:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение целочисленных типов может вызвать неопределённое "])</script><script nonce="">self.__next_f.push([1,"поведение или вычисления по модулю, что ведёт к ошибкам в программе.\",\"html\":\"\u003cp\u003eПереполнение целочисленных типов может вызвать неопределённое поведение или вычисления по модулю, что ведёт к ошибкам в программе.\u003c/p\u003e\\n\"}]\nca:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение целочисленных типов приводит к тому, что программа автоматически преобразует тип данных в более крупный, такой как long или double, чтобы избежать потери данных.\",\"html\":\"\u003cp\u003eПереполнение целочисленных типов приводит к тому, что программа автоматически преобразует тип данных в более крупный, такой как long или double, чтобы избежать потери данных.\u003c/p\u003e\\n\"}]\ncb:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение целочисленных типов связано с проблемами выделения памяти в динамических структурах данных, таких как списки или деревья.\",\"html\":\"\u003cp\u003eПереполнение целочисленных типов связано с проблемами выделения памяти в динамических структурах данных, таких как списки или деревья.\u003c/p\u003e\\n\"}]\ncc:[\"$\",\"$L75\",null,{\"Content\":\"Переполнение целочисленных типов исправляется автоматически системой и не влияет на работу программы.\",\"html\":\"\u003cp\u003eПереполнение целочисленных типов исправляется автоматически системой и не влияет на работу программы.\u003c/"])</script><script nonce="">self.__next_f.push([1,"p\u003e\\n\"}]\ncd:[\"$\",\"$L75\",null,{\"Content\":\"Какие бинарные операции определены в C++ для чисел?\",\"html\":\"\u003cp\u003eКакие бинарные операции определены в C++ для чисел?\u003c/p\u003e\\n\"}]\nce:[\"$\",\"$L75\",null,{\"Content\":\"В C++ определены бинарные операции +, -, *, /, %.\",\"html\":\"\u003cp\u003eВ C++ определены бинарные операции +, -, *, /, %.\u003c/p\u003e\\n\"}]\ncf:[\"$\",\"$L75\",null,{\"Content\":\"В C++ для чисел определены бинарные операции сложения (+), вычитания (-), деления (/), умножения (*) и операции логического ИЛИ (||).\",\"html\":\"\u003cp\u003eВ C++ для чисел определены бинарные операции сложения (+), вычитания (-), деления (/), умножения (*) и операции логического ИЛИ (||).\u003c/p\u003e\\n\"}]\nd0:[\"$\",\"$L75\",null,{\"Content\":\"В C++ бинарные операции используются для работы с битами и включают побитовое И (\u0026), побитовое ИЛИ (|) и побитовое исключающее ИЛИ (^).\",\"html\":\"\u003cp\u003eВ C++ бинарные операции используются для работы с битами и включают побитовое И (\u0026amp;), побитовое ИЛИ (|) и побитовое исключающее ИЛИ (^).\u003c/p\u003e\\n\"}]\nd1:[\"$\",\"$L75\",null,{\"Content\":\"В C++ определены бинарные операции ^, \u0026, |, ~ для чисел.\",\"html\":\"\u003cp\u003eВ C++ определены бинарные операции ^, \u0026amp;, |, ~ для чисел.\u003c/p\u003e\\n\"}]\nd2:[\"$\",\"$L75\",null,{\"Content\":\"Почему важно знать правила выполнения арифметических операций в C++ при написании алгоритмов?\",\"html\":\"\u003cp\u003eПочему важно знать правила выполнения арифметических опе"])</script><script nonce="">self.__next_f.push([1,"раций в C++ при написании алгоритмов?\u003c/p\u003e\\n\"}]\nd3:[\"$\",\"$L75\",null,{\"Content\":\"Знание правил арифметических операций в C++ нужно для корректного написания алгоритмов и вычислений.\",\"html\":\"\u003cp\u003eЗнание правил арифметических операций в C++ нужно для корректного написания алгоритмов и вычислений.\u003c/p\u003e\\n\"}]\nd4:[\"$\",\"$L75\",null,{\"Content\":\"Знание арифметических операций в C++ необходимо только для работы с текстовыми данными, а для числовых вычислений можно использовать любые символы и операторы.\",\"html\":\"\u003cp\u003eЗнание арифметических операций в C++ необходимо только для работы с текстовыми данными, а для числовых вычислений можно использовать любые символы и операторы.\u003c/p\u003e\\n\"}]\nd5:[\"$\",\"$L75\",null,{\"Content\":\"Знание арифметических операций в C++ полезно для понимания принципов работы сетевых протоколов и передачи данных.\",\"html\":\"\u003cp\u003eЗнание арифметических операций в C++ полезно для понимания принципов работы сетевых протоколов и передачи данных.\u003c/p\u003e\\n\"}]\nd6:[\"$\",\"$L75\",null,{\"Content\":\"Знание арифметических операций в C++ важно только для работы с библиотеками графического интерфейса.\",\"html\":\"\u003cp\u003eЗнание арифметических операций в C++ важно только для работы с библиотеками графического интерфейса.\u003c/p\u003e\\n\"}]\nd7:[\"$\",\"$L75\",nu"])</script><script nonce="">self.__next_f.push([1,"ll,{\"Content\":\"Как можно применить операцию получения остатка от деления (%) в программировании на C++?\",\"html\":\"\u003cp\u003eКак можно применить операцию получения остатка от деления (%) в программировании на C++?\u003c/p\u003e\\n\"}]\nd8:[\"$\",\"$L75\",null,{\"Content\":\"Операция % в C++ вычисляет остаток от деления чисел.\",\"html\":\"\u003cp\u003eОперация % в C++ вычисляет остаток от деления чисел.\u003c/p\u003e\\n\"}]\nd9:[\"$\",\"$L75\",null,{\"Content\":\"Операция получения остатка от деления (%) в C++ используется для нахождения наибольшего общего делителя двух чисел.\",\"html\":\"\u003cp\u003eОперация получения остатка от деления (%) в C++ используется для нахождения наибольшего общего делителя двух чисел.\u003c/p\u003e\\n\"}]\nda:[\"$\",\"$L75\",null,{\"Content\":\"Операция получения остатка от деления (%) в C++ тесно связана с логическими операциями и используется для управления потоком выполнения программы.\",\"html\":\"\u003cp\u003eОперация получения остатка от деления (%) в C++ тесно связана с логическими операциями и используется для управления потоком выполнения программы.\u003c/p\u003e\\n\"}]\ndb:[\"$\",\"$L75\",null,{\"Content\":\"Операция % в C++ используется для умножения чисел.\",\"html\":\"\u003cp\u003eОперация % в C++ используется для умножения чисел.\u003c/p\u003e\\n\"}]\ndc:[\"$\",\"$L75\",null,{\"Content\":\"Какие три встроенных типа для записи дробных чисел существуют в C++?\",\"html\":\"\u003cp\u003eК"])</script><script nonce="">self.__next_f.push([1,"акие три встроенных типа для записи дробных чисел существуют в C++?\u003c/p\u003e\\n\"}]\ndd:[\"$\",\"$L75\",null,{\"Content\":\"В C++ три типа для дробных чисел: float, double, long double.\",\"html\":\"\u003cp\u003eВ C++ три типа для дробных чисел: float, double, long double.\u003c/p\u003e\\n\"}]\nde:[\"$\",\"$L75\",null,{\"Content\":\"В C++ для представления дробных чисел применяются три типа: short, int и long.\",\"html\":\"\u003cp\u003eВ C++ для представления дробных чисел применяются три типа: short, int и long.\u003c/p\u003e\\n\"}]\ndf:[\"$\",\"$L75\",null,{\"Content\":\"В C++ есть несколько типов данных для работы с числами, включая целочисленные типы, такие как int и long, которые не подходят для записи дробных значений.\",\"html\":\"\u003cp\u003eВ C++ есть несколько типов данных для работы с числами, включая целочисленные типы, такие как int и long, которые не подходят для записи дробных значений.\u003c/p\u003e\\n\"}]\ne0:[\"$\",\"$L75\",null,{\"Content\":\"В C++ для дробных чисел используют типы: char, int, long.\",\"html\":\"\u003cp\u003eВ C++ для дробных чисел используют типы: char, int, long.\u003c/p\u003e\\n\"}]\ne1:[\"$\",\"$L75\",null,{\"Content\":\"Почему выбор типа числа с плавающей точкой важен при работе с данными в C++?\",\"html\":\"\u003cp\u003eПочему выбор типа числа с плавающей точкой важен при работе с данными в C++?\u003c/p\u003e\\n\"}]\ne2:[\"$\",\"$L75\",null,{\"Content\":\"Выбор типа числа с плавающей точкой важен из-за различий в точности и диапазоне значений.\",\"html\":\"\u003cp\u003eВыбор типа числа "])</script><script nonce="">self.__next_f.push([1,"с плавающей точкой важен из-за различий в точности и диапазоне значений.\u003c/p\u003e\\n\"}]\ne3:[\"$\",\"$L75\",null,{\"Content\":\"Выбор типа числа с плавающей точкой важен, потому что от него зависит скорость выполнения арифметических операций, а не точность или объём данных.\",\"html\":\"\u003cp\u003eВыбор типа числа с плавающей точкой важен, потому что от него зависит скорость выполнения арифметических операций, а не точность или объём данных.\u003c/p\u003e\\n\"}]\ne4:[\"$\",\"$L75\",null,{\"Content\":\"Выбор типа числа с плавающей точкой важен для определения размера переменной в памяти, что влияет на организацию структуры данных в программе.\",\"html\":\"\u003cp\u003eВыбор типа числа с плавающей точкой важен для определения размера переменной в памяти, что влияет на организацию структуры данных в программе.\u003c/p\u003e\\n\"}]\ne5:[\"$\",\"$L75\",null,{\"Content\":\"Выбор типа числа с плавающей точкой не важен, так как все типы автоматически преобразуются друг в друга без потери данных.\",\"html\":\"\u003cp\u003eВыбор типа числа с плавающей точкой не важен, так как все типы автоматически преобразуются друг в друга без потери данных.\u003c/p\u003e\\n\"}]\ne6:[\"$\",\"$L75\",null,{\"Content\":\"В каких случаях рекомендуется использовать тип double в C++ и почему?\",\"html\":\"\u003cp\u003eВ каких случаях рекомендуется использо"])</script><script nonce="">self.__next_f.push([1,"вать тип double в C++ и почему?\u003c/p\u003e\\n\"}]\ne7:[\"$\",\"$L75\",null,{\"Content\":\"Тип double в C++ предпочтительнее использовать для высокой точности дробных чисел.\",\"html\":\"\u003cp\u003eТип double в C++ предпочтительнее использовать для высокой точности дробных чисел.\u003c/p\u003e\\n\"}]\ne8:[\"$\",\"$L75\",null,{\"Content\":\"Тип double в C++ рекомендуется использовать исключительно для работы с комплексными числами, так как он обеспечивает необходимую точность для их представления.\",\"html\":\"\u003cp\u003eТип double в C++ рекомендуется использовать исключительно для работы с комплексными числами, так как он обеспечивает необходимую точность для их представления.\u003c/p\u003e\\n\"}]\ne9:[\"$\",\"$L75\",null,{\"Content\":\"Тип double в C++ используется для определения размера массивов и циклов, где требуется высокая гибкость в изменении значений.\",\"html\":\"\u003cp\u003eТип double в C++ используется для определения размера массивов и циклов, где требуется высокая гибкость в изменении значений.\u003c/p\u003e\\n\"}]\nea:[\"$\",\"$L75\",null,{\"Content\":\"Тип double в C++ применяется для хранения целочисленных значений большого объёма.\",\"html\":\"\u003cp\u003eТип double в C++ применяется для хранения целочисленных значений большого объёма.\u003c/p\u003e\\n\"}]\neb:[\"$\",\"$L75\",null,{\"Content\":\"Что такое автоматический вывод типа в C++?\",\"html\":\"\u003cp\u003eЧто такое автоматический вывод ти"])</script><script nonce="">self.__next_f.push([1,"па в C++?\u003c/p\u003e\\n\"}]\nec:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ — это использование ключевого слова `auto` для определения типа переменной по присвоенному значению.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ — это использование ключевого слова \u003ccode\u003eauto\u003c/code\u003e для определения типа переменной по присвоенному значению.\u003c/p\u003e\\n\"}]\ned:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ — это функция, которая позволяет компилятору определять тип переменной по её имени, а не по значению, что упрощает написание кода.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ — это функция, которая позволяет компилятору определять тип переменной по её имени, а не по значению, что упрощает написание кода.\u003c/p\u003e\\n\"}]\nee:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ связан с использованием шаблонов и позволяет создавать обобщённые функции и классы, что облегчает разработку универсальных алгоритмов.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ связан с использованием шаблонов и позволяет создавать обобщённые функции и классы, что облегчает разработку универсальных алгоритмов.\u003c/p\u003e\\n\"}]\nef:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ — это метод, позволяющий компилятору определ"])</script><script nonce="">self.__next_f.push([1,"ять тип переменной по её адресу в памяти.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ — это метод, позволяющий компилятору определять тип переменной по её адресу в памяти.\u003c/p\u003e\\n\"}]\nf0:[\"$\",\"$L75\",null,{\"Content\":\"Почему использование автоматического вывода типа может упростить работу с сложными типами данных?\",\"html\":\"\u003cp\u003eПочему использование автоматического вывода типа может упростить работу с сложными типами данных?\u003c/p\u003e\\n\"}]\nf1:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ упрощает работу с сложными данными, позволяя компилятору определить тип переменной по её значению.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ упрощает работу с сложными данными, позволяя компилятору определить тип переменной по её значению.\u003c/p\u003e\\n\"}]\nf2:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ работает только для базовых типов данных, таких как int и float, и не применим к сложным структурам данных.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ работает только для базовых типов данных, таких как int и float, и не применим к сложным структурам данных.\u003c/p\u003e\\n\"}]\nf3:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ связан с использованием шаблонов и позволяет создавать более гибкие алгоритмы, но не вл"])</script><script nonce="">self.__next_f.push([1,"ияет на работу со сложными типами данных.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ связан с использованием шаблонов и позволяет создавать более гибкие алгоритмы, но не влияет на работу со сложными типами данных.\u003c/p\u003e\\n\"}]\nf4:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ усложняет работу с данными, так как требует от программиста дополнительного указания типа переменной.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ усложняет работу с данными, так как требует от программиста дополнительного указания типа переменной.\u003c/p\u003e\\n\"}]\nf5:[\"$\",\"$L75\",null,{\"Content\":\"Как можно применить автоматический вывод типа в C++ для сокращения кода?\",\"html\":\"\u003cp\u003eКак можно применить автоматический вывод типа в C++ для сокращения кода?\u003c/p\u003e\\n\"}]\nf6:[\"$\",\"$L75\",null,{\"Content\":\"В C++ автоматический вывод типа с помощью `auto` позволяет сократить код, автоматически определяя тип переменной по присвоенному значению.\",\"html\":\"\u003cp\u003eВ C++ автоматический вывод типа с помощью \u003ccode\u003eauto\u003c/code\u003e позволяет сократить код, автоматически определяя тип переменной по присвоенному значению.\u003c/p\u003e\\n\"}]\nf7:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ осуществляется с помощью ключевого слова `var`, которое позволяет компилятору опре"])</script><script nonce="">self.__next_f.push([1,"делять тип переменной по её значению, сокращая тем самым объём кода.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ осуществляется с помощью ключевого слова \u003ccode\u003evar\u003c/code\u003e, которое позволяет компилятору определять тип переменной по её значению, сокращая тем самым объём кода.\u003c/p\u003e\\n\"}]\nf8:[\"$\",\"$L75\",null,{\"Content\":\"Автоматический вывод типа в C++ связан с использованием шаблонов и позволяет создавать обобщённые функции и классы для работы с различными типами данных.\",\"html\":\"\u003cp\u003eАвтоматический вывод типа в C++ связан с использованием шаблонов и позволяет создавать обобщённые функции и классы для работы с различными типами данных.\u003c/p\u003e\\n\"}]\nf9:[\"$\",\"$L75\",null,{\"Content\":\"В C++ для сокращения кода необходимо явно указывать тип переменной с помощью ключевого слова `auto`.\",\"html\":\"\u003cp\u003eВ C++ для сокращения кода необходимо явно указывать тип переменной с помощью ключевого слова \u003ccode\u003eauto\u003c/code\u003e.\u003c/p\u003e\\n\"}]\n"])</script><script src="https://yastatic.net/s3/cloud/forms/_/embed.js" nonce="" data-nscript="afterInteractive"></script><next-route-announcer style="position: absolute;"></next-route-announcer></body></html>